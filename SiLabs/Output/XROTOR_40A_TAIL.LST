MACRO ASSEMBLER BLHELI                                      12/30/15 18:06:59 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\XROTOR_40A_REV14_3.OBJ
ASSEMBLER INVOKED BY: PRINT SET(BESCNO=188) OBJECT(OUTPUT\XROTOR_40A_REV14_3.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ;
                         4     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                         5     ;
                         6     ; Copyright 2011, 2012 Steffen Skaug
                         7     ; This program is distributed under the terms of the GNU General Public License
                         8     ;
                         9     ; This file is part of BLHeli.
                        10     ;
                        11     ; BLHeli is free software: you can redistribute it and/or modify
                        12     ; it under the terms of the GNU General Public License as published by
                        13     ; the Free Software Foundation, either version 3 of the License, or
                        14     ; (at your option) any later version.
                        15     ;
                        16     ; BLHeli is distributed in the hope that it will be useful,
                        17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        19     ; GNU General Public License for more details.
                        20     ;
                        21     ; You should have received a copy of the GNU General Public License
                        22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                        23     ;
                        24     ;**** **** **** **** ****
                        25     ;
                        26     ; The software was initially designed for use with Eflite mCP X, but is now adapted to copters/planes in general
                        27     ;
                        28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.versanet.de/~bkonze/blc_6a/blc_6a.htm
                        29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                        30     ;
                        31     ; This file is best viewed with tab width set to 5
                        32     ;
                        33     ; The input signal can be positive 1kHz, 2kHz, 4kHz, 8kHz or 12kHz PWM (e.g. taken from the "resistor tap" on mCPx)
                        34     ; And the input signal can be PPM (1-2ms) or OneShot125 (125-250us) at rates up to several hundred Hz.
                        35     ; The code autodetects the various input modes/frequencies
                        36     ; The code can also be programmed to accept inverted input signal.
                        37     ;
                        38     ; The first lines of the software must be modified according to the chosen environment:
                        39     ; Uncomment the selected ESC and main/tail/multi mode
                        40     ; BESCNO EQU "ESC"_"mode" 						
                        41     ; 
                        42     ;**** **** **** **** ****
                        43     ; Revision history:
                        44     ; - Rev1.0: Initial revision based upon BLHeli for AVR controllers
                        45     ; - Rev2.0: Changed "Eeprom" initialization, layout and defaults
                        46     ;           Various changes and improvements to comparator reading. Now using timer1 for time from pwm on/off
                        47     ;           Beeps are made louder
                        48     ;           Added programmable low voltage limit
                        49     ;           Added programmable damped tail mode (only for 1S ESCs)
                        50     ;           Added programmable motor rotation direction
                        51     ; - Rev2.1: (minor changes by 4712)
                        52     ;		  Added Disable TX Programming by PC Setup Application 
                        53     ;		  therfore changed EEPROM_LAYOUT_REVISION = 8					
                        54     ;		  Added Vdd Monitor as reset source when writing to "EEProm"
                        55     ;		  Changed for use of batch file to assemble, link and make hex files	
                        56     ; - Rev2.2: (minor changes by 4712)
                        57     ;           Added Disable Throttle Re-Arming every motor start by PC Setup Application 
                        58     ; - Rev2.3: (minor changes by 4712)
                        59     ;           Added bugfixed (2x CLR C before j(n)c operations)thx Steffen!			
                        60     ; - Rev2.4: Revisions 2.1 to 2.3 integrated
                        61     ; - Rev3.0: Added PPM (1050us-1866us) as accepted input signal
                        62     ;           Added startup rpm as a programming parameter
                        63     ;           Added startup acceleration as a programming parameter
                        64     ;           Added option for using voltage measurements to compensate motor power
                        65     ;           Added governor target by setup as a governor mode option
                        66     ;           Governor is kept active regardless of rpm
                        67     ;           Smooth governor spoolup/down in arm and setup modes
                        68     ;           Increased governor P and I gain programming ranges
                        69     ;           Increased and changed low voltage limit programming range
                        70     ;           Disabled tx programming entry for all but the first arming sequence after power on
                        71     ;           Made it possible to skip parameters in tx programming by setting throttle midstick
                        72     ;           Made it default not to rearm for every restart
                        73     ; - Rev3.1: Fixed bug that prevented chosen parameter to be set in tx programming
                        74     ; - Rev3.2: ...also updated the EEPROM revision parameter
                        75     ; - Rev3.3: Fixed negative number bug in voltage compensation
                        76     ;           Fixed bug in startup power calculation for non-default power
                        77     ;           Prevented possibility for voltage compensation fighting low voltage limiting
                        78     ;           Applied overall spoolup control to ensure soft spoolup in any mode
                        79     ;           Added a delay of 3 seconds from initiation of main motor stop until new startup is allowed
                        80     ;           Reduced beep power to reduce power consumption for very strong motors/ESCs
                        81     ; - Rev3.4: Fixed bug that prevented full power in governor arm and setup modes
                        82     ;           Increased NFETON_DELAY for XP_7A and XP_12A to allow for more powerful fets
                        83     ;           Increased initial spoolup power, and linked to startup power
                        84     ; - Rev4.0: Fixed bug that made tail tx program beeps very weak
                        85     ;           Added thermal protection feature
                        86     ;           Governor P and I gain ranges are extended up to 8.0x gain
                        87     ;           Startup sequence is aborted upon zero throttle
                        88     ;           Avoided voltage compensation function induced latency for tail when voltage compensation is not enabled
                        89     ;           Improved input signal frequency detection robustness
                        90     ; - Rev4.1: Increased thermal protection temperature limits
                        91     ; - Rev5.0: Added multi(copter) operating mode. TAIL define changed to MODE with three modes: MAIN, TAIL and MULTI
                        92     ;           Added programmable commutation timing
                        93     ;           Added a damped light mode that has less damping, but that can be used with all escs
                        94     ;           Added programmable damping force
                        95     ;           Added thermal protection for startup too
                        96     ;           Added wait beeps when waiting more than 30 sec for throttle above zero (after having been armed)
                        97     ;           Modified tail idling to provide option for very low speeds
                        98     ;           Changed PPM range to 1150-1830us
                        99     ;           Arming sequence is dropped for PPM input, unless it is governor arm mode
                       100     ;           Loss of input signal will immediately stop the motor for PPM input
                       101     ;           Bug corrected in Turnigy Plush 6A voltage measurement setup
                       102     ;           FET switching delays are set for original fets. Stronger/doubled/tripled etc fets may require faster pfet off switching
                       103     ;           Miscellaneous other changes
                       104     ; - Rev6.0: Reverted comparator reading routine to rev5.0 equivalent, in order to avoid tail motor stops
                       105     ;           Added governor range programmability
                       106     ;           Implemented startup retry sequence with varying startup power for multi mode
                       107     ;           In damped light mode, damping is now applied to the active nfet phase for fully damped capable ESCs
                       108     ; - Rev6.1: Added input signal qualification criteria for PPM, to avoid triggering on noise spikes (fix for plush hardware)
                       109     ;           Changed main and multi mode stop criteria. Will now be in run mode, even if RC pulse input is zero
                       110     ;           Fixed bug in commutation that caused rough running in damped light mode
                       111     ;           Miscellaneous other changes
                       112     ; - Rev7.0  Added direct startup mode programmability
                       113     ;           Added throttle calibration. Min>=1000us and Max<=2000us. Difference must be >520us, otherwise max is shifted so that difference=520us
                       114     ;           Added programmable throttle change rate
                       115     ;           Added programmable beep strength, beacon strength and beacon delay
                       116     ;           Reduced power step to full power significantly
                       117     ;           Miscellaneous other changes
                       118     ; - Rev8.0  Added a 2 second delay after power up, to wait for receiver initialization
                       119     ;           Added a programming option for disabling low voltage limit, and made it default for MULTI
                       120     ;           Added programable demag compensation, using the concept of SimonK
                       121     ;           Improved robustness against noisy input signal
                       122     ;           Refined direct startup
                       123     ;           Removed voltage compensation
                       124     ;           Miscellaneous other changes
                       125     ; - Rev9.0  Increased programming range for startup power, and made its default ESC dependent
                       126     ;           Made default startup method ESC dependent
                       127     ;           Even more smooth and gentle spoolup for MAIN, to suit larger helis
                       128     ;           Improved transition from stepped startup to run
                       129     ;           Refined direct startup
                       130     ; - Rev9.1  Fixed bug that changed FW revision after throttle calibration or TX programming
                       131     ; - Rev9.2  Altered timing of throttle calibration in order to work with MultiWii calibration firmware
                       132     ;           Reduced main spoolup time to around 5 seconds
                       133     ;           Changed default beacon delay to 3 minutes
                       134     ; - Rev9.3  Fixed bug in Plush 60/80A temperature reading, that caused failure in operation above 4S
                       135     ;           Corrected temperature limit for HiModel cool 22/33/41A, RCTimer 6A, Skywalker 20/40A, Turnigy AE45A, Plush 40/60/80A. Limit was previously set too high
                       136     ; - Rev9.4  Improved timing for increased maximum rpm limit
                       137     ; - Rev10.0 Added closed loop mode for multi
                       138     ;           Added high/low BEC voltage option (for the ESCs where HW supports it)
                       139     ;           Added method of resetting all programmed parameter values to defaults by TX programming
                       140     ;           Added Turnigy K-force 40A and Turnigy K-force 120A HV ESCs
                       141     ;           Enabled fully damped mode for several ESCs
                       142     ;           Extended startup power range downwards to enable very smooth start for large heli main motors
                       143     ;           Extended damping force with a highest setting
                       144     ;           Corrected temperature limits for F310 chips (Plush 40A and AE 45A)
                       145     ;           Implemented temperature reading average in order to avoid problems with ADC noise on Skywalkers
                       146     ;           Increased switching delays for XP 7A fast, in order to avoid cross conduction of N and P fets
                       147     ;           Miscellaneous other changes
                       148     ; - Rev10.1 Relaxed RC signal jitter requirement during frequency measurement
                       149     ;           Corrected bug that prevented using governor low
                       150     ;           Enabled vdd monitor always, in order to reduce likelihood of accidental overwriting of adjustments
                       151     ;           Fixed bug that caused stop for PPM input above 2048us, and moved upper accepted limit to 2160us
                       152     ; - Rev10.2 Corrected temperature limit for AE20-30/XP7-25, where limit was too high
                       153     ;           Corrected temperature limit for 120HV, where limit was too low
                       154     ;           Fixed bug that caused AE20/25/30A not to run in reverse
                       155     ; - Rev10.3 Removed vdd monitor for 1S capable ESCs, in order to avoid brownouts/resets
                       156     ;           Made auto bailout spoolup for main more smooth
                       157     ; - Rev10.4 Ensured that main spoolup and governor activation will always be smooth, regardless of throttle input
                       158     ;           Added capability to operate on 12kHz input signal too
                       159     ; - Rev11.0 Fixed bug of programming default values for governor in MULTI mode
                       160     ;           Disabled interrupts explicitly some places, to avoid possibilities for unintentional fet switching
                       161     ;           Changed interrupt disable strategy, to always allow pwm interrupts, to avoid noise when running at low rpms
                       162     ;           Added governor middle range for MAIN mode
                       163     ;           Added bidirectional mode for TAIL and MULTI mode with PPM input
                       164     ;           Changed and improved demag compensation
                       165     ;           Miscellaneous other changes
                       166     ; - Rev11.1 Fixed bug of slow acceleration response for MAIN mode running without governor
                       167     ;           Fixed bug with PWM input, where throttle remains high even when zeroing throttle (seen on V922 tail)
                       168     ;           Fixed bug in bidirectional operation, where direction change could cause reset
                       169     ;           Improved autorotation bailout for MAIN
                       170     ;           Reduced min speed back to 1220 erpm
                       171     ;           Misc code cleanups
                       172     ; - Rev11.2 Fixed throttle calibration bug
                       173     ;           Added high side driver precharge for all-nfet ESCs
                       174     ;           Optimized timing in general and for demag compensation in particular
                       175     ;           Auto bailout functionality modified
                       176     ;           Governor is deactivated for throttle inputs below 10%
                       177     ;           Increased beacon delay times
                       178     ; - Rev12.0 Added programmable main spoolup time
                       179     ;           Added programmable temperature protection enable
                       180     ;           Bidirectional mode stop/start improved. Motor is now stopped before starting
                       181     ;           Power is limited for very low rpms (when BEMF is low), in order to avoid sync loss 
                       182     ;           Damped light mode is made more smooth and quiet, particularly at low and high rpms
                       183     ;           Comparator signal qualification scheme is changed
                       184     ;           Demag compensation scheme is significantly changed
                       185     ;           Increased jitter tolerance for PPM frequency measurement
                       186     ;           Fully damped mode removed, and damped light only supported on damped capable ESCs
                       187     ;           Default tail mode changed to damped light
                       188     ;           Miscellaneous other changes
                       189     ; - Rev12.1 Fixed bug in tail code
                       190     ;           Improved startup for Atmel
                       191     ;           Added support for multiple high BEC voltages
                       192     ;           Added support for RPM output
                       193     ; - Rev12.2 Improved running smoothness, particularly for damped light
                       194     ;           Avoiding lockup at full throttle when input signal is noisy
                       195     ;           Avoiding detection of 1-wire programming signal as valid throttle signal
                       196     ; - Rev13.0 Removed stepped start
                       197     ;           Removed throttle change rate and damping force parameters
                       198     ;           Added support for OneShot125
                       199     ;           Improved commutation timing accuracy
                       200     ; - Rev13.1 Removed startup ramp for MULTI
                       201     ;           Improved startup for some odd ESCs
                       202     ; - Rev13.2 Still tweaking startup to make it more reliable and faster for all ESC/motor combos
                       203     ;           Increased deadband for bidirectional operation
                       204     ;           Relaxed signal detection criteria
                       205     ;           Added support for running 48MHz capable SiLabs MCUs at 48MHz
                       206     ;           Added bootlader to SiLabs code
                       207     ;           Miscellaneous other changes
                       208     ; - Rev14.0 Improved running at high timing
                       209     ;           Improved running at high RPMs and increased max RPM limit
                       210     ;           Avoid being locked in bootloader (implemented in Suite 13202)
                       211     ;           Improved reliability of 3D (bidirectional) mode and startup
                       212     ;           Smoother running and greatly reduced step to full power in damped light mode
                       213     ;           Removed low voltage limiting for MULTI
                       214     ;           Added pwm dither parameter
                       215     ;           Added setting for enable/disable of low RPM power protection
                       216     ;           Added setting for enable/disable of PWM input
                       217     ;           Better AFW and damping for some ESCs (that have a slow high side driver)
                       218     ;           Miscellaneous other changes
                       219     ; - Rev14.1 Fixed max throttle calibration bug (for non-oneshot)
                       220     ;           Fixed some closed loop mode bugs
                       221     ;           Relaxed signal jitter requirement for looptimes below 1000
                       222     ;           Added skipping of damping fet switching near max power, for improved high end throttle linearity, using the concept of SimonK
                       223     ;           Improved sync hold at high rpms
                       224     ; - Rev14.2 Added stalled motor shutoff after about 10 seconds (for tail and multi code with PPM input)
                       225     ;           Greatly increased maximum rpm limit, and added rpm limiting at 250k erpm (48MHz MCUs at 400k erpm)
                       226     ;           Improved bidirectional operation
                       227     ; - Rev14.3 Moved reset vector to be just before the settings segment, in order to better recover from partially failed flashing operation
                       228     ;           Added 100ms intialization delay for the Graupner Ultra 20A ESC
                       229     ;           Shortened stall detect time to about 5sec, and prevented going into tx programming after a stall
                       230     ;           Optimizations of software timing and running reliability
                       231     ;
                       232     ;           
                       233     ;
                       234     ;**** **** **** **** ****
                       235     ; Up to 8K Bytes of In-System Self-Programmable Flash
                       236     ; 768 Bytes Internal SRAM
                       237     ;
                       238     ;**** **** **** **** ****
                       239     ; Master clock is internal 24MHz oscillator
                       240     ; Timer 0 (167/500ns counts) always counts up and is used for
                       241     ; - PWM generation
                       242     ; Timer 1 (167/500ns counts) always counts up and is used for
                       243     ; - Time from pwm on/off event
                       244     ; Timer 2 (500ns counts) always counts up and is used for
                       245     ; - RC pulse timeout/skip counts and commutation times
                       246     ; Timer 3 (500ns counts) always counts up and is used for
                       247     ; - Commutation timeouts
                       248     ; PCA0 (500ns counts) always counts up and is used for
                       249     ; - RC pulse measurement
                       250     ;
                       251     ;**** **** **** **** ****
                       252     ; Interrupt handling
                       253     ; The F330 does not disable interrupts when entering an interrupt routine.
                       254     ; Also some interrupt flags need to be cleared by software
                       255     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                       256     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                       257     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                       258     ;
                       259     ;**** **** **** **** ****
                       260     ; Motor control:
                       261     ; - Brushless motor control with 6 states for each electrical 360 degrees
                       262     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                       263     ; - Timing advance in this implementation is set to 15deg nominally
                       264     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                       265     ; Motor sequence starting from zero crossing:
                       266     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                       267     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                       268     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                       269     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                       270     ;
                       271     ; Motor startup:
                       272     ; Startup is the only phase, before normal bemf commutation run begins.
                       273     ;
                       274     ;**** **** **** **** ****
                       275     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0001                 276     XP_3A_MAIN 					EQU 1
  0002                 277     XP_3A_TAIL 					EQU 2
  0003                 278     XP_3A_MULTI 					EQU 3
  0004                 279     XP_7A_MAIN 					EQU 4
  0005                 280     XP_7A_TAIL 					EQU 5
  0006                 281     XP_7A_MULTI 					EQU 6
  0007                 282     XP_7A_FAST_MAIN 				EQU 7
  0008                 283     XP_7A_FAST_TAIL 				EQU 8
  0009                 284     XP_7A_FAST_MULTI 				EQU 9
  000A                 285     XP_12A_MAIN 					EQU 10
  000B                 286     XP_12A_TAIL 					EQU 11
  000C                 287     XP_12A_MULTI 					EQU 12
  000D                 288     XP_18A_MAIN 					EQU 13
  000E                 289     XP_18A_TAIL 					EQU 14
  000F                 290     XP_18A_MULTI 					EQU 15
  0010                 291     XP_25A_MAIN 					EQU 16
  0011                 292     XP_25A_TAIL 					EQU 17
  0012                 293     XP_25A_MULTI 					EQU 18
  0013                 294     XP_35A_SW_MAIN 				EQU 19
  0014                 295     XP_35A_SW_TAIL 				EQU 20
  0015                 296     XP_35A_SW_MULTI 				EQU 21
  0016                 297     DP_3A_MAIN 					EQU 22
  0017                 298     DP_3A_TAIL  					EQU 23
  0018                 299     DP_3A_MULTI  					EQU 24
  0019                 300     SUPERMICRO_3P5A_MAIN 			EQU 25
  001A                 301     SUPERMICRO_3P5A_TAIL 			EQU 26   
  001B                 302     SUPERMICRO_3P5A_MULTI 			EQU 27   
  001C                 303     TURNIGY_PLUSH_6A_MAIN 			EQU 28
  001D                 304     TURNIGY_PLUSH_6A_TAIL 			EQU 29   
  001E                 305     TURNIGY_PLUSH_6A_MULTI 			EQU 30   
  001F                 306     TURNIGY_PLUSH_10A_MAIN 			EQU 31
  0020                 307     TURNIGY_PLUSH_10A_TAIL 			EQU 32   
  0021                 308     TURNIGY_PLUSH_10A_MULTI 			EQU 33   
  0022                 309     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                 310     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                 311     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  0025                 312     TURNIGY_PLUSH_18A_MAIN 			EQU 37
  0026                 313     TURNIGY_PLUSH_18A_TAIL 			EQU 38   
  0027                 314     TURNIGY_PLUSH_18A_MULTI 			EQU 39   
  0028                 315     TURNIGY_PLUSH_25A_MAIN 			EQU 40
  0029                 316     TURNIGY_PLUSH_25A_TAIL 			EQU 41   
  002A                 317     TURNIGY_PLUSH_25A_MULTI 			EQU 42   
  002B                 318     TURNIGY_PLUSH_30A_MAIN 			EQU 43
  002C                 319     TURNIGY_PLUSH_30A_TAIL 			EQU 44   
  002D                 320     TURNIGY_PLUSH_30A_MULTI 			EQU 45   
  002E                 321     TURNIGY_PLUSH_40A_MAIN 			EQU 46
  002F                 322     TURNIGY_PLUSH_40A_TAIL 			EQU 47   
  0030                 323     TURNIGY_PLUSH_40A_MULTI 			EQU 48   
  0031                 324     TURNIGY_PLUSH_60A_MAIN 			EQU 49
  0032                 325     TURNIGY_PLUSH_60A_TAIL 			EQU 50   
  0033                 326     TURNIGY_PLUSH_60A_MULTI 			EQU 51   
  0034                 327     TURNIGY_PLUSH_80A_MAIN 			EQU 52
  0035                 328     TURNIGY_PLUSH_80A_TAIL 			EQU 53   
  0036                 329     TURNIGY_PLUSH_80A_MULTI 			EQU 54   
  0037                 330     TURNIGY_PLUSH_NFET_18A_MAIN 		EQU 55
  0038                 331     TURNIGY_PLUSH_NFET_18A_TAIL 		EQU 56   
  0039                 332     TURNIGY_PLUSH_NFET_18A_MULTI 		EQU 57   
  003A                 333     TURNIGY_PLUSH_NFET_25A_MAIN 		EQU 58
  003B                 334     TURNIGY_PLUSH_NFET_25A_TAIL 		EQU 59   
  003C                 335     TURNIGY_PLUSH_NFET_25A_MULTI 		EQU 60   
  003D                 336     TURNIGY_PLUSH_NFET_30A_MAIN 		EQU 61
  003E                 337     TURNIGY_PLUSH_NFET_30A_TAIL 		EQU 62   
  003F                 338     TURNIGY_PLUSH_NFET_30A_MULTI 		EQU 63   
  0040                 339     TURNIGY_AE_20A_MAIN 			EQU 64
  0041                 340     TURNIGY_AE_20A_TAIL 			EQU 65   
  0042                 341     TURNIGY_AE_20A_MULTI 			EQU 66   
  0043                 342     TURNIGY_AE_25A_MAIN 			EQU 67
  0044                 343     TURNIGY_AE_25A_TAIL 			EQU 68   
  0045                 344     TURNIGY_AE_25A_MULTI 			EQU 69   
  0046                 345     TURNIGY_AE_30A_MAIN 			EQU 70
  0047                 346     TURNIGY_AE_30A_TAIL 			EQU 71   
  0048                 347     TURNIGY_AE_30A_MULTI 			EQU 72   
  0049                 348     TURNIGY_AE_45A_MAIN 			EQU 73
  004A                 349     TURNIGY_AE_45A_TAIL 			EQU 74   
  004B                 350     TURNIGY_AE_45A_MULTI 			EQU 75   
  004C                 351     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                 352     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                 353     TURNIGY_KFORCE_40A_MULTI 		EQU 78   
  004F                 354     TURNIGY_KFORCE_70A_HV_MAIN 		EQU 79   
  0050                 355     TURNIGY_KFORCE_70A_HV_TAIL 		EQU 80   
  0051                 356     TURNIGY_KFORCE_70A_HV_MULTI 		EQU 81   
  0052                 357     TURNIGY_KFORCE_120A_HV_MAIN 		EQU 82   
  0053                 358     TURNIGY_KFORCE_120A_HV_TAIL 		EQU 83   
  0054                 359     TURNIGY_KFORCE_120A_HV_MULTI 		EQU 84   
  0055                 360     TURNIGY_KFORCE_120A_HV_V2_MAIN	EQU 85   
  0056                 361     TURNIGY_KFORCE_120A_HV_V2_TAIL 	EQU 86   
  0057                 362     TURNIGY_KFORCE_120A_HV_V2_MULTI 	EQU 87   
  0058                 363     SKYWALKER_20A_MAIN 				EQU 88
  0059                 364     SKYWALKER_20A_TAIL 				EQU 89   
  005A                 365     SKYWALKER_20A_MULTI 			EQU 90   
  005B                 366     SKYWALKER_40A_MAIN 				EQU 91
  005C                 367     SKYWALKER_40A_TAIL 				EQU 92   
  005D                 368     SKYWALKER_40A_MULTI 			EQU 93   
  005E                 369     HIMODEL_COOL_22A_MAIN 			EQU 94
  005F                 370     HIMODEL_COOL_22A_TAIL 			EQU 95   
  0060                 371     HIMODEL_COOL_22A_MULTI 			EQU 96   
  0061                 372     HIMODEL_COOL_33A_MAIN 			EQU 97
  0062                 373     HIMODEL_COOL_33A_TAIL 			EQU 98   
  0063                 374     HIMODEL_COOL_33A_MULTI 			EQU 99  
  0064                 375     HIMODEL_COOL_41A_MAIN 			EQU 100
  0065                 376     HIMODEL_COOL_41A_TAIL 			EQU 101  
  0066                 377     HIMODEL_COOL_41A_MULTI 			EQU 102  
  0067                 378     RCTIMER_6A_MAIN 				EQU 103   
  0068                 379     RCTIMER_6A_TAIL 				EQU 104  
  0069                 380     RCTIMER_6A_MULTI 				EQU 105  
  006A                 381     ALIGN_RCE_BL15X_MAIN			EQU 106   
  006B                 382     ALIGN_RCE_BL15X_TAIL 			EQU 107  
  006C                 383     ALIGN_RCE_BL15X_MULTI 			EQU 108  
  006D                 384     ALIGN_RCE_BL15P_MAIN			EQU 109  
  006E                 385     ALIGN_RCE_BL15P_TAIL 			EQU 110  
  006F                 386     ALIGN_RCE_BL15P_MULTI 			EQU 111  
  0070                 387     ALIGN_RCE_BL35X_MAIN			EQU 112  
  0071                 388     ALIGN_RCE_BL35X_TAIL 			EQU 113  
  0072                 389     ALIGN_RCE_BL35X_MULTI 			EQU 114  
  0073                 390     ALIGN_RCE_BL35P_MAIN			EQU 115   
  0074                 391     ALIGN_RCE_BL35P_TAIL 			EQU 116  
  0075                 392     ALIGN_RCE_BL35P_MULTI 			EQU 117  
  0076                 393     GAUI_GE_183_18A_MAIN			EQU 118   
  0077                 394     GAUI_GE_183_18A_TAIL 			EQU 119  
  0078                 395     GAUI_GE_183_18A_MULTI 			EQU 120  
  0079                 396     H_KING_10A_MAIN				EQU 121   
  007A                 397     H_KING_10A_TAIL 				EQU 122  
  007B                 398     H_KING_10A_MULTI 				EQU 123  
  007C                 399     H_KING_20A_MAIN				EQU 124   
  007D                 400     H_KING_20A_TAIL 				EQU 125  
  007E                 401     H_KING_20A_MULTI 				EQU 126  
  007F                 402     H_KING_35A_MAIN				EQU 127   
  0080                 403     H_KING_35A_TAIL 				EQU 128 
  0081                 404     H_KING_35A_MULTI 				EQU 129  
  0082                 405     H_KING_50A_MAIN				EQU 130   
  0083                 406     H_KING_50A_TAIL 				EQU 131  
  0084                 407     H_KING_50A_MULTI 				EQU 132  
  0085                 408     POLARIS_THUNDER_12A_MAIN			EQU 133   
  0086                 409     POLARIS_THUNDER_12A_TAIL 		EQU 134  
  0087                 410     POLARIS_THUNDER_12A_MULTI 		EQU 135  
  0088                 411     POLARIS_THUNDER_20A_MAIN			EQU 136   
  0089                 412     POLARIS_THUNDER_20A_TAIL 		EQU 137  
  008A                 413     POLARIS_THUNDER_20A_MULTI 		EQU 138  
  008B                 414     POLARIS_THUNDER_30A_MAIN			EQU 139   
  008C                 415     POLARIS_THUNDER_30A_TAIL 		EQU 140  
  008D                 416     POLARIS_THUNDER_30A_MULTI 		EQU 141  
  008E                 417     POLARIS_THUNDER_40A_MAIN			EQU 142   
  008F                 418     POLARIS_THUNDER_40A_TAIL 		EQU 143  
  0090                 419     POLARIS_THUNDER_40A_MULTI 		EQU 144  
  0091                 420     POLARIS_THUNDER_60A_MAIN			EQU 145   
  0092                 421     POLARIS_THUNDER_60A_TAIL 		EQU 146  
  0093                 422     POLARIS_THUNDER_60A_MULTI 		EQU 147  
  0094                 423     POLARIS_THUNDER_80A_MAIN			EQU 148   
  0095                 424     POLARIS_THUNDER_80A_TAIL 		EQU 149  
  0096                 425     POLARIS_THUNDER_80A_MULTI 		EQU 150  
  0097                 426     POLARIS_THUNDER_100A_MAIN		EQU 151   
  0098                 427     POLARIS_THUNDER_100A_TAIL 		EQU 152  
  0099                 428     POLARIS_THUNDER_100A_MULTI 		EQU 153  
  009A                 429     PLATINUM_PRO_30A_MAIN			EQU 154   
  009B                 430     PLATINUM_PRO_30A_TAIL 			EQU 155  
  009C                 431     PLATINUM_PRO_30A_MULTI 			EQU 156  
  009D                 432     PLATINUM_PRO_150A_MAIN			EQU 157   
  009E                 433     PLATINUM_PRO_150A_TAIL 			EQU 158  
  009F                 434     PLATINUM_PRO_150A_MULTI 			EQU 159  
  00A0                 435     PLATINUM_50AV3_MAIN				EQU 160   
  00A1                 436     PLATINUM_50AV3_TAIL 			EQU 161  
  00A2                 437     PLATINUM_50AV3_MULTI 			EQU 162  
  00A3                 438     EAZY_3AV2_MAIN					EQU 163   
  00A4                 439     EAZY_3AV2_TAIL 				EQU 164  
  00A5                 440     EAZY_3AV2_MULTI 				EQU 165  
  00A6                 441     TAROT_30A_MAIN					EQU 166   
  00A7                 442     TAROT_30A_TAIL 				EQU 167  
  00A8                 443     TAROT_30A_MULTI 				EQU 168  
  00A9                 444     SKYIII_30A_MAIN				EQU 169   
  00AA                 445     SKYIII_30A_TAIL 				EQU 170  
  00AB                 446     SKYIII_30A_MULTI 				EQU 171  
  00AC                 447     EMAX_20A_MAIN					EQU 172   
  00AD                 448     EMAX_20A_TAIL 					EQU 173  
  00AE                 449     EMAX_20A_MULTI 				EQU 174  
  00AF                 450     EMAX_40A_MAIN					EQU 175   
  00B0                 451     EMAX_40A_TAIL 					EQU 176  
  00B1                 452     EMAX_40A_MULTI 				EQU 177  
  00B2                 453     EMAX_NANO_20A_MAIN				EQU 178   
  00B3                 454     EMAX_NANO_20A_TAIL 				EQU 179  
  00B4                 455     EMAX_NANO_20A_MULTI 			EQU 180  
  00B5                 456     XROTOR_10A_MAIN				EQU 181   
  00B6                 457     XROTOR_10A_TAIL 				EQU 182  
  00B7                 458     XROTOR_10A_MULTI 				EQU 183  
  00B8                 459     XROTOR_20A_MAIN				EQU 184   
  00B9                 460     XROTOR_20A_TAIL 				EQU 185  
  00BA                 461     XROTOR_20A_MULTI 				EQU 186  
  00BB                 462     XROTOR_40A_MAIN				EQU 187   
  00BC                 463     XROTOR_40A_TAIL 				EQU 188  
  00BD                 464     XROTOR_40A_MULTI 				EQU 189  
  00BE                 465     MDRX62H_MAIN					EQU 190   
  00BF                 466     MDRX62H_TAIL 					EQU 191  
  00C0                 467     MDRX62H_MULTI 					EQU 192  
  00C1                 468     ROTORGEEKS_20A_MAIN				EQU 193   
  00C2                 469     ROTORGEEKS_20A_TAIL 			EQU 194  
  00C3                 470     ROTORGEEKS_20A_MULTI 			EQU 195  
  00C4                 471     FLYCOLOR_FAIRY_6A_MAIN			EQU 196   
  00C5                 472     FLYCOLOR_FAIRY_6A_TAIL 			EQU 197  
  00C6                 473     FLYCOLOR_FAIRY_6A_MULTI 			EQU 198  
  00C7                 474     FLYCOLOR_FAIRY_30A_MAIN			EQU 199   
  00C8                 475     FLYCOLOR_FAIRY_30A_TAIL 			EQU 200  
  00C9                 476     FLYCOLOR_FAIRY_30A_MULTI 		EQU 201  
  00CA                 477     FVT_LITTLEBEE_20A_MAIN			EQU 202  
  00CB                 478     FVT_LITTLEBEE_20A_TAIL			EQU 203  
  00CC                 479     FVT_LITTLEBEE_20A_MULTI			EQU 204  
  00CD                 480     FVT_LITTLEBEE_30A_MAIN			EQU 205  
  00CE                 481     FVT_LITTLEBEE_30A_TAIL			EQU 206  
  00CF                 482     FVT_LITTLEBEE_30A_MULTI			EQU 207  
  00D0                 483     GRAUPNER_ULTRA_20A_MAIN			EQU 208  
  00D1                 484     GRAUPNER_ULTRA_20A_TAIL			EQU 209  
  00D2                 485     GRAUPNER_ULTRA_20A_MULTI			EQU 210  
  00D3                 486     F85_3A_MAIN					EQU 211  
  00D4                 487     F85_3A_TAIL					EQU 212  
  00D5                 488     F85_3A_MULTI					EQU 213  
  00D6                 489     ZTW_SPIDER_PRO_20A_MAIN			EQU 214  
  00D7                 490     ZTW_SPIDER_PRO_20A_TAIL			EQU 215  
  00D8                 491     ZTW_SPIDER_PRO_20A_MULTI			EQU 216  
                       492     
                       493     
                       494     ;**** **** **** **** ****
                       495     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                       496     ;BESCNO EQU XP_3A_Main 
                       497     ;BESCNO EQU XP_3A_Tail
                       498     ;BESCNO EQU XP_3A_Multi
                       499     ;BESCNO EQU XP_7A_Main
                       500     ;BESCNO EQU XP_7A_Tail
                       501     ;BESCNO EQU XP_7A_Multi
                       502     ;BESCNO EQU XP_7A_Fast_Main
                       503     ;BESCNO EQU XP_7A_Fast_Tail
                       504     ;BESCNO EQU XP_7A_Fast_Multi
                       505     ;BESCNO EQU XP_12A_Main
                       506     ;BESCNO EQU XP_12A_Tail 
                       507     ;BESCNO EQU XP_12A_Multi
                       508     ;BESCNO EQU XP_18A_Main 
                       509     ;BESCNO EQU XP_18A_Tail 
                       510     ;BESCNO EQU XP_18A_Multi
                       511     ;BESCNO EQU XP_25A_Main 
                       512     ;BESCNO EQU XP_25A_Tail 
                       513     ;BESCNO EQU XP_25A_Multi
                       514     ;BESCNO EQU XP_35A_SW_Main
                       515     ;BESCNO EQU XP_35A_SW_Tail 
                       516     ;BESCNO EQU XP_35A_SW_Multi
                       517     ;BESCNO EQU DP_3A_Main 						
                       518     ;BESCNO EQU DP_3A_Tail 
                       519     ;BESCNO EQU DP_3A_Multi 
                       520     ;BESCNO EQU Supermicro_3p5A_Main
                       521     ;BESCNO EQU Supermicro_3p5A_Tail 
                       522     ;BESCNO EQU Supermicro_3p5A_Multi
                       523     ;BESCNO EQU Turnigy_Plush_6A_Main 
                       524     ;BESCNO EQU Turnigy_Plush_6A_Tail 
                       525     ;BESCNO EQU Turnigy_Plush_6A_Multi
                       526     ;BESCNO EQU Turnigy_Plush_10A_Main 
                       527     ;BESCNO EQU Turnigy_Plush_10A_Tail 
                       528     ;BESCNO EQU Turnigy_Plush_10A_Multi
                       529     ;BESCNO EQU Turnigy_Plush_12A_Main 
                       530     ;BESCNO EQU Turnigy_Plush_12A_Tail 
                       531     ;BESCNO EQU Turnigy_Plush_12A_Multi 
                       532     ;BESCNO EQU Turnigy_Plush_18A_Main 
                       533     ;BESCNO EQU Turnigy_Plush_18A_Tail 
                       534     ;BESCNO EQU Turnigy_Plush_18A_Multi
                       535     ;BESCNO EQU Turnigy_Plush_25A_Main 
                       536     ;BESCNO EQU Turnigy_Plush_25A_Tail
                       537     ;BESCNO EQU Turnigy_Plush_25A_Multi
                       538     ;BESCNO EQU Turnigy_Plush_30A_Main 
                       539     ;BESCNO EQU Turnigy_Plush_30A_Tail 
                       540     ;BESCNO EQU Turnigy_Plush_30A_Multi
                       541     ;BESCNO EQU Turnigy_Plush_40A_Main 
                       542     ;BESCNO EQU Turnigy_Plush_40A_Tail 
                       543     ;BESCNO EQU Turnigy_Plush_40A_Multi 
                       544     ;BESCNO EQU Turnigy_Plush_60A_Main
                       545     ;BESCNO EQU Turnigy_Plush_60A_Tail 
                       546     ;BESCNO EQU Turnigy_Plush_60A_Multi
                       547     ;BESCNO EQU Turnigy_Plush_80A_Main
                       548     ;BESCNO EQU Turnigy_Plush_80A_Tail 
                       549     ;BESCNO EQU Turnigy_Plush_80A_Multi
                       550     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Main
                       551     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Tail 
                       552     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Multi 
                       553     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Main 
                       554     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Tail
                       555     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Multi
                       556     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Main  
                       557     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Tail 
                       558     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Multi
                       559     ;BESCNO EQU Turnigy_AE_20A_Main 
                       560     ;BESCNO EQU Turnigy_AE_20A_Tail 
                       561     ;BESCNO EQU Turnigy_AE_20A_Multi
                       562     ;BESCNO EQU Turnigy_AE_25A_Main 
                       563     ;BESCNO EQU Turnigy_AE_25A_Tail 
                       564     ;BESCNO EQU Turnigy_AE_25A_Multi
                       565     ;BESCNO EQU Turnigy_AE_30A_Main 
                       566     ;BESCNO EQU Turnigy_AE_30A_Tail 
                       567     ;BESCNO EQU Turnigy_AE_30A_Multi
                       568     ;BESCNO EQU Turnigy_AE_45A_Main
                       569     ;BESCNO EQU Turnigy_AE_45A_Tail 
                       570     ;BESCNO EQU Turnigy_AE_45A_Multi
                       571     ;BESCNO EQU Turnigy_KForce_40A_Main
                       572     ;BESCNO EQU Turnigy_KForce_40A_Tail 
                       573     ;BESCNO EQU Turnigy_KForce_40A_Multi 
                       574     ;BESCNO EQU Turnigy_KForce_70A_HV_Main
                       575     ;BESCNO EQU Turnigy_KForce_70A_HV_Tail 
                       576     ;BESCNO EQU Turnigy_KForce_70A_HV_Multi
                       577     ;BESCNO EQU Turnigy_KForce_120A_HV_Main
                       578     ;BESCNO EQU Turnigy_KForce_120A_HV_Tail 
                       579     ;BESCNO EQU Turnigy_KForce_120A_HV_Multi
                       580     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Main
                       581     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Tail 
                       582     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Multi
                       583     ;BESCNO EQU Skywalker_20A_Main
                       584     ;BESCNO EQU Skywalker_20A_Tail
                       585     ;BESCNO EQU Skywalker_20A_Multi 
                       586     ;BESCNO EQU Skywalker_40A_Main 
                       587     ;BESCNO EQU Skywalker_40A_Tail 
                       588     ;BESCNO EQU Skywalker_40A_Multi
                       589     ;BESCNO EQU HiModel_Cool_22A_Main
                       590     ;BESCNO EQU HiModel_Cool_22A_Tail
                       591     ;BESCNO EQU HiModel_Cool_22A_Multi
                       592     ;BESCNO EQU HiModel_Cool_33A_Main
                       593     ;BESCNO EQU HiModel_Cool_33A_Tail
                       594     ;BESCNO EQU HiModel_Cool_33A_Multi
                       595     ;BESCNO EQU HiModel_Cool_41A_Main
                       596     ;BESCNO EQU HiModel_Cool_41A_Tail
                       597     ;BESCNO EQU HiModel_Cool_41A_Multi
                       598     ;BESCNO EQU RCTimer_6A_Main
                       599     ;BESCNO EQU RCTimer_6A_Tail
                       600     ;BESCNO EQU RCTimer_6A_Multi
                       601     ;BESCNO EQU Align_RCE_BL15X_Main
                       602     ;BESCNO EQU Align_RCE_BL15X_Tail
                       603     ;BESCNO EQU Align_RCE_BL15X_Multi
                       604     ;BESCNO EQU Align_RCE_BL15P_Main
                       605     ;BESCNO EQU Align_RCE_BL15P_Tail
                       606     ;BESCNO EQU Align_RCE_BL15P_Multi 
                       607     ;BESCNO EQU Align_RCE_BL35X_Main 
                       608     ;BESCNO EQU Align_RCE_BL35X_Tail
                       609     ;BESCNO EQU Align_RCE_BL35X_Multi
                       610     ;BESCNO EQU Align_RCE_BL35P_Main
                       611     ;BESCNO EQU Align_RCE_BL35P_Tail
                       612     ;BESCNO EQU Align_RCE_BL35P_Multi
                       613     ;BESCNO EQU Gaui_GE_183_18A_Main
                       614     ;BESCNO EQU Gaui_GE_183_18A_Tail
                       615     ;BESCNO EQU Gaui_GE_183_18A_Multi
                       616     ;BESCNO EQU H_King_10A_Main 
                       617     ;BESCNO EQU H_King_10A_Tail 
                       618     ;BESCNO EQU H_King_10A_Multi
                       619     ;BESCNO EQU H_King_20A_Main
                       620     ;BESCNO EQU H_King_20A_Tail
                       621     ;BESCNO EQU H_King_20A_Multi
                       622     ;BESCNO EQU H_King_35A_Main
                       623     ;BESCNO EQU H_King_35A_Tail
                       624     ;BESCNO EQU H_King_35A_Multi
                       625     ;BESCNO EQU H_King_50A_Main
                       626     ;BESCNO EQU H_King_50A_Tail
                       627     ;BESCNO EQU H_King_50A_Multi
                       628     ;BESCNO EQU Polaris_Thunder_12A_Main
                       629     ;BESCNO EQU Polaris_Thunder_12A_Tail
                       630     ;BESCNO EQU Polaris_Thunder_12A_Multi
                       631     ;BESCNO EQU Polaris_Thunder_20A_Main
                       632     ;BESCNO EQU Polaris_Thunder_20A_Tail
                       633     ;BESCNO EQU Polaris_Thunder_20A_Multi
                       634     ;BESCNO EQU Polaris_Thunder_30A_Main
                       635     ;BESCNO EQU Polaris_Thunder_30A_Tail
                       636     ;BESCNO EQU Polaris_Thunder_30A_Multi
                       637     ;BESCNO EQU Polaris_Thunder_40A_Main
                       638     ;BESCNO EQU Polaris_Thunder_40A_Tail
                       639     ;BESCNO EQU Polaris_Thunder_40A_Multi
                       640     ;BESCNO EQU Polaris_Thunder_60A_Main
                       641     ;BESCNO EQU Polaris_Thunder_60A_Tail
                       642     ;BESCNO EQU Polaris_Thunder_60A_Multi
                       643     ;BESCNO EQU Polaris_Thunder_80A_Main
                       644     ;BESCNO EQU Polaris_Thunder_80A_Tail
                       645     ;BESCNO EQU Polaris_Thunder_80A_Multi
                       646     ;BESCNO EQU Polaris_Thunder_100A_Main
                       647     ;BESCNO EQU Polaris_Thunder_100A_Tail
                       648     ;BESCNO EQU Polaris_Thunder_100A_Multi
                       649     ;BESCNO EQU Platinum_Pro_30A_Main
                       650     ;BESCNO EQU Platinum_Pro_30A_Tail
                       651     ;BESCNO EQU Platinum_Pro_30A_Multi 
                       652     ;BESCNO EQU Platinum_Pro_150A_Main
                       653     ;BESCNO EQU Platinum_Pro_150A_Tail
                       654     ;BESCNO EQU Platinum_Pro_150A_Multi
                       655     ;BESCNO EQU Platinum_50Av3_Main
                       656     ;BESCNO EQU Platinum_50Av3_Tail
                       657     ;BESCNO EQU Platinum_50Av3_Multi 
                       658     ;BESCNO EQU EAZY_3Av2_Main
                       659     ;BESCNO EQU EAZY_3Av2_Tail
                       660     ;BESCNO EQU EAZY_3Av2_Multi
                       661     ;BESCNO EQU Tarot_30A_Main
                       662     ;BESCNO EQU Tarot_30A_Tail
                       663     ;BESCNO EQU Tarot_30A_Multi
                       664     ;BESCNO EQU SkyIII_30A_Main
                       665     ;BESCNO EQU SkyIII_30A_Tail
                       666     ;BESCNO EQU SkyIII_30A_Multi
                       667     ;BESCNO EQU EMAX_20A_Main
                       668     ;BESCNO EQU EMAX_20A_Tail
                       669     ;BESCNO EQU EMAX_20A_Multi 
                       670     ;BESCNO EQU EMAX_40A_Main
                       671     ;BESCNO EQU EMAX_40A_Tail
                       672     ;BESCNO EQU EMAX_40A_Multi 
                       673     ;BESCNO EQU EMAX_Nano_20A_Main
                       674     ;BESCNO EQU EMAX_Nano_20A_Tail
                       675     ;BESCNO EQU EMAX_Nano_20A_Multi 
                       676     ;BESCNO EQU XRotor_10A_Main 
                       677     ;BESCNO EQU XRotor_10A_Tail
                       678     ;BESCNO EQU XRotor_10A_Multi 
                       679     ;BESCNO EQU XRotor_20A_Main
                       680     ;BESCNO EQU XRotor_20A_Tail
                       681     ;BESCNO EQU XRotor_20A_Multi 
                       682     ;BESCNO EQU XRotor_40A_Main
                       683     ;BESCNO EQU XRotor_40A_Tail
                       684     ;BESCNO EQU XRotor_40A_Multi 
                       685     ;BESCNO EQU MDRX62H_Main
                       686     ;BESCNO EQU MDRX62H_Tail
                       687     ;BESCNO EQU MDRX62H_Multi 
                       688     ;BESCNO EQU RotorGeeks_20A_Main
                       689     ;BESCNO EQU RotorGeeks_20A_Tail
                       690     ;BESCNO EQU RotorGeeks_20A_Multi
                       691     ;BESCNO EQU Flycolor_Fairy_6A_Main
                       692     ;BESCNO EQU Flycolor_Fairy_6A_Tail
                       693     ;BESCNO EQU Flycolor_Fairy_6A_Multi
                       694     ;BESCNO EQU Flycolor_Fairy_30A_Main
                       695     ;BESCNO EQU Flycolor_Fairy_30A_Tail
                       696     ;BESCNO EQU Flycolor_Fairy_30A_Multi
                       697     ;BESCNO EQU FVT_Littlebee_20A_Main
                       698     ;BESCNO EQU FVT_Littlebee_20A_Tail
                       699     ;BESCNO EQU FVT_Littlebee_20A_Multi 
                       700     ;BESCNO EQU FVT_Littlebee_30A_Main
                       701     ;BESCNO EQU FVT_Littlebee_30A_Tail
                       702     ;BESCNO EQU FVT_Littlebee_30A_Multi 
                       703     ;BESCNO EQU Graupner_Ultra_20A_Main
                       704     ;BESCNO EQU Graupner_Ultra_20A_Tail
                       705     ;BESCNO EQU Graupner_Ultra_20A_Multi 
                       706     ;BESCNO EQU F85_3A_Main
                       707     ;BESCNO EQU F85_3A_Tail
                       708     ;BESCNO EQU F85_3A_Multi
                       709     ;BESCNO EQU ZTW_Spider_Pro_20A_Main
                       710     ;BESCNO EQU ZTW_Spider_Pro_20A_Tail
                       711     ;BESCNO EQU ZTW_Spider_Pro_20A_Multi
                       712     
                       713     
                       714     ;**** **** **** **** ****
                       715     ; ESC selection statements
                       716     IF BESCNO == XP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       720     
                       721     IF BESCNO == XP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       725     
                       726     IF BESCNO == XP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       730     
                       731     IF BESCNO == XP_7A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       735     
                       736     IF BESCNO == XP_7A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       740     
                       741     IF BESCNO == XP_7A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       745     
                       746     IF BESCNO == XP_7A_FAST_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       750     
                       751     IF BESCNO == XP_7A_FAST_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       755     
                       756     IF BESCNO == XP_7A_FAST_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       760     
                       761     IF BESCNO == XP_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       765     
                       766     IF BESCNO == XP_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       770     
                       771     IF BESCNO == XP_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       775     
                       776     IF BESCNO == XP_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       780     
                       781     IF BESCNO == XP_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       785     
                       786     IF BESCNO == XP_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       790     
                       791     IF BESCNO == XP_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       795     
                       796     IF BESCNO == XP_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       800     
                       801     IF BESCNO == XP_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       805     
                       806     IF BESCNO == XP_35A_SW_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       810     
                       811     IF BESCNO == XP_35A_SW_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       815     
                       816     IF BESCNO == XP_35A_SW_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       820     
                       821     IF BESCNO == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       825     
                       826     IF BESCNO == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       830     
                       831     IF BESCNO == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       835     
                       836     IF BESCNO == SUPERMICRO_3P5A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       840     
                       841     IF BESCNO == SUPERMICRO_3P5A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       845     
                       846     IF BESCNO == SUPERMICRO_3P5A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       850     
                       851     IF BESCNO == TURNIGY_PLUSH_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       855     
                       856     IF BESCNO == TURNIGY_PLUSH_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       860     
                       861     IF BESCNO == TURNIGY_PLUSH_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       865     
                       866     IF BESCNO == TURNIGY_PLUSH_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       870     
                       871     IF BESCNO == TURNIGY_PLUSH_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       875     
                       876     IF BESCNO == TURNIGY_PLUSH_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       880     
                       881     IF BESCNO == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       885     
                       886     IF BESCNO == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       890     
                       891     IF BESCNO == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       895     
                       896     IF BESCNO == TURNIGY_PLUSH_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       900     
                       901     IF BESCNO == TURNIGY_PLUSH_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       905     
                       906     IF BESCNO == TURNIGY_PLUSH_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       910     
                       911     IF BESCNO == TURNIGY_PLUSH_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       915     
                       916     IF BESCNO == TURNIGY_PLUSH_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       920     
                       921     IF BESCNO == TURNIGY_PLUSH_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       925     
                       926     IF BESCNO == TURNIGY_PLUSH_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       930     
                       931     IF BESCNO == TURNIGY_PLUSH_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       935     
                       936     IF BESCNO == TURNIGY_PLUSH_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       940     
                       941     IF BESCNO == TURNIGY_PLUSH_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       945     
                       946     IF BESCNO == TURNIGY_PLUSH_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       950     
                       951     IF BESCNO == TURNIGY_PLUSH_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       955     
                       956     IF BESCNO == TURNIGY_PLUSH_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       960     
                       961     IF BESCNO == TURNIGY_PLUSH_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       965     
                       966     IF BESCNO == TURNIGY_PLUSH_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       970     
                       971     IF BESCNO == TURNIGY_PLUSH_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       975     
                       976     IF BESCNO == TURNIGY_PLUSH_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       980     
                       981     IF BESCNO == TURNIGY_PLUSH_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       985     
                       986     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       990     
                       991     IF BESCNO == TURNIGY_PLUSH_NFET_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       995     
                       996     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1000     
                      1001     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1005     
                      1006     IF BESCNO == TURNIGY_PLUSH_NFET_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1010     
                      1011     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1015     
                      1016     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1020     
                      1021     IF BESCNO == TURNIGY_PLUSH_NFET_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1025     
                      1026     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1030     
                      1031     IF BESCNO == TURNIGY_AE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1035     
                      1036     IF BESCNO == TURNIGY_AE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1040     
                      1041     IF BESCNO == TURNIGY_AE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1045     
                      1046     IF BESCNO == TURNIGY_AE_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1050     
                      1051     IF BESCNO == TURNIGY_AE_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1055     
                      1056     IF BESCNO == TURNIGY_AE_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1060     
                      1061     IF BESCNO == TURNIGY_AE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1065     
                      1066     IF BESCNO == TURNIGY_AE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1070     
                      1071     IF BESCNO == TURNIGY_AE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1075     
                      1076     IF BESCNO == TURNIGY_AE_45A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1080     
                      1081     IF BESCNO == TURNIGY_AE_45A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1085     
                      1086     IF BESCNO == TURNIGY_AE_45A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1090     
                      1091     IF BESCNO == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1095     
                      1096     IF BESCNO == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1100     
                      1101     IF BESCNO == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1105     
                      1106     IF BESCNO == TURNIGY_KFORCE_70A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1110     
                      1111     IF BESCNO == TURNIGY_KFORCE_70A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1115     
                      1116     IF BESCNO == TURNIGY_KFORCE_70A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1120     
                      1121     IF BESCNO == TURNIGY_KFORCE_120A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1125     
                      1126     IF BESCNO == TURNIGY_KFORCE_120A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1130     
                      1131     IF BESCNO == TURNIGY_KFORCE_120A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1135     
                      1136     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1140     
                      1141     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1145     
                      1146     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1150     
                      1151     IF BESCNO == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1155     
                      1156     IF BESCNO == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1160     
                      1161     IF BESCNO == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1165     
                      1166     IF BESCNO == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1170     
                      1171     IF BESCNO == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1175     
                      1176     IF BESCNO == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1180     
                      1181     IF BESCNO == HIMODEL_COOL_22A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1185     
                      1186     IF BESCNO == HIMODEL_COOL_22A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1190     
                      1191     IF BESCNO == HIMODEL_COOL_22A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1195     
                      1196     IF BESCNO == HIMODEL_COOL_33A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1200     
                      1201     IF BESCNO == HIMODEL_COOL_33A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1205     
                      1206     IF BESCNO == HIMODEL_COOL_33A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1210     
                      1211     IF BESCNO == HIMODEL_COOL_41A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1215     
                      1216     IF BESCNO == HIMODEL_COOL_41A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1220     
                      1221     IF BESCNO == HIMODEL_COOL_41A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1225     
                      1226     IF BESCNO == RCTIMER_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1230     
                      1231     IF BESCNO == RCTIMER_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1235     
                      1236     IF BESCNO == RCTIMER_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1240     
                      1241     IF BESCNO == ALIGN_RCE_BL15X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1245     
                      1246     IF BESCNO == ALIGN_RCE_BL15X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1250     
                      1251     IF BESCNO == ALIGN_RCE_BL15X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1255     
                      1256     IF BESCNO == ALIGN_RCE_BL15P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1260     
                      1261     IF BESCNO == ALIGN_RCE_BL15P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1265     
                      1266     IF BESCNO == ALIGN_RCE_BL15P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1270     
                      1271     IF BESCNO == ALIGN_RCE_BL35X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1275     
                      1276     IF BESCNO == ALIGN_RCE_BL35X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1280     
                      1281     IF BESCNO == ALIGN_RCE_BL35X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1285     
                      1286     IF BESCNO == ALIGN_RCE_BL35P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1290     
                      1291     IF BESCNO == ALIGN_RCE_BL35P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1295     
                      1296     IF BESCNO == ALIGN_RCE_BL35P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1300     
                      1301     IF BESCNO == GAUI_GE_183_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1305     
                      1306     IF BESCNO == GAUI_GE_183_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1310     
                      1311     IF BESCNO == GAUI_GE_183_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1315     
                      1316     IF BESCNO == H_KING_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1320     
                      1321     IF BESCNO == H_KING_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1325     
                      1326     IF BESCNO == H_KING_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1330     
                      1331     IF BESCNO == H_KING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1335     
                      1336     IF BESCNO == H_KING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1340     
                      1341     IF BESCNO == H_KING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1345     
                      1346     IF BESCNO == H_KING_35A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1350     
                      1351     IF BESCNO == H_KING_35A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1355     
                      1356     IF BESCNO == H_KING_35A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1360     
                      1361     IF BESCNO == H_KING_50A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1365     
                      1366     IF BESCNO == H_KING_50A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1370     
                      1371     IF BESCNO == H_KING_50A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1375     
                      1376     IF BESCNO == POLARIS_THUNDER_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1380     
                      1381     IF BESCNO == POLARIS_THUNDER_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1385     
                      1386     IF BESCNO == POLARIS_THUNDER_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1390     
                      1391     IF BESCNO == POLARIS_THUNDER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1395     
                      1396     IF BESCNO == POLARIS_THUNDER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1400     
                      1401     IF BESCNO == POLARIS_THUNDER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1405     
                      1406     IF BESCNO == POLARIS_THUNDER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1410     
                      1411     IF BESCNO == POLARIS_THUNDER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1415     
                      1416     IF BESCNO == POLARIS_THUNDER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1420     
                      1421     IF BESCNO == POLARIS_THUNDER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1425     
                      1426     IF BESCNO == POLARIS_THUNDER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1430     
                      1431     IF BESCNO == POLARIS_THUNDER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1435     
                      1436     IF BESCNO == POLARIS_THUNDER_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1440     
                      1441     IF BESCNO == POLARIS_THUNDER_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1445     
                      1446     IF BESCNO == POLARIS_THUNDER_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1450     
                      1451     IF BESCNO == POLARIS_THUNDER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1455     
                      1456     IF BESCNO == POLARIS_THUNDER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1460     
                      1461     IF BESCNO == POLARIS_THUNDER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1465     
                      1466     IF BESCNO == POLARIS_THUNDER_100A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1470     
                      1471     IF BESCNO == POLARIS_THUNDER_100A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1475     
                      1476     IF BESCNO == POLARIS_THUNDER_100A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1480     
                      1481     IF BESCNO == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1485     
                      1486     IF BESCNO == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1490     
                      1491     IF BESCNO == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1495     
                      1496     IF BESCNO == PLATINUM_PRO_150A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1500     
                      1501     IF BESCNO == PLATINUM_PRO_150A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1505     
                      1506     IF BESCNO == PLATINUM_PRO_150A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1510     
                      1511     IF BESCNO == PLATINUM_50AV3_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1515     
                      1516     IF BESCNO == PLATINUM_50AV3_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1520     
                      1521     IF BESCNO == PLATINUM_50AV3_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1525     
                      1526     IF BESCNO == EAZY_3AV2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1530     
                      1531     IF BESCNO == EAZY_3AV2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1535     
                      1536     IF BESCNO == EAZY_3AV2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1540     
                      1541     IF BESCNO == TAROT_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1545     
                      1546     IF BESCNO == TAROT_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1550     
                      1551     IF BESCNO == TAROT_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1555     
                      1556     IF BESCNO == SKYIII_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1560     
                      1561     IF BESCNO == SKYIII_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1565     
                      1566     IF BESCNO == SKYIII_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1570     
                      1571     IF BESCNO == EMAX_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1575     
                      1576     IF BESCNO == EMAX_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1580     
                      1581     IF BESCNO == EMAX_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1585     
                      1586     IF BESCNO == EMAX_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1590     
                      1591     IF BESCNO == EMAX_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1595     
                      1596     IF BESCNO == EMAX_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1600     
                      1601     IF BESCNO == EMAX_NANO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1605     
                      1606     IF BESCNO == EMAX_NANO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1610     
                      1611     IF BESCNO == EMAX_NANO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1615     
                      1616     IF BESCNO == XROTOR_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1620     
                      1621     IF BESCNO == XROTOR_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1625     
                      1626     IF BESCNO == XROTOR_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1630     
                      1631     IF BESCNO == XROTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1635     
                      1636     IF BESCNO == XROTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1640     
                      1641     IF BESCNO == XROTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1645     
                      1646     IF BESCNO == XROTOR_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1650     
                      1651     IF BESCNO == XROTOR_40A_TAIL
  0001                1652     MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                      1653     $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                      2267     ENDIF
                      2268     
                      2269     IF BESCNO == XROTOR_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      2273     
                      2274     IF BESCNO == MDRX62H_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2278     
                      2279     IF BESCNO == MDRX62H_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2283     
                      2284     IF BESCNO == MDRX62H_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2288     
                      2289     IF BESCNO == ROTORGEEKS_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2293     
                      2294     IF BESCNO == ROTORGEEKS_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2298     
                      2299     IF BESCNO == ROTORGEEKS_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2303     
                      2304     IF BESCNO == FLYCOLOR_FAIRY_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2308     
                      2309     IF BESCNO == FLYCOLOR_FAIRY_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2313     
                      2314     IF BESCNO == FLYCOLOR_FAIRY_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2318     
                      2319     IF BESCNO == FLYCOLOR_FAIRY_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2323     
                      2324     IF BESCNO == FLYCOLOR_FAIRY_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2328     
                      2329     IF BESCNO == FLYCOLOR_FAIRY_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2333     
                      2334     IF BESCNO == FVT_LITTLEBEE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2338     
                      2339     IF BESCNO == FVT_LITTLEBEE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2343     
                      2344     IF BESCNO == FVT_LITTLEBEE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2348     
                      2349     IF BESCNO == FVT_LITTLEBEE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2353     
                      2354     IF BESCNO == FVT_LITTLEBEE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2358     
                      2359     IF BESCNO == FVT_LITTLEBEE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2363     
                      2364     IF BESCNO == GRAUPNER_ULTRA_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2368     
                      2369     IF BESCNO == GRAUPNER_ULTRA_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2373     
                      2374     IF BESCNO == GRAUPNER_ULTRA_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2378     
                      2379     IF BESCNO == F85_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2383     
                      2384     IF BESCNO == F85_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2388     
                      2389     IF BESCNO == F85_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2393     
                      2394     IF BESCNO == ZTW_SPIDER_PRO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2398     
                      2399     IF BESCNO == ZTW_SPIDER_PRO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2403     
                      2404     IF BESCNO == ZTW_SPIDER_PRO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2408     
                      2409     
                      2410     ;**** **** **** **** ****
                      2411     ; TX programming defaults
                      2412     ;
                      2413     ; Parameter dependencies:
                      2414     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                      2415     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                      2416     ;
                      2417     ; MAIN
  0007                2418     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                2419     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                2420     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                2421     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                2422     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                2423     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2424     IF DAMPED_MODE_ENABLE == 1
  0002                2425     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
                      2426     ELSE
                               DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low	
                               ENDIF
  0001                2429     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2430     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                2431     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                2432     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                2433     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                2434     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                2435     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                2436     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                      2437     
                      2438     ; TAIL
  0003                2439     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                2440     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                2441     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2442     IF DAMPED_MODE_ENABLE == 1
  0003                2443     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                      2444     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		
                               ENDIF
  0001                2447     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2448     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2449     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                2450     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                2451     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                2452     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2453     DEFAULT_PGM_TAIL_PWM_DITHER		EQU 3 	; 1=Off		2=7			3=15			4=31			5=63
                      2454     
                      2455     ; MULTI
  0009                2456     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                2457     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                2458     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                2459     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0003                2460     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2461     IF DAMPED_MODE_ENABLE == 1
  0001                2462     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight 
                      2463     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low
                               ENDIF
  0002                2466     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                2467     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2468     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0028                2469     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0050                2470     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0004                2471     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2472     DEFAULT_PGM_MULTI_PWM_DITHER		EQU 3 	; 1=Off		2=7			3=15			4=31			5=63
                      2473     
                      2474     ; COMMON
  0001                2475     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 1 	; 1=Enabled 	0=Disabled
  0025                2476     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 37	; 4*37+1000=1148
  00D0                2477     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 208	; 4*208+1000=1832
  007A                2478     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 122	; 4*122+1000=1488 (used in bidirectional mode)
  0000                2479     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0=Low		1+= High or higher	
  0001                2480     DEFAULT_PGM_ENABLE_TEMP_PROT	 	EQU 1 	; 1=Enabled 	0=Disabled
  0001                2481     DEFAULT_PGM_ENABLE_POWER_PROT 	EQU 1 	; 1=Enabled 	0=Disabled
  0000                2482     DEFAULT_PGM_ENABLE_PWM_INPUT	 	EQU 0 	; 1=Enabled 	0=Disabled
                      2483     
                      2484     ; PATRICK'S CHANGES
  002B                2485     MOTOR_PPM_LOW_SLOPE				EQU 43   ;256/6 = 43 -Patrick
                      2486     
                      2487     ;**** **** **** **** ****
                      2488     ; Constant definitions for main
                      2489     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2508     ; Constant definitions for tail
                      2509     IF MODE == 1
                      2510     
  0001                2511     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
  000A                2512     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                2513     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                2514     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                2515     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                2516     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                2517     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                2518     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  0082                2519     RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                      2520     
  0032                2521     PWM_START			EQU	50 	; PWM used as max power during start
                      2522     
  0001                2523     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                      2524     
  0008                2525     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                      2526     
                      2527     ENDIF
                      2528     ; Constant definitions for multi
                      2529     IF MODE == 2
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2548     
                      2549     ;**** **** **** **** ****
                      2550     ; Temporary register definitions
  REG                 2551     TEMP1		EQU	R0
  REG                 2552     TEMP2		EQU	R1
  REG                 2553     TEMP3		EQU	R2
  REG                 2554     TEMP4		EQU	R3
  REG                 2555     TEMP5		EQU	R4
  REG                 2556     TEMP6		EQU	R5
  REG                 2557     TEMP7		EQU	R6
  REG                 2558     TEMP8		EQU	R7
                      2559     
                      2560     ;**** **** **** **** ****
                      2561     ; Register definitions
------                2562     DSEG AT 20H					; Variables segment 
                      2563     
0020                  2564     BIT_ACCESS: 				DS	1		; MUST BE AT THIS ADDRESS. Variable at bit accessible address (for non interrupt routines)
0021                  2565     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                      2566     
0022                  2567     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                  2568     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                  2569     CURRENT_PWM: 				DS	1		; Current pwm
0025                  2570     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited
0026                  2571     CURRENT_PWM_LIM_DITH: 		DS	1		; Current pwm that is limited and dithered (applied to the motor output)
0027                  2572     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0028                  2573     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0029                  2574     RCP_OUTSIDE_RANGE_CNT: 		DS	1		; RC pulse outside range counter (incrementing) 
002A                  2575     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
002B                  2576     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
                      2577     
002C                  2578     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                2579     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                2580     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                2581     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                2582     PWM_TIMER0_OVERFLOW			EQU	3		; Set for 48MHz MCUs when PWM timer 0 overflows
  0004                2583     DEMAG_ENABLED				EQU 	4		; Set when demag compensation is enabled (above a min speed and throttle)
  0005                2584     DEMAG_DETECTED				EQU 	5		; Set when excessive demag time is detected
  0006                2585     DEMAG_CUT_POWER			EQU 	6		; Set when demag compensation cuts power
  0007                2586     HIGH_RPM					EQU 	7		; Set when motor rpm is high (Comm_Period4x_H less than 2)
                      2587     
002D                  2588     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                2589     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                2590     STARTUP_PHASE				EQU 	1		; Set when in startup phase
  0002                2591     INITIAL_RUN_PHASE			EQU	2		; Set when in initial run phase, before synchronized run is achieved
  0003                2592     DIR_CHANGE_BRAKE			EQU 	3		; Set when braking before direction change
  0004                2593     COMP_TIMED_OUT				EQU 	4		; Set when comparator reading timed out
  0005                2594     GOV_ACTIVE				EQU 	5		; Set when governor is active (enabled when speed is above minimum)
  0006                2595     SKIP_DAMP_ON				EQU 	6 		; Set when turning damping fet on is skipped
                      2596     ;						EQU 	7 		
                      2597     
002E                  2598     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                2599     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                2600     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                2601     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode
  0003                2602     PGM_PWM_HIGH_FREQ			EQU	3		; Progremmed pwm high frequency
  0004                2603     RCP_PPM					EQU 	4		; RC pulse ppm type input (set also when oneshot is set)
  0005                2604     RCP_PPM_ONESHOT125			EQU 	5		; RC pulse ppm type input is OneShot125
  0006                2605     RCP_DIR_REV				EQU 	6		; RC pulse direction in bidirectional mode
                      2606     ;						EQU 	7	
                      2607     
002F                  2608     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                2609     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                2610     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                2611     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                2612     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                2613     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                2614     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                2615     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                2616     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                      2617     
                      2618     
                      2619     ;**** **** **** **** ****
                      2620     ; RAM definitions
------                2621     DSEG AT 30H						; Ram data segment, direct addressing
                      2622     
0030                  2623     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                      2624     
0031                  2625     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                  2626     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                      2627     
0033                  2628     STARTUP_CNT: 				DS	1		; Startup phase commutations counter (incrementing)
0034                  2629     INITIAL_RUN_ROT_CNT: 		DS	1		; Initial run rotations counter (incrementing)
0035                  2630     STALL_CNT: 				DS	1		; Counts start/run attempts that resulted in stall. Reset upon a proper stop
0036                  2631     DEMAG_DETECTED_METRIC: 		DS	1		; Metric used to gauge demag event frequency
0037                  2632     DEMAG_PWR_OFF_THRESH: 		DS	1		; Metric threshold above which power is cut
0038                  2633     LOW_RPM_PWR_SLOPE: 			DS	1		; Sets the slope of power increase for low rpms
                      2634     
0039                  2635     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003A                  2636     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003B                  2637     PREV_PREV_COMM_L: 			DS	1		; Pre-previous commutation timer3 timestamp (lo byte)
003C                  2638     PREV_PREV_COMM_H: 			DS	1		; Pre-previous commutation timer3 timestamp (hi byte)
003D                  2639     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003E                  2640     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003F                  2641     COMM_DIFF: 				DS	1		; Timer3 count difference between the last two commutations
0040                  2642     COMM_PHASE: 				DS	1		; Current commutation phase
0041                  2643     COMPARATOR_READ_CNT:  		DS	1		; Number of comparator reads done
                      2644     
0042                  2645     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0043                  2646     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0044                  2647     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0045                  2648     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0046                  2649     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0047                  2650     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0048                  2651     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0049                  2652     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
004A                  2653     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
                      2654     
004B                  2655     WT_ADV_START_L: 			DS	1		; Timer3 start point for commutation advance timing (lo byte)
004C                  2656     WT_ADV_START_H: 			DS	1		; Timer3 start point for commutation advance timing (hi byte)
004D                  2657     WT_ZC_SCAN_START_L: 			DS	1		; Timer3 start point from commutation to zero cross scan (lo byte)
004E                  2658     WT_ZC_SCAN_START_H: 			DS	1		; Timer3 start point from commutation to zero cross scan (hi byte)
004F                  2659     WT_ZC_TOUT_START_L: 			DS	1		; Timer3 start point for zero cross scan timeout (lo byte)
0050                  2660     WT_ZC_TOUT_START_H: 			DS	1		; Timer3 start point for zero cross scan timeout (hi byte)
0051                  2661     WT_COMM_START_L: 			DS	1		; Timer3 start point from zero cross to commutation (lo byte)
0052                  2662     WT_COMM_START_H: 			DS	1		; Timer3 start point from zero cross to commutation (hi byte)
0053                  2663     NEXT_WT_START_L: 			DS	1		; Timer3 start point for next wait period (lo byte)
0054                  2664     NEXT_WT_START_H: 			DS	1		; Timer3 start point for next wait period (hi byte)
                      2665     
0055                  2666     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0056                  2667     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0057                  2668     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0058                  2669     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0059                  2670     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
005A                  2671     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
005B                  2672     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
005C                  2673     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005D                  2674     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005E                  2675     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005F                  2676     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
0060                  2677     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      2678     
0061                  2679     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
0062                  2680     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup
0063                  2681     PWM_LIMIT_BY_RPM: 			DS	1		; Maximum allowed pwm for low or high rpms
0064                  2682     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0065                  2683     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0066                  2684     PWM_DITHER_DECODED: 			DS	1		; Decoded pwm dither value
0067                  2685     PWM_DITHER_EXCESS_POWER: 		DS	1		; Excess power (above max) from pwm dither
0068                  2686     RANDOM: 					DS	1		; Random number from LFSR 
                      2687     
0069                  2688     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
006A                  2689     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
006B                  2690     MAIN_SPOOLUP_TIME_3X: 		DS	1		; Main spoolup time x3
006C                  2691     MAIN_SPOOLUP_TIME_10X: 		DS	1		; Main spoolup time x10
006D                  2692     MAIN_SPOOLUP_TIME_15X: 		DS	1		; Main spoolup time x15
                      2693     
006E                  2694     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006F                  2695     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
0070                  2696     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      2697     
0071                  2698     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      2699     
0072                  2700     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
0073                  2701     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      2702     
0074                  2703     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0075                  2704     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0076                  2705     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      2706     
0077                  2707     SKIP_T2_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 interrupt shall be ignored 
0078                  2708     SKIP_T2H_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 high interrupt shall be ignored 
0079                  2709     TIMER0_OVERFLOW_VALUE: 		DS	1		; Remaining timer 0 wait time used with 48MHz MCUs
007A                  2710     CLOCK_SET_AT_48MHZ: 			DS	1		; Variable set if 48MHz MCUs run at 48MHz
007B                  2711     DAMPINGFET: 				DS	1		; Port position of fet used for damping
007C                  2712     CURRENT_PWM_LIMITED_REMAPPED: 	DS	1
007D                  2713     CURRENT_PWM_LIM_DITH_REMAPPED:  DS	1
                      2714     
                      2715     ; Indirect addressing data segment. The variables below must be in this sequence
------                2716     ISEG AT 080H					
0080                  2717     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  2718     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  2719     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  2720     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  2721     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  2722     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  2723     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  2724     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  2725     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  2726     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  2727     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  2728     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  2729     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  2730     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  2731     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  2732     _PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm (unused - place holder)
0090                  2733     _PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration (unused - place holder)
0091                  2734     _PGM_VOLT_COMP: 			DS	1		; Place holder
0092                  2735     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  2736     _PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force (unused - place holder)
0094                  2737     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  2738     _PGM_STARTUP_METHOD: 		DS	1		; Programmed startup method (unused - place holder)
0096                  2739     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  2740     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  2741     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  2742     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  2743     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  2744     _PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate (unused - place holder)
009C                  2745     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  2746     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  2747     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
009F                  2748     PGM_MAIN_SPOOLUP_TIME: 		DS	1		; Programmed main spoolup time
00A0                  2749     PGM_ENABLE_TEMP_PROT: 		DS	1		; Programmed temperature protection enable
00A1                  2750     PGM_ENABLE_POWER_PROT: 		DS	1		; Programmed low rpm power protection enable
00A2                  2751     PGM_ENABLE_PWM_INPUT: 		DS	1		; Programmed PWM input signal enable
00A3                  2752     PGM_PWM_DITHER: 			DS	1		; Programmed output PWM dither
                      2753     
                      2754     ; The sequence of the variables below is no longer of importance
00A4                  2755     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A5                  2756     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A6                  2757     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
                      2758     
                      2759     
                      2760     ; Indirect addressing data segment
------                2761     ISEG AT 0D0H					
00D0                  2762     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      2763     
                      2764     
                      2765     ;**** **** **** **** ****
------                2766     CSEG AT 1A00H            ; "Eeprom" segment
  000E                2767     EEPROM_FW_MAIN_REVISION		EQU	14		; Main revision of the firmware
  0003                2768     EEPROM_FW_SUB_REVISION		EQU	3		; Sub revision of the firmware
  0014                2769     EEPROM_LAYOUT_REVISION		EQU	20		; Revision of the EEPROM layout
                      2770     
1A00    0E            2771     EEP_FW_MAIN_REVISION:  DB 14 
1A01    03            2772     EEP_FW_SUB_REVISION:  DB 3 
1A02    14            2773     EEP_LAYOUT_REVISION:  DB 20 
                      2774     
                      2775     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH	
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH	
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH						
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH	
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH	
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							
                               EEP_PGM_MAIN_SPOOLUP_TIME:	DB	DEFAULT_PGM_MAIN_SPOOLUP_TIME		; EEPROM copy of programmed main spoolup time
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               _EEP_PGM_PWM_DITHER:		DB	0FFH	
                               ENDIF 
                      2813     
                      2814     IF MODE == 1
1A03    FF            2815     _EEP_PGM_GOV_P_GAIN: 		DB	0FFH							
1A04    FF            2816     _EEP_PGM_GOV_I_GAIN: 		DB	0FFH							
1A05    FF            2817     _EEP_PGM_GOV_MODE: 			DB 	0FFH							
1A06    FF            2818     _EEP_PGM_LOW_VOLTAGE_LIM: 	DB	0FFH							
1A07    03            2819     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    04            2820     EEP_PGM_MOTOR_IDLE:  DB 4 
1A09    09            2821     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    03            2822     EEP_PGM_PWM_FREQ:  DB 3 
1A0B    01            2823     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            2824     EEP_PGM_INPUT_POL:  DB 1 
1A0D    5A            2825     EEP_INITIALIZED_L: 			DB	05AH							; EEPROM initialized signature low byte
1A0E    A5            2826     EEP_INITIALIZED_H: 			DB	0A5H							; EEPROM initialized signature high byte
1A0F    01            2827     EEP_ENABLE_TX_PROGRAM:  DB 1 
1A10    FF            2828     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            2829     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    FF            2830     _EEP_PGM_STARTUP_RPM: 		DB	0FFH
1A13    FF            2831     _EEP_PGM_STARTUP_ACCEL: 		DB	0FFH
1A14    FF            2832     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            2833     EEP_PGM_COMM_TIMING:  DB 3 
1A16    FF            2834     _EEP_PGM_DAMPING_FORCE: 		DB	0FFH
1A17    FF            2835     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    FF            2836     _EEP_PGM_STARTUP_METHOD: 		DB	0FFH
1A19    25            2837     EEP_PGM_PPM_MIN_THROTTLE:  DB 37 
1A1A    D0            2838     EEP_PGM_PPM_MAX_THROTTLE:  DB 208 
1A1B    FA            2839     EEP_PGM_BEEP_STRENGTH:  DB 250 
1A1C    FA            2840     EEP_PGM_BEACON_STRENGTH:  DB 250 
1A1D    04            2841     EEP_PGM_BEACON_DELAY:  DB 4 
1A1E    FF            2842     _EEP_PGM_THROTTLE_RATE: 		DB	0FFH
1A1F    01            2843     EEP_PGM_DEMAG_COMP:  DB 1 
1A20    00            2844     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7A            2845     EEP_PGM_PPM_CENTER_THROTTLE:  DB 122 
1A22    FF            2846     _EEP_PGM_MAIN_SPOOLUP_TIME: 	DB	0FFH
1A23    01            2847     EEP_PGM_TEMP_PROT_ENABLE:  DB 1 
1A24    01            2848     EEP_PGM_ENABLE_POWER_PROT:  DB 1 
1A25    00            2849     EEP_PGM_ENABLE_PWM_INPUT:  DB 0 
1A26    03            2850     EEP_PGM_PWM_DITHER:  DB 3 
                      2851     ENDIF
                      2852     
                      2853     IF MODE == 2
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MULTI_P_GAIN			; EEPROM copy of programmed closed loop P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MULTI_I_GAIN			; EEPROM copy of programmed closed loop I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MULTI_GOVERNOR_MODE	; EEPROM copy of programmed closed loop mode
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_MULTI_GAIN			; EEPROM copy of programmed tail gain
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MULTI_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MULTI_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MULTI_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MULTI_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	055H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0AAH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MULTI_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MULTI_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MULTI_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MULTI_BEACON_DELAY	; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MULTI_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               EEP_PGM_PWM_DITHER:			DB	DEFAULT_PGM_MULTI_PWM_DITHER		; EEPROM copy of programmed output PWM dither
                               ENDIF
                      2891     
1A27    FF            2892     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      2893     
------                2894     CSEG AT 1A60H
1A60    20202020      2895     EEP_NAME: 					DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      2896     
                      2897     ;**** **** **** **** ****
                      2898     INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                2898+1   CSEG AT 0  ; CODE SEGMENT START
0000    0219FD        2898+1   JMP RESET 
------                2898+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200B3        2898+1   JMP T0_INT 
------                2898+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0201AB        2898+1   JMP T2_INT 
------                2898+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020351        2898+1   JMP PCA_INT 
------                2898+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    020337        2898+1   JMP T3_INT 
------                2899     CSEG AT 80H			; Code segment after interrupt vectors 
                      2900     
                      2901     ;**** **** **** **** ****
                      2902     
                      2903     ; Table definitions
0080    02030406      2904     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    0406080C      2905     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
0091    10182030
0095    406080A0
0099    C0
009A    00070F1F      2906     PWM_DITHER_TABLE:   		DB 	00H, 07H, 0FH, 1FH, 3FH
009E    3F
                      2907     IF MODE == 0
                                 IF DAMPED_MODE_ENABLE == 1
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 3, 3, 2, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 2, 3, 2, 2
                                 ENDIF
                               ENDIF
                      2915     IF MODE == 1
                      2916       IF DAMPED_MODE_ENABLE == 1
009F    05050D05      2917     TX_PGM_PARAMS_TAIL:   	DB 	5, 5, 13, 5, 3, 5, 3, 3, 2
00A3    03050303
00A7    02
                      2918       ENDIF
                      2919       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF
                      2922     ENDIF
                      2923     IF MODE == 2
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF 
                               ENDIF
                      2931     
                      2932     ; Subroutine remaps pwm value (implements throttle curve)
                      2933     ; Input: A holds value to be remapped and ranges from 0 to 255
                      2934     ; Output: A holds remapped value
                      2935     ; -Patrick
                      2936     MOTOR_PWM_REMAP: 
00A8    C0F0          2937         PUSH B
00AA    75F02B        2938     MOV B , # 43 
00AD    A4            2939         MUL  AB
00AE    E5F0          2940         MOV  A, B
00B0    D0F0          2941         POP  B
00B2    22            2942         RET
                      2943     
                      2944     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2945     ;
                      2946     ; Timer0 interrupt routine
                      2947     ;
                      2948     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      2949     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      2950     ;
                      2951     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2952     T0_INT: 	; Used for pwm control
00B3    C2AF          2953     	CLR 	EA			; Disable all interrupts
                      2954     IF MCU_48MHZ == 1
                      2955     	; Check overflow flag
00B5    306308        2956     JNB FLAGS0 . 3 , T0_INT_START 
                      2957     
00B8    C263          2958     CLR FLAGS0 . 3 
00BA    85798A        2959     	MOV	TL0, TIMER0_OVERFLOW_VALUE	; Set timer 
00BD    D2AF          2960     	SETB	EA			; Enable all interrupts
00BF    32            2961     	RETI
                      2962     
                      2963     T0_INT_START: 
                      2964     ENDIF
00C0    C0D0          2965     	PUSH	PSW			; Preserve registers through interrupt
00C2    C0E0          2966     	PUSH	ACC	
                      2967     	
                      2968     	; Scale Current_Pwm_Limited and Current_Pwm_Lim_Dith by MOTOR_PPM_LOW_SLOPE -Patrick
                      2969     
                      2970     	; Scale Current_Pwm_Limited -Patrick
00C4    E525          2971     	MOV	A, CURRENT_PWM_LIMITED
00C6    11A8          2972     	CALL MOTOR_PWM_REMAP
00C8    F57C          2973     	MOV  CURRENT_PWM_LIMITED_REMAPPED, A
                      2974     
                      2975     	; Scale Current_Pwm_Lim_Dith -Patrick
00CA    E526          2976     	MOV	A, CURRENT_PWM_LIM_DITH
00CC    11A8          2977     	CALL MOTOR_PWM_REMAP
00CE    F57D          2978     	MOV  CURRENT_PWM_LIM_DITH_REMAPPED, A
                      2979     
                      2980     	; Check if pwm is on
00D0    206227        2981     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      2982     
                      2983     	; Pwm on cycle
00D3    E57C          2984     	MOV	A, CURRENT_PWM_LIMITED_REMAPPED ; Replace with remapped value -Patrick
00D5    6002          2985     	JZ	T0_INT_PWM_ON_EXIT
                      2986     
                      2987     T0_INT_PWM_ON_EXECUTE: 
00D7    E4            2988     	CLR	A					
00D8    73            2989     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      2990     
                      2991     T0_INT_PWM_ON_EXIT: 
                      2992     	; Set timer for coming on cycle length
00D9    E57C          2993     	MOV 	A, CURRENT_PWM_LIMITED_REMAPPED		; Load current pwm and replace with remapped value -Patrick
00DB    F4            2994     	CPL	A						; cpl is 255-x
                      2995     IF MCU_48MHZ == 0
                               	MOV	TL0, A					; Write start point for timer
                               ELSE
00DC    C3            2998     	CLR	C
00DD    33            2999     	RLC	A
00DE    4009          3000     	JC	T0_INT_PWM_ON_SET_TIMER
                      3001     
00E0    758A00        3002     	MOV	TL0, #0
00E3    D263          3003     SETB FLAGS0 . 3 
00E5    F579          3004     	MOV	TIMER0_OVERFLOW_VALUE, A
00E7    01EB          3005     	AJMP	T0_INT_PWM_ON_TIMER_SET
                      3006     
                      3007     T0_INT_PWM_ON_SET_TIMER: 
00E9    F58A          3008     	MOV	TL0, A
                      3009     T0_INT_PWM_ON_TIMER_SET: 
                      3010     ENDIF
                      3011     	; Set other variables
00EB    758B00        3012     	MOV	TL1, #0					; Reset timer1	
                      3013     IF MCU_48MHZ == 1
00EE    758D00        3014     	MOV	TH1, #0		
                      3015     ENDIF
00F1    D262          3016     SETB FLAGS0 . 2 
                      3017     	; Exit interrupt
00F3    D0E0          3018     	POP	ACC			; Restore preserved registers
00F5    D0D0          3019     	POP	PSW
00F7    D2AF          3020     	SETB	EA			; Enable all interrupts
00F9    32            3021     	RETI
                      3022     
                      3023     
                      3024     	; Pwm off cycle
                      3025     T0_INT_PWM_OFF: 
                      3026     IF MCU_48MHZ == 0
                               	MOV	TL0, CURRENT_PWM_LIM_DITH_REMAPPED	; Load new timer setting and replace with remapped value -Patrick
                               ELSE
00FA    C3            3029     	CLR	C
00FB    E57D          3030     	MOV	A, CURRENT_PWM_LIM_DITH_REMAPPED ; Replace with remapped value -Patrick
00FD    33            3031     	RLC	A
00FE    4009          3032     	JC	T0_INT_PWM_OFF_SET_TIMER 
                      3033     
0100    758A00        3034     	MOV	TL0, #0
0103    D263          3035     SETB FLAGS0 . 3 
0105    F579          3036     	MOV	TIMER0_OVERFLOW_VALUE, A
0107    210B          3037     	AJMP	T0_INT_PWM_OFF_TIMER_SET
                      3038     
                      3039     T0_INT_PWM_OFF_SET_TIMER: 
0109    F58A          3040     	MOV	TL0, A
                      3041     T0_INT_PWM_OFF_TIMER_SET: 
                      3042     ENDIF
                      3043     	; Clear pwm on flag
010B    C262          3044     CLR FLAGS0 . 2 
                      3045     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
010D    E57D          3046     	MOV	A, CURRENT_PWM_LIM_DITH_REMAPPED		; Load current pwm and replace with remapped value -Patrick
010F    F4            3047     	CPL	A						; Full pwm?
0110    6038          3048     	JZ	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      3049     
                      3050     IF DAMPED_MODE_ENABLE == 1
                      3051     	; Do not execute damped pwm when stopped
0112    306803        3052     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_EXIT_NFETS_OFF 
                      3053     
                      3054     	; If damped operation, set pFETs on in pwm_off
0115    207213        3055     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      3056     ENDIF
                      3057     
                      3058     T0_INT_PWM_OFF_EXIT_NFETS_OFF: 	
                      3059     	; Separate exit commands here for minimum delay
0118    758B00        3060     	MOV	TL1, #0		; Reset timer1	
                      3061     IF MCU_48MHZ == 1
011B    758D00        3062     	MOV	TH1, #0		
                      3063     ENDIF
011E    D0E0          3064     	POP	ACC			; Restore preserved registers
0120    D0D0          3065     	POP	PSW
                      3066     	ALL_NFETS_OFF 		; Switch off all nfets
0122    C293          3066+1   CLR P1 . 3 
0124    C297          3066+1   CLR P1 . 7 
0126    C294          3066+1   CLR P1 . 4 
0128    D2AF          3067     	SETB	EA			; Enable all interrupts
012A    32            3068     	RETI
                      3069     
                      3070     T0_INT_PWM_OFF_DAMPED: 
                      3071     IF PFETON_DELAY < 128
                      3072     	ALL_NFETS_OFF 				; Switch off all nfets
012B    C293          3072+1   CLR P1 . 3 
012D    C297          3072+1   CLR P1 . 7 
012F    C294          3072+1   CLR P1 . 4 
0131    206E09        3073     JB FLAGS1 . 6 , T0_INT_PWM_OFF_DAMP_DONE 
                      3074     IF PFETON_DELAY NE 0
0134    740C          3075     MOV A , # 12 
0136    D5E0FD        3076     	DJNZ	ACC, $	
                      3077     ENDIF
                      3078     	DAMPING_FET_ON
0139    E57B          3078+1   MOV A , DAMPINGFET 
013B    4290          3078+1   ORL P1 , A 
                      3079     T0_INT_PWM_OFF_DAMP_DONE: 
                      3080     ENDIF
                      3081     IF PFETON_DELAY >= 128			; "Negative", 1's complement
                               	JB	FLAGS1.SKIP_DAMP_ON, T0_INT_PWM_OFF_DAMP_DONE
                               	DAMPING_FET_ON				; Damping fet on
                               	MOV	A, #PFETON_DELAY
                               	CPL	A
                               T0_INT_PWM_OFF_DAMP_DONE:
                               	ALL_NFETS_OFF 				; Switch off all nfets
                               ENDIF
                      3089     T0_INT_PWM_OFF_EXIT: 	
013D    758B00        3090     	MOV	TL1, #0		; Reset timer1	
                      3091     IF MCU_48MHZ == 1
0140    758D00        3092     	MOV	TH1, #0		
                      3093     ENDIF
0143    D0E0          3094     	POP	ACC			; Restore preserved registers
0145    D0D0          3095     	POP	PSW
0147    D2AF          3096     	SETB	EA			; Enable all interrupts
0149    32            3097     	RETI
                      3098     
                      3099     T0_INT_PWM_OFF_FULLPOWER_EXIT: 
014A    758A00        3100     	MOV	TL0, #0		; Set long time till next interrupt
                      3101     IF MCU_48MHZ == 1
014D    D263          3102     SETB FLAGS0 . 3 
014F    757900        3103     	MOV	TIMER0_OVERFLOW_VALUE, #0
                      3104     ENDIF
0152    C28D          3105     	CLR	TF0			; Clear interrupt flag
0154    D262          3106     SETB FLAGS0 . 2 
0156    213D          3107     	AJMP	T0_INT_PWM_OFF_EXIT
                      3108     
                      3109     
                      3110     PWM_NOFET: 	; Dummy pwm on cycle
0158    01D9          3111     	AJMP	T0_INT_PWM_ON_EXIT
                      3112     
                      3113     PWM_AFET: 		; Pwm on cycle afet on
015A    306805        3114     JNB FLAGS1 . 0 , PWM_AFET_EXIT 
015D    206602        3115     JB FLAGS0 . 6 , PWM_AFET_EXIT 
                      3116     	ANFET_ON	
0160    D293          3116+1   SETB P1 . 3 
                      3117     PWM_AFET_EXIT: 
0162    01D9          3118     	AJMP	T0_INT_PWM_ON_EXIT
                      3119     
                      3120     PWM_BFET: 		; Pwm on cycle bfet on
0164    306805        3121     JNB FLAGS1 . 0 , PWM_BFET_EXIT 
0167    206602        3122     JB FLAGS0 . 6 , PWM_BFET_EXIT 
                      3123     	BNFET_ON
016A    D294          3123+1   SETB P1 . 4 
                      3124     PWM_BFET_EXIT: 
016C    01D9          3125     	AJMP	T0_INT_PWM_ON_EXIT
                      3126     
                      3127     PWM_CFET: 		; Pwm on cycle cfet on
016E    306805        3128     JNB FLAGS1 . 0 , PWM_CFET_EXIT 
0171    206602        3129     JB FLAGS0 . 6 , PWM_CFET_EXIT 
                      3130     	CNFET_ON
0174    D297          3130+1   SETB P1 . 7 
                      3131     PWM_CFET_EXIT: 
0176    01D9          3132     	AJMP	T0_INT_PWM_ON_EXIT
                      3133     
                      3134     PWM_AFET_DAMPED: 	
                      3135     	APFET_OFF
0178    C292          3135+1   CLR P1 . 2 
017A    30680A        3136     JNB FLAGS1 . 0 , PWM_AFET_DAMPED_EXIT 
017D    206607        3137     JB FLAGS0 . 6 , PWM_AFET_DAMPED_EXIT 
                      3138     IF NFETON_DELAY NE 0
0180    740C          3139     MOV A , # 12 
0182    D5E0FD        3140     	DJNZ ACC,	$
                      3141     ENDIF
                      3142     PWM_AFET_DAMPED_DONE: 
                      3143     	ANFET_ON								; Switch nFET
0185    D293          3143+1   SETB P1 . 3 
                      3144     PWM_AFET_DAMPED_EXIT: 
0187    01D9          3145     	AJMP	T0_INT_PWM_ON_EXIT
                      3146     
                      3147     PWM_BFET_DAMPED: 
                      3148     	BPFET_OFF
0189    C295          3148+1   CLR P1 . 5 
018B    30680A        3149     JNB FLAGS1 . 0 , PWM_BFET_DAMPED_EXIT 
018E    206607        3150     JB FLAGS0 . 6 , PWM_BFET_DAMPED_EXIT 
                      3151     IF NFETON_DELAY NE 0
0191    740C          3152     MOV A , # 12 
0193    D5E0FD        3153     	DJNZ ACC,	$
                      3154     ENDIF
                      3155     PWM_BFET_DAMPED_DONE: 
                      3156     	BNFET_ON								; Switch nFET
0196    D294          3156+1   SETB P1 . 4 
                      3157     PWM_BFET_DAMPED_EXIT: 
0198    01D9          3158     	AJMP	T0_INT_PWM_ON_EXIT
                      3159     
                      3160     PWM_CFET_DAMPED: 	
                      3161     	CPFET_OFF
019A    C296          3161+1   CLR P1 . 6 
019C    30680A        3162     JNB FLAGS1 . 0 , PWM_CFET_DAMPED_EXIT 
019F    206607        3163     JB FLAGS0 . 6 , PWM_CFET_DAMPED_EXIT 
                      3164     IF NFETON_DELAY NE 0
01A2    740C          3165     MOV A , # 12 
01A4    D5E0FD        3166     	DJNZ ACC,	$
                      3167     ENDIF
                      3168     PWM_CFET_DAMPED_DONE: 
                      3169     	CNFET_ON								; Switch nFET
01A7    D297          3169+1   SETB P1 . 7 
                      3170     PWM_CFET_DAMPED_EXIT:  
01A9    01D9          3171     	AJMP	T0_INT_PWM_ON_EXIT
                      3172     
                      3173     
                      3174     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3175     ;
                      3176     ; Timer2 interrupt routine
                      3177     ;
                      3178     ; No assumptions
                      3179     ;
                      3180     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3181     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
01AB    C2AF          3182     	CLR	EA
01AD    C2AD          3183     	CLR	ET2			; Disable timer2 interrupts
01AF    53E6EF        3184     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
01B2    C0D0          3185     	PUSH	PSW			; Preserve registers through interrupt
01B4    C0E0          3186     	PUSH	ACC
01B6    D2D3          3187     	SETB	PSW.3		; Select register bank 1 for interrupt routines
01B8    D2AF          3188     	SETB	EA
                      3189     IF MCU_48MHZ == 1
01BA    E57A          3190     	MOV	A, CLOCK_SET_AT_48MHZ
01BC    6009          3191     	JZ 	T2_INT_START
                      3192     
                      3193     	; Check skip variable
01BE    E577          3194     	MOV	A, SKIP_T2_INT
01C0    6005          3195     	JZ	T2_INT_START				; Execute this interrupt
                      3196     
01C2    757700        3197     	MOV	SKIP_T2_INT, #0
01C5    41E6          3198     	AJMP	T2_INT_EXIT
                      3199     
                      3200     T2_INT_START: 
01C7    757701        3201     	MOV	SKIP_T2_INT, #1			; Skip next interrupt
                      3202     ENDIF
                      3203     	; Clear low byte interrupt flag
01CA    C2CE          3204     	CLR	TF2L						; Clear interrupt flag
                      3205     	; Check RC pulse timeout counter
01CC    E52A          3206     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
01CE    6007          3207     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      3208     
                      3209     	; Decrement timeout counter (if PWM)
01D0    207449        3210     JB FLAGS2 . 4 , T2_INT_SKIP_START 
                      3211     
01D3    152A          3212     	DEC	RCP_TIMEOUT_CNT			; No - decrement
01D5    411C          3213     	AJMP	T2_INT_SKIP_START
                      3214     
                      3215     T2_INT_PULSES_ABSENT: 
                      3216     	; Timeout counter has reached zero, pulses are absent
01D7    7800          3217     MOV R0 , # 0 
01D9    7900          3218     MOV R1 , # 0 
01DB    20742E        3219     JB FLAGS2 . 4 , T2_INT_PULSES_ABSENT_NO_MAX 
                      3220     
                      3221     	READ_RCP_INT 					; Look at value of Rcp_In
01DE    E580          3221+1   MOV A , P0 
01E0    307E01        3221+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
01E3    F4            3221+1   CPL A  ; YES - INVERT
01E4    30E502        3222     JNB ACC . 5 , ( $+5 ) 
01E7    78FF          3223     MOV R0 , # 255 
                      3224     	RCP_INT_FIRST 					; Set interrupt trig to first again
01E9    53DACF        3224+1   ANL PCA0CPM0 , # 0CFH 
01EC    207E03        3224+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
01EF    43DA20        3224+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
01F2    307E03        3224+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
01F5    43DA10        3224+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3225     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
01F8    C2D8          3225+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
01FA    C271          3226     CLR FLAGS2 . 1 
                      3227     	READ_RCP_INT 					; Look once more at value of Rcp_In
01FC    E580          3227+1   MOV A , P0 
01FE    307E01        3227+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0201    F4            3227+1   CPL A  ; YES - INVERT
0202    30E502        3228     JNB ACC . 5 , ( $+5 ) 
0205    79FF          3229     MOV R1 , # 255 
0207    C3            3230     	CLR	C
0208    E8            3231     MOV A , R0 
0209    99            3232     SUBB A , R1 
020A    70CB          3233     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      3234     
                      3235     T2_INT_PULSES_ABSENT_NO_MAX: 
020C    306103        3236     JNB FLAGS0 . 1 , ( $+6 ) 
                      3237     
020F    752A18        3238     MOV RCP_TIMEOUT_CNT , # 24 
                      3239     
0212    207403        3240     JB FLAGS2 . 4 , T2_INT_PPM_TIMEOUT_SET 
                      3241     
0215    752A18        3242     MOV RCP_TIMEOUT_CNT , # 24 
                      3243     
                      3244     T2_INT_PPM_TIMEOUT_SET: 
0218    885C          3245     MOV NEW_RCP , R0 
021A    D270          3246     SETB FLAGS2 . 0 
                      3247     
                      3248     T2_INT_SKIP_START: 
021C    20740D        3249     JB FLAGS2 . 4 , T2_INT_RCP_UPDATE_START 
                      3250     
                      3251     	; Check RC pulse skip counter
021F    E52B          3252     	MOV	A, RCP_SKIP_CNT			
0221    6004          3253     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      3254     	
                      3255     	; Decrement skip counter (only if edge counter is zero)
0223    152B          3256     	DEC	RCP_SKIP_CNT				; Decrement
0225    412C          3257     	AJMP	T2_INT_RCP_UPDATE_START
                      3258     
                      3259     T2_INT_SKIP_END: 
                      3260     	; Skip counter has reached zero, start looking for RC pulses again
                      3261     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0227    43DA01        3261+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      3262     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
022A    C2D8          3262+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3263     	
                      3264     T2_INT_RCP_UPDATE_START: 
                      3265     	; Process updated RC pulse
022C    207002        3266     JB FLAGS2 . 0 , ( $+5 ) 
022F    418C          3267     	AJMP	T2_INT_CURRENT_PWM_UPDATE	; No - update pwm limits and exit
                      3268     
0231    A85C          3269     MOV R0 , NEW_RCP 
0233    206102        3270     JB FLAGS0 . 1 , ( $+5 ) 
                      3271     
0236    C270          3272     CLR FLAGS2 . 0 
                      3273     
                      3274     	; Use a gain of 1.0625x for pwm input if not governor mode
0238    207431        3275     JB FLAGS2 . 4 , T2_INT_PWM_MIN_RUN 
                      3276     
                      3277     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ELSE
                      3280     
                      3281     IF MODE == 2	; Multi 
                               	MOV	TEMP2, #PGM_GOV_MODE		; Closed loop mode?
                               	CJNE	@TEMP2, #4, T2_INT_PWM_MIN_RUN; Yes - branch
                               ENDIF
                      3285     
                      3286     	; Limit the maximum value to avoid wrap when scaled to pwm range
023B    C3            3287     	CLR	C
023C    E8            3288     MOV A , R0 
023D    94F0          3289     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
023F    4003          3290     	JC	T2_INT_RCP_UPDATE_MULT
                      3291     
0241    74F0          3292     	MOV	A, #240			; Set requested pwm to max
0243    F8            3293     MOV R0 , A 
                      3294     
                      3295     T2_INT_RCP_UPDATE_MULT: 	
                      3296     	; Multiply by 1.0625 (optional adjustment gyro gain)
0244    E8            3297     MOV A , R0 
0245    C4            3298     	SWAP	A			; After this "0.0625"
0246    540F          3299     	ANL	A, #0FH
0248    28            3300     ADD A , R0 
0249    F8            3301     MOV R0 , A 
                      3302     	; Adjust tail gain
024A    7984          3303     MOV R1 , # PGM_MOTOR_GAIN 
024C    B70302        3304     CJNE @ R1 , # 3 , ( $+5 ) 
024F    416C          3305     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      3306     
0251    C3            3307     	CLR	C
0252    13            3308     	RRC	A			; After this "0.5"
0253    C3            3309     	CLR	C
0254    13            3310     	RRC	A			; After this "0.25"
0255    8721          3311     MOV BIT_ACCESS_INT , @ R1 
0257    200802        3312     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      3313     
025A    C3            3314     	CLR	C
025B    13            3315     	RRC	A			; After this "0.125"
                      3316     
                      3317     T2_INT_RCP_GAIN_CORR: 
025C    200A06        3318     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      3319     
025F    C3            3320     	CLR	C
0260    C8            3321     XCH A , R0 
0261    98            3322     SUBB A , R0 
0262    F8            3323     MOV R0 , A 
0263    416C          3324     	AJMP	T2_INT_PWM_MIN_RUN
                      3325     
                      3326     T2_INT_RCP_GAIN_POS: 
0265    28            3327     ADD A , R0 
0266    F8            3328     MOV R0 , A 
0267    5003          3329     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      3330     
0269    74FF          3331     	MOV	A, #0FFH					; Yes - limit
026B    F8            3332     MOV R0 , A 
                      3333     ENDIF
                      3334     
                      3335     T2_INT_PWM_MIN_RUN:  
                      3336     IF MODE == 1	; Tail - limit minimum pwm
                      3337     	; Limit minimum pwm
026C    C3            3338     	CLR	C
026D    E8            3339     MOV A , R0 
026E    9565          3340     	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
0270    5003          3341     	JNC	T2_INT_PWM_UPDATE			; No - branch
                      3342     
0272    E565          3343     	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
0274    F8            3344     MOV R0 , A 
                      3345     ENDIF
                      3346     
                      3347     T2_INT_PWM_UPDATE:  
                      3348     	; Update requested_pwm
0275    8822          3349     MOV REQUESTED_PWM , R0 
                      3350     IF MODE >= 1	; Tail or multi
                      3351     	; Boost pwm during direct start
0277    E52D          3352     	MOV	A, FLAGS1
0279    5406          3353     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
027B    600F          3354     	JZ	T2_INT_CURRENT_PWM_UPDATE
                      3355     
027D    E533          3356     	MOV	A, STARTUP_CNT				; Add an extra power boost during start
027F    C3            3357     	CLR	C
0280    13            3358     	RRC	A
0281    C3            3359     	CLR	C
0282    13            3360     	RRC	A
0283    2522          3361     	ADD	A, REQUESTED_PWM			
0285    F522          3362     	MOV	REQUESTED_PWM, A
0287    5003          3363     	JNC	($+5)
                      3364     
0289    7522FF        3365     	MOV	REQUESTED_PWM, #0FFH
                      3366     
                      3367     ENDIF
                      3368     T2_INT_CURRENT_PWM_UPDATE:  
                      3369     IF MODE == 0 OR MODE == 2	; Main or multi
                               	MOV	TEMP1, #PGM_GOV_MODE		; Governor mode?
                               	CJNE	@TEMP1, #4, T2_INT_PWM_EXIT	; Yes - branch
                               ENDIF
                      3373     
028C    852224        3374     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      3375     IF MODE >= 1	; Tail or multi
                      3376     	; Set current_pwm_limited
028F    A824          3377     MOV R0 , CURRENT_PWM 
0291    C3            3378     	CLR	C
0292    E524          3379     	MOV	A, CURRENT_PWM				; Check against limit
0294    9561          3380     	SUBB	A, PWM_LIMIT
0296    4002          3381     	JC	($+4)					; If current pwm below limit - branch
                      3382     
0298    A861          3383     MOV R0 , PWM_LIMIT 
                      3384     
                      3385     IF MODE == 2	; Multi
                               	; Limit pwm for low rpms
                               	CLR	C
                               	MOV	A, TEMP1					; Check against limit
                               	SUBB	A, PWM_LIMIT_BY_RPM
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT_BY_RPM		; Limit pwm
                               
                               ENDIF
029A    8825          3395     MOV CURRENT_PWM_LIMITED , R0 
                      3396     	; Dither
029C    E566          3397     	MOV	A, PWM_DITHER_DECODED		; Load pwm dither
029E    7002          3398     	JNZ	($+4)					; If active - branch
02A0    41D0          3399     	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                      3400     
02A2    C3            3401     	CLR	C
02A3    E8            3402     MOV A , R0 
02A4    AA66          3403     MOV R2 , PWM_DITHER_DECODED 
02A6    9A            3404     SUBB A , R2 
02A7    5003          3405     	JNC	T2_INT_CURRENT_PWM_FULL_DITHER; If pwm more than dither value, then do full dither
                      3406     
02A9    E8            3407     MOV A , R0 
02AA    FA            3408     MOV R2 , A 
02AB    E4            3409     	CLR	A						; Set pwm minus dither
                      3410     
                      3411     T2_INT_CURRENT_PWM_FULL_DITHER: 
02AC    F9            3412     MOV R1 , A 
02AD    EA            3413     MOV A , R2 
02AE    C3            3414     	CLR	C
02AF    33            3415     	RLC	A						; Shift left once
02B0    FB            3416     MOV R3 , A 
02B1    E568          3417     	MOV	A, RANDOM					; Load random number
02B3    F4            3418     	CPL	A						; Invert to create proper DC bias in random code
02B4    5B            3419     ANL A , R3 
02B5    29            3420     ADD A , R1 
02B6    400D          3421     	JC	T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER	; If dither cause power above max - branch and increase excess 
                      3422     
02B8    2567          3423     	ADD	A, PWM_DITHER_EXCESS_POWER	; Add excess power from previous cycles
02BA    F8            3424     MOV R0 , A 
02BB    E567          3425     	MOV	A, PWM_DITHER_EXCESS_POWER	; Decrement excess power
02BD    6002          3426     	JZ	($+4)
02BF    1567          3427     	DEC	PWM_DITHER_EXCESS_POWER
02C1    400B          3428     	JC	T2_INT_CURRENT_PWM_DITHER_MAX_POWER; If dither cause power above max - branch
                      3429     
02C3    41D0          3430     	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                      3431     
                      3432     T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER: 
02C5    0A            3433     INC R2 
02C6    C3            3434     	CLR	C
02C7    E567          3435     	MOV	A, PWM_DITHER_EXCESS_POWER
02C9    9A            3436     SUBB A , R2 
02CA    5002          3437     	JNC	($+4)
02CC    0567          3438     	INC	PWM_DITHER_EXCESS_POWER
                      3439     
                      3440     T2_INT_CURRENT_PWM_DITHER_MAX_POWER: 
02CE    78FF          3441     MOV R0 , # 255 
                      3442     
                      3443     T2_INT_CURRENT_PWM_NO_DITHER: 
02D0    8826          3444     MOV CURRENT_PWM_LIM_DITH , R0 
                      3445     IF DAMPED_MODE_ENABLE == 1
                      3446     	; Skip damping fet switching for high throttle
02D2    C26E          3447     CLR FLAGS1 . 6 
02D4    C3            3448     	CLR	C
02D5    E526          3449     	MOV	A, CURRENT_PWM_LIM_DITH
02D7    94F8          3450     	SUBB	A, #248
02D9    4002          3451     	JC	T2_INT_PWM_EXIT
02DB    D26E          3452     SETB FLAGS1 . 6 
                      3453     ENDIF
                      3454     ENDIF
                      3455     T2_INT_PWM_EXIT: 	
                      3456     	; Set demag enabled if pwm is above limit
02DD    C3            3457     	CLR	C
02DE    E525          3458     	MOV	A, CURRENT_PWM_LIMITED	
02E0    9440          3459     	SUBB	A, #40H					; Set if above 25%
02E2    4002          3460     	JC	($+4)
                      3461     
02E4    D264          3462     SETB FLAGS0 . 4 
                      3463     
                      3464     T2_INT_EXIT: 	
                      3465     	; Check if high byte flag is set
02E6    20CF0A        3466     	JB	TF2H, T2H_INT		
02E9    D0E0          3467     	POP	ACC			; Restore preserved registers
02EB    D0D0          3468     	POP	PSW
02ED    43E610        3469     	ORL	EIE1, #10H	; Enable PCA0 interrupts
02F0    D2AD          3470     	SETB	ET2			; Enable timer2 interrupts
02F2    32            3471     	RETI
                      3472     
                      3473     T2H_INT: 
                      3474     IF MCU_48MHZ == 1
02F3    E57A          3475     	MOV	A, CLOCK_SET_AT_48MHZ
02F5    6009          3476     	JZ 	T2H_INT_START
                      3477     
                      3478     	; Check skip variable
02F7    E578          3479     	MOV	A, SKIP_T2H_INT
02F9    6005          3480     	JZ	T2H_INT_START				; Execute this interrupt
                      3481     
02FB    757800        3482     	MOV	SKIP_T2H_INT, #0
02FE    612D          3483     	AJMP	T2H_INT_EXIT
                      3484     
                      3485     T2H_INT_START: 
0300    757801        3486     	MOV	SKIP_T2H_INT, #1			; Skip next interrupt
                      3487     ENDIF
                      3488     	; High byte interrupt (happens every 32ms)
0303    C2CF          3489     	CLR	TF2H					; Clear interrupt flag
0305    7801          3490     MOV R0 , # 1 
                      3491     	; Check RC pulse timeout counter (used here for PPM only)
0307    E52A          3492     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
0309    6005          3493     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      3494     
                      3495     	; Decrement timeout counter (if PPM)
030B    307402        3496     JNB FLAGS2 . 4 , T2H_INT_RCP_STOP_CHECK 
                      3497     
030E    152A          3498     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      3499     
                      3500     T2H_INT_RCP_STOP_CHECK: 
                      3501     	; Check RC pulse against stop value
0310    C3            3502     	CLR	C
0311    E55C          3503     	MOV	A, NEW_RCP				; Load new pulse value
0313    9401          3504     SUBB A , # 1 
0315    4005          3505     	JC	T2H_INT_RCP_STOP
                      3506     
                      3507     	; RC pulse higher than stop value, reset stop counter
0317    755F00        3508     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
031A    612D          3509     	AJMP	T2H_INT_RCP_GOV_PWM
                      3510     
                      3511     T2H_INT_RCP_STOP: 	
                      3512     	; RC pulse less than stop value
031C    756000        3513     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
031F    756900        3514     	MOV	SPOOLUP_LIMIT_CNT, #0
0322    E55F          3515     	MOV	A, RCP_STOP_CNT			; Increment stop counter
0324    2401          3516     	ADD	A, #1
0326    F55F          3517     	MOV	RCP_STOP_CNT, A
0328    5003          3518     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      3519     
032A    755FFF        3520     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      3521     
                      3522     T2H_INT_RCP_GOV_PWM: 
                      3523     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	JNB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_GOV_BY_TX; If governor not active - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	JNB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_GOV_BY_TX; If governor not active - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_3X			; No spoolup until 3*N*32ms
                               
                               	JC	T2H_INT_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_10X			; Slow spoolup until "100"*N*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_15X			; Faster spoolup until "150"*N*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	JB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_INC_LIMIT	; If governor active - branch 
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, MAIN_SPOOLUP_TIME_3X	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_EXIT					; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      3649     T2H_INT_EXIT: 
032D    D0E0          3650     	POP	ACC			; Restore preserved registers
032F    D0D0          3651     	POP	PSW
0331    43E610        3652     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0334    D2AD          3653     	SETB	ET2			; Enable timer2 interrupts
0336    32            3654     	RETI
                      3655     
                      3656     
                      3657     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3658     ;
                      3659     ; Timer3 interrupt routine
                      3660     ;
                      3661     ; No assumptions
                      3662     ;
                      3663     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3664     T3_INT: 	; Used for commutation timing
0337    C2AF          3665     	CLR 	EA				; Disable all interrupts
0339    C0D0          3666     	PUSH	PSW				; Preserve registers through interrupt
033B    53E67F        3667     	ANL	EIE1, #7FH		; Disable timer3 interrupts
033E    C260          3668     CLR FLAGS0 . 0 
                      3669     	; Set up next wait
0340    759100        3670     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
0343    855394        3671     	MOV	TMR3L, NEXT_WT_START_L	; Set wait value	
0346    855495        3672     	MOV	TMR3H, NEXT_WT_START_H
0349    759104        3673     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
034C    D0D0          3674     	POP	PSW
034E    D2AF          3675     	SETB	EA				; Enable all interrupts
0350    32            3676     	RETI
                      3677     
                      3678     
                      3679     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3680     ;
                      3681     ; PCA interrupt routine
                      3682     ;
                      3683     ; No assumptions
                      3684     ;
                      3685     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3686     PCA_INT: 	; Used for RC pulse timing
0351    C2AF          3687     	CLR	EA
0353    53E6EF        3688     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
0356    C2AD          3689     	CLR	ET2			; Disable timer2 interrupts
0358    C0D0          3690     	PUSH	PSW			; Preserve registers through interrupt
035A    C0E0          3691     	PUSH	ACC
035C    C0F0          3692     	PUSH	B
035E    D2D3          3693     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0360    D2AF          3694     	SETB	EA
                      3695     	; Get the PCA counter values
                      3696     	GET_RCP_CAPTURE_VALUES
0362    A8FB          3696+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0364    A9FC          3696+1   MOV R1 , PCA0CPH0 
                      3696+1   IF 1 ==1 
0366    E57A          3696+1   MOV A , CLOCK_SET_AT_48MHZ 
0368    6007          3696+1   JZ GET_RCP_END 
036A    C3            3696+1   CLR C 
036B    E9            3696+1   MOV A , R1 
036C    13            3696+1   RRC A 
036D    F9            3696+1   MOV R1 , A 
036E    E8            3696+1   MOV A , R0 
036F    13            3696+1   RRC A 
0370    F8            3696+1   MOV R0 , A 
                      3696+1   GET_RCP_END:  
                      3696+1   ENDIF 
                      3697     	; Clear interrupt flag
                      3698     	RCP_CLEAR_INT_FLAG 				
0371    C2D8          3698+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3699     	; Check which edge it is
0373    307102        3700     JNB FLAGS2 . 1 , ( $+5 ) 
0376    61C3          3701     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      3702     
                      3703     	RCP_INT_SECOND					; Yes - set second edge trig
0378    53DACF        3703+1   ANL PCA0CPM0 , # 0CFH 
037B    207E03        3703+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
037E    43DA10        3703+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
0381    307E03        3703+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0384    43DA20        3703+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0387    D271          3704     SETB FLAGS2 . 1 
                      3705     	; Read RC signal level
                      3706     	READ_RCP_INT			
0389    E580          3706+1   MOV A , P0 
038B    307E01        3706+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
038E    F4            3706+1   CPL A  ; YES - INVERT
                      3707     	; Test RC signal level
038F    20E502        3708     JB ACC . 5 , ( $+5 ) 
0392    619A          3709     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      3710     
                      3711     	; RC pulse was high, store RC pulse start timestamp
0394    8827          3712     MOV RCP_PREV_EDGE_L , R0 
0396    8928          3713     MOV RCP_PREV_EDGE_H , R1 
0398    A1EA          3714     	AJMP	PCA_INT_EXIT				; Exit
                      3715     
                      3716     PCA_INT_FAIL_MINIMUM: 
                      3717     	; Prepare for next interrupt
                      3718     	RCP_INT_FIRST					; Set interrupt trig to first again
039A    53DACF        3718+1   ANL PCA0CPM0 , # 0CFH 
039D    207E03        3718+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03A0    43DA20        3718+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03A3    307E03        3718+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03A6    43DA10        3718+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3719     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03A9    C2D8          3719+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03AB    C271          3720     CLR FLAGS2 . 1 
03AD    307402        3721     JNB FLAGS2 . 4 , ( $+5 ) 
                      3722     
03B0    A1D6          3723     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      3724     
03B2    7800          3725     MOV R0 , # 0 
                      3726     	READ_RCP_INT 					; Test RC signal level again
03B4    E580          3726+1   MOV A , P0 
03B6    307E01        3726+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
03B9    F4            3726+1   CPL A  ; YES - INVERT
03BA    30E502        3727     JNB ACC . 5 , ( $+5 ) 
                      3728     
03BD    A1D6          3729     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      3730     
03BF    885C          3731     MOV NEW_RCP , R0 
03C1    A1BE          3732     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      3733     
                      3734     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      3735     	; Prepare for next interrupt
                      3736     	RCP_INT_FIRST 					; Set first edge trig
03C3    53DACF        3736+1   ANL PCA0CPM0 , # 0CFH 
03C6    207E03        3736+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03C9    43DA20        3736+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03CC    307E03        3736+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03CF    43DA10        3736+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03D2    C271          3737     CLR FLAGS2 . 1 
                      3738     	; Check if pwm frequency shall be measured
03D4    206102        3739     JB FLAGS0 . 1 , ( $+5 ) 
03D7    819C          3740     	AJMP	PCA_INT_FALL				; No - skip measurements
                      3741     
                      3742     	; Set second edge trig only during pwm frequency measurement
                      3743     	RCP_INT_SECOND 				; Set second edge trig
03D9    53DACF        3743+1   ANL PCA0CPM0 , # 0CFH 
03DC    207E03        3743+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03DF    43DA10        3743+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03E2    307E03        3743+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03E5    43DA20        3743+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      3744     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03E8    C2D8          3744+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03EA    D271          3745     SETB FLAGS2 . 1 
                      3746     	; Store edge data to RAM
03EC    8857          3747     MOV RCP_EDGE_L , R0 
03EE    8958          3748     MOV RCP_EDGE_H , R1 
                      3749     	; Calculate pwm frequency
03F0    C3            3750     	CLR	C
03F1    E8            3751     MOV A , R0 
03F2    9555          3752     	SUBB	A, RCP_PREPREV_EDGE_L	
03F4    F8            3753     MOV R0 , A 
03F5    E9            3754     MOV A , R1 
03F6    9556          3755     	SUBB	A, RCP_PREPREV_EDGE_H
03F8    F9            3756     MOV R1 , A 
03F9    7B00          3757     MOV R3 , # 0 
03FB    7E08          3758     MOV R6 , # 8 
03FD    7A00          3759     MOV R2 , # 0 
                      3760     	; Check if pulse is too short
03FF    C3            3761     	CLR	C
0400    E8            3762     MOV A , R0 
0401    948C          3763     	SUBB	A, #LOW(140)				; If pulse below 70us, not accepted
0403    E9            3764     MOV A , R1 
0404    9400          3765     	SUBB	A, #HIGH(140)
0406    5005          3766     	JNC	PCA_INT_CHECK_12KHZ
                      3767     
0408    755B00        3768     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0	; Set not accepted 
040B    818E          3769     	AJMP	PCA_INT_STORE_DATA
                      3770     
                      3771     PCA_INT_CHECK_12KHZ: 
040D    8821          3772     MOV BIT_ACCESS_INT , R0 
040F    78A2          3773     MOV R0 , # PGM_ENABLE_PWM_INPUT 
0411    E6            3774     MOV A , @ R0 
0412    A821          3775     MOV R0 , BIT_ACCESS_INT 
0414    6055          3776     	JZ	PCA_INT_RESTORE_EDGE		; If it is not - branch
                      3777     
                      3778     	; Check if pwm frequency is 12kHz
0416    C3            3779     	CLR	C
0417    E8            3780     MOV A , R0 
0418    94C8          3781     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
041A    E9            3782     MOV A , R1 
041B    9400          3783     	SUBB	A, #HIGH(200)
041D    5008          3784     	JNC	PCA_INT_CHECK_8KHZ
                      3785     
041F    E4            3786     	CLR	A
0420    D2E4          3787     SETB ACC . 4 
0422    FB            3788     MOV R3 , A 
0423    7A0A          3789     MOV R2 , # 10 
0425    8169          3790     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3791     
                      3792     PCA_INT_CHECK_8KHZ: 
                      3793     	; Check if pwm frequency is 8kHz
0427    C3            3794     	CLR	C
0428    E8            3795     MOV A , R0 
0429    9468          3796     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
042B    E9            3797     MOV A , R1 
042C    9401          3798     	SUBB	A, #HIGH(360)
042E    5008          3799     	JNC	PCA_INT_CHECK_4KHZ
                      3800     
0430    E4            3801     	CLR	A
0431    D2E3          3802     SETB ACC . 3 
0433    FB            3803     MOV R3 , A 
0434    7A0F          3804     MOV R2 , # 15 
0436    8169          3805     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3806     
                      3807     PCA_INT_CHECK_4KHZ: 
                      3808     	; Check if pwm frequency is 4kHz
0438    C3            3809     	CLR	C
0439    E8            3810     MOV A , R0 
043A    94D0          3811     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
043C    E9            3812     MOV A , R1 
043D    9402          3813     	SUBB	A, #HIGH(720)
043F    5008          3814     	JNC	PCA_INT_CHECK_2KHZ
                      3815     
0441    E4            3816     	CLR	A
0442    D2E2          3817     SETB ACC . 2 
0444    FB            3818     MOV R3 , A 
0445    7A1E          3819     MOV R2 , # 30 
0447    8169          3820     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3821     
                      3822     PCA_INT_CHECK_2KHZ: 
                      3823     	; Check if pwm frequency is 2kHz
0449    C3            3824     	CLR	C
044A    E8            3825     MOV A , R0 
044B    94A0          3826     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
044D    E9            3827     MOV A , R1 
044E    9405          3828     	SUBB	A, #HIGH(1440)
0450    5008          3829     	JNC	PCA_INT_CHECK_1KHZ
                      3830     
0452    E4            3831     	CLR	A
0453    D2E1          3832     SETB ACC . 1 
0455    FB            3833     MOV R3 , A 
0456    7A3C          3834     MOV R2 , # 60 
0458    8169          3835     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3836     
                      3837     PCA_INT_CHECK_1KHZ: 
                      3838     	; Check if pwm frequency is 1kHz
045A    C3            3839     	CLR	C
045B    E8            3840     MOV A , R0 
045C    9498          3841     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
045E    E9            3842     MOV A , R1 
045F    9408          3843     	SUBB	A, #HIGH(2200)
0461    5008          3844     	JNC	PCA_INT_RESTORE_EDGE
                      3845     
0463    E4            3846     	CLR	A
0464    D2E0          3847     SETB ACC . 0 
0466    FB            3848     MOV R3 , A 
0467    7A78          3849     MOV R2 , # 120 
                      3850     
                      3851     PCA_INT_RESTORE_EDGE_SET_MSB: 
0469    7E00          3852     MOV R6 , # 0 
                      3853     PCA_INT_RESTORE_EDGE: 
                      3854     	; Calculate difference between this period and previous period
046B    C3            3855     	CLR	C
046C    E8            3856     MOV A , R0 
046D    9559          3857     	SUBB	A, RCP_PREV_PERIOD_L
046F    FC            3858     MOV R4 , A 
0470    E9            3859     MOV A , R1 
0471    955A          3860     	SUBB	A, RCP_PREV_PERIOD_H
0473    FD            3861     MOV R5 , A 
                      3862     	; Make positive
0474    30E70A        3863     	JNB	ACC.7, PCA_INT_CHECK_DIFF
0477    EC            3864     MOV A , R4 
0478    F4            3865     	CPL	A
0479    2401          3866     	ADD	A, #1
047B    FC            3867     MOV R4 , A 
047C    ED            3868     MOV A , R5 
047D    F4            3869     	CPL	A
047E    3400          3870     	ADDC	A, #0
0480    FD            3871     MOV R5 , A 
                      3872     
                      3873     PCA_INT_CHECK_DIFF: 
                      3874     	; Check difference
0481    755B00        3875     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0484    C3            3876     	CLR	C
0485    EC            3877     MOV A , R4 
0486    9A            3878     SUBB A , R2 
0487    ED            3879     MOV A , R5 
0488    9E            3880     SUBB A , R6 
0489    5003          3881     	JNC	PCA_INT_STORE_DATA
                      3882     
048B    755B01        3883     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      3884     
                      3885     PCA_INT_STORE_DATA: 
                      3886     	; Store previous period
048E    8859          3887     MOV RCP_PREV_PERIOD_L , R0 
0490    895A          3888     MOV RCP_PREV_PERIOD_H , R1 
                      3889     	; Store pre previous edge
0492    855755        3890     	MOV	RCP_PREPREV_EDGE_L, RCP_EDGE_L
0495    855856        3891     	MOV	RCP_PREPREV_EDGE_H, RCP_EDGE_H
0498    7802          3892     MOV R0 , # 2 
049A    A1BE          3893     	AJMP	PCA_INT_LIMITED
                      3894     
                      3895     PCA_INT_FALL: 
                      3896     	; RC pulse edge was second, calculate new pulse length
049C    C3            3897     	CLR	C
049D    E8            3898     MOV A , R0 
049E    9527          3899     	SUBB	A, RCP_PREV_EDGE_L	
04A0    F8            3900     MOV R0 , A 
04A1    E9            3901     MOV A , R1 
04A2    9528          3902     	SUBB	A, RCP_PREV_EDGE_H
04A4    F9            3903     MOV R1 , A 
04A5    307C02        3904     JNB FLAGS3 . 4 , ( $+5 ) 
04A8    A1A2          3905     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3906     
04AA    307B02        3907     JNB FLAGS3 . 3 , ( $+5 ) 
04AD    A1A2          3908     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3909     
04AF    307A02        3910     JNB FLAGS3 . 2 , ( $+5 ) 
04B2    A19B          3911     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3912     
04B4    207502        3913     JB FLAGS2 . 5 , ( $+5 ) 
04B7    81BF          3914     	AJMP	PCA_INT_FALL_NOT_ONESHOT
                      3915     
04B9    E9            3916     MOV A , R1 
04BA    FD            3917     MOV R5 , A 
04BB    E8            3918     MOV A , R0 
04BC    FC            3919     MOV R4 , A 
04BD    81DE          3920     	AJMP	PCA_INT_FALL_CHECK_RANGE
                      3921     
                      3922     PCA_INT_FALL_NOT_ONESHOT: 
04BF    E9            3923     MOV A , R1 
04C0    C3            3924     	CLR	C
04C1    13            3925     	RRC	A
04C2    F9            3926     MOV R1 , A 
04C3    E8            3927     MOV A , R0 
04C4    13            3928     	RRC	A
04C5    F8            3929     MOV R0 , A 
                      3930     
04C6    307902        3931     JNB FLAGS3 . 1 , ( $+5 ) 
04C9    A19B          3932     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3933     
04CB    E9            3934     MOV A , R1 
04CC    C3            3935     	CLR	C
04CD    13            3936     	RRC	A
04CE    F9            3937     MOV R1 , A 
04CF    E8            3938     MOV A , R0 
04D0    13            3939     	RRC	A
04D1    F8            3940     MOV R0 , A 
                      3941     
04D2    307802        3942     JNB FLAGS3 . 0 , ( $+5 ) 
04D5    A19B          3943     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3944     
04D7    E9            3945     MOV A , R1 
04D8    C3            3946     	CLR	C
04D9    13            3947     	RRC	A
04DA    FD            3948     MOV R5 , A 
04DB    E8            3949     MOV A , R0 
04DC    13            3950     	RRC	A
04DD    FC            3951     MOV R4 , A 
                      3952     PCA_INT_FALL_CHECK_RANGE: 
                      3953     	; Skip range limitation if pwm frequency measurement
04DE    206126        3954     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      3955     
                      3956     	; Check if 2160us or above (in order to ignore false pulses)
04E1    C3            3957     	CLR	C
04E2    EC            3958     MOV A , R4 
04E3    941C          3959     	SUBB	A, #28
04E5    ED            3960     MOV A , R5 
04E6    9402          3961     	SUBB A, #2
04E8    4002          3962     	JC	($+4)						; No - proceed
                      3963     
04EA    81F5          3964     	AJMP	PCA_INT_PPM_OUTSIDE_RANGE		; Yes - ignore pulse
                      3965     
                      3966     PCA_INT_PPM_BELOW_FULL_RANGE: 
                      3967     	; Check if below 800us (in order to ignore false pulses)
04EC    ED            3968     MOV A , R5 
04ED    7018          3969     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      3970     
04EF    C3            3971     	CLR	C
04F0    EC            3972     MOV A , R4 
04F1    94C8          3973     	SUBB	A, #200
04F3    5012          3974     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      3975     
                      3976     PCA_INT_PPM_OUTSIDE_RANGE: 
04F5    0529          3977     	INC	RCP_OUTSIDE_RANGE_CNT
04F7    C3            3978     	CLR	C
04F8    E529          3979     	MOV	A, RCP_OUTSIDE_RANGE_CNT
04FA    940A          3980     	SUBB	A, #10						; Allow a given number of outside pulses
04FC    5002          3981     	JNC	($+4)			
04FE    A1D6          3982     	AJMP	PCA_INT_SET_TIMEOUT				; If below limit - ignore pulse
                      3983     
0500    755C00        3984     	MOV	NEW_RCP, #0					; Set pulse length to zero
0503    D270          3985     SETB FLAGS2 . 0 
0505    A1D6          3986     	AJMP	PCA_INT_SET_TIMEOUT			
                      3987     
                      3988     PCA_INT_PPM_CHECK_FULL_RANGE: 
0507    E529          3989     	MOV	A, RCP_OUTSIDE_RANGE_CNT
0509    6002          3990     	JZ	($+4)
                      3991     
050B    1529          3992     	DEC	RCP_OUTSIDE_RANGE_CNT
                      3993     
                      3994     	; Calculate "1000us" plus throttle minimum
                      3995     IF MODE >= 1	; Tail or multi
050D    7888          3996     MOV R0 , # PGM_DIRECTION 
050F    E6            3997     MOV A , @ R0 
0510    F9            3998     MOV R1 , A 
                      3999     ENDIF
0511    7400          4000     	MOV	A, #0						; Set 1000us as default minimum
0513    207F08        4001     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      4002     
0516    7896          4003     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      4004     IF MODE >= 1	; Tail or multi
0518    B90302        4005     CJNE R1 , # 3 , ( $+5 ) 
                      4006     
051B    789E          4007     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      4008     ENDIF
051D    E6            4009     MOV A , @ R0 
                      4010     
                      4011     PCA_INT_PPM_CALCULATE: 
051E    24FA          4012     	ADD	A, #250						; Add 1000us to minimum
0520    FE            4013     MOV R6 , A 
0521    E4            4014     	CLR	A
0522    3400          4015     	ADDC	A, #0
0524    FF            4016     MOV R7 , A 
                      4017     
0525    C3            4018     	CLR	C
0526    EC            4019     MOV A , R4 
0527    9E            4020     SUBB A , R6 
0528    FC            4021     MOV R4 , A 
0529    ED            4022     MOV A , R5 
052A    9F            4023     SUBB A , R7 
052B    FD            4024     MOV R5 , A 
                      4025     IF MODE >= 1	; Tail or multi
052C    9208          4026     	MOV	BIT_ACCESS_INT.0, C
052E    B90310        4027     CJNE R1 , # 3 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4028     
0531    A208          4029     	MOV	C, BIT_ACCESS_INT.0
0533    5007          4030     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      4031     
                      4032     PCA_INT_PPM_BIDIR_REV: 
0535    207609        4033     JB FLAGS2 . 6 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4034     
0538    D276          4035     SETB FLAGS2 . 6 
053A    A141          4036     	AJMP	PCA_INT_PPM_BIDIR_DIR_SET
                      4037     
                      4038     PCA_INT_PPM_BIDIR_FWD: 
053C    307602        4039     JNB FLAGS2 . 6 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4040     
053F    C276          4041     CLR FLAGS2 . 6 
                      4042     
                      4043     PCA_INT_PPM_BIDIR_DIR_SET: 
0541    A208          4044     	MOV	C, BIT_ACCESS_INT.0
                      4045     ENDIF
0543    5016          4046     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      4047     
                      4048     IF MODE >= 1	; Tail or multi
0545    B9030D        4049     CJNE R1 , # 3 , PCA_INT_PPM_UNIDIR_NEG 
                      4050     
0548    EC            4051     MOV A , R4 
0549    F4            4052     	CPL	A
054A    2401          4053     	ADD	A, #1
054C    FC            4054     MOV R4 , A 
054D    ED            4055     MOV A , R5 
054E    F4            4056     	CPL	A
054F    3400          4057     	ADDC	A, #0
0551    FD            4058     MOV R5 , A 
0552    02055B        4059     	JMP	PCA_INT_PPM_NEG_CHECKED
                      4060     
                      4061     PCA_INT_PPM_UNIDIR_NEG: 
                      4062     ENDIF
0555    7800          4063     MOV R0 , # 0 
0557    7900          4064     MOV R1 , # 0 
0559    A1A2          4065     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4066     
                      4067     PCA_INT_PPM_NEG_CHECKED: 
                      4068     IF MODE >= 1	; Tail or multi
055B    B90315        4069     CJNE R1 , # 3 , PCA_INT_PPM_BIDIR_DONE 
                      4070     
055E    EC            4071     MOV A , R4 
055F    33            4072     	RLC	A
0560    FC            4073     MOV R4 A 
0561    ED            4074     MOV A , R5 
0562    33            4075     	RLC	A
0563    FD            4076     MOV R5 A 
0564    C3            4077     	CLR	C							; Subtract deadband
0565    EC            4078     MOV A , R4 
0566    940A          4079     	SUBB	A, #10		
0568    FC            4080     MOV R4 , A 
0569    ED            4081     MOV A , R5 
056A    9400          4082     	SUBB	A, #0
056C    FD            4083     MOV R5 , A 
056D    5004          4084     	JNC	PCA_INT_PPM_BIDIR_DONE
                      4085     
056F    7C00          4086     MOV R4 , # 0 
0571    7D00          4087     MOV R5 , # 0 
                      4088     
                      4089     PCA_INT_PPM_BIDIR_DONE: 
                      4090     ENDIF
0573    C3            4091     	CLR	C							; Check that RC pulse is within legal range (max 255)
0574    EC            4092     MOV A , R4 
0575    94FF          4093     SUBB A , # 255 
0577    ED            4094     MOV A , R5 
0578    9400          4095     	SUBB	A, #0
057A    4006          4096     	JC	PCA_INT_PPM_MAX_CHECKED
                      4097     
057C    78FF          4098     MOV R0 , # 255 
057E    7900          4099     MOV R1 , # 0 
0580    A1A2          4100     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4101     
                      4102     PCA_INT_PPM_MAX_CHECKED: 
0582    EC            4103     MOV A , R4 
0583    8572F0        4104     	MOV	B, PPM_THROTTLE_GAIN
0586    A4            4105     	MUL	AB
0587    C5F0          4106     	XCH	A, B
0589    A2F7          4107     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
058B    33            4108     	RLC	A
058C    F8            4109     MOV R0 , A 
058D    7900          4110     MOV R1 , # 0 
058F    4003          4111     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      4112     	
0591    0205BE        4113     	JMP	PCA_INT_LIMITED			
                      4114     
                      4115     PCA_INT_PPM_LIMIT_AFTER_MULT: 
0594    78FF          4116     MOV R0 , # 255 
0596    7900          4117     MOV R1 , # 0 
0598    0205BE        4118     	JMP	PCA_INT_LIMITED			
                      4119     
                      4120     PCA_INT_PWM_DIVIDE: 
059B    E9            4121     MOV A , R1 
059C    C3            4122     	CLR	C
059D    13            4123     	RRC	A
059E    F9            4124     MOV R1 , A 
059F    E8            4125     MOV A , R0 
05A0    13            4126     	RRC	A
05A1    F8            4127     MOV R0 , A 
                      4128     
                      4129     PCA_INT_PWM_DIVIDE_DONE: 
05A2    307C0E        4130     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
05A5    E9            4131     MOV A , R1 
05A6    6002          4132     	JZ	($+4)
                      4133     
05A8    78FF          4134     MOV R0 , # 255 
                      4135     
05AA    C3            4136     	CLR	C
05AB    E8            4137     MOV A , R0 
05AC    13            4138     	RRC	A
05AD    38            4139     ADDC A , R0 
05AE    F8            4140     MOV R0 , A 
05AF    E4            4141     	CLR	A
05B0    3400          4142     	ADDC	A, #0
05B2    F9            4143     MOV R1 , A 
                      4144     
                      4145     PCA_INT_CHECK_LEGAL_RANGE: 
                      4146     	; Check that RC pulse is within legal range
05B3    C3            4147     	CLR	C
05B4    E8            4148     MOV A , R0 
05B5    94FF          4149     SUBB A , # 255 
05B7    E9            4150     MOV A , R1 
05B8    9400          4151     	SUBB	A, #0
05BA    4002          4152     	JC	PCA_INT_LIMITED
                      4153     
05BC    78FF          4154     MOV R0 , # 255 
                      4155     
                      4156     PCA_INT_LIMITED: 
                      4157     	; RC pulse value accepted
05BE    885C          4158     MOV NEW_RCP , R0 
05C0    D270          4159     SETB FLAGS2 . 0 
05C2    206102        4160     JB FLAGS0 . 1 , ( $+5 ) 
                      4161     
05C5    A1D6          4162     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      4163     
05C7    741F          4164     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
05C9    F4            4165     	CPL	A
05CA    552F          4166     	ANL	A, FLAGS3					; Clear all pwm frequency flags
05CC    4B            4167     ORL A , R3 
05CD    F52F          4168     	MOV	FLAGS3, A
05CF    C274          4169     CLR FLAGS2 . 4 
05D1    EB            4170     MOV A , R3 
05D2    7002          4171     	JNZ	PCA_INT_SET_TIMEOUT
                      4172     
05D4    D274          4173     SETB FLAGS2 . 4 
                      4174     
                      4175     PCA_INT_SET_TIMEOUT: 
05D6    752A18        4176     MOV RCP_TIMEOUT_CNT , # 24 
05D9    307403        4177     JNB FLAGS2 . 4 , PCA_INT_PPM_TIMEOUT_SET 
                      4178     
05DC    752A0A        4179     MOV RCP_TIMEOUT_CNT , # 10 
                      4180     
                      4181     PCA_INT_PPM_TIMEOUT_SET: 
05DF    306102        4182     JNB FLAGS0 . 1 , ( $+5 ) 
                      4183     
05E2    A1EA          4184     	AJMP PCA_INT_EXIT				; Yes - exit
                      4185     
05E4    207403        4186     JB FLAGS2 . 4 , PCA_INT_EXIT 
                      4187     
                      4188     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
05E7    53DAFE        4188+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      4189     
                      4190     PCA_INT_EXIT: 	; Exit interrupt routine	
05EA    207403        4191     JB FLAGS2 . 4 , ( $+6 ) 
                      4192     
05ED    752B06        4193     MOV RCP_SKIP_CNT , # 6 
                      4194     
05F0    D0F0          4195     	POP	B			; Restore preserved registers
05F2    D0E0          4196     	POP	ACC			
05F4    D0D0          4197     	POP	PSW
05F6    D2AD          4198     	SETB	ET2			; Enable timer2 interrupts
05F8    43E610        4199     	ORL	EIE1, #10H	; Enable PCA0 interrupts
05FB    32            4200     	RETI
                      4201     
                      4202     
                      4203     
                      4204     
                      4205     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4206     ;
                      4207     ; Wait xms ~(x*4*250)  (Different entry points)	
                      4208     ;
                      4209     ; No assumptions
                      4210     ;
                      4211     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4212     WAIT1MS: 	
05FC    7901          4213     MOV R1 , # 1 
05FE    02061A        4214     	JMP	WAITXMS_O
                      4215     
                      4216     WAIT3MS: 	
0601    7903          4217     MOV R1 , # 3 
0603    02061A        4218     	JMP	WAITXMS_O
                      4219     
                      4220     WAIT10MS: 	
0606    790A          4221     MOV R1 , # 10 
0608    02061A        4222     	JMP	WAITXMS_O
                      4223     
                      4224     WAIT30MS: 	
060B    791E          4225     MOV R1 , # 30 
060D    02061A        4226     	JMP	WAITXMS_O
                      4227     
                      4228     WAIT100MS: 	
0610    7964          4229     MOV R1 , # 100 
0612    02061A        4230     	JMP	WAITXMS_O
                      4231     
                      4232     WAIT200MS: 	
0615    79C8          4233     MOV R1 , # 200 
0617    02061A        4234     	JMP	WAITXMS_O
                      4235     
                      4236     WAITXMS_O: 	; Outer loop
061A    7817          4237     MOV R0 , # 23 
                      4238     WAITXMS_M: 	; Middle loop
061C    E4            4239     	CLR	A
061D    D5E0FD        4240      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0620    D8FA          4241     DJNZ R0 , WAITXMS_M 
0622    D9F6          4242     DJNZ R1 , WAITXMS_O 
0624    22            4243     	RET
                      4244     
                      4245     
                      4246     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4247     ;
                      4248     ; Beeper routines (4 different entry points) 
                      4249     ;
                      4250     ; No assumptions
                      4251     ;
                      4252     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4253     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
0625    7A14          4254     MOV R2 , # 20 
0627    7B78          4255     MOV R3 , # 120 
0629    020641        4256     	JMP	BEEP
                      4257     
                      4258     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
062C    7A10          4259     MOV R2 , # 16 
062E    7B8C          4260     MOV R3 , # 140 
0630    020641        4261     	JMP	BEEP
                      4262     
                      4263     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
0633    7A0D          4264     MOV R2 , # 13 
0635    7BB4          4265     MOV R3 , # 180 
0637    020641        4266     	JMP	BEEP
                      4267     
                      4268     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
063A    7A0B          4269     MOV R2 , # 11 
063C    7BC8          4270     MOV R3 , # 200 
063E    020641        4271     	JMP	BEEP
                      4272     
                      4273     BEEP: 	; Beep loop start
0641    7902          4274     MOV R1 , # 2 
                      4275     BEEP_ONOFF: 
0643    B27D          4276     CPL FLAGS3 . 5 
0645    E4            4277     	CLR	A
                      4278     	BPFET_OFF			; BpFET off
0646    C295          4278+1   CLR P1 . 5 
0648    D5E0FD        4279     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      4280     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
064B    D294          4280+1   SETB P1 . 4 
064D    D5E0FD        4281     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      4282     	BNFET_OFF			; BnFET off again
0650    C294          4282+1   CLR P1 . 4 
0652    D5E0FD        4283     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      4284     	BPFET_ON			; BpFET on
0655    D295          4284+1   SETB P1 . 5 
0657    D5E0FD        4285     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      4286     	; Turn on nfet
                      4287     	ANFET_ON			; AnFET on
065A    D293          4287+1   SETB P1 . 3 
065C    E573          4288     	MOV	A, BEEP_STRENGTH
065E    D5E0FD        4289     	DJNZ	ACC, $		
                      4290     	; Turn off nfet
                      4291     	ANFET_OFF			; AnFET off
0661    C293          4291+1   CLR P1 . 3 
0663    7496          4292     	MOV	A, #150		; 25s off
0665    D5E0FD        4293     	DJNZ	ACC, $		
0668    D9D9          4294     DJNZ R1 , BEEP_ONOFF 
                      4295     	; Copy variable
066A    EA            4296     MOV A , R2 
066B    F8            4297     MOV R0 , A 
                      4298     BEEP_OFF: 		; Fets off loop
066C    D5E0FD        4299     	DJNZ	ACC, $
066F    D8FB          4300     DJNZ R0 , BEEP_OFF 
0671    DBCE          4301     DJNZ R3 , BEEP 
                      4302     	BPFET_OFF			; BpFET off
0673    C295          4302+1   CLR P1 . 5 
0675    22            4303     	RET
                      4304     
                      4305     
                      4306     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4307     ;
                      4308     ; Division 16bit unsigned by 16bit unsigned
                      4309     ;
                      4310     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      4311     ; Result will be in Temp2/Temp1
                      4312     ;
                      4313     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4314     DIV_U16_BY_U16: 	
0676    C3            4315     	CLR	C       
0677    7C00          4316     MOV R4 , # 0 
0679    7D00          4317     MOV R5 , # 0 
067B    75F000        4318     	MOV	B, #0
                      4319     DIV_U16_BY_U16_DIV1: 
067E    05F0          4320     	INC	B      			; Increment counter for each left shift
0680    EA            4321     MOV A , R2 
0681    33            4322     	RLC	A      		
0682    FA            4323     MOV R2 , A 
0683    EB            4324     MOV A , R3 
0684    33            4325     	RLC	A      	  	
0685    FB            4326     MOV R3 , A 
0686    50F6          4327     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      4328     DIV_U16_BY_U16_DIV2:         
0688    EB            4329     MOV A , R3 
0689    13            4330     	RRC	A      
068A    FB            4331     MOV R3 , A 
068B    EA            4332     MOV A , R2 
068C    13            4333     	RRC	A      
068D    FA            4334     MOV R2 , A 
068E    C3            4335     	CLR	C      
068F    E9            4336     MOV A , R1 
0690    FF            4337     MOV R7 , A 
0691    E8            4338     MOV A , R0 
0692    FE            4339     MOV R6 , A 
0693    E8            4340     MOV A , R0 
0694    9A            4341     SUBB A , R2 
0695    F8            4342     MOV R0 , A 
0696    E9            4343     MOV A , R1 
0697    9B            4344     SUBB A , R3 
0698    F9            4345     MOV R1 , A 
0699    5004          4346     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
069B    EF            4347     MOV A , R7 
069C    F9            4348     MOV R1 , A 
069D    EE            4349     MOV A , R6 
069E    F8            4350     MOV R0 , A 
                      4351     DIV_U16_BY_U16_DIV3: 
069F    B3            4352     	CPL	C      			; Invert carry, so it can be directly copied into result
06A0    EC            4353     MOV A , R4 
06A1    33            4354     	RLC	A      			; Shift carry flag into temporary result
06A2    FC            4355     MOV R4 , A 
06A3    ED            4356     MOV A , R5 
06A4    33            4357     	RLC	A
06A5    FD            4358     MOV R5 , A 
06A6    D5F0DF        4359     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
06A9    ED            4360     MOV A , R5 
06AA    F9            4361     MOV R1 , A 
06AB    EC            4362     MOV A , R4 
06AC    F8            4363     MOV R0 , A 
06AD    22            4364     	RET
                      4365     
                      4366     
                      4367     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4368     ;
                      4369     ; Multiplication 16bit signed by 8bit unsigned
                      4370     ;
                      4371     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      4372     ; Result will be in Temp2/Temp1. Result will divided by 16
                      4373     ;
                      4374     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4375     MULT_S16_BY_U8_DIV_16: 
06AE    E8            4376     MOV A , R0 
06AF    89F0          4377     MOV B , R1 
06B1    8A20          4378     MOV BIT_ACCESS , R2 
06B3    D2D4          4379     	SETB	PSW.4		; Select register bank 2 for math routines
06B5    F8            4380     MOV R0 , A 
06B6    A9F0          4381     MOV R1 , B 
06B8    7B00          4382     MOV R3 , # 0 
06BA    30F70B        4383     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      4384     
06BD    7BFF          4385     MOV R3 , # 0FFH 
06BF    F4            4386     	CPL	A
06C0    2401          4387     	ADD	A, #1
06C2    F8            4388     MOV R0 , A 
06C3    E9            4389     MOV A , R1 
06C4    F4            4390     	CPL	A
06C5    3400          4391     	ADDC	A, #0
06C7    F9            4392     MOV R1 , A 
                      4393     MULT_S16_BY_U8_POSITIVE: 
06C8    E8            4394     MOV A , R0 
06C9    8520F0        4395     	MOV	B, BIT_ACCESS
06CC    A4            4396     	MUL	AB
06CD    ADF0          4397     MOV R5 , B 
06CF    F8            4398     MOV R0 , A 
06D0    E9            4399     MOV A , R1 
06D1    8520F0        4400     	MOV	B, BIT_ACCESS
06D4    A4            4401     	MUL	AB
06D5    AFF0          4402     MOV R7 , B 
06D7    FE            4403     MOV R6 , A 
06D8    ED            4404     MOV A , R5 
06D9    2E            4405     ADD A , R6 
06DA    F9            4406     MOV R1 , A 
06DB    7400          4407     	MOV	A, #0
06DD    3F            4408     ADDC A , R7 
06DE    FA            4409     MOV R2 , A 
06DF    7C04          4410     MOV R4 , # 4 
                      4411     MULT_S16_BY_U8_DIV_LOOP: 
06E1    C3            4412     	CLR	C			; Rotate right 
06E2    EA            4413     MOV A , R2 
06E3    13            4414     	RRC	A
06E4    FA            4415     MOV R2 , A 
06E5    E9            4416     MOV A , R1 
06E6    13            4417     	RRC	A
06E7    F9            4418     MOV R1 , A 
06E8    E8            4419     MOV A , R0 
06E9    13            4420     	RRC	A
06EA    F8            4421     MOV R0 , A 
06EB    DCF4          4422     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      4423     
06ED    8BF0          4424     MOV B , R3 
06EF    30F70A        4425     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      4426     
06F2    E8            4427     MOV A , R0 
06F3    F4            4428     	CPL	A
06F4    2401          4429     	ADD	A, #1
06F6    F8            4430     MOV R0 , A 
06F7    E9            4431     MOV A , R1 
06F8    F4            4432     	CPL	A
06F9    3400          4433     	ADDC	A, #0
06FB    F9            4434     MOV R1 , A 
                      4435     
                      4436     MULT_S16_BY_U8_EXIT: 
06FC    E8            4437     MOV A , R0 
06FD    89F0          4438     MOV B , R1 
06FF    C2D4          4439     	CLR	PSW.4		; Select normal register bank
0701    F8            4440     MOV R0 , A 
0702    A9F0          4441     MOV R1 , B 
0704    22            4442     	RET
                      4443     
                      4444     
                      4445     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4446     ;
                      4447     ; Calculate governor routines
                      4448     ;
                      4449     ; No assumptions
                      4450     ;
                      4451     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      4452     ; The governor task is split into several routines in order to distribute processing time
                      4453     ;
                      4454     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4455     ; First governor routine - calculate governor target
                      4456     IF MODE == 0	; Main
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	JB	FLAGS1.GOV_ACTIVE, GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	JNB	FLAGS1.GOV_ACTIVE, GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                                
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	CLR	FLAGS1.GOV_ACTIVE
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	SETB	FLAGS1.GOV_ACTIVE
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      4594     IF MODE == 1	; Tail
                      4595     CALC_GOVERNOR_TARGET: 
0705    22            4596     	RET						
                      4597     ENDIF
                      4598     IF MODE == 2	; Multi
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Closed loop mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_TARGET_CALC	; Yes - branch
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_TARGET_CALC:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #RCP_STOP				; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	JMP	GOVERNOR_ACTIVATE			; No - activate
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	CLR	FLAGS1.GOV_ACTIVE
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	TEMP1, #PGM_GOV_MODE		; Store gov mode
                               	MOV	A, @TEMP1
                               	MOV	TEMP5, A
                               	SETB	FLAGS1.GOV_ACTIVE
                               	MOV	A, REQUESTED_PWM			; Load requested pwm
                               	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                               	; Calculate comm period target 2*(51000/Requested_Pwm)
                               	MOV	TEMP1, #38H				; Load 51000
                               	MOV	TEMP2, #0C7H
                               	MOV	TEMP3, COMM_PERIOD4X_L		; Load comm period
                               	MOV	TEMP4, COMM_PERIOD4X_H		
                               	; Set speed range 
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 200k eRPM range here
                               	; Check range
                               	MOV	A, TEMP5
                               	DEC	A
                               	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                               GOVERNOR_ACTIVATE_100K:
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 100k eRPM range here
                               	MOV	A, TEMP5					; Check range again
                               	DEC	A
                               	DEC	A
                               	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                               GOVERNOR_ACTIVATE_50K:
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 50k eRPM range here
                               GOVERNOR_ACTIVATE_RANGE_SET:
                               	CALL	DIV_U16_BY_U16
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      4676     
                      4677     
                      4678     ; Second governor routine - calculate governor proportional error
                      4679     CALC_GOVERNOR_PROP_ERROR: 
                      4680     IF MODE <= 1	; Main or tail
                      4681     	; Load comm period and divide by 2
0706    C3            4682     	CLR	C
0707    E53E          4683     	MOV	A, COMM_PERIOD4X_H
0709    13            4684     	RRC	A
070A    F9            4685     MOV R1 , A 
070B    E53D          4686     	MOV	A, COMM_PERIOD4X_L
070D    13            4687     	RRC	A
070E    F8            4688     MOV R0 , A 
                      4689     	; Calculate error
070F    C3            4690     	CLR	C
0710    E542          4691     	MOV	A, GOV_TARGET_L
0712    98            4692     SUBB A , R0 
0713    F8            4693     MOV R0 , A 
0714    E543          4694     	MOV	A, GOV_TARGET_H
0716    99            4695     SUBB A , R1 
0717    F9            4696     MOV R1 , A 
                      4697     ENDIF
                      4698     IF MODE == 2	; Multi
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, GOVERNOR_REQ_PWM
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               ENDIF
                      4708     	; Check error and limit
0718    500C          4709     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      4710     
071A    C3            4711     	CLR	C
071B    E8            4712     MOV A , R0 
071C    9480          4713     	SUBB	A, #80H					; Is error too negative?
071E    E9            4714     MOV A , R1 
071F    94FF          4715     	SUBB	A, #0FFH
0721    4016          4716     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
0723    02073D        4717     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4718     
                      4719     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0726    C3            4720     	CLR	C
0727    E8            4721     MOV A , R0 
0728    947F          4722     	SUBB	A, #7FH					; Is error too positive?
072A    E9            4723     MOV A , R1 
072B    9400          4724     	SUBB	A, #00H
072D    5003          4725     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
072F    02073D        4726     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4727     
                      4728     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0732    787F          4729     MOV R0 , # 7FH 
0734    7900          4730     MOV R1 , # 00H 
0736    02073D        4731     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4732     
                      4733     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
0739    7880          4734     MOV R0 , # 80H 
073B    79FF          4735     MOV R1 , # 0FFH 
                      4736     
                      4737     GOVERNOR_STORE_PROP_ERROR: 
                      4738     	; Store proportional
073D    8847          4739     MOV GOV_PROPORTIONAL_L , R0 
073F    8948          4740     MOV GOV_PROPORTIONAL_H , R1 
                      4741     CALC_GOVERNOR_PROP_ERROR_EXIT: 
0741    22            4742     	RET						
                      4743     
                      4744     
                      4745     ; Third governor routine - calculate governor integral error
                      4746     CALC_GOVERNOR_INT_ERROR: 
                      4747     	; Add proportional to integral
0742    E547          4748     	MOV	A, GOV_PROPORTIONAL_L
0744    2544          4749     	ADD	A, GOV_INTEGRAL_L
0746    F8            4750     MOV R0 , A 
0747    E548          4751     	MOV	A, GOV_PROPORTIONAL_H
0749    3545          4752     	ADDC	A, GOV_INTEGRAL_H
074B    F9            4753     MOV R1 , A 
074C    854820        4754     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
074F    E4            4755     	CLR	A
0750    300701        4756     	JNB	BIT_ACCESS.7, ($+4)			
0753    F4            4757     	CPL	A
0754    3546          4758     	ADDC	A, GOV_INTEGRAL_X
0756    FA            4759     MOV R2 , A 
                      4760     	; Check integral and limit
0757    30E709        4761     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      4762     
075A    C3            4763     	CLR	C
075B    EA            4764     MOV A , R2 
075C    94F0          4765     	SUBB	A, #0F0H					; Is error too negative?
075E    4015          4766     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
0760    02077B        4767     	JMP	GOVERNOR_CHECK_PWM
                      4768     
                      4769     GOVERNOR_CHECK_INT_LIMIT_POS: 
0763    C3            4770     	CLR	C
0764    EA            4771     MOV A , R2 
0765    940F          4772     	SUBB	A, #0FH					; Is error too positive?
0767    5003          4773     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
0769    02077B        4774     	JMP	GOVERNOR_CHECK_PWM
                      4775     
                      4776     GOVERNOR_LIMIT_INT_ERROR_POS: 
076C    78FF          4777     MOV R0 , # 0FFH 
076E    79FF          4778     MOV R1 , # 0FFH 
0770    7A0F          4779     MOV R2 , # 0FH 
0772    02077B        4780     	JMP	GOVERNOR_CHECK_PWM
                      4781     
                      4782     GOVERNOR_LIMIT_INT_ERROR_NEG: 
0775    7800          4783     MOV R0 , # 00H 
0777    7900          4784     MOV R1 , # 00H 
0779    7AF0          4785     MOV R2 , # 0F0H 
                      4786     
                      4787     GOVERNOR_CHECK_PWM: 
                      4788     	; Check current pwm
077B    C3            4789     	CLR	C
077C    E524          4790     	MOV	A, CURRENT_PWM
077E    9561          4791     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
0780    500A          4792     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      4793     
0782    C3            4794     	CLR	C
0783    7401          4795     	MOV	A, #1
0785    9524          4796     	SUBB	A, CURRENT_PWM				; Is current pwm at minimum?
0787    500B          4797     	JNC	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      4798     
0789    020799        4799     	JMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      4800     
                      4801     GOVERNOR_INT_MAX_PWM: 
078C    E548          4802     	MOV	A, GOV_PROPORTIONAL_H
078E    20E70E        4803     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      4804     
0791    020799        4805     	JMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      4806     
                      4807     GOVERNOR_INT_MIN_PWM: 
0794    E548          4808     	MOV	A, GOV_PROPORTIONAL_H
0796    30E706        4809     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      4810     
                      4811     GOVERNOR_STORE_INT_ERROR: 
                      4812     	; Store integral
0799    8844          4813     MOV GOV_INTEGRAL_L , R0 
079B    8945          4814     MOV GOV_INTEGRAL_H , R1 
079D    8A46          4815     MOV GOV_INTEGRAL_X , R2 
                      4816     CALC_GOVERNOR_INT_ERROR_EXIT: 
079F    22            4817     	RET						
                      4818     
                      4819     
                      4820     ; Fourth governor routine - calculate governor proportional correction
                      4821     CALC_GOVERNOR_PROP_CORRECTION: 
                      4822     	; Load proportional gain
07A0    78A4          4823     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
07A2    E6            4824     MOV A , @ R0 
07A3    FA            4825     MOV R2 , A 
                      4826     	; Load proportional
07A4    C3            4827     	CLR	C
07A5    E547          4828     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
07A7    33            4829     	RLC	A
07A8    F8            4830     MOV R0 , A 
07A9    E548          4831     	MOV	A, GOV_PROPORTIONAL_H
07AB    33            4832     	RLC	A
07AC    F9            4833     MOV R1 , A 
                      4834     	; Apply gain
07AD    D1AE          4835     	CALL	MULT_S16_BY_U8_DIV_16
                      4836     	; Check error and limit (to low byte)
07AF    E9            4837     MOV A , R1 
07B0    30E70B        4838     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      4839     
07B3    C3            4840     	CLR	C
07B4    E8            4841     MOV A , R0 
07B5    9480          4842     	SUBB	A, #80H					; Is error too negative?
07B7    E9            4843     MOV A , R1 
07B8    94FF          4844     	SUBB	A, #0FFH
07BA    4013          4845     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
07BC    E1D3          4846     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4847     
                      4848     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
07BE    C3            4849     	CLR	C
07BF    E8            4850     MOV A , R0 
07C0    947F          4851     	SUBB	A, #7FH					; Is error too positive?
07C2    E9            4852     MOV A , R1 
07C3    9400          4853     	SUBB	A, #00H
07C5    5002          4854     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
07C7    E1D3          4855     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4856     
                      4857     GOVERNOR_LIMIT_PROP_CORR_POS: 
07C9    787F          4858     MOV R0 , # 7FH 
07CB    7900          4859     MOV R1 , # 00H 
07CD    E1D3          4860     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4861     
                      4862     GOVERNOR_LIMIT_PROP_CORR_NEG: 
07CF    7880          4863     MOV R0 , # 80H 
07D1    79FF          4864     MOV R1 , # 0FFH 
                      4865     
                      4866     GOVERNOR_APPLY_PROP_CORR: 
                      4867     	; Test proportional sign
07D3    E8            4868     MOV A , R0 
07D4    20E715        4869     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      4870     
                      4871     	; Subtract positive proportional
07D7    C3            4872     	CLR	C
07D8    E523          4873     	MOV	A, GOVERNOR_REQ_PWM
07DA    98            4874     SUBB A , R0 
07DB    F8            4875     MOV R0 , A 
                      4876     	; Check result
07DC    4009          4877     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      4878     
07DE    C3            4879     	CLR	C
07DF    E8            4880     MOV A , R0 
07E0    9401          4881     	SUBB	A, #1
07E2    4003          4882     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
07E4    0207FA        4883     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4884     
                      4885     GOVERNOR_CORR_PROP_MIN_PWM: 
07E7    7801          4886     MOV R0 , # 1 
07E9    0207FA        4887     	JMP	GOVERNOR_STORE_PROP_CORR
                      4888     
                      4889     GOVERNOR_CORR_NEG_PROP: 
                      4890     	; Add negative proportional
07EC    E8            4891     MOV A , R0 
07ED    F4            4892     	CPL	A
07EE    2401          4893     	ADD	A, #1
07F0    2523          4894     	ADD	A, GOVERNOR_REQ_PWM
07F2    F8            4895     MOV R0 , A 
                      4896     	; Check result
07F3    4003          4897     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
07F5    0207FA        4898     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4899     
                      4900     GOVERNOR_CORR_PROP_MAX_PWM: 
07F8    78FF          4901     MOV R0 , # 255 
                      4902     GOVERNOR_STORE_PROP_CORR: 
                      4903     	; Store proportional pwm
07FA    8849          4904     MOV GOV_PROP_PWM , R0 
                      4905     CALC_GOVERNOR_PROP_CORR_EXIT: 
07FC    22            4906     	RET
                      4907     
                      4908     
                      4909     ; Fifth governor routine - calculate governor integral correction
                      4910     CALC_GOVERNOR_INT_CORRECTION: 
                      4911     	; Load integral gain
07FD    78A5          4912     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
07FF    E6            4913     MOV A , @ R0 
0800    FA            4914     MOV R2 , A 
                      4915     	; Load integral
0801    A845          4916     MOV R0 , GOV_INTEGRAL_H 
0803    A946          4917     MOV R1 , GOV_INTEGRAL_X 
                      4918     	; Apply gain
0805    1206AE        4919     	CALL	MULT_S16_BY_U8_DIV_16
                      4920     	; Check integral and limit
0808    E9            4921     MOV A , R1 
0809    30E70C        4922     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      4923     
080C    C3            4924     	CLR	C
080D    E8            4925     MOV A , R0 
080E    9401          4926     	SUBB	A, #01H					; Is integral too negative?
0810    E9            4927     MOV A , R1 
0811    94FF          4928     	SUBB	A, #0FFH
0813    4016          4929     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0815    02082F        4930     	JMP	GOVERNOR_APPLY_INT_CORR
                      4931     
                      4932     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0818    C3            4933     	CLR	C
0819    E8            4934     MOV A , R0 
081A    94FF          4935     	SUBB	A, #0FFH					; Is integral too positive?
081C    E9            4936     MOV A , R1 
081D    9400          4937     	SUBB	A, #00H
081F    5003          4938     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0821    02082F        4939     	JMP	GOVERNOR_APPLY_INT_CORR
                      4940     
                      4941     GOVERNOR_LIMIT_INT_CORR_POS: 
0824    78FF          4942     MOV R0 , # 0FFH 
0826    7900          4943     MOV R1 , # 00H 
0828    02082F        4944     	JMP	GOVERNOR_APPLY_INT_CORR
                      4945     
                      4946     GOVERNOR_LIMIT_INT_CORR_NEG: 
082B    7801          4947     MOV R0 , # 01H 
082D    79FF          4948     MOV R1 , # 0FFH 
                      4949     
                      4950     GOVERNOR_APPLY_INT_CORR: 
                      4951     	; Test integral sign
082F    E9            4952     MOV A , R1 
0830    20E715        4953     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      4954     
                      4955     	; Subtract positive integral
0833    C3            4956     	CLR	C
0834    E549          4957     	MOV	A, GOV_PROP_PWM
0836    98            4958     SUBB A , R0 
0837    F8            4959     MOV R0 , A 
                      4960     	; Check result
0838    4009          4961     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      4962     
083A    C3            4963     	CLR	C
083B    E8            4964     MOV A , R0 
083C    9401          4965     	SUBB	A, #1
083E    4003          4966     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0840    020856        4967     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4968     
                      4969     GOVERNOR_CORR_INT_MIN_PWM: 
0843    7801          4970     MOV R0 , # 1 
0845    020856        4971     	JMP	GOVERNOR_STORE_INT_CORR
                      4972     
                      4973     GOVERNOR_CORR_NEG_INT: 
                      4974     	; Add negative integral
0848    E8            4975     MOV A , R0 
0849    F4            4976     	CPL	A
084A    2401          4977     	ADD	A, #1
084C    2549          4978     	ADD	A, GOV_PROP_PWM
084E    F8            4979     MOV R0 , A 
                      4980     	; Check result
084F    4003          4981     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0851    020856        4982     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4983     
                      4984     GOVERNOR_CORR_INT_MAX_PWM: 
0854    78FF          4985     MOV R0 , # 255 
                      4986     GOVERNOR_STORE_INT_CORR: 
                      4987     	; Store current pwm
0856    8824          4988     MOV CURRENT_PWM , R0 
                      4989     CALC_GOVERNOR_INT_CORR_EXIT: 
0858    22            4990     	RET
                      4991     
                      4992     
                      4993     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4994     ;
                      4995     ; Set pwm limit low rpm
                      4996     ;
                      4997     ; No assumptions
                      4998     ;
                      4999     ; Sets power limit for low rpms and disables demag for low rpms
                      5000     ;
                      5001     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5002     SET_PWM_LIMIT_LOW_RPM: 
                      5003     	; Set pwm limit and demag disable for low rpms
0859    78FF          5004     MOV R0 , # 0FFH 
085B    C264          5005     CLR FLAGS0 . 4 
085D    20693D        5006     JB FLAGS1 . 1 , SET_PWM_LIMIT_LOW_RPM_EXIT 
0860    206A12        5007     JB FLAGS1 . 2 , SET_PWM_DEMAG_DONE 
                      5008     
0863    D264          5009     SETB FLAGS0 . 4 
0865    C3            5010     	CLR	C
0866    E53E          5011     	MOV	A, COMM_PERIOD4X_H
0868    940A          5012     	SUBB	A, #0AH						; ~31250 eRPM
086A    4009          5013     	JC	SET_PWM_DEMAG_DONE				; If speed above - branch
                      5014     
086C    C3            5015     	CLR	C
086D    E525          5016     	MOV	A, CURRENT_PWM_LIMITED	
086F    9440          5017     	SUBB	A, #40H						; Do not disable if pwm above 25%
0871    5002          5018     	JNC	SET_PWM_DEMAG_DONE
                      5019     
0873    C264          5020     CLR FLAGS0 . 4 
                      5021     
                      5022     SET_PWM_DEMAG_DONE: 
0875    79A1          5023     MOV R1 , # PGM_ENABLE_POWER_PROT 
0877    E7            5024     MOV A , @ R1 
0878    6023          5025     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Exit if disabled
                      5026     
087A    E53E          5027     	MOV	A, COMM_PERIOD4X_H
087C    601F          5028     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Avoid divide by zero
                      5029     
087E    74FF          5030     	MOV	A, #255						; Divide 255 by Comm_Period4x_H
0880    853EF0        5031     	MOV	B, COMM_PERIOD4X_H
0883    84            5032     	DIV	AB
0884    8538F0        5033     	MOV	B, LOW_RPM_PWR_SLOPE			; Multiply by slope
0887    306A03        5034     JNB FLAGS1 . 2 , ( $+6 ) 
088A    75F005        5035     	MOV	B, #5
088D    A4            5036     	MUL	AB
088E    F8            5037     MOV R0 , A 
088F    C5F0          5038     	XCH	A, B
0891    6002          5039     	JZ	($+4)						; Limit to max
                      5040     	
0893    78FF          5041     MOV R0 , # 0FFH 
                      5042     
0895    C3            5043     	CLR	C
0896    E8            5044     MOV A , R0 
0897    9564          5045     	SUBB	A, PWM_SPOOLUP_BEG
0899    5002          5046     	JNC	SET_PWM_LIMIT_LOW_RPM_EXIT
                      5047     
089B    A864          5048     MOV R0 , PWM_SPOOLUP_BEG 
                      5049     
                      5050     SET_PWM_LIMIT_LOW_RPM_EXIT: 
089D    8863          5051     MOV PWM_LIMIT_BY_RPM , R0 
089F    22            5052     	RET
                      5053     	
                      5054     
                      5055     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5056     ;
                      5057     ; Set pwm limit high rpm
                      5058     ;
                      5059     ; No assumptions
                      5060     ;
                      5061     ; Sets power limit for high rpms
                      5062     ;
                      5063     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5064     SET_PWM_LIMIT_HIGH_RPM: 
                      5065     IF MCU_48MHZ == 1
08A0    C3            5066     	CLR	C
08A1    E53D          5067     	MOV	A, COMM_PERIOD4X_L
08A3    94C8          5068     	SUBB	A, #0C8H				; Limit Comm_Period to 200, which is 400k erpm
08A5    E53E          5069     	MOV	A, COMM_PERIOD4X_H
08A7    9400          5070     	SUBB	A, #00H
                      5071     ELSE
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_L
                               	SUBB	A, #40H				; Limit Comm_Period to 320, which is 250k erpm
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, #01H
                               ENDIF
08A9    E563          5078     	MOV	A, PWM_LIMIT_BY_RPM
08AB    5003          5079     	JNC	SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT
                      5080     	
08AD    14            5081     	DEC	A
08AE    01B1          5082     	AJMP	SET_PWM_LIMIT_HIGH_RPM_STORE
                      5083     	
                      5084     SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT: 
08B0    04            5085     	INC	A
                      5086     SET_PWM_LIMIT_HIGH_RPM_STORE: 
08B1    6002          5087     	JZ	($+4)
                      5088     
08B3    F563          5089     	MOV	PWM_LIMIT_BY_RPM, A
                      5090     
08B5    22            5091     	RET
                      5092     
                      5093     
                      5094     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5095     ;
                      5096     ; Measure lipo cells
                      5097     ;
                      5098     ; No assumptions
                      5099     ;
                      5100     ; Measure voltage and calculate lipo cells
                      5101     ;
                      5102     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5103     MEASURE_LIPO_CELLS: 
                      5104     IF MODE >= 1	; Tail or multi
                      5105     	; If not supported, then exit
08B6    0208B9        5106     	JMP	MEASURE_LIPO_EXIT
                      5107     ENDIF
                      5108     IF MODE == 0	; Main
                               	; Load programmed low voltage limit
                               	MOV	TEMP1, #PGM_LOW_VOLTAGE_LIM	; Load limit
                               	MOV	A, @TEMP1				
                               	MOV	BIT_ACCESS, A				; Store in Bit_Access
                               	; Set commutation to BpFET on
                               	CALL	COMM5COMM6			
                               	; Start adc
                               	START_ADC 
                               	; Wait for ADC reference to settle, and then start again
                               	CALL	WAIT1MS
                               	START_ADC
                               	; Wait for ADC conversion to complete
                               MEASURE_LIPO_WAIT_ADC:
                               	GET_ADC_STATUS 
                               	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                               	; Read ADC result
                               	READ_ADC_RESULT
                               	; Stop ADC
                               	STOP_ADC
                               	; Switch power off
                               	CALL	SWITCH_POWER_OFF		
                               	; Set limit step
                               	MOV	LIPO_ADC_LIMIT_L, #ADC_LIMIT_L
                               	MOV	LIPO_ADC_LIMIT_H, #ADC_LIMIT_H
                               	CLR	C
                               	MOV	A, #ADC_LIMIT_H		; Divide 3.0V value by 2
                               	RRC	A
                               	MOV	TEMP6, A
                               	MOV	A, #ADC_LIMIT_L
                               	JZ	MEASURE_LIPO_EXIT		; Exit if disabled
                               
                               	RRC	A
                               	MOV	TEMP5, A
                               	MOV	A, #ADC_LIMIT_L		; Calculate 1.5*3.0V=4.5V value
                               	ADD	A, TEMP5
                               	MOV	TEMP5, A
                               	MOV	A, #ADC_LIMIT_H		
                               	ADDC	A, TEMP6
                               	MOV	TEMP6, A
                               	MOV	A, TEMP5				; Copy step
                               	MOV	TEMP3, A
                               	MOV	A, TEMP6	
                               	MOV	TEMP4, A
                               MEASURE_LIPO_CELL_LOOP:
                               	; Check voltage against xS lower limit
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, TEMP3				; Voltage above limit?
                               	MOV	A, TEMP2
                               	SUBB A, TEMP4
                               	JC	MEASURE_LIPO_ADJUST		; No - branch
                               
                               	; Set xS voltage limit
                               	MOV	A, LIPO_ADC_LIMIT_L		
                               	ADD	A, #ADC_LIMIT_L
                               	MOV	LIPO_ADC_LIMIT_L, A
                               	MOV	A, LIPO_ADC_LIMIT_H		
                               	ADDC	A, #ADC_LIMIT_H
                               	MOV	LIPO_ADC_LIMIT_H, A
                               	; Set (x+1)S lower limit
                               	MOV	A, TEMP3
                               	ADD	A, TEMP5				; Add step
                               	MOV	TEMP3, A
                               	MOV	A, TEMP4
                               	ADDC	A, TEMP6
                               	MOV	TEMP4, A
                               	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                               
                               MEASURE_LIPO_ADJUST:
                               	MOV	TEMP7, LIPO_ADC_LIMIT_L
                               	MOV	TEMP8, LIPO_ADC_LIMIT_H
                               	; Calculate 3.125%
                               	CLR	C
                               	MOV	A, LIPO_ADC_LIMIT_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, LIPO_ADC_LIMIT_L	
                               	RRC	A
                               	MOV	TEMP1, A			; After this 50%
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1	
                               	RRC	A
                               	MOV	TEMP1, A			; After this 25%
                               	; Divide three times to get to 3.125%
                               	MOV	TEMP3, #3
                               MEASURE_LIPO_DIVIDE_LOOP:
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1	
                               	RRC	A
                               	MOV	TEMP1, A			
                               	DJNZ	TEMP3, MEASURE_LIPO_DIVIDE_LOOP
                               
                               	; Add the programmed number of 0.1V (or 3.125% increments)
                               	MOV	TEMP3, BIT_ACCESS		; Load programmed limit (Bit_Access has Pgm_Low_Voltage_Lim)
                               	DEC	TEMP3
                               	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                               
                               	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
                               	MOV	LIPO_ADC_LIMIT_H, #0
                               	JMP	MEASURE_LIPO_EXIT	
                               
                               MEASURE_LIPO_LIMIT_ON:
                               	DEC	TEMP3
                               	MOV	A, TEMP3
                               	JZ	MEASURE_LIPO_UPDATE
                               
                               MEASURE_LIPO_ADD_LOOP:
                               	MOV	A, TEMP7			; Add 3.125%
                               	ADD	A, TEMP1
                               	MOV	TEMP7, A
                               	MOV	A, TEMP8
                               	ADDC	A, TEMP2
                               	MOV	TEMP8, A
                               	DJNZ	TEMP3, MEASURE_LIPO_ADD_LOOP
                               
                               MEASURE_LIPO_UPDATE:
                               	; Set ADC limit
                               	MOV	LIPO_ADC_LIMIT_L, TEMP7
                               	MOV	LIPO_ADC_LIMIT_H, TEMP8
                               ENDIF
                      5235     MEASURE_LIPO_EXIT: 
08B9    22            5236     	RET
                      5237     
                      5238     
                      5239     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5240     ;
                      5241     ; Start ADC conversion
                      5242     ;
                      5243     ; No assumptions
                      5244     ;
                      5245     ; Start conversion used for measuring power supply voltage
                      5246     ;
                      5247     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5248     START_ADC_CONVERSION: 
                      5249     	; Start adc
                      5250     	START_ADC 
08BA    75E890        5250+1   MOV ADC0CN , # 90H  ; ADC START
08BD    22            5251     	RET
                      5252     
                      5253     
                      5254     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5255     ;
                      5256     ; Check temperature, power supply voltage and limit power
                      5257     ;
                      5258     ; No assumptions
                      5259     ;
                      5260     ; Used to limit main motor power in order to maintain the required voltage
                      5261     ;
                      5262     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5263     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      5264     	; Load programmed low voltage limit
08BE    7883          5265     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
08C0    E6            5266     MOV A , @ R0 
08C1    FF            5267     MOV R7 , A 
                      5268     	; Wait for ADC conversion to complete
                      5269     	GET_ADC_STATUS 
08C2    E5E8          5269+1   MOV A , ADC0CN 
08C4    20ECF7        5270     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      5271     	; Read ADC result
                      5272     	READ_ADC_RESULT
08C7    A8BD          5272+1   MOV R0 , ADC0L 
08C9    A9BE          5272+1   MOV R1 , ADC0H 
                      5273     	; Stop ADC
                      5274     	STOP_ADC
                      5275     
08CB    0570          5276     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
08CD    C3            5277     	CLR	C
08CE    E570          5278     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
08D0    9408          5279     SUBB A , # 8 
08D2    4052          5280     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      5281     
08D4    757000        5282     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
08D7    E9            5283     MOV A , R1 
08D8    FA            5284     MOV R2 , A 
08D9    79A0          5285     MOV R1 , # PGM_ENABLE_TEMP_PROT 
08DB    E7            5286     MOV A , @ R1 
08DC    6044          5287     	JZ	TEMP_CHECK_EXIT			; No - branch
                      5288     
08DE    EA            5289     MOV A , R2 
08DF    7007          5290     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      5291     
08E1    E571          5292     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
08E3    601B          5293     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
08E5    0208F4        5294     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      5295     
                      5296     TEMP_AVERAGE_INC_DEC: 
08E8    C3            5297     	CLR	C
08E9    E8            5298     MOV A , R0 
08EA    9571          5299     	SUBB	A, CURRENT_AVERAGE_TEMP
08EC    6010          5300     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      5301     
08EE    E571          5302     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
08F0    5006          5303     	JNC	TEMP_AVERAGE_INC				
                      5304     
08F2    600C          5305     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      5306     TEMP_AVERAGE_DEC: 
08F4    14            5307     	DEC	A						; Decrement average
08F5    020900        5308     	JMP	TEMP_AVERAGE_UPDATED
                      5309     
                      5310     TEMP_AVERAGE_INC: 
08F8    04            5311     	INC	A						; Increment average
08F9    60F9          5312     	JZ	TEMP_AVERAGE_DEC
08FB    020900        5313     	JMP	TEMP_AVERAGE_UPDATED
                      5314     
                      5315     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
08FE    E571          5316     	MOV	A, CURRENT_AVERAGE_TEMP
                      5317     TEMP_AVERAGE_UPDATED: 
0900    F571          5318     	MOV	CURRENT_AVERAGE_TEMP, A
0902    C3            5319     	CLR	C
0903    9472          5320     SUBB A , # 114 
0905    401B          5321     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5322     
0907    7561C0        5323     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      5324     
090A    C3            5325     	CLR	C
090B    9404          5326     SUBB A , # 4 
090D    4013          5327     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5328     
090F    756180        5329     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      5330     
0912    C3            5331     	CLR	C
0913    9404          5332     SUBB A , # 4 
0915    400B          5333     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5334     
0917    756140        5335     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      5336     
091A    C3            5337     	CLR	C
091B    9404          5338     SUBB A , # 4 
091D    4003          5339     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5340     
091F    756100        5341     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      5342     
                      5343     TEMP_CHECK_EXIT: 
                      5344     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0922    75BB09        5344+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0925    22            5345     	RET
                      5346     
                      5347     CHECK_VOLTAGE_START: 
                      5348     IF MODE == 0	; Main 
                               	; Check if low voltage limiting is enabled
                               	MOV	A, TEMP8
                               	CLR	C
                               	SUBB	A, #1					; Is low voltage limit disabled?
                               	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                               
                               	MOV	A, #ADC_LIMIT_L			; Is low voltage limit zero (ESC does not support it)?
                               	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                               
                               	; Check if ADC is saturated
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #0FFH
                               	MOV	A, TEMP2
                               	SUBB	A, #03H
                               	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                               
                               	; Check voltage against limit
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, LIPO_ADC_LIMIT_L
                               	MOV	A, TEMP2
                               	SUBB	A, LIPO_ADC_LIMIT_H
                               	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                               
                               	; Decrease pwm limit
                               	MOV  A, PWM_LIMIT
                               	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                               
                               	DEC	PWM_LIMIT					; Decrement limit
                               	JMP	CHECK_VOLTAGE_LIM
                               
                               CHECK_VOLTAGE_GOOD:
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               	MOV	TEMP1, PWM_LIMIT			; Set limit
                               	CLR	C
                               	MOV	A, CURRENT_PWM
                               	SUBB	A, TEMP1
                               	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                               
                               	MOV	TEMP1, CURRENT_PWM			; Set current pwm (no limiting)
                               
                               CHECK_VOLTAGE_SPOOLUP_LIM:
                               	; Slow spoolup
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_LIMIT_SPOOLUP
                               	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                               
                               	MOV	TEMP1, PWM_LIMIT_SPOOLUP
                               	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
                               	CPL	A
                               	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                                
                               	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                               
                               CHECK_VOLTAGE_EXIT:
                               	MOV  CURRENT_PWM_LIMITED, TEMP1
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               ENDIF
                      5416     IF MODE == 1	; Tail
                      5417     	; Increase pwm limit
0926    E561          5418     	MOV  A, PWM_LIMIT
0928    F4            5419     	CPL	A			
0929    6002          5420     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      5421     
092B    0561          5422     	INC	PWM_LIMIT					; Increment limit
                      5423     
                      5424     CHECK_VOLTAGE_LIM: 
                      5425     ENDIF
                      5426     IF MODE == 2	; Multi
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	ADD	A, #16			
                               	JNC	($+4)					; If not max - branch
                               
                               	MOV	A, #255
                               
                               	MOV	PWM_LIMIT, A				; Increment limit 
                               	; Set current pwm limited if closed loop mode
                               	MOV	TEMP2, #PGM_GOV_MODE		; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)			
                               	AJMP	CHECK_VOLTAGE_PWM_DONE		; No - branch
                               
                               	CLR	C
                               	MOV	TEMP1, PWM_LIMIT			; Set limit
                               	MOV	A, CURRENT_PWM
                               	SUBB	A, TEMP1
                               	JNC	CHECK_VOLTAGE_LOW_RPM		; If current pwm above limit - branch and limit	
                               
                               	MOV	TEMP1, CURRENT_PWM			; Set current pwm (no limiting)
                               
                               CHECK_VOLTAGE_LOW_RPM:
                               	; Limit pwm for low rpms
                               	CLR	C
                               	MOV	A, TEMP1					; Check against limit
                               	SUBB	A, PWM_LIMIT_BY_RPM
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT_BY_RPM		; Limit pwm
                               
                               	MOV  CURRENT_PWM_LIMITED, TEMP1
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               CHECK_VOLTAGE_PWM_DONE:
                               ENDIF
                      5461     	; Set adc mux for next conversion
092D    E570          5462     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
092F    B40703        5463     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      5464     
                      5465     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0932    75BB10        5465+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5466     
                      5467     CHECK_VOLTAGE_RET: 
0935    22            5468     	RET
                      5469     
                      5470     
                      5471     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5472     ;
                      5473     ; Set startup PWM routine
                      5474     ;
                      5475     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      5476     ;
                      5477     ; Used for pwm control during startup
                      5478     ;
                      5479     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5480     SET_STARTUP_PWM: 	
                      5481     	; Adjust startup power
0936    7432          5482     MOV A , # 50 
0938    79A6          5483     MOV R1 , # PGM_STARTUP_PWR_DECODED 
093A    87F0          5484     MOV B , @ R1 
093C    A4            5485     	MUL	AB
093D    C5F0          5486     	XCH	A, B
093F    A2F7          5487     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0941    33            5488     	RLC	A
0942    F8            5489     MOV R0 , A 
0943    C3            5490     	CLR	C
0944    E8            5491     MOV A , R0 
0945    9561          5492     	SUBB	A, PWM_LIMIT	
0947    4002          5493     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      5494     
0949    A861          5495     MOV R0 , PWM_LIMIT 
                      5496     
                      5497     STARTUP_PWM_SET_PWM: 
                      5498     	; Set pwm variables
094B    8822          5499     MOV REQUESTED_PWM , R0 
094D    8824          5500     MOV CURRENT_PWM , R0 
094F    8825          5501     MOV CURRENT_PWM_LIMITED , R0 
0951    8826          5502     MOV CURRENT_PWM_LIM_DITH , R0 
0953    8864          5503     MOV PWM_SPOOLUP_BEG , R0 
0955    22            5504     	RET
                      5505     
                      5506     
                      5507     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5508     ;
                      5509     ; Initialize timing routine
                      5510     ;
                      5511     ; No assumptions
                      5512     ;
                      5513     ; Part of initialization before motor start
                      5514     ;
                      5515     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5516     INITIALIZE_TIMING:  
0956    753D00        5517     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0959    753EF0        5518     	MOV	COMM_PERIOD4X_H, #0F0H
095C    22            5519     	RET
                      5520     
                      5521     
                      5522     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5523     ;
                      5524     ; Calculate next commutation timing routine
                      5525     ;
                      5526     ; No assumptions
                      5527     ;
                      5528     ; Called immediately after each commutation
                      5529     ; Also sets up timer 3 to wait advance timing
                      5530     ; Two entry points are used
                      5531     ;
                      5532     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5533     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
                      5534     	; Read commutation time
095D    75C820        5535     	MOV	TMR2CN, #20H		; Timer2 disabled
0960    A8CC          5536     MOV R0 , TMR2L 
0962    A9CD          5537     MOV R1 , TMR2H 
0964    75C824        5538     	MOV	TMR2CN, #24H		; Timer2 enabled
                      5539     IF MCU_48MHZ == 1
0967    C3            5540     	CLR	C
0968    E9            5541     MOV A , R1 
0969    13            5542     	RRC	A
096A    F9            5543     MOV R1 , A 
096B    E8            5544     MOV A , R0 
096C    13            5545     	RRC	A
096D    F8            5546     MOV R0 , A 
                      5547     ENDIF
                      5548     	; Calculate this commutation time
096E    AA39          5549     MOV R2 , PREV_COMM_L 
0970    AB3A          5550     MOV R3 , PREV_COMM_H 
0972    8839          5551     MOV PREV_COMM_L , R0 
0974    893A          5552     MOV PREV_COMM_H , R1 
0976    C3            5553     	CLR	C
0977    E8            5554     MOV A , R0 
0978    9A            5555     SUBB A , R2 
0979    F8            5556     MOV R0 , A 
097A    E9            5557     MOV A , R1 
097B    9B            5558     SUBB A , R3 
                      5559     IF MCU_48MHZ == 1
097C    547F          5560     	ANL	A, #7FH
                      5561     ENDIF
097E    F9            5562     MOV R1 , A 
097F    306702        5563     JNB FLAGS0 . 7 , ( $+5 ) 
0982    415C          5564     	AJMP	CALC_NEXT_COMM_TIMING_FAST
                      5565     
0984    306933        5566     JNB FLAGS1 . 1 , CALC_NEXT_COMM_STARTUP_DONE 
                      5567     
0987    AC3B          5568     MOV R4 , PREV_PREV_COMM_L 
0989    AD3C          5569     MOV R5 , PREV_PREV_COMM_H 
098B    8A3B          5570     MOV PREV_PREV_COMM_L , R2 
098D    8B3C          5571     MOV PREV_PREV_COMM_H , R3 
098F    C3            5572     	CLR	C
0990    EB            5573     MOV A , R3 
0991    9D            5574     SUBB A , R5 
                      5575     IF MCU_48MHZ == 1
0992    547F          5576     	ANL	A, #7FH
                      5577     ENDIF
0994    FB            5578     MOV R3 , A 
0995    C3            5579     	CLR	C
0996    E9            5580     MOV A , R1 
0997    9B            5581     SUBB A , R3 
0998    F53F          5582     	MOV	COMM_DIFF, A
099A    A839          5583     MOV R0 , PREV_COMM_L 
099C    A93A          5584     MOV R1 , PREV_COMM_H 
099E    C3            5585     	CLR	C
099F    E8            5586     MOV A , R0 
09A0    9C            5587     SUBB A , R4 
09A1    F8            5588     MOV R0 , A 
09A2    E9            5589     MOV A , R1 
09A3    9D            5590     SUBB A , R5 
                      5591     IF MCU_48MHZ == 1
09A4    547F          5592     	ANL	A, #7FH
                      5593     ENDIF
09A6    F9            5594     MOV R1 , A 
                      5595     
09A7    C3            5596     	CLR	C
09A8    E53E          5597     	MOV	A, COMM_PERIOD4X_H		; Average with previous and save
09AA    13            5598     	RRC	A
09AB    FB            5599     MOV R3 , A 
09AC    E53D          5600     	MOV	A, COMM_PERIOD4X_L
09AE    13            5601     	RRC	A
09AF    FA            5602     MOV R2 , A 
09B0    E8            5603     MOV A , R0 
09B1    2A            5604     ADD A , R2 
09B2    F53D          5605     	MOV	COMM_PERIOD4X_L, A
09B4    E9            5606     MOV A , R1 
09B5    3B            5607     ADDC A , R3 
09B6    F53E          5608     	MOV	COMM_PERIOD4X_H, A
09B8    4104          5609     	AJMP	CALC_NEW_WAIT_TIMES_SETUP
                      5610     
                      5611     CALC_NEXT_COMM_STARTUP_DONE: 
                      5612     	; Calculate new commutation time 
09BA    AA3D          5613     MOV R2 , COMM_PERIOD4X_L 
09BC    AB3E          5614     MOV R3 , COMM_PERIOD4X_H 
09BE    AC3D          5615     MOV R4 , COMM_PERIOD4X_L 
09C0    AD3E          5616     MOV R5 , COMM_PERIOD4X_H 
09C2    7E04          5617     MOV R6 , # 4 
09C4    7F02          5618     MOV R7 , # 2 
09C6    C3            5619     	CLR	C
09C7    EB            5620     MOV A , R3 
09C8    9404          5621     	SUBB	A, #04H
09CA    4002          5622     	JC	($+4)
                      5623     
09CC    1E            5624     DEC R6 
09CD    1F            5625     DEC R7 
                      5626     
09CE    C3            5627     	CLR	C
09CF    EB            5628     MOV A , R3 
09D0    9408          5629     	SUBB	A, #08H
09D2    4002          5630     	JC	($+4)
                      5631     
09D4    1E            5632     DEC R6 
09D5    1F            5633     DEC R7 
                      5634     
                      5635     CALC_NEXT_COMM_AVG_PERIOD_DIV: 
09D6    C3            5636     	CLR	C
09D7    ED            5637     MOV A , R5 
09D8    13            5638     	RRC	A					; Divide by 2
09D9    FD            5639     MOV R5 , A 
09DA    EC            5640     MOV A , R4 
09DB    13            5641     	RRC	A
09DC    FC            5642     MOV R4 , A 
09DD    DEF7          5643     DJNZ R6 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      5644     
09DF    C3            5645     	CLR	C
09E0    EA            5646     MOV A , R2 
09E1    9C            5647     SUBB A , R4 
09E2    FA            5648     MOV R2 , A 
09E3    EB            5649     MOV A , R3 
09E4    9D            5650     SUBB A , R5 
09E5    FB            5651     MOV R3 , A 
09E6    EF            5652     MOV A , R7 
09E7    6009          5653     	JZ	CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE
                      5654     
                      5655     CALC_NEXT_COMM_NEW_PERIOD_DIV: 
09E9    C3            5656     	CLR	C
09EA    E9            5657     MOV A , R1 
09EB    13            5658     	RRC	A					; Divide by 2
09EC    F9            5659     MOV R1 , A 
09ED    E8            5660     MOV A , R0 
09EE    13            5661     	RRC	A
09EF    F8            5662     MOV R0 , A 
09F0    DFF7          5663     DJNZ R7 , CALC_NEXT_COMM_NEW_PERIOD_DIV 
                      5664     
                      5665     CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE: 
09F2    EA            5666     MOV A , R2 
09F3    28            5667     ADD A , R0 
09F4    FA            5668     MOV R2 , A 
09F5    EB            5669     MOV A , R3 
09F6    39            5670     ADDC A , R1 
09F7    FB            5671     MOV R3 , A 
09F8    8A3D          5672     MOV COMM_PERIOD4X_L , R2 
09FA    8B3E          5673     MOV COMM_PERIOD4X_H , R3 
09FC    5006          5674     	JNC	CALC_NEW_WAIT_TIMES_SETUP; If period larger than 0xffff - go to slow case
                      5675     
09FE    7BFF          5676     MOV R3 , # 0FFH 
0A00    8B3D          5677     MOV COMM_PERIOD4X_L , R3 
0A02    8B3E          5678     MOV COMM_PERIOD4X_H , R3 
                      5679     
                      5680     CALC_NEW_WAIT_TIMES_SETUP: 	
                      5681     	; Set high rpm bit (if above 156k erpm)
0A04    C3            5682     	CLR	C
0A05    EB            5683     MOV A , R3 
0A06    9402          5684     	SUBB	A, #2
0A08    5002          5685     	JNC	($+4)
                      5686     
0A0A    D267          5687     SETB FLAGS0 . 7 
                      5688     	
                      5689     	; Load programmed commutation timing
0A0C    306904        5690     JNB FLAGS1 . 1 , CALC_NEW_WAIT_PER_STARTUP_DONE 
                      5691     
0A0F    7F03          5692     MOV R7 , # 3 
0A11    412F          5693     	AJMP	CALC_NEW_WAIT_PER_DEMAG_DONE
                      5694     
                      5695     CALC_NEW_WAIT_PER_STARTUP_DONE: 
0A13    7892          5696     MOV R0 , # PGM_COMM_TIMING 
0A15    E6            5697     MOV A , @ R0 
0A16    FF            5698     MOV R7 , A 
0A17    C3            5699     	CLR	C
0A18    E536          5700     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0A1A    9482          5701     	SUBB	A, #130
0A1C    4011          5702     	JC	CALC_NEW_WAIT_PER_DEMAG_DONE
                      5703     
0A1E    0F            5704     INC R7 
                      5705     
0A1F    C3            5706     	CLR	C
0A20    E536          5707     	MOV	A, DEMAG_DETECTED_METRIC
0A22    94A0          5708     	SUBB	A, #160
0A24    4001          5709     	JC	($+3)
                      5710     
0A26    0F            5711     INC R7 
                      5712     
0A27    C3            5713     	CLR	C
0A28    EF            5714     MOV A , R7 
0A29    9406          5715     	SUBB	A, #6
0A2B    4002          5716     	JC	($+4)
                      5717     
0A2D    7F05          5718     MOV R7 , # 5 
                      5719     
                      5720     CALC_NEW_WAIT_PER_DEMAG_DONE: 
                      5721     	; Set timing reduction
                      5722     IF MCU_48MHZ == 0
                               	MOV	TEMP7, #4
                               ELSE
0A2F    7E01          5725     MOV R6 , # 1 
                      5726     ENDIF
                      5727     	; Load current commutation timing
0A31    E53E          5728     	MOV	A, COMM_PERIOD4X_H		; Divide 4 times
0A33    C4            5729     	SWAP	A
0A34    540F          5730     	ANL	A, #00FH
0A36    F9            5731     MOV R1 , A 
0A37    E53E          5732     	MOV	A, COMM_PERIOD4X_H
0A39    C4            5733     	SWAP	A
0A3A    54F0          5734     	ANL	A, #0F0H
0A3C    F8            5735     MOV R0 , A 
0A3D    E53D          5736     	MOV	A, COMM_PERIOD4X_L
0A3F    C4            5737     	SWAP	A
0A40    540F          5738     	ANL	A, #00FH
0A42    28            5739     ADD A , R0 
0A43    F8            5740     MOV R0 , A 
                      5741     
0A44    C3            5742     	CLR	C
0A45    E8            5743     MOV A , R0 
0A46    9E            5744     SUBB A , R6 
0A47    FA            5745     MOV R2 , A 
0A48    E9            5746     MOV A , R1 
0A49    9400          5747     	SUBB	A, #0
0A4B    FB            5748     MOV R3 , A 
0A4C    4009          5749     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      5750     
0A4E    C3            5751     	CLR	C
0A4F    EA            5752     MOV A , R2 
0A50    9402          5753     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0A52    EB            5754     MOV A , R3 
0A53    9400          5755     	SUBB	A, #0
0A55    5004          5756     	JNC	CALC_NEW_WAIT_TIMES_EXIT	; Check that result is still above minumum
                      5757     
                      5758     LOAD_MIN_TIME: 
0A57    7A02          5759     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0A59    E4            5760     	CLR	A
0A5A    FB            5761     MOV R3 , A 
                      5762     
                      5763     CALC_NEW_WAIT_TIMES_EXIT: 	
0A5B    22            5764     	RET
                      5765     
                      5766     
                      5767     ; Fast calculation (Comm_Period4x_H less than 2)
                      5768     CALC_NEXT_COMM_TIMING_FAST: 			
                      5769     	; Calculate new commutation time
0A5C    AA3D          5770     MOV R2 , COMM_PERIOD4X_L 
0A5E    AB3E          5771     MOV R3 , COMM_PERIOD4X_H 
0A60    EB            5772     MOV A , R3 
0A61    C4            5773     	SWAP	A
0A62    FE            5774     MOV R6 , A 
0A63    EA            5775     MOV A , R2 
0A64    C4            5776     	SWAP A
0A65    540F          5777     	ANL	A, #0FH
0A67    4E            5778     ORL A , R6 
0A68    FC            5779     MOV R4 , A 
0A69    C3            5780     	CLR	C
0A6A    EA            5781     MOV A , R2 
0A6B    9C            5782     SUBB A , R4 
0A6C    FA            5783     MOV R2 , A 
0A6D    EB            5784     MOV A , R3 
0A6E    9400          5785     	SUBB	A, #0
0A70    FB            5786     MOV R3 , A 
0A71    C3            5787     	CLR	C
0A72    E8            5788     MOV A , R0 
0A73    13            5789     	RRC	A					; Divide by 2 2 times
0A74    C3            5790     	CLR	C
0A75    13            5791     	RRC	A
0A76    F8            5792     MOV R0 , A 
0A77    EA            5793     MOV A , R2 
0A78    28            5794     ADD A , R0 
0A79    FA            5795     MOV R2 , A 
0A7A    EB            5796     MOV A , R3 
0A7B    3400          5797     	ADDC	A, #0
0A7D    FB            5798     MOV R3 , A 
0A7E    8A3D          5799     MOV COMM_PERIOD4X_L , R2 
0A80    8B3E          5800     MOV COMM_PERIOD4X_H , R3 
0A82    C3            5801     	CLR	C
0A83    EB            5802     MOV A , R3 
0A84    9402          5803     	SUBB	A, #2
0A86    4002          5804     	JC	($+4)
                      5805     
0A88    C267          5806     CLR FLAGS0 . 7 
                      5807     	
                      5808     IF MCU_48MHZ == 0
                               	MOV	TEMP1, #4				; Set timing reduction
                               ELSE
0A8A    7801          5811     MOV R0 , # 1 
                      5812     ENDIF
0A8C    EB            5813     MOV A , R3 
0A8D    C4            5814     	SWAP	A
0A8E    FE            5815     MOV R6 , A 
0A8F    7B00          5816     MOV R3 , # 0 
0A91    EA            5817     MOV A , R2 
0A92    C4            5818     	SWAP A
0A93    540F          5819     	ANL	A, #0FH
0A95    4E            5820     ORL A , R6 
0A96    FA            5821     MOV R2 , A 
0A97    C3            5822     	CLR	C
0A98    EA            5823     MOV A , R2 
0A99    98            5824     SUBB A , R0 
0A9A    FA            5825     MOV R2 , A 
0A9B    4005          5826     	JC	LOAD_MIN_TIME_FAST		; Check that result is still positive
                      5827     
0A9D    C3            5828     	CLR	C
0A9E    9402          5829     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0AA0    5002          5830     	JNC	CALC_NEW_WAIT_TIMES_FAST_DONE	; Check that result is still above minumum
                      5831     
                      5832     LOAD_MIN_TIME_FAST: 
0AA2    7A02          5833     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
                      5834     
                      5835     CALC_NEW_WAIT_TIMES_FAST_DONE: 	
0AA4    7892          5836     MOV R0 , # PGM_COMM_TIMING 
0AA6    E6            5837     MOV A , @ R0 
0AA7    FF            5838     MOV R7 , A 
0AA8    22            5839     	RET
                      5840     
                      5841     
                      5842     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5843     ;
                      5844     ; Wait advance timing routine
                      5845     ;
                      5846     ; No assumptions
                      5847     ; NOTE: Be VERY careful if using temp registers. They are passed over this routine
                      5848     ;
                      5849     ; Waits for the advance timing to elapse and sets up the next zero cross wait
                      5850     ;
                      5851     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5852     WAIT_ADVANCE_TIMING: 	
0AA9    306002        5853     JNB FLAGS0 . 0 , ( $+5 ) 
0AAC    41A9          5854     	AJMP	WAIT_ADVANCE_TIMING
                      5855     
                      5856     	; Setup next wait time
0AAE    854F53        5857     	MOV	NEXT_WT_START_L, WT_ZC_TOUT_START_L
0AB1    855054        5858     	MOV	NEXT_WT_START_H, WT_ZC_TOUT_START_H
0AB4    D260          5859     SETB FLAGS0 . 0 
0AB6    43E680        5860     	ORL	EIE1, #80H	; Enable timer3 interrupts
0AB9    22            5861     	RET
                      5862     
                      5863     
                      5864     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5865     ;
                      5866     ; Calculate new wait times routine
                      5867     ;
                      5868     ; No assumptions
                      5869     ;
                      5870     ; Calculates new wait times
                      5871     ;
                      5872     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5873     CALC_NEW_WAIT_TIMES: 	
0ABA    C3            5874     	CLR	C
0ABB    E4            5875     	CLR	A
0ABC    9A            5876     SUBB A , R2 
0ABD    F8            5877     MOV R0 , A 
0ABE    E4            5878     	CLR	A
0ABF    9B            5879     SUBB A , R3 
0AC0    F9            5880     MOV R1 , A 
                      5881     IF MCU_48MHZ == 1
0AC1    C3            5882     	CLR	C
0AC2    E8            5883     MOV A , R0 
0AC3    33            5884     	RLC	A
0AC4    F8            5885     MOV R0 , A 
0AC5    E9            5886     MOV A , R1 
0AC6    33            5887     	RLC	A
0AC7    F9            5888     MOV R1 , A 
                      5889     ENDIF
0AC8    306702        5890     JNB FLAGS0 . 7 , ( $+5 ) 
0ACB    6149          5891     	AJMP	CALC_NEW_WAIT_TIMES_FAST
                      5892     
0ACD    E8            5893     MOV A , R0 
0ACE    FA            5894     MOV R2 , A 
0ACF    E9            5895     MOV A , R1 
0AD0    FB            5896     MOV R3 , A 
0AD1    D3            5897     	SETB	C					; Negative numbers - set carry
0AD2    E9            5898     MOV A , R1 
0AD3    13            5899     	RRC	A					; Divide by 2
0AD4    FD            5900     MOV R5 , A 
0AD5    E8            5901     MOV A , R0 
0AD6    13            5902     	RRC	A
0AD7    FC            5903     MOV R4 , A 
0AD8    884F          5904     MOV WT_ZC_TOUT_START_L , R0 
0ADA    8950          5905     MOV WT_ZC_TOUT_START_H , R1 
0ADC    C3            5906     	CLR	C
0ADD    EF            5907     MOV A , R7 
0ADE    9403          5908     	SUBB	A, #3				; Is timing normal?
0AE0    6037          5909     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      5910     
0AE2    EF            5911     MOV A , R7 
0AE3    20E00D        5912     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      5913     
0AE6    E8            5914     MOV A , R0 
0AE7    2C            5915     ADD A , R4 
0AE8    F8            5916     MOV R0 , A 
0AE9    E9            5917     MOV A , R1 
0AEA    3D            5918     ADDC A , R5 
0AEB    F9            5919     MOV R1 , A 
0AEC    EC            5920     MOV A , R4 
0AED    FA            5921     MOV R2 , A 
0AEE    ED            5922     MOV A , R5 
0AEF    FB            5923     MOV R3 , A 
0AF0    020B06        5924     	JMP	STORE_TIMES_UP_OR_DOWN
                      5925     
                      5926     ADJUST_TIMING_TWO_STEPS: 
0AF3    E8            5927     MOV A , R0 
0AF4    28            5928     ADD A , R0 
0AF5    F8            5929     MOV R0 , A 
0AF6    E9            5930     MOV A , R1 
0AF7    39            5931     ADDC A , R1 
0AF8    F9            5932     MOV R1 , A 
0AF9    C3            5933     	CLR	C
0AFA    E8            5934     MOV A , R0 
0AFB    2402          5935     	ADD	A, #(COMM_TIME_MIN SHL 1)
0AFD    F8            5936     MOV R0 , A 
0AFE    E9            5937     MOV A , R1 
0AFF    3400          5938     	ADDC	A, #0
0B01    F9            5939     MOV R1 , A 
0B02    7AFE          5940     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
0B04    7BFF          5941     MOV R3 , # 0FFH 
                      5942     
                      5943     STORE_TIMES_UP_OR_DOWN: 
0B06    C3            5944     	CLR	C
0B07    EF            5945     MOV A , R7 
0B08    9403          5946     	SUBB	A, #3					; Is timing higher than normal?
0B0A    400D          5947     	JC	STORE_TIMES_DECREASE		; No - branch
                      5948     
                      5949     STORE_TIMES_INCREASE: 
0B0C    8A51          5950     MOV WT_COMM_START_L , R2 
0B0E    8B52          5951     MOV WT_COMM_START_H , R3 
0B10    884B          5952     MOV WT_ADV_START_L , R0 
0B12    894C          5953     MOV WT_ADV_START_H , R1 
0B14    8C4D          5954     MOV WT_ZC_SCAN_START_L , R4 
0B16    8D4E          5955     MOV WT_ZC_SCAN_START_H , R5 
0B18    22            5956     	RET
                      5957     
                      5958     STORE_TIMES_DECREASE: 
0B19    8851          5959     MOV WT_COMM_START_L , R0 
0B1B    8952          5960     MOV WT_COMM_START_H , R1 
0B1D    8A4B          5961     MOV WT_ADV_START_L , R2 
0B1F    8B4C          5962     MOV WT_ADV_START_H , R3 
0B21    8C4D          5963     MOV WT_ZC_SCAN_START_L , R4 
0B23    8D4E          5964     MOV WT_ZC_SCAN_START_H , R5 
0B25    306920        5965     JNB FLAGS1 . 1 , STORE_TIMES_EXIT 
                      5966     
0B28    C3            5967     	CLR	C
0B29    E533          5968     	MOV	A, STARTUP_CNT			
0B2B    9403          5969     	SUBB	A, #3
0B2D    4019          5970     	JC	STORE_TIMES_EXIT
                      5971     
0B2F    E53F          5972     	MOV	A, COMM_DIFF			; Compensate commutation wait for comparator offset
0B31    A2E7          5973     	MOV	C, ACC.7
0B33    13            5974     	RRC	A
0B34    F8            5975     MOV R0 , A 
0B35    E552          5976     	MOV	A, WT_COMM_START_H
0B37    F4            5977     	CPL	A
0B38    2401          5978     	ADD	A, #1
0B3A    38            5979     ADDC A , R0 
0B3B    400B          5980     	JC	STORE_TIMES_EXIT
0B3D    20E708        5981     	JB	ACC.7, STORE_TIMES_EXIT
                      5982     
0B40    7551FF        5983     	MOV	WT_COMM_START_L, #0FFH
0B43    F4            5984     	CPL	A
0B44    2401          5985     	ADD	A, #1
0B46    F552          5986     	MOV	WT_COMM_START_H, A 
                      5987     
                      5988     STORE_TIMES_EXIT: 
0B48    22            5989     	RET
                      5990     
                      5991     
                      5992     CALC_NEW_WAIT_TIMES_FAST: 	
0B49    E8            5993     MOV A , R0 
0B4A    FA            5994     MOV R2 , A 
0B4B    D3            5995     	SETB	C					; Negative numbers - set carry
0B4C    E8            5996     MOV A , R0 
0B4D    13            5997     	RRC	A
0B4E    FC            5998     MOV R4 , A 
0B4F    884F          5999     MOV WT_ZC_TOUT_START_L , R0 
0B51    C3            6000     	CLR	C
0B52    EF            6001     MOV A , R7 
0B53    9403          6002     	SUBB	A, #3				; Is timing normal?
0B55    601F          6003     	JZ	STORE_TIMES_DECREASE_FAST; Yes - branch
                      6004     
0B57    EF            6005     MOV A , R7 
0B58    20E007        6006     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS_FAST	; If an odd number - branch
                      6007     
0B5B    E8            6008     MOV A , R0 
0B5C    2C            6009     ADD A , R4 
0B5D    F8            6010     MOV R0 , A 
0B5E    EC            6011     MOV A , R4 
0B5F    FA            6012     MOV R2 , A 
0B60    6169          6013     	AJMP	STORE_TIMES_UP_OR_DOWN_FAST
                      6014     
                      6015     ADJUST_TIMING_TWO_STEPS_FAST: 
0B62    E8            6016     MOV A , R0 
0B63    28            6017     ADD A , R0 
0B64    2402          6018     	ADD	A, #(COMM_TIME_MIN SHL 1)
0B66    F8            6019     MOV R0 , A 
0B67    7AFE          6020     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
                      6021     
                      6022     STORE_TIMES_UP_OR_DOWN_FAST: 
0B69    C3            6023     	CLR	C
0B6A    EF            6024     MOV A , R7 
0B6B    9403          6025     	SUBB	A, #3				; Is timing higher than normal?
0B6D    4007          6026     	JC	STORE_TIMES_DECREASE_FAST; No - branch
                      6027     
                      6028     STORE_TIMES_INCREASE_FAST: 
0B6F    8A51          6029     MOV WT_COMM_START_L , R2 
0B71    884B          6030     MOV WT_ADV_START_L , R0 
0B73    8C4D          6031     MOV WT_ZC_SCAN_START_L , R4 
0B75    22            6032     	RET
                      6033     
                      6034     STORE_TIMES_DECREASE_FAST: 
0B76    8851          6035     MOV WT_COMM_START_L , R0 
0B78    8A4B          6036     MOV WT_ADV_START_L , R2 
0B7A    8C4D          6037     MOV WT_ZC_SCAN_START_L , R4 
0B7C    22            6038     	RET
                      6039     
                      6040     
                      6041     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6042     ;
                      6043     ; Wait before zero cross scan routine
                      6044     ;
                      6045     ; No assumptions
                      6046     ;
                      6047     ; Waits for the zero cross scan wait time to elapse
                      6048     ; Also sets up timer 3 for the zero cross scan timeout time
                      6049     ;
                      6050     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6051     WAIT_BEFORE_ZC_SCAN: 	
                      6052     	; Calculate random number
0B7D    E568          6053     	MOV	A, RANDOM
0B7F    C3            6054     	CLR	C
0B80    33            6055     	RLC	A
0B81    5002          6056     	JNC	WAIT_BEFORE_ZC_SCAN_RAND
                      6057     
0B83    646B          6058     	XRL	A, #06BH		; Sequence length of 35, when initialized to 1
                      6059     
                      6060     WAIT_BEFORE_ZC_SCAN_RAND:           
0B85    F568          6061     	MOV	RANDOM, A
                      6062     
                      6063     WAIT_BEFORE_ZC_SCAN_WAIT:           
0B87    306002        6064     JNB FLAGS0 . 0 , ( $+5 ) 
0B8A    6187          6065     	AJMP	WAIT_BEFORE_ZC_SCAN_WAIT
                      6066     
0B8C    D260          6067     SETB FLAGS0 . 0 
0B8E    43E680        6068     	ORL	EIE1, #80H			; Enable timer3 interrupts
0B91    E52D          6069     	MOV	A, FLAGS1
0B93    5406          6070     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0B95    6029          6071     	JZ	WAIT_BEFORE_ZC_SCAN_EXIT		
                      6072     
0B97    A83D          6073     MOV R0 , COMM_PERIOD4X_L 
0B99    A93E          6074     MOV R1 , COMM_PERIOD4X_H 
0B9B    C3            6075     	CLR	C
0B9C    E9            6076     MOV A , R1 
0B9D    13            6077     	RRC	A
0B9E    F9            6078     MOV R1 , A 
0B9F    E8            6079     MOV A , R0 
0BA0    13            6080     	RRC	A
0BA1    F8            6081     MOV R0 , A 
                      6082     IF MCU_48MHZ == 1
0BA2    C3            6083     	CLR	C
0BA3    E8            6084     MOV A , R0 
0BA4    33            6085     	RLC	A
0BA5    F8            6086     MOV R0 , A 
0BA6    E9            6087     MOV A , R1 
0BA7    33            6088     	RLC	A
0BA8    F9            6089     MOV R1 , A 
                      6090     ENDIF
0BA9    53E67F        6091     	ANL	EIE1, #7FH			; Disable timer3 interrupts
0BAC    759100        6092     	MOV	TMR3CN, #00H			; Timer3 disabled and interrupt flag cleared
0BAF    C3            6093     	CLR	C
0BB0    E4            6094     	CLR	A
0BB1    98            6095     SUBB A , R0 
0BB2    F594          6096     	MOV	TMR3L, A
0BB4    E4            6097     	CLR	A
0BB5    99            6098     SUBB A , R1 
0BB6    F595          6099     	MOV	TMR3H, A
0BB8    759104        6100     	MOV	TMR3CN, #04H			; Timer3 enabled and interrupt flag cleared
                      6101     
0BBB    D260          6102     SETB FLAGS0 . 0 
0BBD    43E680        6103     	ORL	EIE1, #80H			; Enable timer3 interrupts
                      6104     
                      6105     WAIT_BEFORE_ZC_SCAN_EXIT:           
0BC0    22            6106     	RET
                      6107     
                      6108     
                      6109     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6110     ;
                      6111     ; Wait for comparator to go low/high routines
                      6112     ;
                      6113     ; No assumptions
                      6114     ;
                      6115     ; Waits for the zero cross scan wait time to elapse
                      6116     ; Then scans for comparator going low/high
                      6117     ;
                      6118     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6119     WAIT_FOR_COMP_OUT_LOW: 
0BC1    D265          6120     SETB FLAGS0 . 5 
0BC3    754100        6121     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0BC6    752000        6122     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0BC9    306B03        6123     JNB FLAGS1 . 3 , ( $+6 ) 
0BCC    752040        6124     	MOV	BIT_ACCESS, #40H		
0BCF    020BE0        6125     	JMP	WAIT_FOR_COMP_OUT_START
                      6126     
                      6127     WAIT_FOR_COMP_OUT_HIGH: 
0BD2    D265          6128     SETB FLAGS0 . 5 
0BD4    754100        6129     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0BD7    752040        6130     	MOV	BIT_ACCESS, #40H			; Desired comparator output
0BDA    306B03        6131     JNB FLAGS1 . 3 , ( $+6 ) 
0BDD    752000        6132     	MOV	BIT_ACCESS, #00H		
                      6133     
                      6134     WAIT_FOR_COMP_OUT_START: 
0BE0    D2AF          6135     	SETB	EA						; Enable interrupts
                      6136     	; Set number of comparator readings
0BE2    7801          6137     MOV R0 , # 1 
0BE4    206722        6138     JB FLAGS0 . 7 , COMP_WAIT_ON_COMP_ABLE 
                      6139     
0BE7    E52D          6140     	MOV	A, FLAGS1					; Clear demag detected flag if start phases
0BE9    5406          6141     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0BEB    6002          6142     	JZ	($+4)
                      6143     		
0BED    C265          6144     CLR FLAGS0 . 5 
                      6145     
0BEF    C3            6146     	CLR	C						; Set number of readings higher for lower speeds
0BF0    E53E          6147     	MOV 	A, COMM_PERIOD4X_H			
0BF2    9405          6148     	SUBB	A, #05H
0BF4    4013          6149     	JC	COMP_WAIT_ON_COMP_ABLE
                      6150     
0BF6    7802          6151     MOV R0 , # 2 
                      6152     
0BF8    9405          6153     	SUBB	A, #05H
0BFA    4008          6154     	JC	COMP_WAIT_NO_OF_READINGS
                      6155     
0BFC    7803          6156     MOV R0 , # 3 
                      6157     
0BFE    9405          6158     	SUBB	A, #05H					; Set number of consecutive readings higher for lower speeds
0C00    4002          6159     	JC	COMP_WAIT_NO_OF_READINGS
                      6160     
0C02    7806          6161     MOV R0 , # 6 
                      6162     
                      6163     COMP_WAIT_NO_OF_READINGS: 
0C04    306902        6164     JNB FLAGS1 . 1 , ( $+5 ) 
0C07    780A          6165     MOV R0 , # 10 
                      6166     
                      6167     COMP_WAIT_ON_COMP_ABLE: 
0C09    206009        6168     JB FLAGS0 . 0 , COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT 
                      6169     
0C0C    E541          6170     	MOV	A, COMPARATOR_READ_CNT			; Check that comparator has been read
0C0E    6005          6171     	JZ	COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT	; If not read - branch
                      6172     
0C10    D2AF          6173     	SETB	EA							; Enable interrupts
0C12    D26C          6174     SETB FLAGS1 . 4 
0C14    22            6175     	RET								; Yes - return
                      6176     
                      6177     
                      6178     COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT: 
0C15    D2AF          6179     	SETB	EA							; Enable interrupts
0C17    00            6180     	NOP								; Allocate only just enough time to capture interrupt
0C18    00            6181     	NOP
0C19    C2AF          6182     	CLR	EA							; Disable interrupts
0C1B    20672A        6183     JB FLAGS0 . 7 , COMP_WAIT_READ_COMP 
                      6184     
0C1E    E53E          6185     	MOV	A, COMM_PERIOD4X_H				; Reduce required distance to pwm transition for higher speeds
0C20    C3            6186     	CLR	C
0C21    FB            6187     MOV R3 , A 
0C22    940F          6188     	SUBB	A, #0FH
0C24    4002          6189     	JC	($+4)
                      6190     
0C26    7B0F          6191     MOV R3 , # 0FH 
                      6192     
0C28    EB            6193     MOV A , R3 
0C29    2405          6194     	ADD	A, #5
0C2B    307301        6195     JNB FLAGS2 . 3 , ( $+4 ) 
                      6196     
0C2E    23            6197     	RL	A
                      6198     
0C2F    306A02        6199     JNB FLAGS1 . 2 , ( $+5 ) 
0C32    7428          6200     	MOV	A, #40
                      6201     
0C34    206201        6202     JB FLAGS0 . 2 , ( $+4 ) 
                      6203     
0C37    23            6204     	RL	A
                      6205     
0C38    F9            6206     MOV R1 , A 
0C39    306902        6207     JNB FLAGS1 . 1 , ( $+5 ) 
0C3C    7982          6208     MOV R1 , # 130 
                      6209     
                      6210     IF MCU_48MHZ == 0
                               	MOV	A, TL1
                               ELSE
0C3E    E58D          6213     	MOV	A, TH1
0C40    13            6214     	RRC	A
0C41    E58B          6215     	MOV	A, TL1
0C43    13            6216     	RRC	A
                      6217     ENDIF
0C44    C3            6218     	CLR	C
0C45    99            6219     SUBB A , R1 
0C46    40C1          6220     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle
                      6221     
                      6222     COMP_WAIT_READ_COMP: 
0C48    0541          6223     	INC	COMPARATOR_READ_CNT			; Increment comparator read count
                      6224     	READ_COMP_OUT					; Read comparator output
0C4A    E59B          6224+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0C4C    F4            6224+1   CPL A 
0C4D    5440          6225     	ANL	A, #40H
0C4F    B52002        6226     	CJNE	A, BIT_ACCESS, COMP_READ_WRONG
0C52    81A1          6227     	AJMP	COMP_READ_OK
                      6228     	
                      6229     COMP_READ_WRONG: 
0C54    306914        6230     JNB FLAGS1 . 1 , COMP_READ_WRONG_NOT_STARTUP 
                      6231     
0C57    08            6232     INC R0 
0C58    C3            6233     	CLR	C
0C59    E8            6234     MOV A , R0 
0C5A    940A          6235     	SUBB	A, #10					; If above initial requirement - go back and restart
0C5C    4002          6236     	JC	($+4)
0C5E    61E0          6237     	AJMP	WAIT_FOR_COMP_OUT_START
                      6238     
0C60    C3            6239     	CLR	C
0C61    E533          6240     	MOV	A, STARTUP_CNT				; For the first commutations - go back and restart
0C63    9406          6241     	SUBB	A, #6
0C65    5002          6242     	JNC	($+4)
0C67    61E0          6243     	AJMP	WAIT_FOR_COMP_OUT_START
                      6244     
0C69    8109          6245     	AJMP	COMP_WAIT_ON_COMP_ABLE		; If below initial requirement - continue to look for good ones
                      6246     
                      6247     COMP_READ_WRONG_NOT_STARTUP: 
0C6B    206502        6248     JB FLAGS0 . 5 , ( $+5 ) 
0C6E    61E0          6249     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct, and timeout already extended - go back and restart
                      6250     
0C70    C265          6251     CLR FLAGS0 . 5 
0C72    53E67F        6252     	ANL	EIE1, #7FH				; Disable timer3 interrupts
0C75    759100        6253     	MOV	TMR3CN, #00H				; Timer3 disabled and interrupt flag cleared
0C78    306710        6254     JNB FLAGS0 . 7 , COMP_READ_WRONG_LOW_RPM 
                      6255     
0C7B    759400        6256     	MOV	TMR3L, #00H				; Set timeout to 256us
                      6257     IF MCU_48MHZ == 1
0C7E    7595FC        6258     	MOV	TMR3H, #0FCH
                      6259     ELSE
                               	MOV	TMR3H, #0FEH
                               ENDIF
                      6262     COMP_READ_WRONG_TIMEOUT_SET: 
0C81    759104        6263     	MOV	TMR3CN, #04H				; Timer3 enabled and interrupt flag cleared
0C84    D260          6264     SETB FLAGS0 . 0 
0C86    43E680        6265     	ORL	EIE1, #80H				; Enable timer3 interrupts
0C89    61E0          6266     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      6267     
                      6268     COMP_READ_WRONG_LOW_RPM: 
0C8B    AE3D          6269     MOV R6 , COMM_PERIOD4X_L 
0C8D    AF3E          6270     MOV R7 , COMM_PERIOD4X_H 
                      6271     IF MCU_48MHZ == 1
0C8F    C3            6272     	CLR	C
0C90    EE            6273     MOV A , R6 
0C91    33            6274     	RLC	A
0C92    FE            6275     MOV R6 , A 
0C93    EF            6276     MOV A , R7 
0C94    33            6277     	RLC	A
0C95    FF            6278     MOV R7 , A 
                      6279     ENDIF
0C96    C3            6280     	CLR	C
0C97    E4            6281     	CLR	A
0C98    9E            6282     SUBB A , R6 
0C99    F594          6283     	MOV	TMR3L, A
0C9B    E4            6284     	CLR	A
0C9C    9F            6285     SUBB A , R7 
0C9D    F595          6286     	MOV	TMR3H, A
0C9F    8181          6287     	AJMP	COMP_READ_WRONG_TIMEOUT_SET
                      6288     
                      6289     COMP_READ_OK: 
0CA1    C3            6290     	CLR	C
0CA2    E533          6291     	MOV	A, STARTUP_CNT				; Force a timeout for the first commutations			
0CA4    9402          6292     	SUBB	A, #2
0CA6    5002          6293     	JNC	($+4)
0CA8    61E0          6294     	AJMP	WAIT_FOR_COMP_OUT_START
                      6295     
0CAA    306502        6296     JNB FLAGS0 . 5 , ( $+5 ) 
0CAD    61E0          6297     	AJMP	WAIT_FOR_COMP_OUT_START
                      6298     
0CAF    D802          6299     DJNZ R0 , COMP_READ_OK_JMP 
0CB1    81B5          6300     	AJMP	($+4)
                      6301     
                      6302     COMP_READ_OK_JMP: 
0CB3    8109          6303     	AJMP	COMP_WAIT_ON_COMP_ABLE	
                      6304     
0CB5    C26C          6305     CLR FLAGS1 . 4 
0CB7    22            6306     	RET							
                      6307     
                      6308     
                      6309     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6310     ;
                      6311     ; Evaluate comparator integrity
                      6312     ;
                      6313     ; No assumptions
                      6314     ;
                      6315     ; Checks comparator signal behaviour versus expected behaviour
                      6316     ;
                      6317     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6318     EVALUATE_COMPARATOR_INTEGRITY: 
0CB8    E52D          6319     	MOV	A, FLAGS1
0CBA    5406          6320     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0CBC    6008          6321     	JZ	EVAL_COMP_CHECK_TIMEOUT
                      6322     
0CBE    206A02        6323     JB FLAGS1 . 2 , ( $+5 ) 
0CC1    0533          6324     	INC	STARTUP_CNT					; Increment counter
0CC3    020CD6        6325     	JMP	EVAL_COMP_EXIT
                      6326     
                      6327     EVAL_COMP_CHECK_TIMEOUT: 
0CC6    306C0D        6328     JNB FLAGS1 . 4 , EVAL_COMP_EXIT 
0CC9    206B0A        6329     JB FLAGS1 . 3 , EVAL_COMP_EXIT 
0CCC    206507        6330     JB FLAGS0 . 5 , EVAL_COMP_EXIT 
0CCF    1581          6331     	DEC	SP								; Routine exit without "ret" command
0CD1    1581          6332     	DEC	SP
0CD3    0215DA        6333     	LJMP	RUN_TO_WAIT_FOR_POWER_ON_FAIL			; Yes - exit run mode
                      6334     
                      6335     EVAL_COMP_EXIT: 
0CD6    22            6336     	RET
                      6337     
                      6338     
                      6339     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6340     ;
                      6341     ; Setup commutation timing routine
                      6342     ;
                      6343     ; No assumptions
                      6344     ;
                      6345     ; Sets up and starts wait from commutation to zero cross
                      6346     ;
                      6347     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6348     SETUP_COMM_WAIT:  
0CD7    53E67F        6349     	ANL	EIE1, #7FH		; Disable timer3 interrupts
0CDA    759100        6350     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
0CDD    855194        6351     	MOV	TMR3L, WT_COMM_START_L
0CE0    855295        6352     	MOV	TMR3H, WT_COMM_START_H
0CE3    759104        6353     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
                      6354     	; Setup next wait time
0CE6    854B53        6355     	MOV	NEXT_WT_START_L, WT_ADV_START_L
0CE9    854C54        6356     	MOV	NEXT_WT_START_H, WT_ADV_START_H
0CEC    D260          6357     SETB FLAGS0 . 0 
0CEE    43E680        6358     	ORL	EIE1, #80H		; Enable timer3 interrupts
0CF1    D2AF          6359     	SETB	EA				; Enable interrupts again
0CF3    22            6360     	RET
                      6361     
                      6362     
                      6363     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6364     ;
                      6365     ; Wait for commutation routine
                      6366     ;
                      6367     ; No assumptions
                      6368     ;
                      6369     ; Waits from zero cross to commutation 
                      6370     ;
                      6371     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6372     WAIT_FOR_COMM:  
                      6373     	; Update demag metric
0CF4    7800          6374     MOV R0 , # 0 
0CF6    306405        6375     JNB FLAGS0 . 4 , ( $+8 ) 
0CF9    306502        6376     JNB FLAGS0 . 5 , ( $+5 ) 
                      6377     
0CFC    7801          6378     MOV R0 , # 1 
                      6379     
0CFE    E536          6380     	MOV	A, DEMAG_DETECTED_METRIC	; Sliding average of 8, 256 when demag and 0 when not. Limited to minimum 120
0D00    75F007        6381     	MOV	B, #7
0D03    A4            6382     	MUL	AB					; Multiply by 7
0D04    F9            6383     MOV R1 , A 
0D05    E5F0          6384     	MOV	A, B					; Add new value for current demag status
0D07    28            6385     ADD A , R0 
0D08    F5F0          6386     	MOV	B, A
0D0A    E9            6387     MOV A , R1 
0D0B    A2F0          6388     	MOV	C, B.0				; Divide by 8
0D0D    13            6389     	RRC	A					
0D0E    A2F1          6390     	MOV	C, B.1
0D10    13            6391     	RRC	A
0D11    A2F2          6392     	MOV	C, B.2
0D13    13            6393     	RRC	A
0D14    F536          6394     	MOV	DEMAG_DETECTED_METRIC, A
0D16    C3            6395     	CLR	C
0D17    9478          6396     	SUBB	A, #120				; Limit to minimum 120
0D19    5003          6397     	JNC	($+5)
                      6398     
0D1B    753678        6399     	MOV	DEMAG_DETECTED_METRIC, #120
                      6400     
0D1E    C3            6401     	CLR	C
0D1F    E536          6402     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0D21    9537          6403     	SUBB	A, DEMAG_PWR_OFF_THRESH
0D23    4008          6404     	JC	WAIT_FOR_COMM_WAIT		; Cut power if many consecutive demags. This will help retain sync during hard accelerations
                      6405     
0D25    D266          6406     SETB FLAGS0 . 6 
                      6407     	ALL_NFETS_OFF
0D27    C293          6407+1   CLR P1 . 3 
0D29    C297          6407+1   CLR P1 . 7 
0D2B    C294          6407+1   CLR P1 . 4 
                      6408     
                      6409     WAIT_FOR_COMM_WAIT: 
0D2D    306002        6410     JNB FLAGS0 . 0 , ( $+5 ) 
0D30    A12D          6411     	AJMP	WAIT_FOR_COMM_WAIT					
                      6412     
                      6413     	; Setup next wait time
0D32    854D53        6414     	MOV	NEXT_WT_START_L, WT_ZC_SCAN_START_L
0D35    854E54        6415     	MOV	NEXT_WT_START_H, WT_ZC_SCAN_START_H
0D38    D260          6416     SETB FLAGS0 . 0 
0D3A    43E680        6417     	ORL	EIE1, #80H			; Enable timer3 interrupts
0D3D    22            6418     	RET
                      6419     
                      6420     
                      6421     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6422     ;
                      6423     ; Commutation routines
                      6424     ;
                      6425     ; No assumptions
                      6426     ;
                      6427     ; Performs commutation switching 
                      6428     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      6429     ;
                      6430     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6431     ; Comm phase 1 to comm phase 2
                      6432     COMM1COMM2: 	
                      6433     	SET_RPM_OUT
0D3E    207D11        6434     JB FLAGS3 . 5 , COMM12_REV 
                      6435     
0D41    C2AF          6436     	CLR 	EA					; Disable all interrupts
0D43    754002        6437     	MOV	COMM_PHASE, #2
                      6438     	BPFET_OFF 				; Turn off pfet
0D46    C295          6438+1   CLR P1 . 5 
                      6439     	APFET_ON					; Turn on pfet
0D48    D292          6439+1   SETB P1 . 2 
0D4A    D2AF          6440     	SETB	EA
                      6441     	SET_COMP_PHASE_B 			; Set comparator phase
0D4C    759F80        6441+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0D4F    020F0D        6442     	JMP	COMM_EXIT
                      6443     
                      6444     COMM12_REV: 	
0D52    C2AF          6445     	CLR 	EA					; Disable all interrupts
0D54    754002        6446     	MOV	COMM_PHASE, #2
                      6447     	BPFET_OFF 				; Turn off pfet
0D57    C295          6447+1   CLR P1 . 5 
                      6448     	CPFET_ON					; Turn on pfet (reverse)
0D59    D296          6448+1   SETB P1 . 6 
0D5B    D2AF          6449     	SETB	EA
                      6450     	SET_COMP_PHASE_B 			; Set comparator phase
0D5D    759F80        6450+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0D60    020F0D        6451     	JMP	COMM_EXIT
                      6452     
                      6453     
                      6454     ; Comm phase 2 to comm phase 3
                      6455     COMM2COMM3: 	
                      6456     	CLEAR_RPM_OUT
0D63    307243        6457     JNB FLAGS2 . 2 , COMM23_NONDAMP 
                      6458     
                      6459     	; Comm2Comm3 Damped
0D66    207D20        6460     JB FLAGS3 . 5 , COMM23_DAMP_REV 
                      6461     
0D69    C2AF          6462     	CLR 	EA					; Disable all interrupts
0D6B    754003        6463     	MOV	COMM_PHASE, #3
0D6E    900189        6464     	MOV	DPTR, #PWM_BFET_DAMPED	
0D71    757B20        6465     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6466     	CNFET_OFF					; Turn off fets
0D74    C297          6466+1   CLR P1 . 7 
                      6467     	CPFET_OFF						
0D76    C296          6467+1   CLR P1 . 6 
0D78    306204        6468     JNB FLAGS0 . 2 , COMM23_NFET_OFF 
                      6469     	BNFET_ON					; Pwm on - turn on nfet
0D7B    D294          6469+1   SETB P1 . 4 
0D7D    A181          6470     	AJMP	COMM23_FETS_DONE
                      6471     COMM23_NFET_OFF: 
                      6472     	BPFET_ON					; Pwm off - switch damping fets	
0D7F    D295          6472+1   SETB P1 . 5 
                      6473     COMM23_FETS_DONE: 
0D81    D2AF          6474     	SETB	EA
                      6475     	SET_COMP_PHASE_C 			; Set comparator phase
0D83    759F89        6475+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0D86    020F0D        6476     	LJMP	COMM_EXIT
                      6477     
                      6478     	; Comm2Comm3 Damped reverse
                      6479     COMM23_DAMP_REV: 
0D89    C2AF          6480     	CLR 	EA					; Disable all interrupts
0D8B    754003        6481     	MOV	COMM_PHASE, #3
0D8E    900189        6482     	MOV	DPTR, #PWM_BFET_DAMPED	
0D91    757B20        6483     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6484     	ANFET_OFF					; Turn off fets (reverse)
0D94    C293          6484+1   CLR P1 . 3 
                      6485     	APFET_OFF						
0D96    C292          6485+1   CLR P1 . 2 
0D98    306204        6486     JNB FLAGS0 . 2 , COMM23_NFET_OFF_REV 
                      6487     	BNFET_ON					; Pwm on - turn on nfet
0D9B    D294          6487+1   SETB P1 . 4 
0D9D    A1A1          6488     	AJMP	COMM23_FETS_DONE_REV
                      6489     COMM23_NFET_OFF_REV: 
                      6490     	BPFET_ON					; Pwm off - switch damping fets	
0D9F    D295          6490+1   SETB P1 . 5 
                      6491     COMM23_FETS_DONE_REV: 
0DA1    D2AF          6492     	SETB	EA
                      6493     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0DA3    759F81        6493+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0DA6    020F0D        6494     	LJMP	COMM_EXIT
                      6495     
                      6496     	; Comm2Comm3 Non-damped
                      6497     COMM23_NONDAMP: 
0DA9    207D17        6498     JB FLAGS3 . 5 , COMM23_NONDAMP_REV 
                      6499     
0DAC    C2AF          6500     	CLR 	EA					; Disable all interrupts
0DAE    754003        6501     	MOV	COMM_PHASE, #3
0DB1    900164        6502     	MOV	DPTR, #PWM_BFET	
                      6503     	CNFET_OFF					; Turn off nfet
0DB4    C297          6503+1   CLR P1 . 7 
0DB6    306202        6504     JNB FLAGS0 . 2 , COMM23_NFET_DONE 
                      6505     	BNFET_ON					; Yes - turn on nfet
0DB9    D294          6505+1   SETB P1 . 4 
                      6506     COMM23_NFET_DONE: 
0DBB    D2AF          6507     	SETB	EA
                      6508     	SET_COMP_PHASE_C 			; Set comparator phase
0DBD    759F89        6508+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0DC0    020F0D        6509     	LJMP	COMM_EXIT
                      6510     
                      6511     	; Comm2Comm3 Non-damped reverse
                      6512     COMM23_NONDAMP_REV: 
0DC3    C2AF          6513     	CLR 	EA					; Disable all interrupts
0DC5    754003        6514     	MOV	COMM_PHASE, #3
0DC8    900164        6515     	MOV	DPTR, #PWM_BFET	
                      6516     	ANFET_OFF					; Turn off nfet (reverse)
0DCB    C293          6516+1   CLR P1 . 3 
0DCD    306202        6517     JNB FLAGS0 . 2 , COMM23_NFET_DONE_REV 
                      6518     	BNFET_ON					; Yes - turn on nfet
0DD0    D294          6518+1   SETB P1 . 4 
                      6519     COMM23_NFET_DONE_REV: 
0DD2    D2AF          6520     	SETB	EA
                      6521     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0DD4    759F81        6521+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0DD7    020F0D        6522     	LJMP	COMM_EXIT
                      6523     
                      6524     
                      6525     ; Comm phase 3 to comm phase 4
                      6526     COMM3COMM4: 	
                      6527     	SET_RPM_OUT
0DDA    207D11        6528     JB FLAGS3 . 5 , COMM34_REV 
                      6529     
0DDD    C2AF          6530     	CLR 	EA					; Disable all interrupts
0DDF    754004        6531     	MOV	COMM_PHASE, #4
                      6532     	APFET_OFF 				; Turn off pfet
0DE2    C292          6532+1   CLR P1 . 2 
                      6533     	CPFET_ON					; Turn on pfet
0DE4    D296          6533+1   SETB P1 . 6 
0DE6    D2AF          6534     	SETB	EA
                      6535     	SET_COMP_PHASE_A 			; Set comparator phase
0DE8    759F81        6535+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0DEB    020F0D        6536     	JMP	COMM_EXIT
                      6537     
                      6538     COMM34_REV: 	
0DEE    C2AF          6539     	CLR 	EA					; Disable all interrupts
0DF0    754004        6540     	MOV	COMM_PHASE, #4
                      6541     	CPFET_OFF 				; Turn off pfet (reverse)
0DF3    C296          6541+1   CLR P1 . 6 
                      6542     	APFET_ON					; Turn on pfet (reverse)
0DF5    D292          6542+1   SETB P1 . 2 
0DF7    D2AF          6543     	SETB	EA
                      6544     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0DF9    759F89        6544+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0DFC    020F0D        6545     	JMP	COMM_EXIT
                      6546     
                      6547     
                      6548     ; Comm phase 4 to comm phase 5
                      6549     COMM4COMM5: 	
                      6550     	CLEAR_RPM_OUT
0DFF    307243        6551     JNB FLAGS2 . 2 , COMM45_NONDAMP 
                      6552     
                      6553     	; Comm4Comm5 Damped
0E02    207D20        6554     JB FLAGS3 . 5 , COMM45_DAMP_REV 
                      6555     
0E05    C2AF          6556     	CLR 	EA					; Disable all interrupts
0E07    754005        6557     	MOV	COMM_PHASE, #5
0E0A    900178        6558     	MOV	DPTR, #PWM_AFET_DAMPED	
0E0D    757B04        6559     	MOV	DAMPINGFET, #(1 SHL APFET)
                      6560     	BNFET_OFF					; Turn off fets
0E10    C294          6560+1   CLR P1 . 4 
                      6561     	BPFET_OFF						
0E12    C295          6561+1   CLR P1 . 5 
0E14    306204        6562     JNB FLAGS0 . 2 , COMM45_NFET_OFF 
                      6563     	ANFET_ON					; Pwm on - turn on nfet
0E17    D293          6563+1   SETB P1 . 3 
0E19    C11D          6564     	AJMP	COMM45_FETS_DONE
                      6565     COMM45_NFET_OFF: 
                      6566     	APFET_ON					; Pwm off - switch damping fets	
0E1B    D292          6566+1   SETB P1 . 2 
                      6567     COMM45_FETS_DONE: 
0E1D    D2AF          6568     	SETB	EA
                      6569     	SET_COMP_PHASE_B 			; Set comparator phase
0E1F    759F80        6569+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E22    020F0D        6570     	LJMP	COMM_EXIT
                      6571     
                      6572     	; Comm4Comm5 Damped reverse
                      6573     COMM45_DAMP_REV: 
0E25    C2AF          6574     	CLR 	EA					; Disable all interrupts
0E27    754005        6575     	MOV	COMM_PHASE, #5
0E2A    90019A        6576     	MOV	DPTR, #PWM_CFET_DAMPED	; (reverse)
0E2D    757B40        6577     	MOV	DAMPINGFET, #(1 SHL CPFET)	; (reverse)
                      6578     	BNFET_OFF					; Turn off fets
0E30    C294          6578+1   CLR P1 . 4 
                      6579     	BPFET_OFF						
0E32    C295          6579+1   CLR P1 . 5 
0E34    306204        6580     JNB FLAGS0 . 2 , COMM45_NFET_OFF_REV 
                      6581     	CNFET_ON					; Pwm on - turn on nfet (reverse)
0E37    D297          6581+1   SETB P1 . 7 
0E39    C13D          6582     	AJMP	COMM45_FETS_DONE_REV
                      6583     COMM45_NFET_OFF_REV: 
                      6584     	CPFET_ON					; Pwm off - switch damping fets (reverse)	
0E3B    D296          6584+1   SETB P1 . 6 
                      6585     COMM45_FETS_DONE_REV: 
0E3D    D2AF          6586     	SETB	EA
                      6587     	SET_COMP_PHASE_B 			; Set comparator phase
0E3F    759F80        6587+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E42    020F0D        6588     	LJMP	COMM_EXIT
                      6589     
                      6590     	; Comm4Comm5 Non-damped
                      6591     COMM45_NONDAMP: 
0E45    207D17        6592     JB FLAGS3 . 5 , COMM45_NONDAMP_REV 
                      6593     
0E48    C2AF          6594     	CLR 	EA					; Disable all interrupts
0E4A    754005        6595     	MOV	COMM_PHASE, #5
0E4D    90015A        6596     	MOV	DPTR, #PWM_AFET	
                      6597     	BNFET_OFF					; Turn off nfet
0E50    C294          6597+1   CLR P1 . 4 
0E52    306202        6598     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      6599     	ANFET_ON					; Yes - turn on nfet
0E55    D293          6599+1   SETB P1 . 3 
                      6600     COMM45_NFET_DONE: 
0E57    D2AF          6601     	SETB	EA
                      6602     	SET_COMP_PHASE_B 			; Set comparator phase
0E59    759F80        6602+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E5C    020F0D        6603     	LJMP	COMM_EXIT
                      6604     
                      6605     	; Comm4Comm5 Non-damped reverse
                      6606     COMM45_NONDAMP_REV: 
0E5F    C2AF          6607     	CLR 	EA					; Disable all interrupts
0E61    754005        6608     	MOV	COMM_PHASE, #5
0E64    90016E        6609     	MOV	DPTR, #PWM_CFET		;  (reverse)
                      6610     	BNFET_OFF					; Turn off nfet
0E67    C294          6610+1   CLR P1 . 4 
0E69    3062EB        6611     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      6612     	CNFET_ON					; Yes - turn on nfet (reverse)
0E6C    D297          6612+1   SETB P1 . 7 
0E6E    D2AF          6613     	SETB	EA
                      6614     	SET_COMP_PHASE_B 			; Set comparator phase
0E70    759F80        6614+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E73    020F0D        6615     	LJMP	COMM_EXIT
                      6616     
                      6617     
                      6618     ; Comm phase 5 to comm phase 6
                      6619     COMM5COMM6: 	
                      6620     	SET_RPM_OUT
0E76    207D11        6621     JB FLAGS3 . 5 , COMM56_REV 
                      6622     
0E79    C2AF          6623     	CLR 	EA					; Disable all interrupts
0E7B    754006        6624     	MOV	COMM_PHASE, #6
                      6625     	CPFET_OFF 				; Turn off pfet
0E7E    C296          6625+1   CLR P1 . 6 
                      6626     	BPFET_ON					; Turn on pfet
0E80    D295          6626+1   SETB P1 . 5 
0E82    D2AF          6627     	SETB	EA
                      6628     	SET_COMP_PHASE_C 			; Set comparator phase
0E84    759F89        6628+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0E87    020F0D        6629     	JMP	COMM_EXIT
                      6630     
                      6631     COMM56_REV: 
0E8A    C2AF          6632     	CLR 	EA					; Disable all interrupts
0E8C    754006        6633     	MOV	COMM_PHASE, #6
                      6634     	APFET_OFF 				; Turn off pfet (reverse)
0E8F    C292          6634+1   CLR P1 . 2 
                      6635     	BPFET_ON					; Turn on pfet
0E91    D295          6635+1   SETB P1 . 5 
0E93    D2AF          6636     	SETB	EA
                      6637     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0E95    759F81        6637+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0E98    020F0D        6638     	JMP	COMM_EXIT
                      6639     
                      6640     
                      6641     ; Comm phase 6 to comm phase 1
                      6642     COMM6COMM1: 	
                      6643     	CLEAR_RPM_OUT
0E9B    307242        6644     JNB FLAGS2 . 2 , COMM61_NONDAMP 
                      6645     
                      6646     	; Comm6Comm1 Damped
0E9E    207D20        6647     JB FLAGS3 . 5 , COMM61_DAMP_REV 
                      6648     
0EA1    C2AF          6649     	CLR 	EA					; Disable all interrupts
0EA3    754001        6650     	MOV	COMM_PHASE, #1
0EA6    90019A        6651     	MOV	DPTR, #PWM_CFET_DAMPED	
0EA9    757B40        6652     	MOV	DAMPINGFET, #(1 SHL CPFET)
                      6653     	ANFET_OFF					; Turn off fets
0EAC    C293          6653+1   CLR P1 . 3 
                      6654     	APFET_OFF						
0EAE    C292          6654+1   CLR P1 . 2 
0EB0    306204        6655     JNB FLAGS0 . 2 , COMM61_NFET_OFF 
                      6656     	CNFET_ON					; Pwm on - turn on nfet
0EB3    D297          6656+1   SETB P1 . 7 
0EB5    C1B9          6657     	AJMP	COMM61_FETS_DONE
                      6658     COMM61_NFET_OFF: 
                      6659     	CPFET_ON					; Pwm off - switch damping fets	
0EB7    D296          6659+1   SETB P1 . 6 
                      6660     COMM61_FETS_DONE: 
0EB9    D2AF          6661     	SETB	EA
                      6662     	SET_COMP_PHASE_A 			; Set comparator phase
0EBB    759F81        6662+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0EBE    020F0D        6663     	LJMP	COMM_EXIT
                      6664     
                      6665     	; Comm6Comm1 Damped reverse
                      6666     COMM61_DAMP_REV: 
0EC1    C2AF          6667     	CLR 	EA					; Disable all interrupts
0EC3    754001        6668     	MOV	COMM_PHASE, #1
0EC6    900178        6669     	MOV	DPTR, #PWM_AFET_DAMPED	; (reverse)	
0EC9    757B04        6670     	MOV	DAMPINGFET, #(1 SHL APFET)	; (reverse)
                      6671     	CNFET_OFF					; Turn off fets (reverse)
0ECC    C297          6671+1   CLR P1 . 7 
                      6672     	CPFET_OFF						
0ECE    C296          6672+1   CLR P1 . 6 
0ED0    306204        6673     JNB FLAGS0 . 2 , COMM61_NFET_OFF_REV 
                      6674     	ANFET_ON					; Pwm on - turn on nfet
0ED3    D293          6674+1   SETB P1 . 3 
0ED5    C1D9          6675     	AJMP	COMM61_FETS_DONE_REV
                      6676     COMM61_NFET_OFF_REV: 
                      6677     	APFET_ON					; Pwm off - switch damping fets (reverse)	
0ED7    D292          6677+1   SETB P1 . 2 
                      6678     COMM61_FETS_DONE_REV: 
0ED9    D2AF          6679     	SETB	EA
                      6680     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0EDB    759F89        6680+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0EDE    E10D          6681     	AJMP	COMM_EXIT
                      6682     
                      6683     	; Comm6Comm1 Non-damped
                      6684     COMM61_NONDAMP: 
0EE0    207D16        6685     JB FLAGS3 . 5 , COMM61_NONDAMP_REV 
                      6686     
0EE3    C2AF          6687     	CLR 	EA					; Disable all interrupts
0EE5    754001        6688     	MOV	COMM_PHASE, #1
0EE8    90016E        6689     	MOV	DPTR, #PWM_CFET	
                      6690     	ANFET_OFF					; Turn off nfet
0EEB    C293          6690+1   CLR P1 . 3 
0EED    306202        6691     JNB FLAGS0 . 2 , COMM61_NFET_DONE 
                      6692     	CNFET_ON					; Yes - turn on nfet
0EF0    D297          6692+1   SETB P1 . 7 
                      6693     COMM61_NFET_DONE: 
0EF2    D2AF          6694     	SETB	EA
                      6695     	SET_COMP_PHASE_A 			; Set comparator phase
0EF4    759F81        6695+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0EF7    E10D          6696     	AJMP	COMM_EXIT
                      6697     
                      6698     	; Comm6Comm1 Non-damped reverse
                      6699     COMM61_NONDAMP_REV: 
0EF9    C2AF          6700     	CLR 	EA					; Disable all interrupts
0EFB    754001        6701     	MOV	COMM_PHASE, #1
0EFE    90015A        6702     	MOV	DPTR, #PWM_AFET		; (reverse)
                      6703     	CNFET_OFF					; Turn off nfet (reverse)
0F01    C297          6703+1   CLR P1 . 7 
0F03    306202        6704     JNB FLAGS0 . 2 , COMM61_NFET_DONE_REV 
                      6705     	ANFET_ON					; Yes - turn on nfet (reverse)
0F06    D293          6705+1   SETB P1 . 3 
                      6706     COMM61_NFET_DONE_REV: 
0F08    D2AF          6707     	SETB	EA
                      6708     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0F0A    759F89        6708+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
                      6709     
                      6710     COMM_EXIT: 
0F0D    C266          6711     CLR FLAGS0 . 6 
0F0F    22            6712     	RET
                      6713     
                      6714     
                      6715     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6716     ;
                      6717     ; Switch power off routine
                      6718     ;
                      6719     ; No assumptions
                      6720     ;
                      6721     ; Switches all fets off 
                      6722     ;
                      6723     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6724     SWITCH_POWER_OFF: 
0F10    900158        6725     	MOV	DPTR, #PWM_NOFET	; Set DPTR register to pwm_nofet		
0F13    757B00        6726     	MOV	DAMPINGFET, #0
                      6727     	ALL_NFETS_OFF			; Turn off all nfets
0F16    C293          6727+1   CLR P1 . 3 
0F18    C297          6727+1   CLR P1 . 7 
0F1A    C294          6727+1   CLR P1 . 4 
                      6728     	ALL_PFETS_OFF			; Turn off all pfets
0F1C    C292          6728+1   CLR P1 . 2 
0F1E    C296          6728+1   CLR P1 . 6 
0F20    C295          6728+1   CLR P1 . 5 
0F22    C262          6729     CLR FLAGS0 . 2 
0F24    22            6730     	RET			
                      6731     
                      6732     
                      6733     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6734     ;
                      6735     ; Set default parameters
                      6736     ;
                      6737     ; No assumptions
                      6738     ;
                      6739     ; Sets default programming parameters
                      6740     ;
                      6741     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6742     SET_DEFAULT_PARAMETERS: 
                      6743     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_SPOOLUP_TIME
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Pwm dither
                               ENDIF
                      6814     IF MODE == 1	; Tail
0F25    7880          6815     MOV R0 , # PGM_GOV_P_GAIN 
0F27    76FF          6816     MOV @ R0 , # 0FFH 
0F29    08            6817     INC R0 
0F2A    76FF          6818     MOV @ R0 , # 0FFH 
0F2C    08            6819     INC R0 
0F2D    76FF          6820     MOV @ R0 , # 0FFH 
0F2F    08            6821     INC R0 
0F30    76FF          6822     MOV @ R0 , # 0FFH 
0F32    08            6823     INC R0 
0F33    7603          6824     MOV @ R0 , # 3 
0F35    08            6825     INC R0 
0F36    7604          6826     MOV @ R0 , # 4 
0F38    08            6827     INC R0 
0F39    7609          6828     MOV @ R0 , # 9 
0F3B    08            6829     INC R0 
0F3C    7603          6830     MOV @ R0 , # 3 
0F3E    08            6831     INC R0 
0F3F    7601          6832     MOV @ R0 , # 1 
0F41    08            6833     INC R0 
0F42    7601          6834     MOV @ R0 , # 1 
                      6835     
0F44    788C          6836     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
0F46    7601          6837     MOV @ R0 , # 1 
0F48    08            6838     INC R0 
0F49    76FF          6839     MOV @ R0 , # 0FFH 
0F4B    08            6840     INC R0 
0F4C    76FF          6841     MOV @ R0 , # 0FFH 
0F4E    08            6842     INC R0 
0F4F    76FF          6843     MOV @ R0 , # 0FFH 
0F51    08            6844     INC R0 
0F52    76FF          6845     MOV @ R0 , # 0FFH 
0F54    08            6846     INC R0 
0F55    76FF          6847     MOV @ R0 , # 0FFH 
0F57    08            6848     INC R0 
0F58    7603          6849     MOV @ R0 , # 3 
0F5A    08            6850     INC R0 
0F5B    76FF          6851     MOV @ R0 , # 0FFH 
0F5D    08            6852     INC R0 
0F5E    76FF          6853     MOV @ R0 , # 0FFH 
0F60    08            6854     INC R0 
0F61    76FF          6855     MOV @ R0 , # 0FFH 
0F63    08            6856     INC R0 
0F64    7625          6857     MOV @ R0 , # 37 
0F66    08            6858     INC R0 
0F67    76D0          6859     MOV @ R0 , # 208 
0F69    08            6860     INC R0 
0F6A    76FA          6861     MOV @ R0 , # 250 
0F6C    08            6862     INC R0 
0F6D    76FA          6863     MOV @ R0 , # 250 
0F6F    08            6864     INC R0 
0F70    7604          6865     MOV @ R0 , # 4 
0F72    08            6866     INC R0 
0F73    76FF          6867     MOV @ R0 , # 0FFH 
0F75    08            6868     INC R0 
0F76    7601          6869     MOV @ R0 , # 1 
0F78    08            6870     INC R0 
0F79    7600          6871     MOV @ R0 , # 0 
0F7B    08            6872     INC R0 
0F7C    767A          6873     MOV @ R0 , # 122 
0F7E    08            6874     INC R0 
0F7F    76FF          6875     MOV @ R0 , # 0FFH 
0F81    08            6876     INC R0 
0F82    7601          6877     MOV @ R0 , # 1 
0F84    08            6878     INC R0 
0F85    7601          6879     MOV @ R0 , # 1 
0F87    08            6880     INC R0 
0F88    7600          6881     MOV @ R0 , # 0 
0F8A    08            6882     INC R0 
0F8B    7603          6883     MOV @ R0 , # 3 
                      6884     ENDIF
                      6885     IF MODE == 2	; Multi
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_PWM_DITHER
                               ENDIF
0F8D    22            6956     	RET
                      6957     
                      6958     
                      6959     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6960     ;
                      6961     ; Decode parameters
                      6962     ;
                      6963     ; No assumptions
                      6964     ;
                      6965     ; Decodes programming parameters
                      6966     ;
                      6967     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6968     DECODE_PARAMETERS: 
                      6969     	; Load programmed pwm frequency
0F8E    7887          6970     MOV R0 , # PGM_PWM_FREQ 
0F90    E6            6971     MOV A , @ R0 
0F91    FF            6972     MOV R7 , A 
0F92    C272          6973     CLR FLAGS2 . 2 
                      6974     IF DAMPED_MODE_ENABLE == 1
0F94    BF0302        6975     CJNE R7 , # 3 , ( $+5 ) 
0F97    D272          6976     SETB FLAGS2 . 2 
                      6977     ENDIF
                      6978     	; Load programmed direction
0F99    7888          6979     MOV R0 , # PGM_DIRECTION 
                      6980     IF MODE >= 1	; Tail or multi
0F9B    E6            6981     MOV A , @ R0 
0F9C    C3            6982     	CLR	C
0F9D    9403          6983     	SUBB	A, #3
0F9F    6008          6984     	JZ	DECODE_PARAMS_DIR_SET
                      6985     ENDIF
                      6986     
0FA1    C27D          6987     CLR FLAGS3 . 5 
0FA3    E6            6988     MOV A , @ R0 
0FA4    30E102        6989     	JNB	ACC.1, ($+5)
0FA7    D27D          6990     SETB FLAGS3 . 5 
                      6991     DECODE_PARAMS_DIR_SET: 
0FA9    C27E          6992     CLR FLAGS3 . 6 
0FAB    7889          6993     MOV R0 , # PGM_INPUT_POL 
0FAD    E6            6994     MOV A , @ R0 
0FAE    30E102        6995     	JNB	ACC.1, ($+5)
0FB1    D27E          6996     SETB FLAGS3 . 6 
0FB3    C3            6997     	CLR	C
0FB4    EF            6998     MOV A , R7 
0FB5    9402          6999     	SUBB	A, #2
0FB7    6008          7000     	JZ	DECODE_PWM_FREQ_LOW
                      7001     
0FB9    758E01        7002     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
0FBC    D273          7003     SETB FLAGS2 . 3 
0FBE    020FC6        7004     	JMP	DECODE_PWM_FREQ_END
                      7005     
                      7006     DECODE_PWM_FREQ_LOW: 
0FC1    758E00        7007     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
0FC4    C273          7008     CLR FLAGS2 . 3 
                      7009     
                      7010     DECODE_PWM_FREQ_END: 
0FC6    22            7011     	RET
                      7012     
                      7013     
                      7014     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7015     ;
                      7016     ; Decode settings
                      7017     ;
                      7018     ; No assumptions
                      7019     ;
                      7020     ; Decodes various settings
                      7021     ;
                      7022     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7023     DECODE_SETTINGS: 
                      7024     	; Decode governor gains
0FC7    7880          7025     MOV R0 , # PGM_GOV_P_GAIN 
0FC9    E6            7026     MOV A , @ R0 
0FCA    14            7027     	DEC	A	
0FCB    900080        7028     	MOV	DPTR, #GOV_GAIN_TABLE
0FCE    93            7029     	MOVC A, @A+DPTR	
0FCF    78A4          7030     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0FD1    F6            7031     MOV @ R0 , A 
0FD2    7881          7032     MOV R0 , # PGM_GOV_I_GAIN 
0FD4    E6            7033     MOV A , @ R0 
0FD5    14            7034     	DEC	A	
0FD6    900080        7035     	MOV	DPTR, #GOV_GAIN_TABLE
0FD9    93            7036     	MOVC A, @A+DPTR	
0FDA    78A5          7037     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0FDC    F6            7038     MOV @ R0 , A 
                      7039     	; Decode startup power
0FDD    7886          7040     MOV R0 , # PGM_STARTUP_PWR 
0FDF    E6            7041     MOV A , @ R0 
0FE0    14            7042     	DEC	A	
0FE1    90008D        7043     	MOV	DPTR, #STARTUP_POWER_TABLE
0FE4    93            7044     	MOVC A, @A+DPTR	
0FE5    78A6          7045     MOV R0 , # PGM_STARTUP_PWR_DECODED 
0FE7    F6            7046     MOV @ R0 , A 
                      7047     IF MODE == 0	; Main
                               	; Decode spoolup time
                               	MOV	TEMP1, #PGM_MAIN_SPOOLUP_TIME		
                               	MOV	A, @TEMP1
                               	MOV	TEMP1, A		; Store
                               	JNZ	($+3)		; If not zero - branch
                               	
                               	INC	TEMP1
                               
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #17		; Limit to 17 max
                               	JC	($+4)
                               
                               	MOV	TEMP1, #17
                               
                               	MOV	A, TEMP1
                               	ADD	A, TEMP1
                               	ADD	A, TEMP1		; Now 3x
                               	MOV	MAIN_SPOOLUP_TIME_3X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		; Now 10x
                               	MOV	MAIN_SPOOLUP_TIME_10X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		
                               	ADD	A, TEMP1		; Now 15x
                               	MOV	MAIN_SPOOLUP_TIME_15X, A
                               ENDIF
                      7076     	; Decode demag compensation
0FE8    789C          7077     MOV R0 , # PGM_DEMAG_COMP 
0FEA    E6            7078     MOV A , @ R0 
0FEB    7537FF        7079     	MOV	DEMAG_PWR_OFF_THRESH, #255	; Set default
0FEE    75380C        7080     	MOV	LOW_RPM_PWR_SLOPE, #12		; Set default
                      7081     
0FF1    B40206        7082     	CJNE	A, #2, DECODE_DEMAG_HIGH
                      7083     
0FF4    7537A0        7084     	MOV	DEMAG_PWR_OFF_THRESH, #160	; Settings for demag comp low
0FF7    75380A        7085     	MOV	LOW_RPM_PWR_SLOPE, #10		
                      7086     
                      7087     DECODE_DEMAG_HIGH: 
0FFA    B40306        7088     	CJNE	A, #3, DECODE_DEMAG_DONE
                      7089     
0FFD    753782        7090     	MOV	DEMAG_PWR_OFF_THRESH, #130	; Settings for demag comp high
1000    753805        7091     	MOV	LOW_RPM_PWR_SLOPE, #5		
                      7092     
                      7093     DECODE_DEMAG_DONE: 
                      7094     	; Decode pwm dither
1003    78A3          7095     MOV R0 , # PGM_PWM_DITHER 
1005    E6            7096     MOV A , @ R0 
1006    14            7097     	DEC	A	
1007    90009A        7098     	MOV	DPTR, #PWM_DITHER_TABLE
100A    93            7099     	MOVC A, @A+DPTR	
100B    F566          7100     	MOV	PWM_DITHER_DECODED, A
100D    120F10        7101     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1010    22            7102     	RET
                      7103     
                      7104     
                      7105     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7106     ;
                      7107     ; Set BEC voltage
                      7108     ;
                      7109     ; No assumptions
                      7110     ;
                      7111     ; Sets the BEC output voltage low or high
                      7112     ;
                      7113     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7114     SET_BEC_VOLTAGE: 
                      7115     	; Set bec voltage
                      7116     IF HIGH_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
                      7126     IF HIGH_BEC_VOLTAGE == 2
                               	SET_BEC_0				; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	CJNE	A, #1, SET_BEC_VOLTAGE_2	
                               
                               	SET_BEC_1				; Set to level 1
                               
                               SET_BEC_VOLTAGE_2:
                               	CJNE	A, #2, SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_2				; Set to level 2
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
1011    22            7141     	RET
                      7142     
                      7143     
                      7144     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7145     ;
                      7146     ; Find throttle gain
                      7147     ;
                      7148     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      7149     ;
                      7150     ; Finds throttle gain from throttle calibration values
                      7151     ;
                      7152     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7153     FIND_THROTTLE_GAIN: 
                      7154     	; Load programmed minimum and maximum throttle
1012    7896          7155     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1014    E6            7156     MOV A , @ R0 
1015    FA            7157     MOV R2 , A 
1016    7897          7158     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1018    E6            7159     MOV A , @ R0 
1019    FB            7160     MOV R3 , A 
101A    7888          7161     MOV R0 , # PGM_DIRECTION 
101C    E6            7162     MOV A , @ R0 
101D    B40305        7163     	CJNE	A, #3, FIND_THROTTLE_GAIN_CHECK_FULL
                      7164     
1020    C3            7165     	CLR	C
1021    EB            7166     MOV A , R3 
1022    940E          7167     	SUBB	A, #14				; Compensate for higher deadband in bidirectional
1024    FB            7168     MOV R3 , A 
                      7169     
                      7170     FIND_THROTTLE_GAIN_CHECK_FULL: 
                      7171     	; Check if full range is chosen
1025    307F04        7172     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      7173     
1028    7A00          7174     MOV R2 , # 0 
102A    7BFF          7175     MOV R3 , # 255 
                      7176     
                      7177     FIND_THROTTLE_GAIN_CALCULATE: 
                      7178     	; Calculate difference
102C    C3            7179     	CLR	C
102D    EB            7180     MOV A , R3 
102E    9A            7181     SUBB A , R2 
102F    FC            7182     MOV R4 , A 
                      7183     	; Check that difference is minimum 130
1030    C3            7184     	CLR	C
1031    9482          7185     	SUBB	A, #130
1033    5002          7186     	JNC	($+4)
                      7187     
1035    7C82          7188     MOV R4 , # 130 
                      7189     
                      7190     	; Find gain
1037    757200        7191     	MOV	PPM_THROTTLE_GAIN, #0
                      7192     TEST_THROTTLE_GAIN: 
103A    0572          7193     	INC	PPM_THROTTLE_GAIN
103C    EC            7194     MOV A , R4 
103D    8572F0        7195     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
1040    A4            7196     	MUL	AB
1041    C3            7197     	CLR	C
1042    E5F0          7198     	MOV	A, B
1044    947D          7199     	SUBB	A, #125
1046    40F2          7200     	JC	TEST_THROTTLE_GAIN
1048    22            7201     	RET
                      7202     
                      7203     
                      7204     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7205     ;
                      7206     ; Average throttle 
                      7207     ;
                      7208     ; Outputs result in Temp3
                      7209     ;
                      7210     ; Averages throttle calibration readings
                      7211     ;
                      7212     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7213     AVERAGE_THROTTLE: 
1049    D27F          7214     SETB FLAGS3 . 7 
104B    1112          7215     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
104D    12060B        7216     	CALL WAIT30MS		
1050    7A00          7217     MOV R2 , # 0 
1052    7B00          7218     MOV R3 , # 0 
1054    7C10          7219     MOV R4 , # 16 
                      7220     AVERAGE_THROTTLE_MEAS: 
1056    120601        7221     	CALL	WAIT3MS			; Wait for new RC pulse value
1059    E55C          7222     	MOV	A, NEW_RCP		; Get new RC pulse value
105B    2A            7223     ADD A , R2 
105C    FA            7224     MOV R2 , A 
105D    7400          7225     	MOV	A, #0
105F    3B            7226     ADDC A , R3 
1060    FB            7227     MOV R3 , A 
1061    DCF3          7228     DJNZ R4 , AVERAGE_THROTTLE_MEAS 
                      7229     
1063    7C04          7230     MOV R4 , # 4 
                      7231     AVERAGE_THROTTLE_DIV: 
1065    C3            7232     	CLR	C
1066    EB            7233     MOV A , R3 
1067    13            7234     	RRC	A      
1068    FB            7235     MOV R3 , A 
1069    EA            7236     MOV A , R2 
106A    13            7237     	RRC	A      
106B    FA            7238     MOV R2 , A 
106C    DCF7          7239     DJNZ R4 , AVERAGE_THROTTLE_DIV 
                      7240     
106E    FE            7241     MOV R6 , A 
106F    C27F          7242     CLR FLAGS3 . 7 
1071    1112          7243     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
1073    22            7244     	RET
                      7245     
                      7246     
                      7247     
                      7248     
                      7249     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7250     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7251     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7252     ;
                      7253     ; Main program start
                      7254     ;
                      7255     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7256     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7257     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7258     PGM_START: 
                      7259     	; Check flash lock byte
1074    E5EF          7260     	MOV	A, RSTSRC			
1076    20E603        7261     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      7262     
1079    752000        7263     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      7264     
107C    0520          7265     	INC	BIT_ACCESS
107E    903FFF        7266     MOV DPTR , # 16383 
1081    E520          7267     	MOV	A, BIT_ACCESS
1083    14            7268     	DEC	A
1084    6006          7269     	JZ	LOCK_BYTE_TEST
                      7270     
1086    901FFF        7271     MOV DPTR , # 8191 
1089    14            7272     	DEC	A
108A    6000          7273     	JZ	LOCK_BYTE_TEST
                      7274     
                      7275     LOCK_BYTE_TEST: 
108C    93            7276     	MOVC A, @A+DPTR		; Read lock byte
108D    04            7277     	INC	A				
108E    6003          7278     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      7279     
                      7280     IF ONE_S_CAPABLE == 0		
1090    75EF12        7281     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      7282     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      7285     
                      7286     LOCK_BYTE_OK: 
                      7287     	; Disable the WDT.
                      7288     IF SIGNATURE_001 == 0F3H		
1093    53D9BF        7289     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      7290     ENDIF
                      7291     IF SIGNATURE_001 == 0F8H		
                               	MOV	WDTCN, #0DEH		; Disable watchdog
                               	MOV	WDTCN, #0ADH		
                               ENDIF
                      7295     	; Initialize stack
1096    7581C0        7296     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      7297     	; Initialize VDD monitor
1099    43FF80        7298     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
109C    1205FC        7299     	CALL	WAIT1MS			; Wait at least 100us
                      7300     IF ONE_S_CAPABLE == 0		
109F    75EF02        7301     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      7302     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      7305     	; Set clock frequency
                      7306     IF SIGNATURE_001 == 0F3H		
10A2    43B203        7307     	ORL	OSCICN, #03H		; Set clock divider to 1 (not supported on 'f850)
                      7308     ENDIF
                      7309     IF SIGNATURE_001 == 0F8H		
                               	MOV	CLKSEL, #00H		; Set clock divider to 1 (not supported on 'f3xx)
                               ENDIF
10A5    E5B3          7312     	MOV	A, OSCICL				
10A7    2404          7313     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
10A9    20E70D        7314     	JB	ACC.7, RESET_CAL_DONE	; Is carry (7bit) set? - branch
                      7315     
10AC    F521          7316     	MOV	BIT_ACCESS_INT, A
                      7317     IF SIGNATURE_002 <> 010H		
10AE    E5E3          7318     	MOV	A, OSCLCN
                      7319     ELSE
                               	MOV	A, OSCXCN
                               ENDIF
10B0    20E006        7322     	JB	ACC.0, RESET_CAL_DONE	; Set if cal aleady done
                      7323     
10B3    8521B3        7324     	MOV	OSCICL, BIT_ACCESS_INT
                      7325     IF SIGNATURE_002 <> 010H		
10B6    43E301        7326     	ORL	OSCLCN, #01H			; Tag that cal is done
                      7327     ELSE
                               	ORL	OSCXCN, #01H			; Tag that cal is done
                               ENDIF
                      7330     
                      7331     RESET_CAL_DONE: 
                      7332     	; Switch power off
10B9    120F10        7333     	CALL	SWITCH_POWER_OFF
                      7334     	; Ports initialization
10BC    7580FF        7335     MOV P0 , # 255 
10BF    75A400        7336     MOV P0MDOUT , # 0 
10C2    75F1F0        7337     MOV P0MDIN , # -16 
10C5    75D4DF        7338     MOV P0SKIP , # -33 
10C8    759002        7339     MOV P1 , # 2 
10CB    75A5FC        7340     MOV P1MDOUT , # 252 
10CE    75F2FD        7341     MOV P1MDIN , # -3 
10D1    75D502        7342     MOV P1SKIP , # 2 
                      7343     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
10D4    75A610        7346     MOV P2MDOUT , # 16 
                      7347     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      7354     	; Initialize the XBAR and related functionality
                      7355     	INITIALIZE_XBAR
10D7    75A0FF        7355+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
10DA    75F3F1        7355+1   MOV P2MDIN , # -15 
10DD    75E241        7355+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      7356     	; Clear RAM
10E0    E4            7357     	CLR	A				; Clear accumulator
10E1    F8            7358     MOV R0 , A 
                      7359     CLEAR_RAM: 	
10E2    F6            7360     MOV @ R0 , A 
10E3    D8FD          7361     DJNZ R0 , CLEAR_RAM 
                      7362     	; Initialize LFSR
10E5    756801        7363     	MOV	RANDOM, #1
                      7364     	; Set default programmed parameters
10E8    120F25        7365     	CALL	SET_DEFAULT_PARAMETERS
                      7366     	; Read all programmed parameters
10EB    121625        7367     	CALL READ_ALL_EEPROM_PARAMETERS
                      7368     	; Set beep strength
10EE    7898          7369     MOV R0 , # PGM_BEEP_STRENGTH 
10F0    8673          7370     MOV BEEP_STRENGTH , @ R0 
                      7371     	; Set initial arm variable
10F2    753001        7372     	MOV	INITIAL_ARM, #1
                      7373     	; Initializing beep
10F5    C2AF          7374     	CLR	EA				; Disable interrupts explicitly
10F7    120615        7375     	CALL WAIT200MS	
10FA    120625        7376     	CALL BEEP_F1
10FD    12060B        7377     	CALL WAIT30MS
1100    12062C        7378     	CALL BEEP_F2
1103    12060B        7379     	CALL WAIT30MS
1106    120633        7380     	CALL BEEP_F3
1109    12060B        7381     	CALL WAIT30MS
                      7382     IF MODE <= 1	; Main or tail
                      7383     	; Wait for receiver to initialize
110C    12173E        7384     	CALL	WAIT1S
110F    120615        7385     	CALL	WAIT200MS
1112    120615        7386     	CALL	WAIT200MS
1115    120610        7387     	CALL	WAIT100MS
                      7388     ENDIF
                      7389     
                      7390     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7391     ;
                      7392     ; No signal entry point
                      7393     ;
                      7394     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7395     INIT_NO_SIGNAL: 
                      7396     	; Disable interrupts explicitly
1118    C2AF          7397     	CLR	EA				
                      7398     	; Check if input signal is high for more than 15ms
111A    78FA          7399     MOV R0 , # 250 
                      7400     INPUT_HIGH_CHECK_1: 
111C    79FA          7401     MOV R1 , # 250 
                      7402     INPUT_HIGH_CHECK_2: 
111E    308507        7403     JNB 128 . 5 , BOOTLOADER_DONE 
1121    D9FB          7404     DJNZ R1 , INPUT_HIGH_CHECK_2 
1123    D8F7          7405     DJNZ R0 , INPUT_HIGH_CHECK_1 
                      7406     
1125    021C00        7407     	LJMP	1C00H			; Jump to bootloader
                      7408     
                      7409     BOOTLOADER_DONE: 
                      7410     	; Decode parameters
1128    120F8E        7411     	CALL	DECODE_PARAMETERS
                      7412     	; Decode settings
112B    120FC7        7413     	CALL	DECODE_SETTINGS
                      7414     	; Set BEC voltage
112E    1111          7415     	CALL	SET_BEC_VOLTAGE
                      7416     	; Find throttle gain from stored min and max settings
1130    1112          7417     	CALL	FIND_THROTTLE_GAIN
                      7418     	; Set beep strength
1132    7898          7419     MOV R0 , # PGM_BEEP_STRENGTH 
1134    8673          7420     MOV BEEP_STRENGTH , @ R0 
                      7421     	; Switch power off
1136    120F10        7422     	CALL	SWITCH_POWER_OFF
                      7423     	; Set clock frequency
                      7424     IF MCU_48MHZ == 1
                      7425     	SET_MCU_CLK_24MHZ
1139    75B680        7425+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
113C    75A900        7425+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
113F    757A00        7425+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      7426     ENDIF
                      7427     	; Timer control
1142    758850        7428     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      7429     	; Timer mode
1145    758912        7430     	MOV	TMOD, #12H		; Timer0 as 8bit, timer1 as 16bit
                      7431     	; Timer2: clk/12 for 128us and 32ms interrupts
1148    75C824        7432     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      7433     	; Timer3: clk/12 for commutation timing
114B    759104        7434     	MOV	TMR3CN, #04H		; Timer3 enabled
                      7435     	; PCA
114E    75D840        7436     	MOV	PCA0CN, #40H		; PCA enabled
                      7437     	; Enable interrupts
1151    75A822        7438     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
1154    75B802        7439     	MOV	IP, #02H			; High priority to timer0 interrupts
1157    75E690        7440     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      7441     	; Initialize comparator
115A    759B80        7442     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
115D    759D00        7443     	MOV	CPT0MD, #00H		; Comparator response time 100ns
                      7444     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #00H		; Comparator response time 100ns
                               ENDIF
                      7448     	; Initialize ADC
                      7449     	INITIALIZE_ADC			; Initialize ADC operation
1160    75D10E        7449+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
                      7449+1   IF MCU_50MHZ ==0 
1163    75BC58        7449+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
                      7449+1   ELSE 
                               MOV ADC0CF , # 0C0H  ; ADC CLOCK 2MHZ
                               ENDIF 
1166    75BB09        7449+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
1169    75BA11        7449+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
116C    75E880        7449+1   MOV ADC0CN , # 80H  ; ADC ENABLED
116F    1205FC        7450     	CALL	WAIT1MS
1172    D2AF          7451     	SETB	EA				; Enable all interrupts
                      7452     	; Measure number of lipo cells
1174    1208B6        7453     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      7454     	; Initialize RC pulse
                      7455     	RCP_INT_FIRST 					; Enable interrupt and set to first edge
1177    53DACF        7455+1   ANL PCA0CPM0 , # 0CFH 
117A    207E03        7455+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
117D    43DA20        7455+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1180    307E03        7455+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1183    43DA10        7455+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7456     	RCP_INT_ENABLE		 			; Enable interrupt
1186    43DA01        7456+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      7457     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
1189    C2D8          7457+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
118B    C271          7458     CLR FLAGS2 . 1 
118D    120615        7459     	CALL WAIT200MS
                      7460     
                      7461     	; Measure PWM frequency
                      7462     MEASURE_PWM_FREQ_INIT: 	
1190    D261          7463     SETB FLAGS0 . 1 
1192    7B03          7464     MOV R3 , # 3 
                      7465     MEASURE_PWM_FREQ_START: 	
1194    7A0C          7466     MOV R2 , # 12 
                      7467     MEASURE_PWM_FREQ_LOOP: 	
                      7468     	; Check if period diff was accepted
1196    E55B          7469     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1198    7007          7470     	JNZ	MEASURE_PWM_FREQ_WAIT
                      7471     
119A    7A0C          7472     MOV R2 , # 12 
119C    DB03          7473     DJNZ R3 , ( $+5 ) 
119E    021118        7474     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      7475     
                      7476     MEASURE_PWM_FREQ_WAIT: 
11A1    12060B        7477     	CALL	WAIT30MS						; Wait 30ms for new pulse
11A4    207003        7478     JB FLAGS2 . 0 , ( $+6 ) 
11A7    021118        7479     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      7480     
11AA    C270          7481     CLR FLAGS2 . 0 
11AC    E55C          7482     	MOV	A, NEW_RCP					; Load value
11AE    C3            7483     	CLR	C
11AF    9402          7484     SUBB A , # 2 
11B1    40E1          7485     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      7486     
11B3    E52F          7487     	MOV	A, FLAGS3						; Check pwm frequency flags
11B5    541F          7488     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
11B7    855E5D        7489     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
11BA    F55E          7490     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
11BC    B55DD5        7491     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      7492     
11BF    DAD5          7493     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      7494     
                      7495     	; Clear measure pwm frequency flag
11C1    C261          7496     CLR FLAGS0 . 1 
                      7497     	; Set up RC pulse interrupts after pwm frequency measurement
                      7498     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
11C3    53DACF        7498+1   ANL PCA0CPM0 , # 0CFH 
11C6    207E03        7498+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
11C9    43DA20        7498+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
11CC    307E03        7498+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
11CF    43DA10        7498+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7499     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
11D2    C2D8          7499+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
11D4    C271          7500     CLR FLAGS2 . 1 
11D6    78A2          7501     MOV R0 , # PGM_ENABLE_PWM_INPUT 
11D8    E6            7502     MOV A , @ R0 
11D9    7008          7503     	JNZ	TEST_FOR_ONESHOT				; If it is - proceed
                      7504     
11DB    D274          7505     SETB FLAGS2 . 4 
11DD    E52F          7506     	MOV	A, FLAGS3						; Clear pwm frequency flags
11DF    54E0          7507     	ANL	A, #NOT((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
11E1    F52F          7508     	MOV	FLAGS3, A
                      7509     
                      7510     TEST_FOR_ONESHOT: 	
                      7511     	; Test whether signal is OneShot125
11E3    C275          7512     CLR FLAGS2 . 5 
11E5    752900        7513     	MOV	RCP_OUTSIDE_RANGE_CNT, #0		; Reset out of range counter
11E8    120610        7514     	CALL WAIT100MS						; Wait for new RC pulse
11EB    307409        7515     JNB FLAGS2 . 4 , VALIDATE_RCP_START 
                      7516     
11EE    C3            7517     	CLR	C
11EF    E529          7518     	MOV	A, RCP_OUTSIDE_RANGE_CNT			; Check how many pulses were outside normal PPM range (800-2160us)
11F1    940A          7519     	SUBB	A, #10						
11F3    4002          7520     	JC	VALIDATE_RCP_START
                      7521     
11F5    D275          7522     SETB FLAGS2 . 5 
                      7523     
                      7524     	; Validate RC pulse
                      7525     VALIDATE_RCP_START: 	
11F7    120601        7526     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
11FA    7802          7527     MOV R0 , # 2 
11FC    307402        7528     JNB FLAGS2 . 4 , ( $+5 ) 
                      7529     
11FF    7800          7530     MOV R0 , # 0 
                      7531     
1201    C3            7532     	CLR	C
1202    E55C          7533     	MOV	A, NEW_RCP					; Load value
1204    98            7534     SUBB A , R0 
1205    40F0          7535     	JC	VALIDATE_RCP_START				; No - start over
                      7536     
                      7537     	; Beep arm sequence start signal
1207    C2AF          7538     	CLR 	EA							; Disable all interrupts
1209    120625        7539     	CALL BEEP_F1						; Signal that RC pulse is ready
120C    120625        7540     	CALL BEEP_F1
120F    120625        7541     	CALL BEEP_F1
1212    D2AF          7542     	SETB	EA							; Enable all interrupts
1214    120615        7543     	CALL WAIT200MS	
                      7544     
                      7545     	; Arming sequence start
1217    754A00        7546     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      7547     ARMING_START: 
                      7548     IF MODE >= 1	; Tail or multi
121A    7888          7549     MOV R0 , # PGM_DIRECTION 
121C    E6            7550     MOV A , @ R0 
121D    B40302        7551     	CJNE	A, #3, ($+5)
                      7552     
1220    41F6          7553     	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                      7554     ENDIF
                      7555     
1222    120601        7556     	CALL WAIT3MS
1225    788C          7557     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1227    E6            7558     MOV A , @ R0 
1228    C3            7559     	CLR	C
1229    9401          7560     	SUBB	A, #1				; Is TX programming enabled?
122B    5003          7561     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      7562     
122D    0212F6        7563     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7564     
                      7565     ARMING_INITIAL_ARM_CHECK: 
1230    E530          7566     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
1232    C3            7567     	CLR	C
1233    9401          7568     	SUBB	A, #1				; Is it the initial arm sequence?
1235    5003          7569     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      7570     
1237    0212F6        7571     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      7572     
                      7573     ARMING_PPM_CHECK: 
123A    207435        7574     JB FLAGS2 . 4 , THROTTLE_HIGH_CAL_START 
                      7575     
                      7576     	; PWM tx program entry
123D    C3            7577     	CLR	C
123E    E55C          7578     	MOV	A, NEW_RCP			; Load new RC pulse value
1240    94FF          7579     SUBB A , # 255 
1242    5003          7580     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      7581     
1244    0212F6        7582     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7583     
                      7584     PROGRAM_BY_TX_ENTRY_PWM: 	
1247    C2AF          7585     	CLR	EA					; Disable all interrupts
1249    12063A        7586     	CALL BEEP_F4
124C    D2AF          7587     	SETB	EA					; Enable all interrupts
124E    120610        7588     	CALL WAIT100MS
1251    C3            7589     	CLR	C
1252    E55C          7590     	MOV	A, NEW_RCP			; Load new RC pulse value
1254    9401          7591     SUBB A , # 1 
1256    50EF          7592     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      7593     
                      7594     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
1258    C2AF          7595     	CLR	EA					; Disable all interrupts
125A    120625        7596     	CALL BEEP_F1
125D    120606        7597     	CALL WAIT10MS
1260    120625        7598     	CALL BEEP_F1
1263    D2AF          7599     	SETB	EA					; Enable all interrupts
1265    120610        7600     	CALL WAIT100MS
1268    C3            7601     	CLR	C
1269    E55C          7602     	MOV	A, NEW_RCP			; Load new RC pulse value
126B    94FF          7603     SUBB A , # 255 
126D    40E9          7604     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      7605     
126F    0217C3        7606     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7607     
                      7608     	; PPM throttle calibration and tx program entry
                      7609     THROTTLE_HIGH_CAL_START: 
                      7610     IF MODE <= 1	; Main or tail
1272    7F05          7611     MOV R7 , # 5 
                      7612     ELSE
                               	MOV	TEMP8, #2				; Set 1 seconds wait time
                               ENDIF
                      7615     THROTTLE_HIGH_CAL: 			
1274    D27F          7616     SETB FLAGS3 . 7 
1276    1112          7617     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1278    120610        7618     	CALL WAIT100MS				; Wait for new throttle value
127B    C2AF          7619     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
127D    C27F          7620     CLR FLAGS3 . 7 
127F    1112          7621     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1281    AE5C          7622     MOV R6 , NEW_RCP 
1283    C3            7623     	CLR	C
1284    E55C          7624     	MOV	A, NEW_RCP			; Load new RC pulse value
1286    947F          7625     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
1288    D2AF          7626     	SETB	EA					; Enable interrupts
128A    4074          7627     	JC	ARM_TARGET_UPDATED		; No - branch
                      7628     
128C    1205FC        7629     	CALL WAIT1MS		
128F    C2AF          7630     	CLR	EA					; Disable all interrupts
1291    12063A        7631     	CALL BEEP_F4
1294    D2AF          7632     	SETB	EA					; Enable all interrupts
1296    DFDC          7633     DJNZ R7 , THROTTLE_HIGH_CAL 
                      7634     
1298    1149          7635     	CALL	AVERAGE_THROTTLE
129A    C3            7636     	CLR	C
129B    EE            7637     MOV A , R6 
129C    9405          7638     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
129E    7897          7639     MOV R0 , # PGM_PPM_MAX_THROTTLE 
12A0    F6            7640     MOV @ R0 , A 
12A1    120615        7641     	CALL WAIT200MS				
12A4    121667        7642     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
12A7    121746        7643     	CALL	SUCCESS_BEEP
                      7644     
                      7645     THROTTLE_LOW_CAL_START: 
12AA    7F0A          7646     MOV R7 , # 10 
                      7647     THROTTLE_LOW_CAL: 			
12AC    D27F          7648     SETB FLAGS3 . 7 
12AE    1112          7649     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
12B0    120610        7650     	CALL WAIT100MS
12B3    C2AF          7651     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
12B5    C27F          7652     CLR FLAGS3 . 7 
12B7    1112          7653     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
12B9    AE5C          7654     MOV R6 , NEW_RCP 
12BB    C3            7655     	CLR	C
12BC    E55C          7656     	MOV	A, NEW_RCP			; Load new RC pulse value
12BE    947F          7657     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
12C0    D2AF          7658     	SETB	EA					; Enable interrupts
12C2    50E6          7659     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      7660     
12C4    1205FC        7661     	CALL WAIT1MS		
12C7    C2AF          7662     	CLR	EA					; Disable all interrupts
12C9    120625        7663     	CALL BEEP_F1
12CC    120606        7664     	CALL WAIT10MS
12CF    120625        7665     	CALL BEEP_F1
12D2    D2AF          7666     	SETB	EA					; Enable all interrupts
12D4    DFD6          7667     DJNZ R7 , THROTTLE_LOW_CAL 
                      7668     
12D6    1149          7669     	CALL	AVERAGE_THROTTLE
12D8    EE            7670     MOV A , R6 
12D9    2405          7671     	ADD	A, #5				; Add about 2%
12DB    7896          7672     MOV R0 , # PGM_PPM_MIN_THROTTLE 
12DD    F6            7673     MOV @ R0 , A 
12DE    120615        7674     	CALL WAIT200MS				
12E1    121667        7675     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
12E4    121775        7676     	CALL	SUCCESS_BEEP_INVERTED
                      7677     
                      7678     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
12E7    120610        7679     	CALL WAIT100MS
12EA    1112          7680     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
12EC    C3            7681     	CLR	C
12ED    E55C          7682     	MOV	A, NEW_RCP			; Load new RC pulse value
12EF    94FF          7683     SUBB A , # 255 
12F1    40F4          7684     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      7685     
12F3    0217C3        7686     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7687     
                      7688     PROGRAM_BY_TX_CHECKED: 
12F6    C3            7689     	CLR	C
12F7    E55C          7690     	MOV	A, NEW_RCP			; Load new RC pulse value
12F9    954A          7691     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
12FB    4003          7692     	JC	ARM_TARGET_UPDATED		; No - do not update
                      7693     
12FD    855C4A        7694     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      7695     
                      7696     ARM_TARGET_UPDATED: 
1300    120610        7697     	CALL WAIT100MS				; Wait for new throttle value
1303    7801          7698     MOV R0 , # 1 
1305    7988          7699     MOV R1 , # PGM_DIRECTION 
1307    E7            7700     MOV A , @ R1 
1308    B40302        7701     	CJNE	A, #3, ($+5)			; No - branch
                      7702     
130B    7805          7703     MOV R0 , # ( RCP_STOP+4 ) 
                      7704     
130D    C3            7705     	CLR	C
130E    E55C          7706     	MOV	A, NEW_RCP			; Load new RC pulse value
1310    98            7707     SUBB A , R0 
1311    4002          7708     	JC	ARM_END_BEEP			; Yes - proceed
                      7709     
1313    411A          7710     	JMP	ARMING_START			; No - start over
                      7711     
                      7712     ARM_END_BEEP: 
                      7713     	; Beep arm sequence end signal
1315    C2AF          7714     	CLR 	EA					; Disable all interrupts
1317    12063A        7715     	CALL BEEP_F4				; Signal that rcpulse is ready
131A    12063A        7716     	CALL BEEP_F4
131D    12063A        7717     	CALL BEEP_F4
1320    D2AF          7718     	SETB	EA					; Enable all interrupts
1322    120615        7719     	CALL WAIT200MS
                      7720     
                      7721     	; Clear initial arm variable
1325    753000        7722     	MOV	INITIAL_ARM, #0
                      7723     
                      7724     	; Armed and waiting for power on
                      7725     WAIT_FOR_POWER_ON: 
1328    E4            7726     	CLR	A
1329    F531          7727     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
132B    F532          7728     	MOV	POWER_ON_WAIT_CNT_H, A	
                      7729     WAIT_FOR_POWER_ON_LOOP: 
132D    0531          7730     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
132F    E531          7731     	MOV	A, POWER_ON_WAIT_CNT_L
1331    F4            7732     	CPL	A
1332    7039          7733     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      7734     
1334    0532          7735     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
1336    789A          7736     MOV R0 , # PGM_BEACON_DELAY 
1338    E6            7737     MOV A , @ R0 
1339    7819          7738     MOV R0 , # 25 
133B    14            7739     	DEC	A
133C    6012          7740     	JZ	BEEP_DELAY_SET
                      7741     
133E    7832          7742     MOV R0 , # 50 
1340    14            7743     	DEC	A
1341    600D          7744     	JZ	BEEP_DELAY_SET
                      7745     
1343    787D          7746     MOV R0 , # 125 
1345    14            7747     	DEC	A
1346    6008          7748     	JZ	BEEP_DELAY_SET
                      7749     
1348    78FA          7750     MOV R0 , # 250 
134A    14            7751     	DEC	A
134B    6003          7752     	JZ	BEEP_DELAY_SET
                      7753     
134D    753200        7754     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      7755     
                      7756     BEEP_DELAY_SET: 
1350    C3            7757     	CLR	C
1351    E532          7758     	MOV	A, POWER_ON_WAIT_CNT_H
1353    98            7759     SUBB A , R0 
1354    4017          7760     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      7761     
1356    1532          7762     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
1358    7531B4        7763     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
135B    7899          7764     MOV R0 , # PGM_BEACON_STRENGTH 
135D    8673          7765     MOV BEEP_STRENGTH , @ R0 
135F    C2AF          7766     	CLR 	EA					; Disable all interrupts
1361    12063A        7767     	CALL BEEP_F4				; Signal that there is no signal
1364    D2AF          7768     	SETB	EA					; Enable all interrupts
1366    7898          7769     MOV R0 , # PGM_BEEP_STRENGTH 
1368    8673          7770     MOV BEEP_STRENGTH , @ R0 
136A    120610        7771     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      7772     
                      7773     WAIT_FOR_POWER_ON_NO_BEEP: 
136D    120606        7774     	CALL WAIT10MS
1370    E52A          7775     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
1372    7005          7776     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      7777     
1374    307402        7778     JNB FLAGS2 . 4 , WAIT_FOR_POWER_ON_PPM_NOT_MISSING 
                      7779     
1377    2118          7780     	JMP	INIT_NO_SIGNAL					; If ppm and pulses missing - go back to detect input signal
                      7781     
                      7782     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
1379    7801          7783     MOV R0 , # 1 
137B    207402        7784     JB FLAGS2 . 4 , ( $+5 ) 
                      7785     
137E    7806          7786     MOV R0 , # ( RCP_STOP+5 ) 
                      7787     
1380    C3            7788     	CLR	C
1381    E55C          7789     	MOV	A, NEW_RCP			; Load new RC pulse value
1383    98            7790     SUBB A , R0 
1384    40A7          7791     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      7792     
                      7793     IF MODE >= 1	; Tail or multi
1386    7888          7794     MOV R0 , # PGM_DIRECTION 
1388    E6            7795     MOV A , @ R0 
1389    C3            7796     	CLR	C
138A    9403          7797     	SUBB	A, #3
138C    6003          7798     	JZ 	WAIT_FOR_POWER_ON_CHECK_TIMEOUT	; Do not wait if bidirectional operation
                      7799     ENDIF
                      7800     
138E    120610        7801     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      7802     
                      7803     WAIT_FOR_POWER_ON_CHECK_TIMEOUT: 
1391    E52A          7804     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
1393    7003          7805     	JNZ	($+5)				; If it is not zero - proceed
                      7806     
1395    021118        7807     	LJMP	INIT_NO_SIGNAL			; If it is zero (pulses missing) - go back to detect input signal
                      7808     
                      7809     
                      7810     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7811     ;
                      7812     ; Start entry point
                      7813     ;
                      7814     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7815     INIT_START: 
1398    C2AF          7816     	CLR	EA
139A    120F10        7817     	CALL SWITCH_POWER_OFF
139D    E4            7818     	CLR	A
139E    F522          7819     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
13A0    F523          7820     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
13A2    F524          7821     	MOV	CURRENT_PWM, A			; Set current pwm to zero
13A4    F525          7822     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
13A6    F526          7823     	MOV	CURRENT_PWM_LIM_DITH, A
13A8    F567          7824     	MOV	PWM_DITHER_EXCESS_POWER, A
13AA    D2AF          7825     	SETB	EA
13AC    7885          7826     MOV R0 , # PGM_MOTOR_IDLE 
13AE    E6            7827     MOV A , @ R0 
13AF    C3            7828     	CLR	C
13B0    33            7829     	RLC	A
13B1    F565          7830     	MOV	PWM_MOTOR_IDLE, A
13B3    E4            7831     	CLR	A
13B4    F542          7832     	MOV	GOV_TARGET_L, A		; Set target to zero
13B6    F543          7833     	MOV	GOV_TARGET_H, A
13B8    F544          7834     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
13BA    F545          7835     	MOV	GOV_INTEGRAL_H, A
13BC    F546          7836     	MOV	GOV_INTEGRAL_X, A
13BE    F570          7837     	MOV	ADC_CONVERSION_CNT, A
13C0    F52C          7838     	MOV	FLAGS0, A				; Clear flags0
13C2    F52D          7839     	MOV	FLAGS1, A				; Clear flags1
13C4    F536          7840     	MOV	DEMAG_DETECTED_METRIC, A	; Clear demag metric
                      7841     	;**** **** **** **** ****
                      7842     	; Motor start beginning
                      7843     	;**** **** **** **** **** 
13C6    757008        7844     MOV ADC_CONVERSION_CNT , # 8 
                      7845     	SET_ADC_IP_TEMP
13C9    75BB10        7845+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
13CC    1205FC        7846     	CALL WAIT1MS
13CF    1208BA        7847     	CALL START_ADC_CONVERSION
                      7848     READ_INITIAL_TEMP: 
                      7849     	GET_ADC_STATUS 
13D2    E5E8          7849+1   MOV A , ADC0CN 
13D4    20ECFB        7850     	JB	AD0BUSY, READ_INITIAL_TEMP
                      7851     	READ_ADC_RESULT						; Read initial temperature
13D7    A8BD          7851+1   MOV R0 , ADC0L 
13D9    A9BE          7851+1   MOV R1 , ADC0H 
13DB    E9            7852     MOV A , R1 
13DC    7001          7853     	JNZ	($+3)							; Is reading below 256?
                      7854     
13DE    F8            7855     MOV R0 , A 
                      7856     
13DF    8871          7857     MOV CURRENT_AVERAGE_TEMP , R0 
13E1    1208BE        7858     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
13E4    757008        7859     MOV ADC_CONVERSION_CNT , # 8 
                      7860     	SET_ADC_IP_TEMP
13E7    75BB10        7860+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      7861     	; Set up start operating conditions
13EA    7887          7862     MOV R0 , # PGM_PWM_FREQ 
13EC    E6            7863     MOV A , @ R0 
13ED    FE            7864     MOV R6 , A 
13EE    7602          7865     MOV @ R0 , # 2 
13F0    120F8E        7866     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
13F3    7887          7867     MOV R0 , # PGM_PWM_FREQ 
13F5    EE            7868     MOV A , R6 
13F6    F6            7869     MOV @ R0 , A 
                      7870     	; Set max allowed power
13F7    C2AF          7871     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
13F9    7561FF        7872     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
13FC    120936        7873     	CALL SET_STARTUP_PWM
13FF    852261        7874     	MOV	PWM_LIMIT, REQUESTED_PWM
1402    852262        7875     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
1405    852263        7876     	MOV	PWM_LIMIT_BY_RPM, REQUESTED_PWM
1408    D2AF          7877     	SETB	EA
140A    752201        7878     	MOV	REQUESTED_PWM, #1			; Set low pwm again after calling set_startup_pwm
140D    752401        7879     	MOV	CURRENT_PWM, #1
1410    752501        7880     	MOV	CURRENT_PWM_LIMITED, #1	
1413    752601        7881     	MOV	CURRENT_PWM_LIM_DITH, #1
1416    856069        7882     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1419    756A01        7883     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      7884     	; Begin startup sequence
                      7885     IF MCU_48MHZ == 1
                      7886     	SET_MCU_CLK_48MHZ
141C    75B690        7886+1   MOV FLSCL , # 90H  ; SET FLASH TIMING FOR 48MHZ
141F    75A903        7886+1   MOV CLKSEL , # 3  ; SET CLOCK TO 48MHZ
1422    757A01        7886+1   MOV CLOCK_SET_AT_48MHZ , # 1 
                      7887     ENDIF
1425    7888          7888     MOV R0 , # PGM_DIRECTION 
1427    E6            7889     MOV A , @ R0 
1428    B40307        7890     	CJNE	A, #3, INIT_START_BIDIR_DONE
                      7891     
142B    C27D          7892     CLR FLAGS3 . 5 
142D    307602        7893     JNB FLAGS2 . 6 , ( $+5 ) 
1430    D27D          7894     SETB FLAGS3 . 5 
                      7895     
                      7896     INIT_START_BIDIR_DONE: 
1432    D268          7897     SETB FLAGS1 . 0 
1434    D269          7898     SETB FLAGS1 . 1 
1436    753300        7899     	MOV	STARTUP_CNT, #0			; Reset counter
1439    120E76        7900     	CALL COMM5COMM6				; Initialize commutation
143C    120E9B        7901     	CALL COMM6COMM1				
143F    12095D        7902     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
1442    12095D        7903     	CALL	CALC_NEXT_COMM_TIMING		
1445    120956        7904     	CALL INITIALIZE_TIMING			; Initialize timing
1448    12095D        7905     	CALL	CALC_NEXT_COMM_TIMING		
144B    120ABA        7906     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
144E    120956        7907     	CALL	INITIALIZE_TIMING			; Initialize timing
1451    120B7D        7908     	CALL	WAIT_BEFORE_ZC_SCAN			; Set up comparator timeout
1454    021464        7909     	JMP	RUN1
                      7910     
                      7911     
                      7912     
                      7913     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7914     ;
                      7915     ; Run entry point
                      7916     ;
                      7917     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7918     DAMPED_TRANSITION: 
                      7919     	; Transition from nondamped to damped if applicable
1457    C2AF          7920     	CLR	EA
1459    120F8E        7921     	CALL	DECODE_PARAMETERS		; Set programmed parameters
145C    D2AF          7922     	SETB	EA
145E    757000        7923     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      7924     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
1461    75BB09        7924+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      7925     
                      7926     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      7927     ; Out_cA changes from low to high
                      7928     RUN1: 
1464    120BD2        7929     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
1467    120CD7        7930     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
146A    120CB8        7931     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
146D    120705        7932     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
1470    120CF4        7933     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
1473    120D3E        7934     	CALL COMM1COMM2			; Commutate
1476    12095D        7935     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
1479    120AA9        7936     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
147C    120ABA        7937     	CALL CALC_NEW_WAIT_TIMES
147F    120B7D        7938     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      7939     
                      7940     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      7941     ; Out_cB changes from high to low
                      7942     RUN2: 
1482    120BC1        7943     	CALL WAIT_FOR_COMP_OUT_LOW
1485    120CD7        7944     	CALL SETUP_COMM_WAIT	
1488    120CB8        7945     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
148B    306D03        7946     JNB FLAGS1 . 5 , ( $+6 ) 
148E    120706        7947     	LCALL CALC_GOVERNOR_PROP_ERROR
1491    206703        7948     JB FLAGS0 . 7 , ( $+6 ) 
1494    120859        7949     	LCALL SET_PWM_LIMIT_LOW_RPM
1497    306703        7950     JNB FLAGS0 . 7 , ( $+6 ) 
149A    1208A0        7951     	LCALL SET_PWM_LIMIT_HIGH_RPM
149D    120CF4        7952     	CALL WAIT_FOR_COMM
14A0    120D63        7953     	CALL COMM2COMM3
14A3    12095D        7954     	CALL CALC_NEXT_COMM_TIMING
14A6    120AA9        7955     	CALL WAIT_ADVANCE_TIMING
14A9    120ABA        7956     	CALL CALC_NEW_WAIT_TIMES
14AC    120B7D        7957     	CALL WAIT_BEFORE_ZC_SCAN	
                      7958     
                      7959     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      7960     ; Out_cC changes from low to high
                      7961     RUN3: 
14AF    120BD2        7962     	CALL WAIT_FOR_COMP_OUT_HIGH
14B2    120CD7        7963     	CALL SETUP_COMM_WAIT	
14B5    120CB8        7964     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
14B8    306D03        7965     JNB FLAGS1 . 5 , ( $+6 ) 
14BB    120742        7966     	LCALL CALC_GOVERNOR_INT_ERROR
14BE    120CF4        7967     	CALL WAIT_FOR_COMM
14C1    120DDA        7968     	CALL COMM3COMM4
14C4    12095D        7969     	CALL CALC_NEXT_COMM_TIMING
14C7    120AA9        7970     	CALL WAIT_ADVANCE_TIMING
14CA    120ABA        7971     	CALL CALC_NEW_WAIT_TIMES
14CD    120B7D        7972     	CALL WAIT_BEFORE_ZC_SCAN	
                      7973     
                      7974     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      7975     ; Out_cA changes from high to low
                      7976     RUN4: 
14D0    120BC1        7977     	CALL WAIT_FOR_COMP_OUT_LOW
14D3    120CD7        7978     	CALL SETUP_COMM_WAIT	
14D6    120CB8        7979     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
14D9    306D03        7980     JNB FLAGS1 . 5 , ( $+6 ) 
14DC    1207A0        7981     	LCALL CALC_GOVERNOR_PROP_CORRECTION
14DF    120CF4        7982     	CALL WAIT_FOR_COMM
14E2    120DFF        7983     	CALL COMM4COMM5
14E5    12095D        7984     	CALL CALC_NEXT_COMM_TIMING
14E8    120AA9        7985     	CALL WAIT_ADVANCE_TIMING
14EB    120ABA        7986     	CALL CALC_NEW_WAIT_TIMES
14EE    120B7D        7987     	CALL WAIT_BEFORE_ZC_SCAN	
                      7988     
                      7989     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      7990     ; Out_cB changes from low to high
                      7991     RUN5: 
14F1    120BD2        7992     	CALL WAIT_FOR_COMP_OUT_HIGH
14F4    120CD7        7993     	CALL SETUP_COMM_WAIT	
14F7    120CB8        7994     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
14FA    306D03        7995     JNB FLAGS1 . 5 , ( $+6 ) 
14FD    1207FD        7996     	LCALL CALC_GOVERNOR_INT_CORRECTION
1500    120CF4        7997     	CALL WAIT_FOR_COMM
1503    120E76        7998     	CALL COMM5COMM6
1506    12095D        7999     	CALL CALC_NEXT_COMM_TIMING
1509    120AA9        8000     	CALL WAIT_ADVANCE_TIMING
150C    120ABA        8001     	CALL CALC_NEW_WAIT_TIMES
150F    120B7D        8002     	CALL WAIT_BEFORE_ZC_SCAN	
                      8003     
                      8004     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      8005     ; Out_cC changes from high to low
                      8006     RUN6: 
1512    1208BA        8007     	CALL START_ADC_CONVERSION
1515    120BC1        8008     	CALL WAIT_FOR_COMP_OUT_LOW
1518    120CD7        8009     	CALL SETUP_COMM_WAIT	
151B    120CB8        8010     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
151E    120CF4        8011     	CALL WAIT_FOR_COMM
1521    120E9B        8012     	CALL COMM6COMM1
1524    1208BE        8013     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1527    12095D        8014     	CALL CALC_NEXT_COMM_TIMING
152A    120AA9        8015     	CALL WAIT_ADVANCE_TIMING
152D    120ABA        8016     	CALL CALC_NEW_WAIT_TIMES
1530    120B7D        8017     	CALL WAIT_BEFORE_ZC_SCAN	
                      8018     
                      8019     	; Check if it is direct startup
1533    306932        8020     JNB FLAGS1 . 1 , NORMAL_RUN_CHECKS 
1536    206B2F        8021     JB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      8022     
                      8023     	; Set spoolup power variables
1539    856461        8024     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
153C    856462        8025     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
153F    856069        8026     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1542    756A01        8027     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8028     	; Check startup counter
1545    7918          8029     MOV R1 , # 24 
1547    7A0C          8030     MOV R2 , # 12 
1549    C3            8031     	CLR	C
154A    E533          8032     	MOV	A, STARTUP_CNT				; Load counter
154C    99            8033     SUBB A , R1 
154D    400C          8034     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      8035     
154F    C269          8036     CLR FLAGS1 . 1 
1551    D26A          8037     SETB FLAGS1 . 2 
1553    8A34          8038     MOV INITIAL_RUN_ROT_CNT , R2 
                      8039     IF MODE == 1	; Tail
1555    7561FF        8040     	MOV	PWM_LIMIT, #0FFH			; Allow full power
                      8041     ENDIF
                      8042     IF MODE == 2	; Multi
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG
                               	MOV	PWM_LIMIT_BY_RPM, PWM_SPOOLUP_BEG
                               ENDIF
1558    021568        8046     	JMP	NORMAL_RUN_CHECKS
                      8047     
                      8048     DIRECT_START_CHECK_RCP: 
155B    C3            8049     	CLR	C
155C    E55C          8050     	MOV	A, NEW_RCP				; Load new pulse value
155E    9401          8051     SUBB A , # 1 
1560    4003          8052     	JC	($+5)
                      8053     
1562    021464        8054     	LJMP	RUN1						; Continue to run 
                      8055     
1565    0215E2        8056     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8057     
                      8058     
                      8059     NORMAL_RUN_CHECKS: 
                      8060     	; Check if it is initial run phase
1568    306A1B        8061     JNB FLAGS1 . 2 , INITIAL_RUN_PHASE_DONE 
156B    206B18        8062     JB FLAGS1 . 3 , INITIAL_RUN_PHASE_DONE 
                      8063     
                      8064     	; Decrement startup rotaton count
156E    E534          8065     	MOV	A, INITIAL_RUN_ROT_CNT
1570    14            8066     	DEC	A
                      8067     	; Check number of nondamped rotations
1571    7004          8068     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      8069     
1573    C26A          8070     CLR FLAGS1 . 2 
1575    8157          8071     	JMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      8072     
                      8073     NORMAL_RUN_CHECK_STARTUP_ROT: 
1577    F534          8074     	MOV	INITIAL_RUN_ROT_CNT, A		; Not zero - store counter
                      8075     
1579    C3            8076     	CLR	C
157A    E55C          8077     	MOV	A, NEW_RCP				; Load new pulse value
157C    9401          8078     SUBB A , # 1 
157E    4003          8079     	JC	($+5)
                      8080     
1580    021464        8081     	LJMP	RUN1						; Continue to run 
                      8082     
1583    0215E2        8083     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8084     
                      8085     INITIAL_RUN_PHASE_DONE: 
                      8086     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      8099     	; Exit run loop after a given time
1586    C3            8100     	CLR	C
1587    E55F          8101     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
1589    7882          8102     MOV R0 , # 130 
158B    98            8103     SUBB A , R0 
158C    5054          8104     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      8105     
158E    307404        8106     JNB FLAGS2 . 4 , RUN6_CHECK_DIR 
                      8107     
1591    E52A          8108     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1593    604D          8109     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      8110     
                      8111     RUN6_CHECK_DIR: 
                      8112     IF MODE >= 1	; Tail or multi
1595    7888          8113     MOV R0 , # PGM_DIRECTION 
1597    E6            8114     MOV A , @ R0 
1598    B40317        8115     	CJNE	A, #3, RUN6_CHECK_SPEED
                      8116     
159B    207D05        8117     JB FLAGS3 . 5 , RUN6_CHECK_DIR_REV 
159E    207607        8118     JB FLAGS2 . 6 , RUN6_CHECK_DIR_CHANGE 
15A1    A1B2          8119     	AJMP	RUN6_CHECK_SPEED
                      8120     
                      8121     RUN6_CHECK_DIR_REV: 
15A3    307602        8122     JNB FLAGS2 . 6 , RUN6_CHECK_DIR_CHANGE 
15A6    A1B2          8123     	AJMP	RUN6_CHECK_SPEED
                      8124     
                      8125     RUN6_CHECK_DIR_CHANGE: 
15A8    206B07        8126     JB FLAGS1 . 3 , RUN6_CHECK_SPEED 
                      8127     
15AB    D26B          8128     SETB FLAGS1 . 3 
15AD    856461        8129     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set max power while braking
15B0    81D0          8130     	JMP	RUN4						; Go back to run 4, thereby changing force direction
                      8131     
                      8132     RUN6_CHECK_SPEED: 
                      8133     ENDIF
15B2    78F0          8134     MOV R0 , # 0F0H 
15B4    306B05        8135     JNB FLAGS1 . 3 , RUN6_BRAKE_DONE 
                      8136     
15B7    856461        8137     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG 	; Set max power while braking
15BA    7820          8138     MOV R0 , # 20H 
                      8139     
                      8140     RUN6_BRAKE_DONE: 
15BC    C3            8141     	CLR	C
15BD    E53E          8142     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
15BF    98            8143     SUBB A , R0 
15C0    5002          8144     	JNC	($+4)					; Yes - stop or turn direction 
15C2    8164          8145     	AJMP	RUN1						; No - go back to run 1
                      8146     
                      8147     IF MODE >= 1	; Tail or multi
15C4    306B1B        8148     JNB FLAGS1 . 3 , RUN_TO_WAIT_FOR_POWER_ON 
                      8149     
15C7    C26B          8150     CLR FLAGS1 . 3 
15C9    C27D          8151     CLR FLAGS3 . 5 
15CB    307602        8152     JNB FLAGS2 . 6 , ( $+5 ) 
15CE    D27D          8153     SETB FLAGS3 . 5 
15D0    D26A          8154     SETB FLAGS1 . 2 
15D2    753412        8155     	MOV	INITIAL_RUN_ROT_CNT, #18
15D5    856461        8156     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set initial max power
15D8    8164          8157     	AJMP	RUN1						; Go back to run 1 
                      8158     ENDIF
                      8159     
                      8160     RUN_TO_WAIT_FOR_POWER_ON_FAIL: 	
15DA    0535          8161     	INC	STALL_CNT					; Increment stall count
15DC    E55C          8162     	MOV	A, NEW_RCP				; Check if RCP is zero, then it is a normal stop			
15DE    6002          8163     	JZ	RUN_TO_WAIT_FOR_POWER_ON
15E0    A1E5          8164     	AJMP	RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE
                      8165     
                      8166     RUN_TO_WAIT_FOR_POWER_ON: 	
15E2    753500        8167     	MOV	STALL_CNT, #0
                      8168     
                      8169     RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE: 
15E5    C2AF          8170     	CLR	EA
15E7    120F10        8171     	CALL SWITCH_POWER_OFF
15EA    7887          8172     MOV R0 , # PGM_PWM_FREQ 
15EC    E6            8173     MOV A , @ R0 
15ED    FE            8174     MOV R6 , A 
15EE    7602          8175     MOV @ R0 , # 2 
15F0    120F8E        8176     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
15F3    7887          8177     MOV R0 , # PGM_PWM_FREQ 
15F5    EE            8178     MOV A , R6 
15F6    F6            8179     MOV @ R0 , A 
15F7    E4            8180     	CLR	A
15F8    F522          8181     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
15FA    F523          8182     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
15FC    F524          8183     	MOV	CURRENT_PWM, A				; Set current pwm to zero
15FE    F525          8184     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1600    F526          8185     	MOV	CURRENT_PWM_LIM_DITH, A	
1602    F565          8186     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1604    C268          8187     CLR FLAGS1 . 0 
                      8188     IF MCU_48MHZ == 1
                      8189     	SET_MCU_CLK_24MHZ
1606    75B680        8189+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
1609    75A900        8189+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
160C    757A00        8189+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      8190     ENDIF
160F    D2AF          8191     	SETB	EA
1611    1205FC        8192     	CALL	WAIT1MS					; Wait for pwm to be stopped
1614    120F10        8193     	CALL SWITCH_POWER_OFF
                      8194     IF MODE == 0	; Main
                               	JNB	FLAGS2.RCP_PPM, RUN_TO_NEXT_STATE_MAIN	; If flag is not set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	INIT_NO_SIGNAL				; If it is zero (pulses missing) - go back to detect input signal
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      8214     IF MODE >= 1	; Tail or multi
1617    307409        8215     JNB FLAGS2 . 4 , JMP_WAIT_FOR_POWER_ON 
                      8216     
161A    C3            8217     	CLR	C
161B    E535          8218     	MOV	A, STALL_CNT
161D    9405          8219     	SUBB	A, #5
161F    4002          8220     	JC	JMP_WAIT_FOR_POWER_ON
1621    2118          8221     	JMP	INIT_NO_SIGNAL
                      8222     
                      8223     JMP_WAIT_FOR_POWER_ON: 
1623    6128          8224     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      8225     ENDIF
                      8226     
                      8227     
                      8228     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8229     
                      8230     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      8890     $INCLUDE (BLHELIBOOTLOAD.INC)			; Include source code for bootloader
                      9283     
                      9284     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      9285     
                      9286     
------                9287     CSEG AT 19FDH
                      9288     RESET: 
19FD    021074        9289     LJMP	PGM_START
                      9290     
                      9291     
                      9292     
                      9293     
                      9294     END
MACRO ASSEMBLER BLHELI                                      12/30/15 18:07:00 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

SET4 . . . . . . .  C ADDR   1CC5H   A 
ID3. . . . . . . .  C ADDR   1C52H   A 
BYTE_CNTH. . . . .  D ADDR   0028H   A 
CRCH . . . . . . .  D ADDR   0023H   A 
CMDL . . . . . . .    REG    R4             
XH . . . . . . . .    REG    R1             
NORMAL_RUN_CHECK_~  C ADDR   1577H   A 
DECODE_DEMAG_HIGH.  C ADDR   0FFAH   A 
COMM61_DAMP_REV. .  C ADDR   0EC1H   A 
COMP_WAIT_ON_COMP~  C ADDR   0C09H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0BC0H   A 
CHECK_TEMP_VOLTAG~  C ADDR   08BEH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0824H   A 
GOVERNOR_CORR_NEG~  C ADDR   07ECH   A 
PCA_INT_PPM_BELOW~  C ADDR   04ECH   A 
T2_INT_CURRENT_PW~  C ADDR   02D0H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
TIMER0_OVERFLOW_V~  D ADDR   0079H   A 
PPM_THROTTLE_GAIN.  D ADDR   0072H   A 
LIPO_ADC_LIMIT_H .  D ADDR   006FH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005EH   A 
RCP_EDGE_H . . . .  D ADDR   0058H   A 
FLAGS3 . . . . . .  D ADDR   002FH   A 
RCP_PREV_EDGE_L. .  D ADDR   0027H   A 
ADC_IP . . . . . .  N NUMB   0001h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
POLARIS_THUNDER_4~  N NUMB   008Fh            
POLARIS_THUNDER_3~  N NUMB   008Dh            
POLARIS_THUNDER_1~  N NUMB   0087h            
SET5 . . . . . . .  C ADDR   1CCBH   A 
ID4. . . . . . . .  C ADDR   1C5DH   A 
BOOT_START . . . .  N NUMB   1C00h            
FUNCTION_BEEP. . .  C ADDR   17AAH   A 
INIT_START . . . .  C ADDR   1398H   A 
PROGRAM_BY_TX_ENT~  C ADDR   1247H   A 
FIND_THROTTLE_GAI~  C ADDR   102CH   A 
COMM45_NONDAMP . .  C ADDR   0E45H   A 
COMM4COMM5 . . . .  C ADDR   0DFFH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0A04H   A 
SET_PWM_LIMIT_HIG~  C ADDR   08B0H   A 
SET_PWM_DEMAG_DONE  C ADDR   0875H   A 
PCA_INT_RESTORE_E~  C ADDR   0469H   A 
T2H_INT_RCP_STOP .  C ADDR   031CH   A 
T0_INT_PWM_OFF_DA~  C ADDR   013DH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006DH   A 
RANDOM . . . . . .  D ADDR   0068H   A 
PWM_MOTOR_IDLE . .  D ADDR   0065H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005DH   A 
NEXT_WT_START_L. .  D ADDR   0053H   A 
COMM_PERIOD4X_H. .  D ADDR   003EH   A 
PWM_START. . . . .  N NUMB   0032h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D6h            
EMAX_NANO_20A_TAIL  N NUMB   00B3h            
PLATINUM_50AV3_TA~  N NUMB   00A1h            
PLATINUM_PRO_30A_~  N NUMB   009Ah            
POLARIS_THUNDER_4~  N NUMB   0090h            
H_KING_35A_TAIL. .  N NUMB   0080h            
SET6 . . . . . . .  C ADDR   1CD3H   A 
ID5. . . . . . . .  C ADDR   1C6AH   A 
ERRORPROG. . . . .  N NUMB   00C5h            
ERRORCRC . . . . .  N NUMB   00C2h            
BOOT_DELAY . . . .  N NUMB   5F5E10h            
PARAVAL_BEEP . . .  C ADDR   17B8H   A 
COMM45_DAMP_REV. .  C ADDR   0E25H   A 
COMM23_NFET_DONE .  C ADDR   0DBBH   A 
GOVERNOR_CHECK_PWM  C ADDR   077BH   A 
PWM_AFET_DAMPED_D~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
DEMAG_DETECTED_ME~  D ADDR   0036H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
SIGNATURE_001. . .  N NUMB   00F3h            
RTX_PORT . . . . .  N NUMB   0080h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
EMAX_NANO_20A_MUL~  N NUMB   00B4h            
PLATINUM_50AV3_MU~  N NUMB   00A2h            
POLARIS_THUNDER_6~  N NUMB   0092h            
H_KING_35A_MULTI .  N NUMB   0081h            
TURNIGY_AE_25A_MA~  N NUMB   0043h            
TURNIGY_AE_20A_TA~  N NUMB   0041h            
TURNIGY_PLUSH_10A~  N NUMB   001Fh            
XP_35A_SW_TAIL . .  N NUMB   0014h            
GETC . . . . . . .  C ADDR   1D7FH   A 
BIT_CNT. . . . . .  D ADDR   0026H   A 
BOOT_PAGES . . . .  N NUMB   0001h            
WRITE_EEPROM_SIGN~  C ADDR   16D9H   A 
WAIT_FOR_POWER_ON.  C ADDR   1328H   A 
THROTTLE_LOW_CAL_~  C ADDR   12AAH   A 
ERASE_AND_STORE_A~  C ADDR   1667H   A 
ARMING_INITIAL_AR~  C ADDR   1230H   A 
PROGRAM_BY_TX_CHE~  C ADDR   12F6H   A 
FIND_THROTTLE_GAI~  C ADDR   1025H   A 
SET_DEFAULT_PARAM~  C ADDR   0F25H   A 
COMM56_REV . . . .  C ADDR   0E8AH   A 
COMM5COMM6 . . . .  C ADDR   0E76H   A 
COMM23_NFET_OFF_R~  C ADDR   0D9FH   A 
COMP_READ_OK . . .  C ADDR   0CA1H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0AA4H   A 
CALC_NEXT_COMM_TI~  C ADDR   095DH   A 
PCA_INT_STORE_DATA  C ADDR   048EH   A 
T2_INT_RCP_GAIN_P~  C ADDR   0265H   A 
T2_INT_RCP_UPDATE~  C ADDR   022CH   A 
PWM_BFET_DAMPED_D~  C ADDR   0196H   A 
RESET. . . . . . .  C ADDR   19FDH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   00A4H   A 
PGM_ENABLE_TEMP_P~  I ADDR   00A0H   A 
_PGM_THROTTLE_RATE  I ADDR   009BH   A 
_PGM_STARTUP_RPM .  I ADDR   008FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   0062H   A 
RCP_PREPREV_EDGE_H  D ADDR   0056H   A 
WT_ZC_SCAN_START_L  D ADDR   004DH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0003h            
STARTUP_PHASE. . .  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
SIGNATURE_002. . .  N NUMB   0090h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C5h            
POLARIS_THUNDER_6~  N NUMB   0093h            
SKYWALKER_20A_MAIN  N NUMB   0058h            
TURNIGY_AE_30A_TA~  N NUMB   0047h            
TURNIGY_AE_20A_MU~  N NUMB   0042h            
XP_35A_SW_MULTI. .  N NUMB   0015h            
XP_7A_MAIN . . . .  N NUMB   0004h            
PRO3 . . . . . . .  C ADDR   1D01H   A 
BOOT_SIGN. . . . .  C ADDR   1DD6H   A 
BYTE_CNTL. . . . .  D ADDR   0027H   A 
BAUDH. . . . . . .  D ADDR   0025H   A 
CRCL . . . . . . .  D ADDR   0022H   A 
XL . . . . . . . .    REG    R0             
FUNCTION_NEXT. . .  C ADDR   1822H   A 
THROTTLE_HIGH_CAL.  C ADDR   1274H   A 
COMM61_NFET_DONE .  C ADDR   0EF2H   A 
STORE_TIMES_INCRE~  C ADDR   0B6FH   A 
STARTUP_PWM_SET_P~  C ADDR   094BH   A 
PWM_CFET_DAMPED_D~  C ADDR   01A7H   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006EH   A 
RCP_EDGE_L . . . .  D ADDR   0057H   A 
COMM_DIFF. . . . .  D ADDR   003FH   A 
STALL_CNT. . . . .  D ADDR   0035H   A 
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
RTX_PIN. . . . . .  N NUMB   0005h            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C6h            
POLARIS_THUNDER_8~  N NUMB   0095h            
TURNIGY_KFORCE_12~  N NUMB   0053h            
TURNIGY_AE_45A_MA~  N NUMB   0049h            
TURNIGY_AE_30A_MU~  N NUMB   0048h            
TURNIGY_PLUSH_30A~  N NUMB   002Bh            
TURNIGY_PLUSH_12A~  N NUMB   0022h            
XP_3A_TAIL . . . .  N NUMB   0002h            
PRO4 . . . . . . .  C ADDR   1D0DH   A 
MAIN . . . . . . .  C ADDR   1C7CH   A 
PARAVAL_NEXT . . .  C ADDR   180CH   A 
WRITE_EEPROM_BYTE.  C ADDR   16ADH   A 
TEST_FOR_ONESHOT .  C ADDR   11E3H   A 
MEASURE_PWM_FREQ_~  C ADDR   1190H   A 
COMM61_NFET_OFF_R~  C ADDR   0ED7H   A 
COMM_EXIT. . . . .  C ADDR   0F0DH   A 
CALC_GOVERNOR_INT~  C ADDR   07FDH   A 
PCA_INT_PPM_CHECK~  C ADDR   0507H   A 
PCA_INT_FALL_CHEC~  C ADDR   04DEH   A 
PCA_INT_PWM_DIVIDE  C ADDR   059BH   A 
PCA_INT_LIMITED. .  C ADDR   05BEH   A 
T2H_INT_START. . .  C ADDR   0300H   A 
T2_INT_PWM_UPDATE.  C ADDR   0275H   A 
T0_INT_PWM_OFF_DA~  C ADDR   012BH   A 
EEP_DUMMY. . . . .  C ADDR   1A27H   A 
EEP_PGM_ENABLE_PW~  C ADDR   1A25H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A13H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
CLOCK_SET_AT_48MHZ  D ADDR   007AH   A 
COMM_PERIOD4X_L. .  D ADDR   003DH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
RTX_MDIN . . . . .  N NUMB   00F1h            
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0001h            
POLARIS_THUNDER_8~  N NUMB   0096h            
SKYWALKER_40A_MAIN  N NUMB   005Bh            
TURNIGY_KFORCE_12~  N NUMB   0054h            
TURNIGY_PLUSH_40A~  N NUMB   002Eh            
SUPERMICRO_3P5A_M~  N NUMB   0019h            
XP_3A_MULTI. . . .  N NUMB   0003h            
WAIT1. . . . . . .  C ADDR   1DCFH   A 
PRO5 . . . . . . .  C ADDR   1D13H   A 
FUNC_PARAVAL_WAIT.  C ADDR   17D6H   A 
WRITE_TAG. . . . .  C ADDR   1702H   A 
READ_EEPROM_STORE~  C ADDR   163EH   A 
RUN6_CHECK_DIR . .  C ADDR   1595H   A 
RUN1 . . . . . . .  C ADDR   1464H   A 
WAIT_FOR_POWER_ON~  C ADDR   1391H   A 
MEASURE_PWM_FREQ_~  C ADDR   11A1H   A 
CLEAR_RAM. . . . .  C ADDR   10E2H   A 
SET_BEC_VOLTAGE. .  C ADDR   1011H   A 
DECODE_DEMAG_DONE.  C ADDR   1003H   A 
COMM45_NFET_DONE .  C ADDR   0E57H   A 
WAIT_FOR_COMM. . .  C ADDR   0CF4H   A 
ADJUST_TIMING_TWO~  C ADDR   0B62H   A 
CALC_GOVERNOR_PRO~  C ADDR   0741H   A 
DIV_U16_BY_U16_DI~  C ADDR   067EH   A 
WAIT100MS. . . . .  C ADDR   0610H   A 
WAIT1MS. . . . . .  C ADDR   05FCH   A 
T0_INT_PWM_OFF_TI~  C ADDR   010BH   A 
T0_INT_PWM_OFF_SE~  C ADDR   0109H   A 
STARTUP_POWER_TAB~  C ADDR   008DH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
SKIP_T2_INT. . . .  D ADDR   0077H   A 
TX_PGM_BEEP_NO . .  D ADDR   0076H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   006AH   A 
WT_ZC_TOUT_START_H  D ADDR   0050H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
RTX_MDOUT. . . . .  N NUMB   00A4h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D7h            
PLATINUM_PRO_30A_~  N NUMB   009Bh            
TURNIGY_KFORCE_12~  N NUMB   0055h            
RD1. . . . . . . .  C ADDR   1D2AH   A 
PRO6 . . . . . . .  C ADDR   1D20H   A 
ABD. . . . . . . .  C ADDR   1C2BH   A 
FUNCTION_PARAVAL_~  C ADDR   17A4H   A 
STORE_NEW_VALUE_I~  C ADDR   170AH   A 
RUN2 . . . . . . .  C ADDR   1482H   A 
ARMING_PPM_CHECK .  C ADDR   123AH   A 
COMM45_NFET_OFF_R~  C ADDR   0E3BH   A 
COMM23_FETS_DONE .  C ADDR   0D81H   A 
COMP_READ_WRONG_T~  C ADDR   0C81H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0B7DH   A 
STORE_TIMES_EXIT .  C ADDR   0B48H   A 
GOVERNOR_CORR_INT~  C ADDR   0843H   A 
GOVERNOR_STORE_PR~  C ADDR   073DH   A 
DIV_U16_BY_U16_DI~  C ADDR   0688H   A 
WAIT200MS. . . . .  C ADDR   0615H   A 
T2_INT_RCP_GAIN_C~  C ADDR   025CH   A 
T2_INT_CURRENT_PW~  C ADDR   028CH   A 
T2_INT_PULSES_ABS~  C ADDR   01D7H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_MAIN_SPOOLUP_~  I ADDR   009FH   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0055H   A 
GOV_ACTIVE . . . .  N NUMB   0005h            
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D8h            
PLATINUM_PRO_30A_~  N NUMB   009Ch            
TURNIGY_AE_25A_TA~  N NUMB   0044h            
TURNIGY_PLUSH_60A~  N NUMB   0031h            
TURNIGY_PLUSH_10A~  N NUMB   0020h            
MAI1 . . . . . . .  C ADDR   1C7EH   A 
IN1. . . . . . . .  C ADDR   1C74H   A 
BAUDL. . . . . . .  D ADDR   0024H   A 
RUN3 . . . . . . .  C ADDR   14AFH   A 
GOVERNOR_LIMIT_IN~  C ADDR   082BH   A 
GOVERNOR_CHECK_IN~  C ADDR   0763H   A 
DIV_U16_BY_U16_DI~  C ADDR   069FH   A 
WAIT3MS. . . . . .  C ADDR   0601H   A 
T2_INT_PULSES_ABS~  C ADDR   020CH   A 
T0_INT_PWM_ON_TIM~  C ADDR   00EBH   A 
T0_INT_PWM_ON_SET~  C ADDR   00E9H   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0045H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
RCP_PPM_ONESHOT125  N NUMB   0005h            
DIR_CHANGE_BRAKE .  N NUMB   0003h            
DEMAG_ENABLED. . .  N NUMB   0004h            
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   0082h            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
POLARIS_THUNDER_1~  N NUMB   0097h            
SKYWALKER_20A_TAIL  N NUMB   0059h            
TURNIGY_AE_25A_MU~  N NUMB   0045h            
TURNIGY_PLUSH_25A~  N NUMB   0028h            
TURNIGY_PLUSH_10A~  N NUMB   0021h            
XP_7A_TAIL . . . .  N NUMB   0005h            
PUTP . . . . . . .  C ADDR   1D40H   A 
SETBUF . . . . . .  C ADDR   1CBFH   A 
MAI2 . . . . . . .  C ADDR   1CA0H   A 
ERRORCOMMAND . . .  N NUMB   00C1h            
BEEP_NO_ENTRY. . .  C ADDR   17CFH   A 
JMP_WAIT_FOR_POWE~  C ADDR   1623H   A 
DIRECT_START_CHEC~  C ADDR   155BH   A 
RUN4 . . . . . . .  C ADDR   14D0H   A 
COMM61_FETS_DONE .  C ADDR   0EB9H   A 
COMM23_NONDAMP_REV  C ADDR   0DC3H   A 
COMP_READ_OK_JMP .  C ADDR   0CB3H   A 
STORE_TIMES_UP_OR~  C ADDR   0B06H   A 
STORE_TIMES_DECRE~  C ADDR   0B19H   A 
CALC_NEXT_COMM_NE~  C ADDR   09E9H   A 
TEMP_AVERAGE_INC .  C ADDR   08F8H   A 
GOVERNOR_CORR_INT~  C ADDR   0854H   A 
MULT_S16_BY_U8_DI~  C ADDR   06AEH   A 
PCA_INT_PPM_NEG_C~  C ADDR   055BH   A 
T2_INT_EXIT. . . .  C ADDR   02E6H   A 
_EEP_PGM_DAMPING_~  C ADDR   1A16H   A 
PWM_DITHER_EXCESS~  D ADDR   0067H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   005Ah            
TURNIGY_AE_45A_TA~  N NUMB   004Ah            
TURNIGY_PLUSH_80A~  N NUMB   0034h            
TURNIGY_PLUSH_30A~  N NUMB   002Ch            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
XP_7A_MULTI. . . .  N NUMB   0006h            
PUT1 . . . . . . .  C ADDR   1D46H   A 
READ_TAGS. . . . .  C ADDR   16E8H   A 
RUN5 . . . . . . .  C ADDR   14F1H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0A5BH   A 
SET_PWM_LIMIT_HIG~  C ADDR   08A0H   A 
GOVERNOR_CORR_NEG~  C ADDR   0848H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0732H   A 
CALC_GOVERNOR_TAR~  C ADDR   0705H   A 
PCA_INT_PWM_DIVID~  C ADDR   05A2H   A 
PCA_INT_CHECK_12K~  C ADDR   040DH   A 
EEP_PGM_MOTOR_IDLE  C ADDR   1A08H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
CURRENT_PWM_LIMIT~  D ADDR   007CH   A 
BEEP_STRENGTH. . .  D ADDR   0073H   A 
RCP_PREV_PERIOD_H.  D ADDR   005AH   A 
WT_COMM_START_H. .  D ADDR   0052H   A 
WT_ZC_TOUT_START_L  D ADDR   004FH   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
F85_3A_MAIN. . . .  N NUMB   00D3h            
SKYWALKER_40A_TAIL  N NUMB   005Ch            
TURNIGY_AE_45A_MU~  N NUMB   004Bh            
TURNIGY_PLUSH_40A~  N NUMB   002Fh            
TURNIGY_PLUSH_30A~  N NUMB   002Dh            
TURNIGY_PLUSH_18A~  N NUMB   0025h            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
SUPERMICRO_3P5A_T~  N NUMB   001Ah            
PUT2 . . . . . . .  C ADDR   1D59H   A 
MAI4 . . . . . . .  C ADDR   1CD6H   A 
BAUDTIME . . . . .  N NUMB   0198h            
RUN6_CHECK_DIR_CH~  C ADDR   15A8H   A 
RUN6 . . . . . . .  C ADDR   1512H   A 
ARMING_START . . .  C ADDR   121AH   A 
MEASURE_PWM_FREQ_~  C ADDR   1196H   A 
COMM61_NONDAMP_REV  C ADDR   0EF9H   A 
COMM45_FETS_DONE .  C ADDR   0E1DH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0B85H   A 
PCA_INT_CHECK_LEG~  C ADDR   05B3H   A 
PCA_INT_FALL_NOT_~  C ADDR   04BFH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
_EEP_PGM_GOV_MODE.  C ADDR   1A05H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
PREV_PREV_COMM_H .  D ADDR   003CH   A 
RCP_UPDATED. . . .  N NUMB   0000h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
MUX_A1 . . . . . .  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Ah            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
FLYCOLOR_FAIRY_30~  N NUMB   00C7h            
ROTORGEEKS_20A_MA~  N NUMB   00C1h            
ALIGN_RCE_BL15P_M~  N NUMB   006Dh            
SKYWALKER_40A_MUL~  N NUMB   005Dh            
TURNIGY_KFORCE_12~  N NUMB   0056h            
TURNIGY_PLUSH_40A~  N NUMB   0030h            
SUPERMICRO_3P5A_M~  N NUMB   001Bh            
DP_3A_MAIN . . . .  N NUMB   0016h            
PUT3 . . . . . . .  C ADDR   1D65H   A 
MAI5 . . . . . . .  C ADDR   1D25H   A 
WAIT_FOR_LOW . . .  C ADDR   1C42H   A 
PARAH. . . . . . .    REG    R3             
ARM_TARGET_UPDATED  C ADDR   1300H   A 
EVALUATE_COMPARAT~  C ADDR   0CB8H   A 
COMP_WAIT_READ_CO~  C ADDR   0C48H   A 
TEMP_CHECK_EXIT. .  C ADDR   0922H   A 
GOVERNOR_APPLY_PR~  C ADDR   07D3H   A 
PWM_AFET_EXIT. . .  C ADDR   0162H   A 
PGM_ENABLE_PWM_IN~  I ADDR   00A2H   A 
_PGM_STARTUP_ACCEL  I ADDR   0090H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
CURRENT_PWM_LIM_D~  D ADDR   007DH   A 
GOV_INTEGRAL_L . .  D ADDR   0044H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0025h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
TURNIGY_KFORCE_12~  N NUMB   0057h            
TURNIGY_PLUSH_60A~  N NUMB   0032h            
PUT4 . . . . . . .  C ADDR   1D77H   A 
MAI6 . . . . . . .  C ADDR   1D36H   A 
CNTH . . . . . . .    REG    R7             
WRITE_EEPROM_BLOC~  C ADDR   168AH   A 
NORMAL_RUN_CHECKS.  C ADDR   1568H   A 
INIT_NO_SIGNAL . .  C ADDR   1118H   A 
COMM45_NONDAMP_REV  C ADDR   0E5FH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0BE0H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0AA9H   A 
CALC_NEW_WAIT_PER~  C ADDR   0A13H   A 
CALC_GOVERNOR_PRO~  C ADDR   0706H   A 
PCA_INT_PPM_UNIDI~  C ADDR   0555H   A 
T2_INT_PPM_TIMEOU~  C ADDR   0218H   A 
PWM_BFET_EXIT. . .  C ADDR   016CH   A 
T0_INT_PWM_OFF_EX~  C ADDR   0118H   A 
_EEP_PGM_GOV_I_GA~  C ADDR   1A04H   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
POLARIS_THUNDER_1~  N NUMB   0098h            
ALIGN_RCE_BL35P_M~  N NUMB   0073h            
TURNIGY_PLUSH_60A~  N NUMB   0033h            
TURNIGY_PLUSH_25A~  N NUMB   0029h            
POLYNOM. . . . . .  N NUMB   A001h            
WRITE_EEPROM_BLOC~  C ADDR   1698H   A 
PROGRAM_BY_TX_ENT~  C ADDR   12E7H   A 
READ_ALL_EEPROM_P~  C ADDR   1625H   A 
COMM23_NFET_DONE_~  C ADDR   0DD2H   A 
CALC_NEXT_COMM_NE~  C ADDR   09F2H   A 
PWM_CFET_EXIT. . .  C ADDR   0176H   A 
T0_INT . . . . . .  C ADDR   00B3H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A18H   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
SKIP_T2H_INT . . .  D ADDR   0078H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006BH   A 
RCP_STOP_CNT . . .  D ADDR   005FH   A 
NEW_RCP. . . . . .  D ADDR   005CH   A 
RCP_PREV_PERIOD_L.  D ADDR   0059H   A 
WT_COMM_START_L. .  D ADDR   0051H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
INITIAL_RUN_PHASE.  N NUMB   0002h            
HIGH_RPM . . . . .  N NUMB   0007h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00D0h            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0003h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
POLARIS_THUNDER_1~  N NUMB   0099h            
TURNIGY_PLUSH_80A~  N NUMB   0035h            
TURNIGY_PLUSH_25A~  N NUMB   002Ah            
INIT_START_BIDIR_~  C ADDR   1432H   A 
EVAL_COMP_EXIT . .  C ADDR   0CD6H   A 
PCA_INT_SET_TIMEO~  C ADDR   05D6H   A 
PWM_NOFET. . . . .  C ADDR   0158H   A 
T0_INT_PWM_ON_EXE~  C ADDR   00D7H   A 
EEP_PGM_PWM_DITHER  C ADDR   1A26H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
PREV_PREV_COMM_L .  D ADDR   003BH   A 
PREV_COMM_H. . . .  D ADDR   003AH   A 
RCP_DIR_REV. . . .  N NUMB   0006h            
RCP_TIMEOUT_CNT. .  D ADDR   002AH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0004h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
F85_3A_TAIL. . . .  N NUMB   00D4h            
FVT_LITTLEBEE_20A~  N NUMB   00CAh            
MDRX62H_MAIN . . .  N NUMB   00BEh            
TURNIGY_PLUSH_80A~  N NUMB   0036h            
TURNIGY_PLUSH_18A~  N NUMB   0026h            
XP_12A_MAIN. . . .  N NUMB   000Ah            
PUTW . . . . . . .  C ADDR   1D38H   A 
PARAL. . . . . . .    REG    R2             
BOOTLOADER_DONE. .  C ADDR   1128H   A 
AVERAGE_THROTTLE .  C ADDR   1049H   A 
DECODE_PARAMS_DIR~  C ADDR   0FA9H   A 
COMM61_NFET_DONE_~  C ADDR   0F08H   A 
SETUP_COMM_WAIT. .  C ADDR   0CD7H   A 
CALC_NEXT_COMM_TI~  C ADDR   0A5CH   A 
CHECK_VOLTAGE_LIM.  C ADDR   092DH   A 
CALC_GOVERNOR_INT~  C ADDR   079FH   A 
T2_INT . . . . . .  C ADDR   01ABH   A 
_PGM_DAMPING_FORCE  I ADDR   0093H   A 
AUTO_BAILOUT_ARMED  D ADDR   0060H   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
MOTOR_PPM_LOW_SLO~  N NUMB   002Bh            
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0002h            
CNFET. . . . . . .  N NUMB   0007h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
F85_3A_MULTI . . .  N NUMB   00D5h            
FVT_LITTLEBEE_30A~  N NUMB   00CDh            
FLYCOLOR_FAIRY_30~  N NUMB   00C8h            
ROTORGEEKS_20A_TA~  N NUMB   00C2h            
ALIGN_RCE_BL15P_T~  N NUMB   006Eh            
RCTIMER_6A_MAIN. .  N NUMB   0067h            
TURNIGY_PLUSH_NFE~  N NUMB   003Dh            
TURNIGY_PLUSH_18A~  N NUMB   0027h            
DP_3A_TAIL . . . .  N NUMB   0017h            
XP_7A_FAST_MAIN. .  N NUMB   0007h            
GET1 . . . . . . .  C ADDR   1D84H   A 
BYTE_REG . . . . .  D ADDR   0021H   A 
CNTL . . . . . . .    REG    R6             
STORE_TAIL_FUNC_1.  C ADDR   170EH   A 
ARM_END_BEEP . . .  C ADDR   1315H   A 
THROTTLE_HIGH_CAL~  C ADDR   1272H   A 
PGM_START. . . . .  C ADDR   1074H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0BC1H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0ABAH   A 
LOAD_MIN_TIME. . .  C ADDR   0A57H   A 
SET_STARTUP_PWM. .  C ADDR   0936H   A 
GOVERNOR_STORE_IN~  C ADDR   0799H   A 
T2H_INT_EXIT . . .  C ADDR   032DH   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   0337H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0075H   A 
ADC_CONVERSION_CNT  D ADDR   0070H   A 
GOV_ARM_TARGET . .  D ADDR   004AH   A 
RCP_PPM. . . . . .  N NUMB   0004h            
RCP_OUTSIDE_RANGE~  D ADDR   0029H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0005h            
ADC_LIMIT_L. . . .  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
GRAUPNER_ULTRA_20~  N NUMB   00D0h            
FLYCOLOR_FAIRY_30~  N NUMB   00C9h            
ROTORGEEKS_20A_MU~  N NUMB   00C3h            
EMAX_20A_MAIN. . .  N NUMB   00ACh            
TAROT_30A_MAIN . .  N NUMB   00A6h            
ALIGN_RCE_BL15P_M~  N NUMB   006Fh            
DP_3A_MULTI. . . .  N NUMB   0018h            
GET2 . . . . . . .  C ADDR   1D99H   A 
FUNC_PARAVAL . . .  C ADDR   17D2H   A 
WAIT1S_LOOP. . . .  C ADDR   1740H   A 
STORE_TAIL_FUNC_2.  C ADDR   1713H   A 
RUN6_CHECK_DIR_REV  C ADDR   15A3H   A 
AVERAGE_THROTTLE_~  C ADDR   1065H   A 
CALC_GOVERNOR_PRO~  C ADDR   07FCH   A 
GOVERNOR_INT_MIN_~  C ADDR   0794H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0739H   A 
BEEP_F1. . . . . .  C ADDR   0625H   A 
PCA_INT_PPM_OUTSI~  C ADDR   04F5H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   0071H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0064H   A 
PWM_LIMIT. . . . .  D ADDR   0061H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0006h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
ALIGN_RCE_BL35P_T~  N NUMB   0074h            
GET3 . . . . . . .  C ADDR   1DBDH   A 
STORE_TAIL_FUNC_3.  C ADDR   1718H   A 
INITIAL_RUN_PHASE~  C ADDR   1586H   A 
TEST_THROTTLE_GAIN  C ADDR   103AH   A 
COMM23_FETS_DONE_~  C ADDR   0DA1H   A 
CALC_NEXT_COMM_ST~  C ADDR   09BAH   A 
GOVERNOR_STORE_PR~  C ADDR   07FAH   A 
GOVERNOR_CHECK_PR~  C ADDR   07BEH   A 
MULT_S16_BY_U8_PO~  C ADDR   06C8H   A 
DIV_U16_BY_U16 . .  C ADDR   0676H   A 
BEEP_ONOFF . . . .  C ADDR   0643H   A 
BEEP_F2. . . . . .  C ADDR   062CH   A 
PCA_INT_PPM_BIDIR~  C ADDR   053CH   A 
PCA_INT_CHECK_DIFF  C ADDR   0481H   A 
T2_INT_SKIP_START.  C ADDR   021CH   A 
PWM_AFET . . . . .  C ADDR   015AH   A 
T0_INT_PWM_OFF_FU~  C ADDR   014AH   A 
EEP_PGM_ENABLE_PO~  C ADDR   1A24H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0014h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
PREV_COMM_L. . . .  D ADDR   0039H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
XROTOR_10A_MAIN. .  N NUMB   00B5h            
EMAX_40A_MAIN. . .  N NUMB   00AFh            
ALIGN_RCE_BL35P_M~  N NUMB   0075h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ah            
TURNIGY_KFORCE_70~  N NUMB   004Fh            
TURNIGY_KFORCE_40~  N NUMB   004Ch            
XP_25A_MAIN. . . .  N NUMB   0010h            
INIT . . . . . . .  C ADDR   1C00H   A 
PARAVAL_NO_ENTRY .  C ADDR   17CCH   A 
STORE_TAIL_FUNC_4.  C ADDR   171DH   A 
RUN6_BRAKE_DONE. .  C ADDR   15BCH   A 
SUCCESS_BEEP_INVE~  C ADDR   1775H   A 
SUCCESS_BEEP . . .  C ADDR   1746H   A 
FIND_THROTTLE_GAIN  C ADDR   1012H   A 
DECODE_SETTINGS. .  C ADDR   0FC7H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   15DAH   A 
TEMP_AVERAGE_INC_~  C ADDR   08E8H   A 
GOVERNOR_INT_MAX_~  C ADDR   078CH   A 
GOVERNOR_LIMIT_IN~  C ADDR   076CH   A 
BEEP_F3. . . . . .  C ADDR   0633H   A 
PCA_INT_FAIL_MINI~  C ADDR   039AH   A 
PWM_BFET . . . . .  C ADDR   0164H   A 
T0_INT_PWM_OFF_EX~  C ADDR   013DH   A 
_EEP_PGM_GOV_P_GA~  C ADDR   1A03H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0069H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
SKIP_DAMP_ON . . .  N NUMB   0006h            
P1_INIT. . . . . .  N NUMB   0002h            
RTX_SKIP . . . . .  N NUMB   00D4h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
FVT_LITTLEBEE_20A~  N NUMB   00CBh            
MDRX62H_TAIL . . .  N NUMB   00BFh            
XROTOR_20A_MAIN. .  N NUMB   00B8h            
PLATINUM_PRO_150A~  N NUMB   009Dh            
TURNIGY_PLUSH_NFE~  N NUMB   003Ah            
XP_12A_TAIL. . . .  N NUMB   000Bh            
UART_LOOP. . . . .  N NUMB   001Ah            
STORE_TAIL_FUNC_5.  C ADDR   1722H   A 
DAMPED_TRANSITION.  C ADDR   1457H   A 
BEEP_DELAY_SET . .  C ADDR   1350H   A 
PROGRAM_BY_TX_ENT~  C ADDR   1258H   A 
LOCK_BYTE_OK . . .  C ADDR   1093H   A 
AVERAGE_THROTTLE_~  C ADDR   1056H   A 
DECODE_PWM_FREQ_L~  C ADDR   0FC1H   A 
COMM61_FETS_DONE_~  C ADDR   0ED9H   A 
COMP_READ_WRONG_L~  C ADDR   0C8BH   A 
SET_PWM_LIMIT_LOW~  C ADDR   089DH   A 
BEEP_F4. . . . . .  C ADDR   063AH   A 
PCA_INT_PPM_MAX_C~  C ADDR   0582H   A 
PCA_INT_RESTORE_E~  C ADDR   046BH   A 
T2_INT_CURRENT_PW~  C ADDR   02CEH   A 
PWM_CFET . . . . .  C ADDR   016EH   A 
PGM_STARTUP_PWR_D~  I ADDR   00A6H   A 
_PGM_STARTUP_METH~  I ADDR   0095H   A 
_PGM_VOLT_COMP . .  I ADDR   0091H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0006h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
FVT_LITTLEBEE_30A~  N NUMB   00CEh            
FVT_LITTLEBEE_20A~  N NUMB   00CCh            
MDRX62H_MULTI. . .  N NUMB   00C0h            
H_KING_10A_MAIN. .  N NUMB   0079h            
ALIGN_RCE_BL35X_M~  N NUMB   0070h            
RCTIMER_6A_TAIL. .  N NUMB   0068h            
TURNIGY_PLUSH_NFE~  N NUMB   003Eh            
XP_18A_MAIN. . . .  N NUMB   000Dh            
XP_12A_MULTI . . .  N NUMB   000Ch            
XP_7A_FAST_TAIL. .  N NUMB   0008h            
PROGRAM_BY_TX_EXIT  C ADDR   1833H   A 
STORE_TAIL_FUNC_6.  C ADDR   1727H   A 
READ_EEPROM_BYTE .  C ADDR   16A9H   A 
THROTTLE_LOW_CAL .  C ADDR   12ACH   A 
COMP_READ_WRONG. .  C ADDR   0C54H   A 
STORE_TIMES_UP_OR~  C ADDR   0B69H   A 
STORE_TIMES_DECRE~  C ADDR   0B76H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0900H   A 
SET_PWM_LIMIT_HIG~  C ADDR   08B1H   A 
GOVERNOR_APPLY_IN~  C ADDR   082FH   A 
GOVERNOR_LIMIT_PR~  C ADDR   07C9H   A 
BEEP_OFF . . . . .  C ADDR   066CH   A 
WAIT10MS . . . . .  C ADDR   0606H   A 
T2_INT_CURRENT_PW~  C ADDR   02ACH   A 
PWM_AFET_DAMPED_E~  C ADDR   0187H   A 
T0_INT_PWM_ON_EXIT  C ADDR   00D9H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Eh            
PGM_PWM_DITHER . .  I ADDR   00A3H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0074H   A 
INITIAL_RUN_ROT_C~  D ADDR   0034H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
GRAUPNER_ULTRA_20~  N NUMB   00D1h            
FVT_LITTLEBEE_30A~  N NUMB   00CFh            
XROTOR_40A_MAIN. .  N NUMB   00BBh            
EMAX_20A_TAIL. . .  N NUMB   00ADh            
TAROT_30A_TAIL . .  N NUMB   00A7h            
H_KING_20A_MAIN. .  N NUMB   007Ch            
RCTIMER_6A_MULTI .  N NUMB   0069h            
HIMODEL_COOL_22A_~  N NUMB   005Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0037h            
XP_7A_FAST_MULTI .  N NUMB   0009h            
GETW . . . . . . .  C ADDR   1D7BH   A 
STORE_TAIL_FUNC_7.  C ADDR   172CH   A 
READ_TAG . . . . .  C ADDR   16F1H   A 
RESET_CAL_DONE . .  C ADDR   10B9H   A 
DECODE_PARAMETERS.  C ADDR   0F8EH   A 
COMM45_FETS_DONE_~  C ADDR   0E3DH   A 
COMM23_NFET_OFF. .  C ADDR   0D7FH   A 
STORE_TIMES_INCRE~  C ADDR   0B0CH   A 
MEASURE_LIPO_CELLS  C ADDR   08B6H   A 
CALC_GOVERNOR_INT~  C ADDR   0742H   A 
PCA_INT_PPM_CALCU~  C ADDR   051EH   A 
PCA_INT_EXIT . . .  C ADDR   05EAH   A 
T2_INT_RCP_UPDATE~  C ADDR   0244H   A 
PWM_BFET_DAMPED_E~  C ADDR   0198H   A 
RCP_PERIOD_DIFF_A~  D ADDR   005BH   A 
COMPARATOR_READ_C~  D ADDR   0041H   A 
STARTUP_CNT. . . .  D ADDR   0033H   A 
PWM_TIMER0_OVERFL~  N NUMB   0003h            
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
GRAUPNER_ULTRA_20~  N NUMB   00D2h            
EMAX_20A_MULTI . .  N NUMB   00AEh            
TAROT_30A_MULTI. .  N NUMB   00A8h            
HIMODEL_COOL_41A_~  N NUMB   0064h            
TURNIGY_PLUSH_6A_~  N NUMB   001Ch            
GETX . . . . . . .  C ADDR   1D89H   A 
STORE_TAIL_FUNC_8.  C ADDR   1731H   A 
RUN6_CHECK_SPEED .  C ADDR   15B2H   A 
WAIT_FOR_POWER_ON~  C ADDR   1379H   A 
SWITCH_POWER_OFF .  C ADDR   0F10H   A 
COMP_READ_WRONG_N~  C ADDR   0C6BH   A 
CALC_NEW_WAIT_PER~  C ADDR   0A2FH   A 
WAIT30MS . . . . .  C ADDR   060BH   A 
PCA_INT_PPM_BIDIR~  C ADDR   0573H   A 
PCA_INT_CHECK_1KHZ  C ADDR   045AH   A 
T2H_INT. . . . . .  C ADDR   02F3H   A 
PWM_CFET_DAMPED_E~  C ADDR   01A9H   A 
MOTOR_PWM_REMAP. .  C ADDR   00A8H   A 
GOV_INTEGRAL_X . .  D ADDR   0046H   A 
COMP_TIMED_OUT . .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   000Ch            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
XROTOR_10A_TAIL. .  N NUMB   00B6h            
EMAX_40A_TAIL. . .  N NUMB   00B0h            
EAZY_3AV2_MAIN . .  N NUMB   00A3h            
ALIGN_RCE_BL15X_T~  N NUMB   006Bh            
HIMODEL_COOL_33A_~  N NUMB   0061h            
TURNIGY_KFORCE_70~  N NUMB   0050h            
TURNIGY_KFORCE_40~  N NUMB   004Dh            
XP_25A_TAIL. . . .  N NUMB   0011h            
RST. . . . . . . .  C ADDR   1CBDH   A 
SUCCESS. . . . . .  N NUMB   0030h            
BOOT_VERSION . . .  N NUMB   0006h            
XTAL . . . . . . .  N NUMB   17D7840h            
FUNC_PARAVAL_CONT~  C ADDR   17FFH   A 
STORE_TAIL_FUNC_9.  C ADDR   1736H   A 
WRITE_TAGS . . . .  C ADDR   16FBH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   15E2H   A 
WAIT1S . . . . . .  C ADDR   173EH   A 
COMM61_NFET_OFF. .  C ADDR   0EB7H   A 
EVAL_COMP_CHECK_T~  C ADDR   0CC6H   A 
COMP_WAIT_ON_COMP~  C ADDR   0C15H   A 
ADJUST_TIMING_TWO~  C ADDR   0AF3H   A 
INITIALIZE_TIMING.  C ADDR   0956H   A 
CHECK_VOLTAGE_RET.  C ADDR   0935H   A 
WAITXMS_M. . . . .  C ADDR   061CH   A 
PCA_INT_CHECK_2KHZ  C ADDR   0449H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
WT_ADV_START_H . .  D ADDR   004CH   A 
GOV_TARGET_H . . .  D ADDR   0043H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
XROTOR_20A_TAIL. .  N NUMB   00B9h            
XROTOR_10A_MULTI .  N NUMB   00B7h            
EMAX_40A_MULTI . .  N NUMB   00B1h            
SKYIII_30A_MAIN. .  N NUMB   00A9h            
PLATINUM_PRO_150A~  N NUMB   009Eh            
POLARIS_THUNDER_2~  N NUMB   0088h            
H_KING_50A_MAIN. .  N NUMB   0082h            
GAUI_GE_183_18A_M~  N NUMB   0076h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ch            
TURNIGY_KFORCE_70~  N NUMB   0051h            
TURNIGY_KFORCE_40~  N NUMB   004Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Bh            
XP_25A_MULTI . . .  N NUMB   0012h            
EXIT . . . . . . .  C ADDR   1CB4H   A 
BOOT_MSG . . . . .  C ADDR   1DDCH   A 
READ_INITIAL_TEMP.  C ADDR   13D2H   A 
WAIT_FOR_POWER_ON~  C ADDR   136DH   A 
DECODE_PWM_FREQ_E~  C ADDR   0FC6H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0D2DH   A 
START_ADC_CONVERS~  C ADDR   08BAH   A 
MULT_S16_BY_U8_EX~  C ADDR   06FCH   A 
PCA_INT_PPM_LIMIT~  C ADDR   0594H   A 
GET_RCP_END. . . .  C ADDR   0371H   A 
T2H_INT_RCP_GOV_P~  C ADDR   032DH   A 
T2_INT_PWM_MIN_RUN  C ADDR   026CH   A 
PWM_DITHER_TABLE .  C ADDR   009AH   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
PGM_ENABLE_POWER_~  I ADDR   00A1H   A 
PWM_DITHER_DECODED  D ADDR   0066H   A 
PWM_LIMIT_BY_RPM .  D ADDR   0063H   A 
LOW_RPM_PWR_SLOPE.  D ADDR   0038H   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   000Ch            
HIGH_BEC_VOLTAGE .  N NUMB   0000h            
PSW. . . . . . . .  D ADDR   00D0H   A 
XROTOR_20A_MULTI .  N NUMB   00BAh            
PLATINUM_PRO_150A~  N NUMB   009Fh            
POLARIS_THUNDER_3~  N NUMB   008Bh            
POLARIS_THUNDER_1~  N NUMB   0085h            
H_KING_10A_TAIL. .  N NUMB   007Ah            
ALIGN_RCE_BL35X_T~  N NUMB   0071h            
TURNIGY_PLUSH_NFE~  N NUMB   003Ch            
XP_18A_TAIL. . . .  N NUMB   000Eh            
WAITF. . . . . . .  C ADDR   1DC9H   A 
BOOT_BAUDRATE. . .  N NUMB   4B00h            
STORE_IN_RAM_EXIT.  C ADDR   173BH   A 
VALIDATE_RCP_START  C ADDR   11F7H   A 
LOCK_BYTE_TEST . .  C ADDR   108CH   A 
COMM45_NFET_OFF. .  C ADDR   0E1BH   A 
COMM12_REV . . . .  C ADDR   0D52H   A 
COMM1COMM2 . . . .  C ADDR   0D3EH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0B87H   A 
TEMP_AVERAGE_UPDA~  C ADDR   08FEH   A 
TEMP_AVERAGE_DEC .  C ADDR   08F4H   A 
CALC_GOVERNOR_PRO~  C ADDR   07A0H   A 
WAITXMS_O. . . . .  C ADDR   061AH   A 
PCA_INT_PPM_TIMEO~  C ADDR   05DFH   A 
PCA_INT_CHECK_4KHZ  C ADDR   0438H   A 
T0_INT_PWM_OFF . .  C ADDR   00FAH   A 
T0_INT_START . . .  C ADDR   00C0H   A 
TX_PGM_PARAMS_TAIL  C ADDR   009FH   A 
EEPROM_FW_SUB_REV~  N NUMB   0003h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0048H   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
XROTOR_40A_TAIL. .  N NUMB   00BCh            
POLARIS_THUNDER_4~  N NUMB   008Eh            
H_KING_20A_TAIL. .  N NUMB   007Dh            
H_KING_10A_MULTI .  N NUMB   007Bh            
ALIGN_RCE_BL35X_M~  N NUMB   0072h            
HIMODEL_COOL_22A_~  N NUMB   005Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0038h            
XP_18A_MULTI . . .  N NUMB   000Fh            
PUTC . . . . . . .  C ADDR   1D5CH   A 
BIT_REG. . . . . .  D ADDR   0020H   A 
CMDH . . . . . . .    REG    R5             
READ_EEPROM_EXIT .  C ADDR   1666H   A 
WAIT_FOR_POWER_ON~  C ADDR   132DH   A 
INPUT_HIGH_CHECK_1  C ADDR   111CH   A 
CHECK_VOLTAGE_STA~  C ADDR   0926H   A 
SET_PWM_LIMIT_LOW~  C ADDR   0859H   A 
CALC_GOVERNOR_INT~  C ADDR   0858H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0775H   A 
MULT_S16_BY_U8_DI~  C ADDR   06E1H   A 
BEEP . . . . . . .  C ADDR   0641H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0541H   A 
PCA_INT_FALL . . .  C ADDR   049CH   A 
T2_INT_PWM_EXIT. .  C ADDR   02DDH   A 
T2_INT_SKIP_END. .  C ADDR   0227H   A 
EEP_PGM_TEMP_PROT~  C ADDR   1A23H   A 
_EEP_PGM_THROTTLE~  C ADDR   1A1EH   A 
_EEP_PGM_STARTUP_~  C ADDR   1A12H   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A5H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006CH   A 
COMM_PHASE . . . .  D ADDR   0040H   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
XROTOR_40A_MULTI .  N NUMB   00BDh            
EMAX_NANO_20A_MAIN  N NUMB   00B2h            
PLATINUM_50AV3_MA~  N NUMB   00A0h            
H_KING_35A_MAIN. .  N NUMB   007Fh            
H_KING_20A_MULTI .  N NUMB   007Eh            
HIMODEL_COOL_41A_~  N NUMB   0065h            
HIMODEL_COOL_22A_~  N NUMB   0060h            
TURNIGY_PLUSH_NFE~  N NUMB   0039h            
TURNIGY_PLUSH_6A_~  N NUMB   001Dh            
WAITH. . . . . . .  C ADDR   1DCDH   A 
ERASE_FLASH. . . .  C ADDR   16C2H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   15E5H   A 
PROGRAM_BY_TX. . .  C ADDR   17C3H   A 
INPUT_HIGH_CHECK_2  C ADDR   111EH   A 
COMM23_NONDAMP . .  C ADDR   0DA9H   A 
COMM2COMM3 . . . .  C ADDR   0D63H   A 
CALC_NEXT_COMM_AV~  C ADDR   09D6H   A 
GOVERNOR_STORE_IN~  C ADDR   0856H   A 
GOVERNOR_CHECK_IN~  C ADDR   0818H   A 
GOVERNOR_CORR_PRO~  C ADDR   07E7H   A 
T2_INT_START . . .  C ADDR   01C7H   A 
PWM_AFET_DAMPED. .  C ADDR   0178H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
NEXT_WT_START_H. .  D ADDR   0054H   A 
WT_ADV_START_L . .  D ADDR   004BH   A 
GOV_TARGET_L . . .  D ADDR   0042H   A 
DEMAG_PWR_OFF_THR~  D ADDR   0037H   A 
FLAGS0 . . . . . .  D ADDR   002CH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
EAZY_3AV2_TAIL . .  N NUMB   00A4h            
POLARIS_THUNDER_6~  N NUMB   0091h            
HIMODEL_COOL_41A_~  N NUMB   0066h            
HIMODEL_COOL_33A_~  N NUMB   0062h            
TURNIGY_AE_20A_MA~  N NUMB   0040h            
TURNIGY_PLUSH_6A_~  N NUMB   001Eh            
XP_35A_SW_MAIN . .  N NUMB   0013h            
ID1. . . . . . . .  C ADDR   1C47H   A 
FUNC_PARAVAL_STORE  C ADDR   17F2H   A 
WRITE_EEPROM_BYTE~  C ADDR   16AEH   A 
READ_EEPROM_BLOCK1  C ADDR   164EH   A 
READ_EEPROM_READ .  C ADDR   1647H   A 
COMM23_DAMP_REV. .  C ADDR   0D89H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B49H   A 
LOAD_MIN_TIME_FAST  C ADDR   0AA2H   A 
MEASURE_LIPO_EXIT.  C ADDR   08B9H   A 
GOVERNOR_LIMIT_PR~  C ADDR   07CFH   A 
GOVERNOR_CHECK_PR~  C ADDR   0726H   A 
PCA_INT_SECOND_ME~  C ADDR   03C3H   A 
T2H_INT_RCP_STOP_~  C ADDR   0310H   A 
PWM_BFET_DAMPED. .  C ADDR   0189H   A 
PCA_INT. . . . . .  C ADDR   0351H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
FLAGS1 . . . . . .  D ADDR   002DH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C4h            
SKYIII_30A_TAIL. .  N NUMB   00AAh            
EAZY_3AV2_MULTI. .  N NUMB   00A5h            
POLARIS_THUNDER_2~  N NUMB   0089h            
H_KING_50A_TAIL. .  N NUMB   0083h            
GAUI_GE_183_18A_T~  N NUMB   0077h            
HIMODEL_COOL_33A_~  N NUMB   0063h            
TURNIGY_AE_30A_MA~  N NUMB   0046h            
BOOT_INFO. . . . .  C ADDR   1DE0H   A 
ERRORVERIFY. . . .  N NUMB   00C0h            
READ_EEPROM_BLOCK2  C ADDR   165CH   A 
MEASURE_PWM_FREQ_~  C ADDR   1194H   A 
COMM61_NONDAMP . .  C ADDR   0EE0H   A 
COMM6COMM1 . . . .  C ADDR   0E9BH   A 
COMM34_REV . . . .  C ADDR   0DEEH   A 
COMM3COMM4 . . . .  C ADDR   0DDAH   A 
COMP_WAIT_NO_OF_R~  C ADDR   0C04H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0BD2H   A 
GOVERNOR_CORR_PRO~  C ADDR   07F8H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0535H   A 
PCA_INT_CHECK_8KHZ  C ADDR   0427H   A 
T2_INT_CURRENT_PW~  C ADDR   02C5H   A 
PWM_CFET_DAMPED. .  C ADDR   019AH   A 
_EEP_PGM_MAIN_SPO~  C ADDR   1A22H   A 
_EEP_PGM_LOW_VOLT~  C ADDR   1A06H   A 
DAMPINGFET . . . .  D ADDR   007BH   A 
WT_ZC_SCAN_START_H  D ADDR   004EH   A 
GOV_PROP_PWM . . .  D ADDR   0049H   A 
GOV_PROPORTIONAL_L  D ADDR   0047H   A 
FLAGS2 . . . . . .  D ADDR   002EH   A 
DEMAG_DETECTED . .  N NUMB   0005h            
RCP_SKIP_CNT . . .  D ADDR   002BH   A 
CURRENT_PWM_LIM_D~  D ADDR   0026H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
MCU_48MHZ. . . . .  N NUMB   0001h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
SKYIII_30A_MULTI .  N NUMB   00ABh            
POLARIS_THUNDER_8~  N NUMB   0094h            
POLARIS_THUNDER_3~  N NUMB   008Ch            
POLARIS_THUNDER_2~  N NUMB   008Ah            
POLARIS_THUNDER_1~  N NUMB   0086h            
H_KING_50A_MULTI .  N NUMB   0084h            
GAUI_GE_183_18A_M~  N NUMB   0078h            
TURNIGY_KFORCE_12~  N NUMB   0052h            
XP_3A_MAIN . . . .  N NUMB   0001h            



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6671    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =    103    ----
   IDATA SIZE       =     87    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
