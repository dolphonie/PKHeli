MACRO ASSEMBLER BLHELI                                      12/30/15 18:06:56 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\XROTOR_40A_REV14_3.OBJ
ASSEMBLER INVOKED BY: PRINT SET(BESCNO=187) OBJECT(OUTPUT\XROTOR_40A_REV14_3.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ;
                         4     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                         5     ;
                         6     ; Copyright 2011, 2012 Steffen Skaug
                         7     ; This program is distributed under the terms of the GNU General Public License
                         8     ;
                         9     ; This file is part of BLHeli.
                        10     ;
                        11     ; BLHeli is free software: you can redistribute it and/or modify
                        12     ; it under the terms of the GNU General Public License as published by
                        13     ; the Free Software Foundation, either version 3 of the License, or
                        14     ; (at your option) any later version.
                        15     ;
                        16     ; BLHeli is distributed in the hope that it will be useful,
                        17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        19     ; GNU General Public License for more details.
                        20     ;
                        21     ; You should have received a copy of the GNU General Public License
                        22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                        23     ;
                        24     ;**** **** **** **** ****
                        25     ;
                        26     ; The software was initially designed for use with Eflite mCP X, but is now adapted to copters/planes in general
                        27     ;
                        28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.versanet.de/~bkonze/blc_6a/blc_6a.htm
                        29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                        30     ;
                        31     ; This file is best viewed with tab width set to 5
                        32     ;
                        33     ; The input signal can be positive 1kHz, 2kHz, 4kHz, 8kHz or 12kHz PWM (e.g. taken from the "resistor tap" on mCPx)
                        34     ; And the input signal can be PPM (1-2ms) or OneShot125 (125-250us) at rates up to several hundred Hz.
                        35     ; The code autodetects the various input modes/frequencies
                        36     ; The code can also be programmed to accept inverted input signal.
                        37     ;
                        38     ; The first lines of the software must be modified according to the chosen environment:
                        39     ; Uncomment the selected ESC and main/tail/multi mode
                        40     ; BESCNO EQU "ESC"_"mode" 						
                        41     ; 
                        42     ;**** **** **** **** ****
                        43     ; Revision history:
                        44     ; - Rev1.0: Initial revision based upon BLHeli for AVR controllers
                        45     ; - Rev2.0: Changed "Eeprom" initialization, layout and defaults
                        46     ;           Various changes and improvements to comparator reading. Now using timer1 for time from pwm on/off
                        47     ;           Beeps are made louder
                        48     ;           Added programmable low voltage limit
                        49     ;           Added programmable damped tail mode (only for 1S ESCs)
                        50     ;           Added programmable motor rotation direction
                        51     ; - Rev2.1: (minor changes by 4712)
                        52     ;		  Added Disable TX Programming by PC Setup Application 
                        53     ;		  therfore changed EEPROM_LAYOUT_REVISION = 8					
                        54     ;		  Added Vdd Monitor as reset source when writing to "EEProm"
                        55     ;		  Changed for use of batch file to assemble, link and make hex files	
                        56     ; - Rev2.2: (minor changes by 4712)
                        57     ;           Added Disable Throttle Re-Arming every motor start by PC Setup Application 
                        58     ; - Rev2.3: (minor changes by 4712)
                        59     ;           Added bugfixed (2x CLR C before j(n)c operations)thx Steffen!			
                        60     ; - Rev2.4: Revisions 2.1 to 2.3 integrated
                        61     ; - Rev3.0: Added PPM (1050us-1866us) as accepted input signal
                        62     ;           Added startup rpm as a programming parameter
                        63     ;           Added startup acceleration as a programming parameter
                        64     ;           Added option for using voltage measurements to compensate motor power
                        65     ;           Added governor target by setup as a governor mode option
                        66     ;           Governor is kept active regardless of rpm
                        67     ;           Smooth governor spoolup/down in arm and setup modes
                        68     ;           Increased governor P and I gain programming ranges
                        69     ;           Increased and changed low voltage limit programming range
                        70     ;           Disabled tx programming entry for all but the first arming sequence after power on
                        71     ;           Made it possible to skip parameters in tx programming by setting throttle midstick
                        72     ;           Made it default not to rearm for every restart
                        73     ; - Rev3.1: Fixed bug that prevented chosen parameter to be set in tx programming
                        74     ; - Rev3.2: ...also updated the EEPROM revision parameter
                        75     ; - Rev3.3: Fixed negative number bug in voltage compensation
                        76     ;           Fixed bug in startup power calculation for non-default power
                        77     ;           Prevented possibility for voltage compensation fighting low voltage limiting
                        78     ;           Applied overall spoolup control to ensure soft spoolup in any mode
                        79     ;           Added a delay of 3 seconds from initiation of main motor stop until new startup is allowed
                        80     ;           Reduced beep power to reduce power consumption for very strong motors/ESCs
                        81     ; - Rev3.4: Fixed bug that prevented full power in governor arm and setup modes
                        82     ;           Increased NFETON_DELAY for XP_7A and XP_12A to allow for more powerful fets
                        83     ;           Increased initial spoolup power, and linked to startup power
                        84     ; - Rev4.0: Fixed bug that made tail tx program beeps very weak
                        85     ;           Added thermal protection feature
                        86     ;           Governor P and I gain ranges are extended up to 8.0x gain
                        87     ;           Startup sequence is aborted upon zero throttle
                        88     ;           Avoided voltage compensation function induced latency for tail when voltage compensation is not enabled
                        89     ;           Improved input signal frequency detection robustness
                        90     ; - Rev4.1: Increased thermal protection temperature limits
                        91     ; - Rev5.0: Added multi(copter) operating mode. TAIL define changed to MODE with three modes: MAIN, TAIL and MULTI
                        92     ;           Added programmable commutation timing
                        93     ;           Added a damped light mode that has less damping, but that can be used with all escs
                        94     ;           Added programmable damping force
                        95     ;           Added thermal protection for startup too
                        96     ;           Added wait beeps when waiting more than 30 sec for throttle above zero (after having been armed)
                        97     ;           Modified tail idling to provide option for very low speeds
                        98     ;           Changed PPM range to 1150-1830us
                        99     ;           Arming sequence is dropped for PPM input, unless it is governor arm mode
                       100     ;           Loss of input signal will immediately stop the motor for PPM input
                       101     ;           Bug corrected in Turnigy Plush 6A voltage measurement setup
                       102     ;           FET switching delays are set for original fets. Stronger/doubled/tripled etc fets may require faster pfet off switching
                       103     ;           Miscellaneous other changes
                       104     ; - Rev6.0: Reverted comparator reading routine to rev5.0 equivalent, in order to avoid tail motor stops
                       105     ;           Added governor range programmability
                       106     ;           Implemented startup retry sequence with varying startup power for multi mode
                       107     ;           In damped light mode, damping is now applied to the active nfet phase for fully damped capable ESCs
                       108     ; - Rev6.1: Added input signal qualification criteria for PPM, to avoid triggering on noise spikes (fix for plush hardware)
                       109     ;           Changed main and multi mode stop criteria. Will now be in run mode, even if RC pulse input is zero
                       110     ;           Fixed bug in commutation that caused rough running in damped light mode
                       111     ;           Miscellaneous other changes
                       112     ; - Rev7.0  Added direct startup mode programmability
                       113     ;           Added throttle calibration. Min>=1000us and Max<=2000us. Difference must be >520us, otherwise max is shifted so that difference=520us
                       114     ;           Added programmable throttle change rate
                       115     ;           Added programmable beep strength, beacon strength and beacon delay
                       116     ;           Reduced power step to full power significantly
                       117     ;           Miscellaneous other changes
                       118     ; - Rev8.0  Added a 2 second delay after power up, to wait for receiver initialization
                       119     ;           Added a programming option for disabling low voltage limit, and made it default for MULTI
                       120     ;           Added programable demag compensation, using the concept of SimonK
                       121     ;           Improved robustness against noisy input signal
                       122     ;           Refined direct startup
                       123     ;           Removed voltage compensation
                       124     ;           Miscellaneous other changes
                       125     ; - Rev9.0  Increased programming range for startup power, and made its default ESC dependent
                       126     ;           Made default startup method ESC dependent
                       127     ;           Even more smooth and gentle spoolup for MAIN, to suit larger helis
                       128     ;           Improved transition from stepped startup to run
                       129     ;           Refined direct startup
                       130     ; - Rev9.1  Fixed bug that changed FW revision after throttle calibration or TX programming
                       131     ; - Rev9.2  Altered timing of throttle calibration in order to work with MultiWii calibration firmware
                       132     ;           Reduced main spoolup time to around 5 seconds
                       133     ;           Changed default beacon delay to 3 minutes
                       134     ; - Rev9.3  Fixed bug in Plush 60/80A temperature reading, that caused failure in operation above 4S
                       135     ;           Corrected temperature limit for HiModel cool 22/33/41A, RCTimer 6A, Skywalker 20/40A, Turnigy AE45A, Plush 40/60/80A. Limit was previously set too high
                       136     ; - Rev9.4  Improved timing for increased maximum rpm limit
                       137     ; - Rev10.0 Added closed loop mode for multi
                       138     ;           Added high/low BEC voltage option (for the ESCs where HW supports it)
                       139     ;           Added method of resetting all programmed parameter values to defaults by TX programming
                       140     ;           Added Turnigy K-force 40A and Turnigy K-force 120A HV ESCs
                       141     ;           Enabled fully damped mode for several ESCs
                       142     ;           Extended startup power range downwards to enable very smooth start for large heli main motors
                       143     ;           Extended damping force with a highest setting
                       144     ;           Corrected temperature limits for F310 chips (Plush 40A and AE 45A)
                       145     ;           Implemented temperature reading average in order to avoid problems with ADC noise on Skywalkers
                       146     ;           Increased switching delays for XP 7A fast, in order to avoid cross conduction of N and P fets
                       147     ;           Miscellaneous other changes
                       148     ; - Rev10.1 Relaxed RC signal jitter requirement during frequency measurement
                       149     ;           Corrected bug that prevented using governor low
                       150     ;           Enabled vdd monitor always, in order to reduce likelihood of accidental overwriting of adjustments
                       151     ;           Fixed bug that caused stop for PPM input above 2048us, and moved upper accepted limit to 2160us
                       152     ; - Rev10.2 Corrected temperature limit for AE20-30/XP7-25, where limit was too high
                       153     ;           Corrected temperature limit for 120HV, where limit was too low
                       154     ;           Fixed bug that caused AE20/25/30A not to run in reverse
                       155     ; - Rev10.3 Removed vdd monitor for 1S capable ESCs, in order to avoid brownouts/resets
                       156     ;           Made auto bailout spoolup for main more smooth
                       157     ; - Rev10.4 Ensured that main spoolup and governor activation will always be smooth, regardless of throttle input
                       158     ;           Added capability to operate on 12kHz input signal too
                       159     ; - Rev11.0 Fixed bug of programming default values for governor in MULTI mode
                       160     ;           Disabled interrupts explicitly some places, to avoid possibilities for unintentional fet switching
                       161     ;           Changed interrupt disable strategy, to always allow pwm interrupts, to avoid noise when running at low rpms
                       162     ;           Added governor middle range for MAIN mode
                       163     ;           Added bidirectional mode for TAIL and MULTI mode with PPM input
                       164     ;           Changed and improved demag compensation
                       165     ;           Miscellaneous other changes
                       166     ; - Rev11.1 Fixed bug of slow acceleration response for MAIN mode running without governor
                       167     ;           Fixed bug with PWM input, where throttle remains high even when zeroing throttle (seen on V922 tail)
                       168     ;           Fixed bug in bidirectional operation, where direction change could cause reset
                       169     ;           Improved autorotation bailout for MAIN
                       170     ;           Reduced min speed back to 1220 erpm
                       171     ;           Misc code cleanups
                       172     ; - Rev11.2 Fixed throttle calibration bug
                       173     ;           Added high side driver precharge for all-nfet ESCs
                       174     ;           Optimized timing in general and for demag compensation in particular
                       175     ;           Auto bailout functionality modified
                       176     ;           Governor is deactivated for throttle inputs below 10%
                       177     ;           Increased beacon delay times
                       178     ; - Rev12.0 Added programmable main spoolup time
                       179     ;           Added programmable temperature protection enable
                       180     ;           Bidirectional mode stop/start improved. Motor is now stopped before starting
                       181     ;           Power is limited for very low rpms (when BEMF is low), in order to avoid sync loss 
                       182     ;           Damped light mode is made more smooth and quiet, particularly at low and high rpms
                       183     ;           Comparator signal qualification scheme is changed
                       184     ;           Demag compensation scheme is significantly changed
                       185     ;           Increased jitter tolerance for PPM frequency measurement
                       186     ;           Fully damped mode removed, and damped light only supported on damped capable ESCs
                       187     ;           Default tail mode changed to damped light
                       188     ;           Miscellaneous other changes
                       189     ; - Rev12.1 Fixed bug in tail code
                       190     ;           Improved startup for Atmel
                       191     ;           Added support for multiple high BEC voltages
                       192     ;           Added support for RPM output
                       193     ; - Rev12.2 Improved running smoothness, particularly for damped light
                       194     ;           Avoiding lockup at full throttle when input signal is noisy
                       195     ;           Avoiding detection of 1-wire programming signal as valid throttle signal
                       196     ; - Rev13.0 Removed stepped start
                       197     ;           Removed throttle change rate and damping force parameters
                       198     ;           Added support for OneShot125
                       199     ;           Improved commutation timing accuracy
                       200     ; - Rev13.1 Removed startup ramp for MULTI
                       201     ;           Improved startup for some odd ESCs
                       202     ; - Rev13.2 Still tweaking startup to make it more reliable and faster for all ESC/motor combos
                       203     ;           Increased deadband for bidirectional operation
                       204     ;           Relaxed signal detection criteria
                       205     ;           Added support for running 48MHz capable SiLabs MCUs at 48MHz
                       206     ;           Added bootlader to SiLabs code
                       207     ;           Miscellaneous other changes
                       208     ; - Rev14.0 Improved running at high timing
                       209     ;           Improved running at high RPMs and increased max RPM limit
                       210     ;           Avoid being locked in bootloader (implemented in Suite 13202)
                       211     ;           Improved reliability of 3D (bidirectional) mode and startup
                       212     ;           Smoother running and greatly reduced step to full power in damped light mode
                       213     ;           Removed low voltage limiting for MULTI
                       214     ;           Added pwm dither parameter
                       215     ;           Added setting for enable/disable of low RPM power protection
                       216     ;           Added setting for enable/disable of PWM input
                       217     ;           Better AFW and damping for some ESCs (that have a slow high side driver)
                       218     ;           Miscellaneous other changes
                       219     ; - Rev14.1 Fixed max throttle calibration bug (for non-oneshot)
                       220     ;           Fixed some closed loop mode bugs
                       221     ;           Relaxed signal jitter requirement for looptimes below 1000
                       222     ;           Added skipping of damping fet switching near max power, for improved high end throttle linearity, using the concept of SimonK
                       223     ;           Improved sync hold at high rpms
                       224     ; - Rev14.2 Added stalled motor shutoff after about 10 seconds (for tail and multi code with PPM input)
                       225     ;           Greatly increased maximum rpm limit, and added rpm limiting at 250k erpm (48MHz MCUs at 400k erpm)
                       226     ;           Improved bidirectional operation
                       227     ; - Rev14.3 Moved reset vector to be just before the settings segment, in order to better recover from partially failed flashing operation
                       228     ;           Added 100ms intialization delay for the Graupner Ultra 20A ESC
                       229     ;           Shortened stall detect time to about 5sec, and prevented going into tx programming after a stall
                       230     ;           Optimizations of software timing and running reliability
                       231     ;
                       232     ;           
                       233     ;
                       234     ;**** **** **** **** ****
                       235     ; Up to 8K Bytes of In-System Self-Programmable Flash
                       236     ; 768 Bytes Internal SRAM
                       237     ;
                       238     ;**** **** **** **** ****
                       239     ; Master clock is internal 24MHz oscillator
                       240     ; Timer 0 (167/500ns counts) always counts up and is used for
                       241     ; - PWM generation
                       242     ; Timer 1 (167/500ns counts) always counts up and is used for
                       243     ; - Time from pwm on/off event
                       244     ; Timer 2 (500ns counts) always counts up and is used for
                       245     ; - RC pulse timeout/skip counts and commutation times
                       246     ; Timer 3 (500ns counts) always counts up and is used for
                       247     ; - Commutation timeouts
                       248     ; PCA0 (500ns counts) always counts up and is used for
                       249     ; - RC pulse measurement
                       250     ;
                       251     ;**** **** **** **** ****
                       252     ; Interrupt handling
                       253     ; The F330 does not disable interrupts when entering an interrupt routine.
                       254     ; Also some interrupt flags need to be cleared by software
                       255     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                       256     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                       257     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                       258     ;
                       259     ;**** **** **** **** ****
                       260     ; Motor control:
                       261     ; - Brushless motor control with 6 states for each electrical 360 degrees
                       262     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                       263     ; - Timing advance in this implementation is set to 15deg nominally
                       264     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                       265     ; Motor sequence starting from zero crossing:
                       266     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                       267     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                       268     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                       269     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                       270     ;
                       271     ; Motor startup:
                       272     ; Startup is the only phase, before normal bemf commutation run begins.
                       273     ;
                       274     ;**** **** **** **** ****
                       275     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0001                 276     XP_3A_MAIN 					EQU 1
  0002                 277     XP_3A_TAIL 					EQU 2
  0003                 278     XP_3A_MULTI 					EQU 3
  0004                 279     XP_7A_MAIN 					EQU 4
  0005                 280     XP_7A_TAIL 					EQU 5
  0006                 281     XP_7A_MULTI 					EQU 6
  0007                 282     XP_7A_FAST_MAIN 				EQU 7
  0008                 283     XP_7A_FAST_TAIL 				EQU 8
  0009                 284     XP_7A_FAST_MULTI 				EQU 9
  000A                 285     XP_12A_MAIN 					EQU 10
  000B                 286     XP_12A_TAIL 					EQU 11
  000C                 287     XP_12A_MULTI 					EQU 12
  000D                 288     XP_18A_MAIN 					EQU 13
  000E                 289     XP_18A_TAIL 					EQU 14
  000F                 290     XP_18A_MULTI 					EQU 15
  0010                 291     XP_25A_MAIN 					EQU 16
  0011                 292     XP_25A_TAIL 					EQU 17
  0012                 293     XP_25A_MULTI 					EQU 18
  0013                 294     XP_35A_SW_MAIN 				EQU 19
  0014                 295     XP_35A_SW_TAIL 				EQU 20
  0015                 296     XP_35A_SW_MULTI 				EQU 21
  0016                 297     DP_3A_MAIN 					EQU 22
  0017                 298     DP_3A_TAIL  					EQU 23
  0018                 299     DP_3A_MULTI  					EQU 24
  0019                 300     SUPERMICRO_3P5A_MAIN 			EQU 25
  001A                 301     SUPERMICRO_3P5A_TAIL 			EQU 26   
  001B                 302     SUPERMICRO_3P5A_MULTI 			EQU 27   
  001C                 303     TURNIGY_PLUSH_6A_MAIN 			EQU 28
  001D                 304     TURNIGY_PLUSH_6A_TAIL 			EQU 29   
  001E                 305     TURNIGY_PLUSH_6A_MULTI 			EQU 30   
  001F                 306     TURNIGY_PLUSH_10A_MAIN 			EQU 31
  0020                 307     TURNIGY_PLUSH_10A_TAIL 			EQU 32   
  0021                 308     TURNIGY_PLUSH_10A_MULTI 			EQU 33   
  0022                 309     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                 310     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                 311     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  0025                 312     TURNIGY_PLUSH_18A_MAIN 			EQU 37
  0026                 313     TURNIGY_PLUSH_18A_TAIL 			EQU 38   
  0027                 314     TURNIGY_PLUSH_18A_MULTI 			EQU 39   
  0028                 315     TURNIGY_PLUSH_25A_MAIN 			EQU 40
  0029                 316     TURNIGY_PLUSH_25A_TAIL 			EQU 41   
  002A                 317     TURNIGY_PLUSH_25A_MULTI 			EQU 42   
  002B                 318     TURNIGY_PLUSH_30A_MAIN 			EQU 43
  002C                 319     TURNIGY_PLUSH_30A_TAIL 			EQU 44   
  002D                 320     TURNIGY_PLUSH_30A_MULTI 			EQU 45   
  002E                 321     TURNIGY_PLUSH_40A_MAIN 			EQU 46
  002F                 322     TURNIGY_PLUSH_40A_TAIL 			EQU 47   
  0030                 323     TURNIGY_PLUSH_40A_MULTI 			EQU 48   
  0031                 324     TURNIGY_PLUSH_60A_MAIN 			EQU 49
  0032                 325     TURNIGY_PLUSH_60A_TAIL 			EQU 50   
  0033                 326     TURNIGY_PLUSH_60A_MULTI 			EQU 51   
  0034                 327     TURNIGY_PLUSH_80A_MAIN 			EQU 52
  0035                 328     TURNIGY_PLUSH_80A_TAIL 			EQU 53   
  0036                 329     TURNIGY_PLUSH_80A_MULTI 			EQU 54   
  0037                 330     TURNIGY_PLUSH_NFET_18A_MAIN 		EQU 55
  0038                 331     TURNIGY_PLUSH_NFET_18A_TAIL 		EQU 56   
  0039                 332     TURNIGY_PLUSH_NFET_18A_MULTI 		EQU 57   
  003A                 333     TURNIGY_PLUSH_NFET_25A_MAIN 		EQU 58
  003B                 334     TURNIGY_PLUSH_NFET_25A_TAIL 		EQU 59   
  003C                 335     TURNIGY_PLUSH_NFET_25A_MULTI 		EQU 60   
  003D                 336     TURNIGY_PLUSH_NFET_30A_MAIN 		EQU 61
  003E                 337     TURNIGY_PLUSH_NFET_30A_TAIL 		EQU 62   
  003F                 338     TURNIGY_PLUSH_NFET_30A_MULTI 		EQU 63   
  0040                 339     TURNIGY_AE_20A_MAIN 			EQU 64
  0041                 340     TURNIGY_AE_20A_TAIL 			EQU 65   
  0042                 341     TURNIGY_AE_20A_MULTI 			EQU 66   
  0043                 342     TURNIGY_AE_25A_MAIN 			EQU 67
  0044                 343     TURNIGY_AE_25A_TAIL 			EQU 68   
  0045                 344     TURNIGY_AE_25A_MULTI 			EQU 69   
  0046                 345     TURNIGY_AE_30A_MAIN 			EQU 70
  0047                 346     TURNIGY_AE_30A_TAIL 			EQU 71   
  0048                 347     TURNIGY_AE_30A_MULTI 			EQU 72   
  0049                 348     TURNIGY_AE_45A_MAIN 			EQU 73
  004A                 349     TURNIGY_AE_45A_TAIL 			EQU 74   
  004B                 350     TURNIGY_AE_45A_MULTI 			EQU 75   
  004C                 351     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                 352     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                 353     TURNIGY_KFORCE_40A_MULTI 		EQU 78   
  004F                 354     TURNIGY_KFORCE_70A_HV_MAIN 		EQU 79   
  0050                 355     TURNIGY_KFORCE_70A_HV_TAIL 		EQU 80   
  0051                 356     TURNIGY_KFORCE_70A_HV_MULTI 		EQU 81   
  0052                 357     TURNIGY_KFORCE_120A_HV_MAIN 		EQU 82   
  0053                 358     TURNIGY_KFORCE_120A_HV_TAIL 		EQU 83   
  0054                 359     TURNIGY_KFORCE_120A_HV_MULTI 		EQU 84   
  0055                 360     TURNIGY_KFORCE_120A_HV_V2_MAIN	EQU 85   
  0056                 361     TURNIGY_KFORCE_120A_HV_V2_TAIL 	EQU 86   
  0057                 362     TURNIGY_KFORCE_120A_HV_V2_MULTI 	EQU 87   
  0058                 363     SKYWALKER_20A_MAIN 				EQU 88
  0059                 364     SKYWALKER_20A_TAIL 				EQU 89   
  005A                 365     SKYWALKER_20A_MULTI 			EQU 90   
  005B                 366     SKYWALKER_40A_MAIN 				EQU 91
  005C                 367     SKYWALKER_40A_TAIL 				EQU 92   
  005D                 368     SKYWALKER_40A_MULTI 			EQU 93   
  005E                 369     HIMODEL_COOL_22A_MAIN 			EQU 94
  005F                 370     HIMODEL_COOL_22A_TAIL 			EQU 95   
  0060                 371     HIMODEL_COOL_22A_MULTI 			EQU 96   
  0061                 372     HIMODEL_COOL_33A_MAIN 			EQU 97
  0062                 373     HIMODEL_COOL_33A_TAIL 			EQU 98   
  0063                 374     HIMODEL_COOL_33A_MULTI 			EQU 99  
  0064                 375     HIMODEL_COOL_41A_MAIN 			EQU 100
  0065                 376     HIMODEL_COOL_41A_TAIL 			EQU 101  
  0066                 377     HIMODEL_COOL_41A_MULTI 			EQU 102  
  0067                 378     RCTIMER_6A_MAIN 				EQU 103   
  0068                 379     RCTIMER_6A_TAIL 				EQU 104  
  0069                 380     RCTIMER_6A_MULTI 				EQU 105  
  006A                 381     ALIGN_RCE_BL15X_MAIN			EQU 106   
  006B                 382     ALIGN_RCE_BL15X_TAIL 			EQU 107  
  006C                 383     ALIGN_RCE_BL15X_MULTI 			EQU 108  
  006D                 384     ALIGN_RCE_BL15P_MAIN			EQU 109  
  006E                 385     ALIGN_RCE_BL15P_TAIL 			EQU 110  
  006F                 386     ALIGN_RCE_BL15P_MULTI 			EQU 111  
  0070                 387     ALIGN_RCE_BL35X_MAIN			EQU 112  
  0071                 388     ALIGN_RCE_BL35X_TAIL 			EQU 113  
  0072                 389     ALIGN_RCE_BL35X_MULTI 			EQU 114  
  0073                 390     ALIGN_RCE_BL35P_MAIN			EQU 115   
  0074                 391     ALIGN_RCE_BL35P_TAIL 			EQU 116  
  0075                 392     ALIGN_RCE_BL35P_MULTI 			EQU 117  
  0076                 393     GAUI_GE_183_18A_MAIN			EQU 118   
  0077                 394     GAUI_GE_183_18A_TAIL 			EQU 119  
  0078                 395     GAUI_GE_183_18A_MULTI 			EQU 120  
  0079                 396     H_KING_10A_MAIN				EQU 121   
  007A                 397     H_KING_10A_TAIL 				EQU 122  
  007B                 398     H_KING_10A_MULTI 				EQU 123  
  007C                 399     H_KING_20A_MAIN				EQU 124   
  007D                 400     H_KING_20A_TAIL 				EQU 125  
  007E                 401     H_KING_20A_MULTI 				EQU 126  
  007F                 402     H_KING_35A_MAIN				EQU 127   
  0080                 403     H_KING_35A_TAIL 				EQU 128 
  0081                 404     H_KING_35A_MULTI 				EQU 129  
  0082                 405     H_KING_50A_MAIN				EQU 130   
  0083                 406     H_KING_50A_TAIL 				EQU 131  
  0084                 407     H_KING_50A_MULTI 				EQU 132  
  0085                 408     POLARIS_THUNDER_12A_MAIN			EQU 133   
  0086                 409     POLARIS_THUNDER_12A_TAIL 		EQU 134  
  0087                 410     POLARIS_THUNDER_12A_MULTI 		EQU 135  
  0088                 411     POLARIS_THUNDER_20A_MAIN			EQU 136   
  0089                 412     POLARIS_THUNDER_20A_TAIL 		EQU 137  
  008A                 413     POLARIS_THUNDER_20A_MULTI 		EQU 138  
  008B                 414     POLARIS_THUNDER_30A_MAIN			EQU 139   
  008C                 415     POLARIS_THUNDER_30A_TAIL 		EQU 140  
  008D                 416     POLARIS_THUNDER_30A_MULTI 		EQU 141  
  008E                 417     POLARIS_THUNDER_40A_MAIN			EQU 142   
  008F                 418     POLARIS_THUNDER_40A_TAIL 		EQU 143  
  0090                 419     POLARIS_THUNDER_40A_MULTI 		EQU 144  
  0091                 420     POLARIS_THUNDER_60A_MAIN			EQU 145   
  0092                 421     POLARIS_THUNDER_60A_TAIL 		EQU 146  
  0093                 422     POLARIS_THUNDER_60A_MULTI 		EQU 147  
  0094                 423     POLARIS_THUNDER_80A_MAIN			EQU 148   
  0095                 424     POLARIS_THUNDER_80A_TAIL 		EQU 149  
  0096                 425     POLARIS_THUNDER_80A_MULTI 		EQU 150  
  0097                 426     POLARIS_THUNDER_100A_MAIN		EQU 151   
  0098                 427     POLARIS_THUNDER_100A_TAIL 		EQU 152  
  0099                 428     POLARIS_THUNDER_100A_MULTI 		EQU 153  
  009A                 429     PLATINUM_PRO_30A_MAIN			EQU 154   
  009B                 430     PLATINUM_PRO_30A_TAIL 			EQU 155  
  009C                 431     PLATINUM_PRO_30A_MULTI 			EQU 156  
  009D                 432     PLATINUM_PRO_150A_MAIN			EQU 157   
  009E                 433     PLATINUM_PRO_150A_TAIL 			EQU 158  
  009F                 434     PLATINUM_PRO_150A_MULTI 			EQU 159  
  00A0                 435     PLATINUM_50AV3_MAIN				EQU 160   
  00A1                 436     PLATINUM_50AV3_TAIL 			EQU 161  
  00A2                 437     PLATINUM_50AV3_MULTI 			EQU 162  
  00A3                 438     EAZY_3AV2_MAIN					EQU 163   
  00A4                 439     EAZY_3AV2_TAIL 				EQU 164  
  00A5                 440     EAZY_3AV2_MULTI 				EQU 165  
  00A6                 441     TAROT_30A_MAIN					EQU 166   
  00A7                 442     TAROT_30A_TAIL 				EQU 167  
  00A8                 443     TAROT_30A_MULTI 				EQU 168  
  00A9                 444     SKYIII_30A_MAIN				EQU 169   
  00AA                 445     SKYIII_30A_TAIL 				EQU 170  
  00AB                 446     SKYIII_30A_MULTI 				EQU 171  
  00AC                 447     EMAX_20A_MAIN					EQU 172   
  00AD                 448     EMAX_20A_TAIL 					EQU 173  
  00AE                 449     EMAX_20A_MULTI 				EQU 174  
  00AF                 450     EMAX_40A_MAIN					EQU 175   
  00B0                 451     EMAX_40A_TAIL 					EQU 176  
  00B1                 452     EMAX_40A_MULTI 				EQU 177  
  00B2                 453     EMAX_NANO_20A_MAIN				EQU 178   
  00B3                 454     EMAX_NANO_20A_TAIL 				EQU 179  
  00B4                 455     EMAX_NANO_20A_MULTI 			EQU 180  
  00B5                 456     XROTOR_10A_MAIN				EQU 181   
  00B6                 457     XROTOR_10A_TAIL 				EQU 182  
  00B7                 458     XROTOR_10A_MULTI 				EQU 183  
  00B8                 459     XROTOR_20A_MAIN				EQU 184   
  00B9                 460     XROTOR_20A_TAIL 				EQU 185  
  00BA                 461     XROTOR_20A_MULTI 				EQU 186  
  00BB                 462     XROTOR_40A_MAIN				EQU 187   
  00BC                 463     XROTOR_40A_TAIL 				EQU 188  
  00BD                 464     XROTOR_40A_MULTI 				EQU 189  
  00BE                 465     MDRX62H_MAIN					EQU 190   
  00BF                 466     MDRX62H_TAIL 					EQU 191  
  00C0                 467     MDRX62H_MULTI 					EQU 192  
  00C1                 468     ROTORGEEKS_20A_MAIN				EQU 193   
  00C2                 469     ROTORGEEKS_20A_TAIL 			EQU 194  
  00C3                 470     ROTORGEEKS_20A_MULTI 			EQU 195  
  00C4                 471     FLYCOLOR_FAIRY_6A_MAIN			EQU 196   
  00C5                 472     FLYCOLOR_FAIRY_6A_TAIL 			EQU 197  
  00C6                 473     FLYCOLOR_FAIRY_6A_MULTI 			EQU 198  
  00C7                 474     FLYCOLOR_FAIRY_30A_MAIN			EQU 199   
  00C8                 475     FLYCOLOR_FAIRY_30A_TAIL 			EQU 200  
  00C9                 476     FLYCOLOR_FAIRY_30A_MULTI 		EQU 201  
  00CA                 477     FVT_LITTLEBEE_20A_MAIN			EQU 202  
  00CB                 478     FVT_LITTLEBEE_20A_TAIL			EQU 203  
  00CC                 479     FVT_LITTLEBEE_20A_MULTI			EQU 204  
  00CD                 480     FVT_LITTLEBEE_30A_MAIN			EQU 205  
  00CE                 481     FVT_LITTLEBEE_30A_TAIL			EQU 206  
  00CF                 482     FVT_LITTLEBEE_30A_MULTI			EQU 207  
  00D0                 483     GRAUPNER_ULTRA_20A_MAIN			EQU 208  
  00D1                 484     GRAUPNER_ULTRA_20A_TAIL			EQU 209  
  00D2                 485     GRAUPNER_ULTRA_20A_MULTI			EQU 210  
  00D3                 486     F85_3A_MAIN					EQU 211  
  00D4                 487     F85_3A_TAIL					EQU 212  
  00D5                 488     F85_3A_MULTI					EQU 213  
  00D6                 489     ZTW_SPIDER_PRO_20A_MAIN			EQU 214  
  00D7                 490     ZTW_SPIDER_PRO_20A_TAIL			EQU 215  
  00D8                 491     ZTW_SPIDER_PRO_20A_MULTI			EQU 216  
                       492     
                       493     
                       494     ;**** **** **** **** ****
                       495     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                       496     ;BESCNO EQU XP_3A_Main 
                       497     ;BESCNO EQU XP_3A_Tail
                       498     ;BESCNO EQU XP_3A_Multi
                       499     ;BESCNO EQU XP_7A_Main
                       500     ;BESCNO EQU XP_7A_Tail
                       501     ;BESCNO EQU XP_7A_Multi
                       502     ;BESCNO EQU XP_7A_Fast_Main
                       503     ;BESCNO EQU XP_7A_Fast_Tail
                       504     ;BESCNO EQU XP_7A_Fast_Multi
                       505     ;BESCNO EQU XP_12A_Main
                       506     ;BESCNO EQU XP_12A_Tail 
                       507     ;BESCNO EQU XP_12A_Multi
                       508     ;BESCNO EQU XP_18A_Main 
                       509     ;BESCNO EQU XP_18A_Tail 
                       510     ;BESCNO EQU XP_18A_Multi
                       511     ;BESCNO EQU XP_25A_Main 
                       512     ;BESCNO EQU XP_25A_Tail 
                       513     ;BESCNO EQU XP_25A_Multi
                       514     ;BESCNO EQU XP_35A_SW_Main
                       515     ;BESCNO EQU XP_35A_SW_Tail 
                       516     ;BESCNO EQU XP_35A_SW_Multi
                       517     ;BESCNO EQU DP_3A_Main 						
                       518     ;BESCNO EQU DP_3A_Tail 
                       519     ;BESCNO EQU DP_3A_Multi 
                       520     ;BESCNO EQU Supermicro_3p5A_Main
                       521     ;BESCNO EQU Supermicro_3p5A_Tail 
                       522     ;BESCNO EQU Supermicro_3p5A_Multi
                       523     ;BESCNO EQU Turnigy_Plush_6A_Main 
                       524     ;BESCNO EQU Turnigy_Plush_6A_Tail 
                       525     ;BESCNO EQU Turnigy_Plush_6A_Multi
                       526     ;BESCNO EQU Turnigy_Plush_10A_Main 
                       527     ;BESCNO EQU Turnigy_Plush_10A_Tail 
                       528     ;BESCNO EQU Turnigy_Plush_10A_Multi
                       529     ;BESCNO EQU Turnigy_Plush_12A_Main 
                       530     ;BESCNO EQU Turnigy_Plush_12A_Tail 
                       531     ;BESCNO EQU Turnigy_Plush_12A_Multi 
                       532     ;BESCNO EQU Turnigy_Plush_18A_Main 
                       533     ;BESCNO EQU Turnigy_Plush_18A_Tail 
                       534     ;BESCNO EQU Turnigy_Plush_18A_Multi
                       535     ;BESCNO EQU Turnigy_Plush_25A_Main 
                       536     ;BESCNO EQU Turnigy_Plush_25A_Tail
                       537     ;BESCNO EQU Turnigy_Plush_25A_Multi
                       538     ;BESCNO EQU Turnigy_Plush_30A_Main 
                       539     ;BESCNO EQU Turnigy_Plush_30A_Tail 
                       540     ;BESCNO EQU Turnigy_Plush_30A_Multi
                       541     ;BESCNO EQU Turnigy_Plush_40A_Main 
                       542     ;BESCNO EQU Turnigy_Plush_40A_Tail 
                       543     ;BESCNO EQU Turnigy_Plush_40A_Multi 
                       544     ;BESCNO EQU Turnigy_Plush_60A_Main
                       545     ;BESCNO EQU Turnigy_Plush_60A_Tail 
                       546     ;BESCNO EQU Turnigy_Plush_60A_Multi
                       547     ;BESCNO EQU Turnigy_Plush_80A_Main
                       548     ;BESCNO EQU Turnigy_Plush_80A_Tail 
                       549     ;BESCNO EQU Turnigy_Plush_80A_Multi
                       550     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Main
                       551     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Tail 
                       552     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Multi 
                       553     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Main 
                       554     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Tail
                       555     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Multi
                       556     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Main  
                       557     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Tail 
                       558     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Multi
                       559     ;BESCNO EQU Turnigy_AE_20A_Main 
                       560     ;BESCNO EQU Turnigy_AE_20A_Tail 
                       561     ;BESCNO EQU Turnigy_AE_20A_Multi
                       562     ;BESCNO EQU Turnigy_AE_25A_Main 
                       563     ;BESCNO EQU Turnigy_AE_25A_Tail 
                       564     ;BESCNO EQU Turnigy_AE_25A_Multi
                       565     ;BESCNO EQU Turnigy_AE_30A_Main 
                       566     ;BESCNO EQU Turnigy_AE_30A_Tail 
                       567     ;BESCNO EQU Turnigy_AE_30A_Multi
                       568     ;BESCNO EQU Turnigy_AE_45A_Main
                       569     ;BESCNO EQU Turnigy_AE_45A_Tail 
                       570     ;BESCNO EQU Turnigy_AE_45A_Multi
                       571     ;BESCNO EQU Turnigy_KForce_40A_Main
                       572     ;BESCNO EQU Turnigy_KForce_40A_Tail 
                       573     ;BESCNO EQU Turnigy_KForce_40A_Multi 
                       574     ;BESCNO EQU Turnigy_KForce_70A_HV_Main
                       575     ;BESCNO EQU Turnigy_KForce_70A_HV_Tail 
                       576     ;BESCNO EQU Turnigy_KForce_70A_HV_Multi
                       577     ;BESCNO EQU Turnigy_KForce_120A_HV_Main
                       578     ;BESCNO EQU Turnigy_KForce_120A_HV_Tail 
                       579     ;BESCNO EQU Turnigy_KForce_120A_HV_Multi
                       580     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Main
                       581     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Tail 
                       582     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Multi
                       583     ;BESCNO EQU Skywalker_20A_Main
                       584     ;BESCNO EQU Skywalker_20A_Tail
                       585     ;BESCNO EQU Skywalker_20A_Multi 
                       586     ;BESCNO EQU Skywalker_40A_Main 
                       587     ;BESCNO EQU Skywalker_40A_Tail 
                       588     ;BESCNO EQU Skywalker_40A_Multi
                       589     ;BESCNO EQU HiModel_Cool_22A_Main
                       590     ;BESCNO EQU HiModel_Cool_22A_Tail
                       591     ;BESCNO EQU HiModel_Cool_22A_Multi
                       592     ;BESCNO EQU HiModel_Cool_33A_Main
                       593     ;BESCNO EQU HiModel_Cool_33A_Tail
                       594     ;BESCNO EQU HiModel_Cool_33A_Multi
                       595     ;BESCNO EQU HiModel_Cool_41A_Main
                       596     ;BESCNO EQU HiModel_Cool_41A_Tail
                       597     ;BESCNO EQU HiModel_Cool_41A_Multi
                       598     ;BESCNO EQU RCTimer_6A_Main
                       599     ;BESCNO EQU RCTimer_6A_Tail
                       600     ;BESCNO EQU RCTimer_6A_Multi
                       601     ;BESCNO EQU Align_RCE_BL15X_Main
                       602     ;BESCNO EQU Align_RCE_BL15X_Tail
                       603     ;BESCNO EQU Align_RCE_BL15X_Multi
                       604     ;BESCNO EQU Align_RCE_BL15P_Main
                       605     ;BESCNO EQU Align_RCE_BL15P_Tail
                       606     ;BESCNO EQU Align_RCE_BL15P_Multi 
                       607     ;BESCNO EQU Align_RCE_BL35X_Main 
                       608     ;BESCNO EQU Align_RCE_BL35X_Tail
                       609     ;BESCNO EQU Align_RCE_BL35X_Multi
                       610     ;BESCNO EQU Align_RCE_BL35P_Main
                       611     ;BESCNO EQU Align_RCE_BL35P_Tail
                       612     ;BESCNO EQU Align_RCE_BL35P_Multi
                       613     ;BESCNO EQU Gaui_GE_183_18A_Main
                       614     ;BESCNO EQU Gaui_GE_183_18A_Tail
                       615     ;BESCNO EQU Gaui_GE_183_18A_Multi
                       616     ;BESCNO EQU H_King_10A_Main 
                       617     ;BESCNO EQU H_King_10A_Tail 
                       618     ;BESCNO EQU H_King_10A_Multi
                       619     ;BESCNO EQU H_King_20A_Main
                       620     ;BESCNO EQU H_King_20A_Tail
                       621     ;BESCNO EQU H_King_20A_Multi
                       622     ;BESCNO EQU H_King_35A_Main
                       623     ;BESCNO EQU H_King_35A_Tail
                       624     ;BESCNO EQU H_King_35A_Multi
                       625     ;BESCNO EQU H_King_50A_Main
                       626     ;BESCNO EQU H_King_50A_Tail
                       627     ;BESCNO EQU H_King_50A_Multi
                       628     ;BESCNO EQU Polaris_Thunder_12A_Main
                       629     ;BESCNO EQU Polaris_Thunder_12A_Tail
                       630     ;BESCNO EQU Polaris_Thunder_12A_Multi
                       631     ;BESCNO EQU Polaris_Thunder_20A_Main
                       632     ;BESCNO EQU Polaris_Thunder_20A_Tail
                       633     ;BESCNO EQU Polaris_Thunder_20A_Multi
                       634     ;BESCNO EQU Polaris_Thunder_30A_Main
                       635     ;BESCNO EQU Polaris_Thunder_30A_Tail
                       636     ;BESCNO EQU Polaris_Thunder_30A_Multi
                       637     ;BESCNO EQU Polaris_Thunder_40A_Main
                       638     ;BESCNO EQU Polaris_Thunder_40A_Tail
                       639     ;BESCNO EQU Polaris_Thunder_40A_Multi
                       640     ;BESCNO EQU Polaris_Thunder_60A_Main
                       641     ;BESCNO EQU Polaris_Thunder_60A_Tail
                       642     ;BESCNO EQU Polaris_Thunder_60A_Multi
                       643     ;BESCNO EQU Polaris_Thunder_80A_Main
                       644     ;BESCNO EQU Polaris_Thunder_80A_Tail
                       645     ;BESCNO EQU Polaris_Thunder_80A_Multi
                       646     ;BESCNO EQU Polaris_Thunder_100A_Main
                       647     ;BESCNO EQU Polaris_Thunder_100A_Tail
                       648     ;BESCNO EQU Polaris_Thunder_100A_Multi
                       649     ;BESCNO EQU Platinum_Pro_30A_Main
                       650     ;BESCNO EQU Platinum_Pro_30A_Tail
                       651     ;BESCNO EQU Platinum_Pro_30A_Multi 
                       652     ;BESCNO EQU Platinum_Pro_150A_Main
                       653     ;BESCNO EQU Platinum_Pro_150A_Tail
                       654     ;BESCNO EQU Platinum_Pro_150A_Multi
                       655     ;BESCNO EQU Platinum_50Av3_Main
                       656     ;BESCNO EQU Platinum_50Av3_Tail
                       657     ;BESCNO EQU Platinum_50Av3_Multi 
                       658     ;BESCNO EQU EAZY_3Av2_Main
                       659     ;BESCNO EQU EAZY_3Av2_Tail
                       660     ;BESCNO EQU EAZY_3Av2_Multi
                       661     ;BESCNO EQU Tarot_30A_Main
                       662     ;BESCNO EQU Tarot_30A_Tail
                       663     ;BESCNO EQU Tarot_30A_Multi
                       664     ;BESCNO EQU SkyIII_30A_Main
                       665     ;BESCNO EQU SkyIII_30A_Tail
                       666     ;BESCNO EQU SkyIII_30A_Multi
                       667     ;BESCNO EQU EMAX_20A_Main
                       668     ;BESCNO EQU EMAX_20A_Tail
                       669     ;BESCNO EQU EMAX_20A_Multi 
                       670     ;BESCNO EQU EMAX_40A_Main
                       671     ;BESCNO EQU EMAX_40A_Tail
                       672     ;BESCNO EQU EMAX_40A_Multi 
                       673     ;BESCNO EQU EMAX_Nano_20A_Main
                       674     ;BESCNO EQU EMAX_Nano_20A_Tail
                       675     ;BESCNO EQU EMAX_Nano_20A_Multi 
                       676     ;BESCNO EQU XRotor_10A_Main 
                       677     ;BESCNO EQU XRotor_10A_Tail
                       678     ;BESCNO EQU XRotor_10A_Multi 
                       679     ;BESCNO EQU XRotor_20A_Main
                       680     ;BESCNO EQU XRotor_20A_Tail
                       681     ;BESCNO EQU XRotor_20A_Multi 
                       682     ;BESCNO EQU XRotor_40A_Main
                       683     ;BESCNO EQU XRotor_40A_Tail
                       684     ;BESCNO EQU XRotor_40A_Multi 
                       685     ;BESCNO EQU MDRX62H_Main
                       686     ;BESCNO EQU MDRX62H_Tail
                       687     ;BESCNO EQU MDRX62H_Multi 
                       688     ;BESCNO EQU RotorGeeks_20A_Main
                       689     ;BESCNO EQU RotorGeeks_20A_Tail
                       690     ;BESCNO EQU RotorGeeks_20A_Multi
                       691     ;BESCNO EQU Flycolor_Fairy_6A_Main
                       692     ;BESCNO EQU Flycolor_Fairy_6A_Tail
                       693     ;BESCNO EQU Flycolor_Fairy_6A_Multi
                       694     ;BESCNO EQU Flycolor_Fairy_30A_Main
                       695     ;BESCNO EQU Flycolor_Fairy_30A_Tail
                       696     ;BESCNO EQU Flycolor_Fairy_30A_Multi
                       697     ;BESCNO EQU FVT_Littlebee_20A_Main
                       698     ;BESCNO EQU FVT_Littlebee_20A_Tail
                       699     ;BESCNO EQU FVT_Littlebee_20A_Multi 
                       700     ;BESCNO EQU FVT_Littlebee_30A_Main
                       701     ;BESCNO EQU FVT_Littlebee_30A_Tail
                       702     ;BESCNO EQU FVT_Littlebee_30A_Multi 
                       703     ;BESCNO EQU Graupner_Ultra_20A_Main
                       704     ;BESCNO EQU Graupner_Ultra_20A_Tail
                       705     ;BESCNO EQU Graupner_Ultra_20A_Multi 
                       706     ;BESCNO EQU F85_3A_Main
                       707     ;BESCNO EQU F85_3A_Tail
                       708     ;BESCNO EQU F85_3A_Multi
                       709     ;BESCNO EQU ZTW_Spider_Pro_20A_Main
                       710     ;BESCNO EQU ZTW_Spider_Pro_20A_Tail
                       711     ;BESCNO EQU ZTW_Spider_Pro_20A_Multi
                       712     
                       713     
                       714     ;**** **** **** **** ****
                       715     ; ESC selection statements
                       716     IF BESCNO == XP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       720     
                       721     IF BESCNO == XP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       725     
                       726     IF BESCNO == XP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       730     
                       731     IF BESCNO == XP_7A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       735     
                       736     IF BESCNO == XP_7A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       740     
                       741     IF BESCNO == XP_7A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       745     
                       746     IF BESCNO == XP_7A_FAST_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       750     
                       751     IF BESCNO == XP_7A_FAST_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       755     
                       756     IF BESCNO == XP_7A_FAST_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       760     
                       761     IF BESCNO == XP_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       765     
                       766     IF BESCNO == XP_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       770     
                       771     IF BESCNO == XP_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       775     
                       776     IF BESCNO == XP_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       780     
                       781     IF BESCNO == XP_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       785     
                       786     IF BESCNO == XP_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       790     
                       791     IF BESCNO == XP_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       795     
                       796     IF BESCNO == XP_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       800     
                       801     IF BESCNO == XP_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       805     
                       806     IF BESCNO == XP_35A_SW_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       810     
                       811     IF BESCNO == XP_35A_SW_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       815     
                       816     IF BESCNO == XP_35A_SW_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       820     
                       821     IF BESCNO == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       825     
                       826     IF BESCNO == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       830     
                       831     IF BESCNO == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       835     
                       836     IF BESCNO == SUPERMICRO_3P5A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       840     
                       841     IF BESCNO == SUPERMICRO_3P5A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       845     
                       846     IF BESCNO == SUPERMICRO_3P5A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       850     
                       851     IF BESCNO == TURNIGY_PLUSH_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       855     
                       856     IF BESCNO == TURNIGY_PLUSH_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       860     
                       861     IF BESCNO == TURNIGY_PLUSH_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       865     
                       866     IF BESCNO == TURNIGY_PLUSH_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       870     
                       871     IF BESCNO == TURNIGY_PLUSH_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       875     
                       876     IF BESCNO == TURNIGY_PLUSH_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       880     
                       881     IF BESCNO == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       885     
                       886     IF BESCNO == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       890     
                       891     IF BESCNO == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       895     
                       896     IF BESCNO == TURNIGY_PLUSH_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       900     
                       901     IF BESCNO == TURNIGY_PLUSH_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       905     
                       906     IF BESCNO == TURNIGY_PLUSH_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       910     
                       911     IF BESCNO == TURNIGY_PLUSH_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       915     
                       916     IF BESCNO == TURNIGY_PLUSH_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       920     
                       921     IF BESCNO == TURNIGY_PLUSH_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       925     
                       926     IF BESCNO == TURNIGY_PLUSH_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       930     
                       931     IF BESCNO == TURNIGY_PLUSH_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       935     
                       936     IF BESCNO == TURNIGY_PLUSH_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       940     
                       941     IF BESCNO == TURNIGY_PLUSH_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       945     
                       946     IF BESCNO == TURNIGY_PLUSH_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       950     
                       951     IF BESCNO == TURNIGY_PLUSH_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       955     
                       956     IF BESCNO == TURNIGY_PLUSH_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       960     
                       961     IF BESCNO == TURNIGY_PLUSH_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       965     
                       966     IF BESCNO == TURNIGY_PLUSH_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       970     
                       971     IF BESCNO == TURNIGY_PLUSH_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       975     
                       976     IF BESCNO == TURNIGY_PLUSH_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       980     
                       981     IF BESCNO == TURNIGY_PLUSH_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       985     
                       986     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       990     
                       991     IF BESCNO == TURNIGY_PLUSH_NFET_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       995     
                       996     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1000     
                      1001     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1005     
                      1006     IF BESCNO == TURNIGY_PLUSH_NFET_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1010     
                      1011     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1015     
                      1016     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1020     
                      1021     IF BESCNO == TURNIGY_PLUSH_NFET_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1025     
                      1026     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1030     
                      1031     IF BESCNO == TURNIGY_AE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1035     
                      1036     IF BESCNO == TURNIGY_AE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1040     
                      1041     IF BESCNO == TURNIGY_AE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1045     
                      1046     IF BESCNO == TURNIGY_AE_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1050     
                      1051     IF BESCNO == TURNIGY_AE_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1055     
                      1056     IF BESCNO == TURNIGY_AE_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1060     
                      1061     IF BESCNO == TURNIGY_AE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1065     
                      1066     IF BESCNO == TURNIGY_AE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1070     
                      1071     IF BESCNO == TURNIGY_AE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1075     
                      1076     IF BESCNO == TURNIGY_AE_45A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1080     
                      1081     IF BESCNO == TURNIGY_AE_45A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1085     
                      1086     IF BESCNO == TURNIGY_AE_45A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1090     
                      1091     IF BESCNO == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1095     
                      1096     IF BESCNO == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1100     
                      1101     IF BESCNO == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1105     
                      1106     IF BESCNO == TURNIGY_KFORCE_70A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1110     
                      1111     IF BESCNO == TURNIGY_KFORCE_70A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1115     
                      1116     IF BESCNO == TURNIGY_KFORCE_70A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1120     
                      1121     IF BESCNO == TURNIGY_KFORCE_120A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1125     
                      1126     IF BESCNO == TURNIGY_KFORCE_120A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1130     
                      1131     IF BESCNO == TURNIGY_KFORCE_120A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1135     
                      1136     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1140     
                      1141     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1145     
                      1146     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1150     
                      1151     IF BESCNO == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1155     
                      1156     IF BESCNO == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1160     
                      1161     IF BESCNO == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1165     
                      1166     IF BESCNO == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1170     
                      1171     IF BESCNO == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1175     
                      1176     IF BESCNO == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1180     
                      1181     IF BESCNO == HIMODEL_COOL_22A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1185     
                      1186     IF BESCNO == HIMODEL_COOL_22A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1190     
                      1191     IF BESCNO == HIMODEL_COOL_22A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1195     
                      1196     IF BESCNO == HIMODEL_COOL_33A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1200     
                      1201     IF BESCNO == HIMODEL_COOL_33A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1205     
                      1206     IF BESCNO == HIMODEL_COOL_33A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1210     
                      1211     IF BESCNO == HIMODEL_COOL_41A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1215     
                      1216     IF BESCNO == HIMODEL_COOL_41A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1220     
                      1221     IF BESCNO == HIMODEL_COOL_41A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1225     
                      1226     IF BESCNO == RCTIMER_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1230     
                      1231     IF BESCNO == RCTIMER_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1235     
                      1236     IF BESCNO == RCTIMER_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1240     
                      1241     IF BESCNO == ALIGN_RCE_BL15X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1245     
                      1246     IF BESCNO == ALIGN_RCE_BL15X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1250     
                      1251     IF BESCNO == ALIGN_RCE_BL15X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1255     
                      1256     IF BESCNO == ALIGN_RCE_BL15P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1260     
                      1261     IF BESCNO == ALIGN_RCE_BL15P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1265     
                      1266     IF BESCNO == ALIGN_RCE_BL15P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1270     
                      1271     IF BESCNO == ALIGN_RCE_BL35X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1275     
                      1276     IF BESCNO == ALIGN_RCE_BL35X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1280     
                      1281     IF BESCNO == ALIGN_RCE_BL35X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1285     
                      1286     IF BESCNO == ALIGN_RCE_BL35P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1290     
                      1291     IF BESCNO == ALIGN_RCE_BL35P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1295     
                      1296     IF BESCNO == ALIGN_RCE_BL35P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1300     
                      1301     IF BESCNO == GAUI_GE_183_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1305     
                      1306     IF BESCNO == GAUI_GE_183_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1310     
                      1311     IF BESCNO == GAUI_GE_183_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1315     
                      1316     IF BESCNO == H_KING_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1320     
                      1321     IF BESCNO == H_KING_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1325     
                      1326     IF BESCNO == H_KING_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1330     
                      1331     IF BESCNO == H_KING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1335     
                      1336     IF BESCNO == H_KING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1340     
                      1341     IF BESCNO == H_KING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1345     
                      1346     IF BESCNO == H_KING_35A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1350     
                      1351     IF BESCNO == H_KING_35A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1355     
                      1356     IF BESCNO == H_KING_35A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1360     
                      1361     IF BESCNO == H_KING_50A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1365     
                      1366     IF BESCNO == H_KING_50A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1370     
                      1371     IF BESCNO == H_KING_50A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1375     
                      1376     IF BESCNO == POLARIS_THUNDER_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1380     
                      1381     IF BESCNO == POLARIS_THUNDER_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1385     
                      1386     IF BESCNO == POLARIS_THUNDER_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1390     
                      1391     IF BESCNO == POLARIS_THUNDER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1395     
                      1396     IF BESCNO == POLARIS_THUNDER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1400     
                      1401     IF BESCNO == POLARIS_THUNDER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1405     
                      1406     IF BESCNO == POLARIS_THUNDER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1410     
                      1411     IF BESCNO == POLARIS_THUNDER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1415     
                      1416     IF BESCNO == POLARIS_THUNDER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1420     
                      1421     IF BESCNO == POLARIS_THUNDER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1425     
                      1426     IF BESCNO == POLARIS_THUNDER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1430     
                      1431     IF BESCNO == POLARIS_THUNDER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1435     
                      1436     IF BESCNO == POLARIS_THUNDER_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1440     
                      1441     IF BESCNO == POLARIS_THUNDER_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1445     
                      1446     IF BESCNO == POLARIS_THUNDER_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1450     
                      1451     IF BESCNO == POLARIS_THUNDER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1455     
                      1456     IF BESCNO == POLARIS_THUNDER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1460     
                      1461     IF BESCNO == POLARIS_THUNDER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1465     
                      1466     IF BESCNO == POLARIS_THUNDER_100A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1470     
                      1471     IF BESCNO == POLARIS_THUNDER_100A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1475     
                      1476     IF BESCNO == POLARIS_THUNDER_100A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1480     
                      1481     IF BESCNO == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1485     
                      1486     IF BESCNO == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1490     
                      1491     IF BESCNO == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1495     
                      1496     IF BESCNO == PLATINUM_PRO_150A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1500     
                      1501     IF BESCNO == PLATINUM_PRO_150A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1505     
                      1506     IF BESCNO == PLATINUM_PRO_150A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1510     
                      1511     IF BESCNO == PLATINUM_50AV3_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1515     
                      1516     IF BESCNO == PLATINUM_50AV3_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1520     
                      1521     IF BESCNO == PLATINUM_50AV3_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1525     
                      1526     IF BESCNO == EAZY_3AV2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1530     
                      1531     IF BESCNO == EAZY_3AV2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1535     
                      1536     IF BESCNO == EAZY_3AV2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1540     
                      1541     IF BESCNO == TAROT_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1545     
                      1546     IF BESCNO == TAROT_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1550     
                      1551     IF BESCNO == TAROT_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1555     
                      1556     IF BESCNO == SKYIII_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1560     
                      1561     IF BESCNO == SKYIII_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1565     
                      1566     IF BESCNO == SKYIII_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1570     
                      1571     IF BESCNO == EMAX_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1575     
                      1576     IF BESCNO == EMAX_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1580     
                      1581     IF BESCNO == EMAX_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1585     
                      1586     IF BESCNO == EMAX_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1590     
                      1591     IF BESCNO == EMAX_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1595     
                      1596     IF BESCNO == EMAX_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1600     
                      1601     IF BESCNO == EMAX_NANO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1605     
                      1606     IF BESCNO == EMAX_NANO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1610     
                      1611     IF BESCNO == EMAX_NANO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1615     
                      1616     IF BESCNO == XROTOR_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1620     
                      1621     IF BESCNO == XROTOR_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1625     
                      1626     IF BESCNO == XROTOR_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1630     
                      1631     IF BESCNO == XROTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1635     
                      1636     IF BESCNO == XROTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1640     
                      1641     IF BESCNO == XROTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1645     
                      1646     IF BESCNO == XROTOR_40A_MAIN
  0000                1647     MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                      1648     $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                      2262     ENDIF
                      2263     
                      2264     IF BESCNO == XROTOR_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      2268     
                      2269     IF BESCNO == XROTOR_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      2273     
                      2274     IF BESCNO == MDRX62H_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2278     
                      2279     IF BESCNO == MDRX62H_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2283     
                      2284     IF BESCNO == MDRX62H_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2288     
                      2289     IF BESCNO == ROTORGEEKS_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2293     
                      2294     IF BESCNO == ROTORGEEKS_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2298     
                      2299     IF BESCNO == ROTORGEEKS_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2303     
                      2304     IF BESCNO == FLYCOLOR_FAIRY_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2308     
                      2309     IF BESCNO == FLYCOLOR_FAIRY_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2313     
                      2314     IF BESCNO == FLYCOLOR_FAIRY_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2318     
                      2319     IF BESCNO == FLYCOLOR_FAIRY_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2323     
                      2324     IF BESCNO == FLYCOLOR_FAIRY_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2328     
                      2329     IF BESCNO == FLYCOLOR_FAIRY_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2333     
                      2334     IF BESCNO == FVT_LITTLEBEE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2338     
                      2339     IF BESCNO == FVT_LITTLEBEE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2343     
                      2344     IF BESCNO == FVT_LITTLEBEE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2348     
                      2349     IF BESCNO == FVT_LITTLEBEE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2353     
                      2354     IF BESCNO == FVT_LITTLEBEE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2358     
                      2359     IF BESCNO == FVT_LITTLEBEE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2363     
                      2364     IF BESCNO == GRAUPNER_ULTRA_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2368     
                      2369     IF BESCNO == GRAUPNER_ULTRA_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2373     
                      2374     IF BESCNO == GRAUPNER_ULTRA_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2378     
                      2379     IF BESCNO == F85_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2383     
                      2384     IF BESCNO == F85_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2388     
                      2389     IF BESCNO == F85_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2393     
                      2394     IF BESCNO == ZTW_SPIDER_PRO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2398     
                      2399     IF BESCNO == ZTW_SPIDER_PRO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2403     
                      2404     IF BESCNO == ZTW_SPIDER_PRO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2408     
                      2409     
                      2410     ;**** **** **** **** ****
                      2411     ; TX programming defaults
                      2412     ;
                      2413     ; Parameter dependencies:
                      2414     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                      2415     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                      2416     ;
                      2417     ; MAIN
  0007                2418     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                2419     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                2420     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                2421     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                2422     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                2423     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2424     IF DAMPED_MODE_ENABLE == 1
  0002                2425     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
                      2426     ELSE
                               DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low	
                               ENDIF
  0001                2429     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2430     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                2431     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                2432     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                2433     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                2434     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                2435     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                2436     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                      2437     
                      2438     ; TAIL
  0003                2439     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                2440     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                2441     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2442     IF DAMPED_MODE_ENABLE == 1
  0003                2443     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                      2444     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		
                               ENDIF
  0001                2447     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2448     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2449     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                2450     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                2451     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                2452     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2453     DEFAULT_PGM_TAIL_PWM_DITHER		EQU 3 	; 1=Off		2=7			3=15			4=31			5=63
                      2454     
                      2455     ; MULTI
  0009                2456     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                2457     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                2458     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                2459     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0003                2460     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2461     IF DAMPED_MODE_ENABLE == 1
  0001                2462     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight 
                      2463     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low
                               ENDIF
  0002                2466     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                2467     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2468     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0028                2469     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0050                2470     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0004                2471     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2472     DEFAULT_PGM_MULTI_PWM_DITHER		EQU 3 	; 1=Off		2=7			3=15			4=31			5=63
                      2473     
                      2474     ; COMMON
  0001                2475     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 1 	; 1=Enabled 	0=Disabled
  0025                2476     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 37	; 4*37+1000=1148
  00D0                2477     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 208	; 4*208+1000=1832
  007A                2478     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 122	; 4*122+1000=1488 (used in bidirectional mode)
  0000                2479     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0=Low		1+= High or higher	
  0001                2480     DEFAULT_PGM_ENABLE_TEMP_PROT	 	EQU 1 	; 1=Enabled 	0=Disabled
  0001                2481     DEFAULT_PGM_ENABLE_POWER_PROT 	EQU 1 	; 1=Enabled 	0=Disabled
  0000                2482     DEFAULT_PGM_ENABLE_PWM_INPUT	 	EQU 0 	; 1=Enabled 	0=Disabled
                      2483     
                      2484     ; PATRICK'S CHANGES
  002B                2485     MOTOR_PPM_LOW_SLOPE				EQU 43   ;256/6 = 43 -Patrick
                      2486     
                      2487     ;**** **** **** **** ****
                      2488     ; Constant definitions for main
                      2489     IF MODE == 0
                      2490     
  0002                2491     GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
  000A                2492     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0040                2493     RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0020                2494     RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                2495     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                2496     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                2497     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                2498     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                2499     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                      2500     
  0032                2501     PWM_START			EQU	50 	; PWM used as max power during start
                      2502     
  0001                2503     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                      2504     
  0008                2505     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                      2506     
                      2507     ENDIF
                      2508     ; Constant definitions for tail
                      2509     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2528     ; Constant definitions for multi
                      2529     IF MODE == 2
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2548     
                      2549     ;**** **** **** **** ****
                      2550     ; Temporary register definitions
  REG                 2551     TEMP1		EQU	R0
  REG                 2552     TEMP2		EQU	R1
  REG                 2553     TEMP3		EQU	R2
  REG                 2554     TEMP4		EQU	R3
  REG                 2555     TEMP5		EQU	R4
  REG                 2556     TEMP6		EQU	R5
  REG                 2557     TEMP7		EQU	R6
  REG                 2558     TEMP8		EQU	R7
                      2559     
                      2560     ;**** **** **** **** ****
                      2561     ; Register definitions
------                2562     DSEG AT 20H					; Variables segment 
                      2563     
0020                  2564     BIT_ACCESS: 				DS	1		; MUST BE AT THIS ADDRESS. Variable at bit accessible address (for non interrupt routines)
0021                  2565     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                      2566     
0022                  2567     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                  2568     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                  2569     CURRENT_PWM: 				DS	1		; Current pwm
0025                  2570     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited
0026                  2571     CURRENT_PWM_LIM_DITH: 		DS	1		; Current pwm that is limited and dithered (applied to the motor output)
0027                  2572     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0028                  2573     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0029                  2574     RCP_OUTSIDE_RANGE_CNT: 		DS	1		; RC pulse outside range counter (incrementing) 
002A                  2575     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
002B                  2576     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
                      2577     
002C                  2578     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                2579     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                2580     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                2581     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                2582     PWM_TIMER0_OVERFLOW			EQU	3		; Set for 48MHz MCUs when PWM timer 0 overflows
  0004                2583     DEMAG_ENABLED				EQU 	4		; Set when demag compensation is enabled (above a min speed and throttle)
  0005                2584     DEMAG_DETECTED				EQU 	5		; Set when excessive demag time is detected
  0006                2585     DEMAG_CUT_POWER			EQU 	6		; Set when demag compensation cuts power
  0007                2586     HIGH_RPM					EQU 	7		; Set when motor rpm is high (Comm_Period4x_H less than 2)
                      2587     
002D                  2588     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                2589     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                2590     STARTUP_PHASE				EQU 	1		; Set when in startup phase
  0002                2591     INITIAL_RUN_PHASE			EQU	2		; Set when in initial run phase, before synchronized run is achieved
  0003                2592     DIR_CHANGE_BRAKE			EQU 	3		; Set when braking before direction change
  0004                2593     COMP_TIMED_OUT				EQU 	4		; Set when comparator reading timed out
  0005                2594     GOV_ACTIVE				EQU 	5		; Set when governor is active (enabled when speed is above minimum)
  0006                2595     SKIP_DAMP_ON				EQU 	6 		; Set when turning damping fet on is skipped
                      2596     ;						EQU 	7 		
                      2597     
002E                  2598     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                2599     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                2600     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                2601     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode
  0003                2602     PGM_PWM_HIGH_FREQ			EQU	3		; Progremmed pwm high frequency
  0004                2603     RCP_PPM					EQU 	4		; RC pulse ppm type input (set also when oneshot is set)
  0005                2604     RCP_PPM_ONESHOT125			EQU 	5		; RC pulse ppm type input is OneShot125
  0006                2605     RCP_DIR_REV				EQU 	6		; RC pulse direction in bidirectional mode
                      2606     ;						EQU 	7	
                      2607     
002F                  2608     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                2609     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                2610     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                2611     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                2612     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                2613     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                2614     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                2615     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                2616     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                      2617     
                      2618     
                      2619     ;**** **** **** **** ****
                      2620     ; RAM definitions
------                2621     DSEG AT 30H						; Ram data segment, direct addressing
                      2622     
0030                  2623     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                      2624     
0031                  2625     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                  2626     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                      2627     
0033                  2628     STARTUP_CNT: 				DS	1		; Startup phase commutations counter (incrementing)
0034                  2629     INITIAL_RUN_ROT_CNT: 		DS	1		; Initial run rotations counter (incrementing)
0035                  2630     STALL_CNT: 				DS	1		; Counts start/run attempts that resulted in stall. Reset upon a proper stop
0036                  2631     DEMAG_DETECTED_METRIC: 		DS	1		; Metric used to gauge demag event frequency
0037                  2632     DEMAG_PWR_OFF_THRESH: 		DS	1		; Metric threshold above which power is cut
0038                  2633     LOW_RPM_PWR_SLOPE: 			DS	1		; Sets the slope of power increase for low rpms
                      2634     
0039                  2635     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003A                  2636     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003B                  2637     PREV_PREV_COMM_L: 			DS	1		; Pre-previous commutation timer3 timestamp (lo byte)
003C                  2638     PREV_PREV_COMM_H: 			DS	1		; Pre-previous commutation timer3 timestamp (hi byte)
003D                  2639     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003E                  2640     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003F                  2641     COMM_DIFF: 				DS	1		; Timer3 count difference between the last two commutations
0040                  2642     COMM_PHASE: 				DS	1		; Current commutation phase
0041                  2643     COMPARATOR_READ_CNT:  		DS	1		; Number of comparator reads done
                      2644     
0042                  2645     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0043                  2646     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0044                  2647     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0045                  2648     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0046                  2649     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0047                  2650     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0048                  2651     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0049                  2652     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
004A                  2653     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
                      2654     
004B                  2655     WT_ADV_START_L: 			DS	1		; Timer3 start point for commutation advance timing (lo byte)
004C                  2656     WT_ADV_START_H: 			DS	1		; Timer3 start point for commutation advance timing (hi byte)
004D                  2657     WT_ZC_SCAN_START_L: 			DS	1		; Timer3 start point from commutation to zero cross scan (lo byte)
004E                  2658     WT_ZC_SCAN_START_H: 			DS	1		; Timer3 start point from commutation to zero cross scan (hi byte)
004F                  2659     WT_ZC_TOUT_START_L: 			DS	1		; Timer3 start point for zero cross scan timeout (lo byte)
0050                  2660     WT_ZC_TOUT_START_H: 			DS	1		; Timer3 start point for zero cross scan timeout (hi byte)
0051                  2661     WT_COMM_START_L: 			DS	1		; Timer3 start point from zero cross to commutation (lo byte)
0052                  2662     WT_COMM_START_H: 			DS	1		; Timer3 start point from zero cross to commutation (hi byte)
0053                  2663     NEXT_WT_START_L: 			DS	1		; Timer3 start point for next wait period (lo byte)
0054                  2664     NEXT_WT_START_H: 			DS	1		; Timer3 start point for next wait period (hi byte)
                      2665     
0055                  2666     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0056                  2667     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0057                  2668     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0058                  2669     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0059                  2670     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
005A                  2671     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
005B                  2672     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
005C                  2673     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005D                  2674     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005E                  2675     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005F                  2676     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
0060                  2677     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      2678     
0061                  2679     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
0062                  2680     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup
0063                  2681     PWM_LIMIT_BY_RPM: 			DS	1		; Maximum allowed pwm for low or high rpms
0064                  2682     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0065                  2683     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0066                  2684     PWM_DITHER_DECODED: 			DS	1		; Decoded pwm dither value
0067                  2685     PWM_DITHER_EXCESS_POWER: 		DS	1		; Excess power (above max) from pwm dither
0068                  2686     RANDOM: 					DS	1		; Random number from LFSR 
                      2687     
0069                  2688     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
006A                  2689     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
006B                  2690     MAIN_SPOOLUP_TIME_3X: 		DS	1		; Main spoolup time x3
006C                  2691     MAIN_SPOOLUP_TIME_10X: 		DS	1		; Main spoolup time x10
006D                  2692     MAIN_SPOOLUP_TIME_15X: 		DS	1		; Main spoolup time x15
                      2693     
006E                  2694     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006F                  2695     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
0070                  2696     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      2697     
0071                  2698     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      2699     
0072                  2700     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
0073                  2701     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      2702     
0074                  2703     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0075                  2704     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0076                  2705     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      2706     
0077                  2707     SKIP_T2_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 interrupt shall be ignored 
0078                  2708     SKIP_T2H_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 high interrupt shall be ignored 
0079                  2709     TIMER0_OVERFLOW_VALUE: 		DS	1		; Remaining timer 0 wait time used with 48MHz MCUs
007A                  2710     CLOCK_SET_AT_48MHZ: 			DS	1		; Variable set if 48MHz MCUs run at 48MHz
007B                  2711     DAMPINGFET: 				DS	1		; Port position of fet used for damping
007C                  2712     CURRENT_PWM_LIMITED_REMAPPED: 	DS	1
007D                  2713     CURRENT_PWM_LIM_DITH_REMAPPED:  DS	1
                      2714     
                      2715     ; Indirect addressing data segment. The variables below must be in this sequence
------                2716     ISEG AT 080H					
0080                  2717     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  2718     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  2719     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  2720     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  2721     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  2722     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  2723     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  2724     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  2725     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  2726     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  2727     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  2728     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  2729     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  2730     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  2731     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  2732     _PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm (unused - place holder)
0090                  2733     _PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration (unused - place holder)
0091                  2734     _PGM_VOLT_COMP: 			DS	1		; Place holder
0092                  2735     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  2736     _PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force (unused - place holder)
0094                  2737     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  2738     _PGM_STARTUP_METHOD: 		DS	1		; Programmed startup method (unused - place holder)
0096                  2739     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  2740     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  2741     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  2742     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  2743     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  2744     _PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate (unused - place holder)
009C                  2745     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  2746     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  2747     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
009F                  2748     PGM_MAIN_SPOOLUP_TIME: 		DS	1		; Programmed main spoolup time
00A0                  2749     PGM_ENABLE_TEMP_PROT: 		DS	1		; Programmed temperature protection enable
00A1                  2750     PGM_ENABLE_POWER_PROT: 		DS	1		; Programmed low rpm power protection enable
00A2                  2751     PGM_ENABLE_PWM_INPUT: 		DS	1		; Programmed PWM input signal enable
00A3                  2752     PGM_PWM_DITHER: 			DS	1		; Programmed output PWM dither
                      2753     
                      2754     ; The sequence of the variables below is no longer of importance
00A4                  2755     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A5                  2756     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A6                  2757     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
                      2758     
                      2759     
                      2760     ; Indirect addressing data segment
------                2761     ISEG AT 0D0H					
00D0                  2762     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      2763     
                      2764     
                      2765     ;**** **** **** **** ****
------                2766     CSEG AT 1A00H            ; "Eeprom" segment
  000E                2767     EEPROM_FW_MAIN_REVISION		EQU	14		; Main revision of the firmware
  0003                2768     EEPROM_FW_SUB_REVISION		EQU	3		; Sub revision of the firmware
  0014                2769     EEPROM_LAYOUT_REVISION		EQU	20		; Revision of the EEPROM layout
                      2770     
1A00    0E            2771     EEP_FW_MAIN_REVISION:  DB 14 
1A01    03            2772     EEP_FW_SUB_REVISION:  DB 3 
1A02    14            2773     EEP_LAYOUT_REVISION:  DB 20 
                      2774     
                      2775     IF MODE == 0
1A03    07            2776     EEP_PGM_GOV_P_GAIN:  DB 7 
1A04    07            2777     EEP_PGM_GOV_I_GAIN:  DB 7 
1A05    01            2778     EEP_PGM_GOV_MODE:  DB 1 
1A06    04            2779     EEP_PGM_LOW_VOLTAGE_LIM:  DB 4 
1A07    FF            2780     _EEP_PGM_MOTOR_GAIN: 		DB	0FFH							
1A08    FF            2781     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							
1A09    09            2782     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    02            2783     EEP_PGM_PWM_FREQ:  DB 2 
1A0B    01            2784     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            2785     EEP_PGM_INPUT_POL:  DB 1 
1A0D    A5            2786     EEP_INITIALIZED_L: 			DB	0A5H							; EEPROM initialized signature low byte
1A0E    5A            2787     EEP_INITIALIZED_H: 			DB	05AH							; EEPROM initialized signature high byte
1A0F    01            2788     EEP_ENABLE_TX_PROGRAM:  DB 1 
1A10    00            2789     EEP_MAIN_REARM_START:  DB 0 
1A11    B4            2790     EEP_PGM_GOV_SETUP_TARGET:  DB 180 
1A12    FF            2791     _EEP_PGM_STARTUP_RPM: 		DB	0FFH	
1A13    FF            2792     _EEP_PGM_STARTUP_ACCEL: 		DB	0FFH	
1A14    FF            2793     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            2794     EEP_PGM_COMM_TIMING:  DB 3 
1A16    FF            2795     _EEP_PGM_DAMPING_FORCE: 		DB	0FFH						
1A17    01            2796     EEP_PGM_GOV_RANGE:  DB 1 
1A18    FF            2797     _EEP_PGM_STARTUP_METHOD: 		DB	0FFH	
1A19    25            2798     EEP_PGM_PPM_MIN_THROTTLE:  DB 37 
1A1A    D0            2799     EEP_PGM_PPM_MAX_THROTTLE:  DB 208 
1A1B    78            2800     EEP_PGM_BEEP_STRENGTH:  DB 120 
1A1C    C8            2801     EEP_PGM_BEACON_STRENGTH:  DB 200 
1A1D    04            2802     EEP_PGM_BEACON_DELAY:  DB 4 
1A1E    FF            2803     _EEP_PGM_THROTTLE_RATE: 		DB	0FFH	
1A1F    01            2804     EEP_PGM_DEMAG_COMP:  DB 1 
1A20    00            2805     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    FF            2806     _EEP_PGM_PPM_CENTER_THROTTLE: 	DB	0FFH							
1A22    0A            2807     EEP_PGM_MAIN_SPOOLUP_TIME:  DB 10 
1A23    01            2808     EEP_PGM_TEMP_PROT_ENABLE:  DB 1 
1A24    01            2809     EEP_PGM_ENABLE_POWER_PROT:  DB 1 
1A25    00            2810     EEP_PGM_ENABLE_PWM_INPUT:  DB 0 
1A26    FF            2811     _EEP_PGM_PWM_DITHER: 		DB	0FFH	
                      2812     ENDIF 
                      2813     
                      2814     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               EEP_PGM_PWM_DITHER:			DB	DEFAULT_PGM_TAIL_PWM_DITHER		; EEPROM copy of programmed output PWM dither
                               ENDIF
                      2852     
                      2853     IF MODE == 2
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MULTI_P_GAIN			; EEPROM copy of programmed closed loop P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MULTI_I_GAIN			; EEPROM copy of programmed closed loop I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MULTI_GOVERNOR_MODE	; EEPROM copy of programmed closed loop mode
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_MULTI_GAIN			; EEPROM copy of programmed tail gain
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MULTI_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MULTI_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MULTI_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MULTI_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	055H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0AAH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MULTI_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MULTI_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MULTI_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MULTI_BEACON_DELAY	; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MULTI_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               EEP_PGM_PWM_DITHER:			DB	DEFAULT_PGM_MULTI_PWM_DITHER		; EEPROM copy of programmed output PWM dither
                               ENDIF
                      2891     
1A27    FF            2892     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      2893     
------                2894     CSEG AT 1A60H
1A60    20202020      2895     EEP_NAME: 					DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      2896     
                      2897     ;**** **** **** **** ****
                      2898     INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                2898+1   CSEG AT 0  ; CODE SEGMENT START
0000    0219FD        2898+1   JMP RESET 
------                2898+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200B5        2898+1   JMP T0_INT 
------                2898+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0201AD        2898+1   JMP T2_INT 
------                2898+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020361        2898+1   JMP PCA_INT 
------                2898+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    020347        2898+1   JMP T3_INT 
------                2899     CSEG AT 80H			; Code segment after interrupt vectors 
                      2900     
                      2901     ;**** **** **** **** ****
                      2902     
                      2903     ; Table definitions
0080    02030406      2904     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    0406080C      2905     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
0091    10182030
0095    406080A0
0099    C0
009A    00070F1F      2906     PWM_DITHER_TABLE:   		DB 	00H, 07H, 0FH, 1FH, 3FH
009E    3F
                      2907     IF MODE == 0
                      2908       IF DAMPED_MODE_ENABLE == 1
009F    0D0D0403      2909     	TX_PGM_PARAMS_MAIN:   	DB 	13, 13, 4, 3, 6, 13, 5, 3, 3, 2, 2
00A3    060D0503
00A7    030202
                      2910       ENDIF
                      2911       IF DAMPED_MODE_ENABLE == 0
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 2, 3, 2, 2
                                 ENDIF
                      2914     ENDIF
                      2915     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF
                               ENDIF
                      2923     IF MODE == 2
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF 
                               ENDIF
                      2931     
                      2932     ; Subroutine remaps pwm value (implements throttle curve)
                      2933     ; Input: A holds value to be remapped and ranges from 0 to 255
                      2934     ; Output: A holds remapped value
                      2935     ; -Patrick
                      2936     MOTOR_PWM_REMAP: 
00AA    C0F0          2937         PUSH B
00AC    75F02B        2938     MOV B , # 43 
00AF    A4            2939         MUL  AB
00B0    E5F0          2940         MOV  A, B
00B2    D0F0          2941         POP  B
00B4    22            2942         RET
                      2943     
                      2944     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2945     ;
                      2946     ; Timer0 interrupt routine
                      2947     ;
                      2948     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      2949     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      2950     ;
                      2951     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2952     T0_INT: 	; Used for pwm control
00B5    C2AF          2953     	CLR 	EA			; Disable all interrupts
                      2954     IF MCU_48MHZ == 1
                      2955     	; Check overflow flag
00B7    306308        2956     JNB FLAGS0 . 3 , T0_INT_START 
                      2957     
00BA    C263          2958     CLR FLAGS0 . 3 
00BC    85798A        2959     	MOV	TL0, TIMER0_OVERFLOW_VALUE	; Set timer 
00BF    D2AF          2960     	SETB	EA			; Enable all interrupts
00C1    32            2961     	RETI
                      2962     
                      2963     T0_INT_START: 
                      2964     ENDIF
00C2    C0D0          2965     	PUSH	PSW			; Preserve registers through interrupt
00C4    C0E0          2966     	PUSH	ACC	
                      2967     	
                      2968     	; Scale Current_Pwm_Limited and Current_Pwm_Lim_Dith by MOTOR_PPM_LOW_SLOPE -Patrick
                      2969     
                      2970     	; Scale Current_Pwm_Limited -Patrick
00C6    E525          2971     	MOV	A, CURRENT_PWM_LIMITED
00C8    11AA          2972     	CALL MOTOR_PWM_REMAP
00CA    F57C          2973     	MOV  CURRENT_PWM_LIMITED_REMAPPED, A
                      2974     
                      2975     	; Scale Current_Pwm_Lim_Dith -Patrick
00CC    E526          2976     	MOV	A, CURRENT_PWM_LIM_DITH
00CE    11AA          2977     	CALL MOTOR_PWM_REMAP
00D0    F57D          2978     	MOV  CURRENT_PWM_LIM_DITH_REMAPPED, A
                      2979     
                      2980     	; Check if pwm is on
00D2    206227        2981     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      2982     
                      2983     	; Pwm on cycle
00D5    E57C          2984     	MOV	A, CURRENT_PWM_LIMITED_REMAPPED ; Replace with remapped value -Patrick
00D7    6002          2985     	JZ	T0_INT_PWM_ON_EXIT
                      2986     
                      2987     T0_INT_PWM_ON_EXECUTE: 
00D9    E4            2988     	CLR	A					
00DA    73            2989     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      2990     
                      2991     T0_INT_PWM_ON_EXIT: 
                      2992     	; Set timer for coming on cycle length
00DB    E57C          2993     	MOV 	A, CURRENT_PWM_LIMITED_REMAPPED		; Load current pwm and replace with remapped value -Patrick
00DD    F4            2994     	CPL	A						; cpl is 255-x
                      2995     IF MCU_48MHZ == 0
                               	MOV	TL0, A					; Write start point for timer
                               ELSE
00DE    C3            2998     	CLR	C
00DF    33            2999     	RLC	A
00E0    4009          3000     	JC	T0_INT_PWM_ON_SET_TIMER
                      3001     
00E2    758A00        3002     	MOV	TL0, #0
00E5    D263          3003     SETB FLAGS0 . 3 
00E7    F579          3004     	MOV	TIMER0_OVERFLOW_VALUE, A
00E9    01ED          3005     	AJMP	T0_INT_PWM_ON_TIMER_SET
                      3006     
                      3007     T0_INT_PWM_ON_SET_TIMER: 
00EB    F58A          3008     	MOV	TL0, A
                      3009     T0_INT_PWM_ON_TIMER_SET: 
                      3010     ENDIF
                      3011     	; Set other variables
00ED    758B00        3012     	MOV	TL1, #0					; Reset timer1	
                      3013     IF MCU_48MHZ == 1
00F0    758D00        3014     	MOV	TH1, #0		
                      3015     ENDIF
00F3    D262          3016     SETB FLAGS0 . 2 
                      3017     	; Exit interrupt
00F5    D0E0          3018     	POP	ACC			; Restore preserved registers
00F7    D0D0          3019     	POP	PSW
00F9    D2AF          3020     	SETB	EA			; Enable all interrupts
00FB    32            3021     	RETI
                      3022     
                      3023     
                      3024     	; Pwm off cycle
                      3025     T0_INT_PWM_OFF: 
                      3026     IF MCU_48MHZ == 0
                               	MOV	TL0, CURRENT_PWM_LIM_DITH_REMAPPED	; Load new timer setting and replace with remapped value -Patrick
                               ELSE
00FC    C3            3029     	CLR	C
00FD    E57D          3030     	MOV	A, CURRENT_PWM_LIM_DITH_REMAPPED ; Replace with remapped value -Patrick
00FF    33            3031     	RLC	A
0100    4009          3032     	JC	T0_INT_PWM_OFF_SET_TIMER 
                      3033     
0102    758A00        3034     	MOV	TL0, #0
0105    D263          3035     SETB FLAGS0 . 3 
0107    F579          3036     	MOV	TIMER0_OVERFLOW_VALUE, A
0109    210D          3037     	AJMP	T0_INT_PWM_OFF_TIMER_SET
                      3038     
                      3039     T0_INT_PWM_OFF_SET_TIMER: 
010B    F58A          3040     	MOV	TL0, A
                      3041     T0_INT_PWM_OFF_TIMER_SET: 
                      3042     ENDIF
                      3043     	; Clear pwm on flag
010D    C262          3044     CLR FLAGS0 . 2 
                      3045     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
010F    E57D          3046     	MOV	A, CURRENT_PWM_LIM_DITH_REMAPPED		; Load current pwm and replace with remapped value -Patrick
0111    F4            3047     	CPL	A						; Full pwm?
0112    6038          3048     	JZ	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      3049     
                      3050     IF DAMPED_MODE_ENABLE == 1
                      3051     	; Do not execute damped pwm when stopped
0114    306803        3052     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_EXIT_NFETS_OFF 
                      3053     
                      3054     	; If damped operation, set pFETs on in pwm_off
0117    207213        3055     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      3056     ENDIF
                      3057     
                      3058     T0_INT_PWM_OFF_EXIT_NFETS_OFF: 	
                      3059     	; Separate exit commands here for minimum delay
011A    758B00        3060     	MOV	TL1, #0		; Reset timer1	
                      3061     IF MCU_48MHZ == 1
011D    758D00        3062     	MOV	TH1, #0		
                      3063     ENDIF
0120    D0E0          3064     	POP	ACC			; Restore preserved registers
0122    D0D0          3065     	POP	PSW
                      3066     	ALL_NFETS_OFF 		; Switch off all nfets
0124    C293          3066+1   CLR P1 . 3 
0126    C297          3066+1   CLR P1 . 7 
0128    C294          3066+1   CLR P1 . 4 
012A    D2AF          3067     	SETB	EA			; Enable all interrupts
012C    32            3068     	RETI
                      3069     
                      3070     T0_INT_PWM_OFF_DAMPED: 
                      3071     IF PFETON_DELAY < 128
                      3072     	ALL_NFETS_OFF 				; Switch off all nfets
012D    C293          3072+1   CLR P1 . 3 
012F    C297          3072+1   CLR P1 . 7 
0131    C294          3072+1   CLR P1 . 4 
0133    206E09        3073     JB FLAGS1 . 6 , T0_INT_PWM_OFF_DAMP_DONE 
                      3074     IF PFETON_DELAY NE 0
0136    740C          3075     MOV A , # 12 
0138    D5E0FD        3076     	DJNZ	ACC, $	
                      3077     ENDIF
                      3078     	DAMPING_FET_ON
013B    E57B          3078+1   MOV A , DAMPINGFET 
013D    4290          3078+1   ORL P1 , A 
                      3079     T0_INT_PWM_OFF_DAMP_DONE: 
                      3080     ENDIF
                      3081     IF PFETON_DELAY >= 128			; "Negative", 1's complement
                               	JB	FLAGS1.SKIP_DAMP_ON, T0_INT_PWM_OFF_DAMP_DONE
                               	DAMPING_FET_ON				; Damping fet on
                               	MOV	A, #PFETON_DELAY
                               	CPL	A
                               T0_INT_PWM_OFF_DAMP_DONE:
                               	ALL_NFETS_OFF 				; Switch off all nfets
                               ENDIF
                      3089     T0_INT_PWM_OFF_EXIT: 	
013F    758B00        3090     	MOV	TL1, #0		; Reset timer1	
                      3091     IF MCU_48MHZ == 1
0142    758D00        3092     	MOV	TH1, #0		
                      3093     ENDIF
0145    D0E0          3094     	POP	ACC			; Restore preserved registers
0147    D0D0          3095     	POP	PSW
0149    D2AF          3096     	SETB	EA			; Enable all interrupts
014B    32            3097     	RETI
                      3098     
                      3099     T0_INT_PWM_OFF_FULLPOWER_EXIT: 
014C    758A00        3100     	MOV	TL0, #0		; Set long time till next interrupt
                      3101     IF MCU_48MHZ == 1
014F    D263          3102     SETB FLAGS0 . 3 
0151    757900        3103     	MOV	TIMER0_OVERFLOW_VALUE, #0
                      3104     ENDIF
0154    C28D          3105     	CLR	TF0			; Clear interrupt flag
0156    D262          3106     SETB FLAGS0 . 2 
0158    213F          3107     	AJMP	T0_INT_PWM_OFF_EXIT
                      3108     
                      3109     
                      3110     PWM_NOFET: 	; Dummy pwm on cycle
015A    01DB          3111     	AJMP	T0_INT_PWM_ON_EXIT
                      3112     
                      3113     PWM_AFET: 		; Pwm on cycle afet on
015C    306805        3114     JNB FLAGS1 . 0 , PWM_AFET_EXIT 
015F    206602        3115     JB FLAGS0 . 6 , PWM_AFET_EXIT 
                      3116     	ANFET_ON	
0162    D293          3116+1   SETB P1 . 3 
                      3117     PWM_AFET_EXIT: 
0164    01DB          3118     	AJMP	T0_INT_PWM_ON_EXIT
                      3119     
                      3120     PWM_BFET: 		; Pwm on cycle bfet on
0166    306805        3121     JNB FLAGS1 . 0 , PWM_BFET_EXIT 
0169    206602        3122     JB FLAGS0 . 6 , PWM_BFET_EXIT 
                      3123     	BNFET_ON
016C    D294          3123+1   SETB P1 . 4 
                      3124     PWM_BFET_EXIT: 
016E    01DB          3125     	AJMP	T0_INT_PWM_ON_EXIT
                      3126     
                      3127     PWM_CFET: 		; Pwm on cycle cfet on
0170    306805        3128     JNB FLAGS1 . 0 , PWM_CFET_EXIT 
0173    206602        3129     JB FLAGS0 . 6 , PWM_CFET_EXIT 
                      3130     	CNFET_ON
0176    D297          3130+1   SETB P1 . 7 
                      3131     PWM_CFET_EXIT: 
0178    01DB          3132     	AJMP	T0_INT_PWM_ON_EXIT
                      3133     
                      3134     PWM_AFET_DAMPED: 	
                      3135     	APFET_OFF
017A    C292          3135+1   CLR P1 . 2 
017C    30680A        3136     JNB FLAGS1 . 0 , PWM_AFET_DAMPED_EXIT 
017F    206607        3137     JB FLAGS0 . 6 , PWM_AFET_DAMPED_EXIT 
                      3138     IF NFETON_DELAY NE 0
0182    740C          3139     MOV A , # 12 
0184    D5E0FD        3140     	DJNZ ACC,	$
                      3141     ENDIF
                      3142     PWM_AFET_DAMPED_DONE: 
                      3143     	ANFET_ON								; Switch nFET
0187    D293          3143+1   SETB P1 . 3 
                      3144     PWM_AFET_DAMPED_EXIT: 
0189    01DB          3145     	AJMP	T0_INT_PWM_ON_EXIT
                      3146     
                      3147     PWM_BFET_DAMPED: 
                      3148     	BPFET_OFF
018B    C295          3148+1   CLR P1 . 5 
018D    30680A        3149     JNB FLAGS1 . 0 , PWM_BFET_DAMPED_EXIT 
0190    206607        3150     JB FLAGS0 . 6 , PWM_BFET_DAMPED_EXIT 
                      3151     IF NFETON_DELAY NE 0
0193    740C          3152     MOV A , # 12 
0195    D5E0FD        3153     	DJNZ ACC,	$
                      3154     ENDIF
                      3155     PWM_BFET_DAMPED_DONE: 
                      3156     	BNFET_ON								; Switch nFET
0198    D294          3156+1   SETB P1 . 4 
                      3157     PWM_BFET_DAMPED_EXIT: 
019A    01DB          3158     	AJMP	T0_INT_PWM_ON_EXIT
                      3159     
                      3160     PWM_CFET_DAMPED: 	
                      3161     	CPFET_OFF
019C    C296          3161+1   CLR P1 . 6 
019E    30680A        3162     JNB FLAGS1 . 0 , PWM_CFET_DAMPED_EXIT 
01A1    206607        3163     JB FLAGS0 . 6 , PWM_CFET_DAMPED_EXIT 
                      3164     IF NFETON_DELAY NE 0
01A4    740C          3165     MOV A , # 12 
01A6    D5E0FD        3166     	DJNZ ACC,	$
                      3167     ENDIF
                      3168     PWM_CFET_DAMPED_DONE: 
                      3169     	CNFET_ON								; Switch nFET
01A9    D297          3169+1   SETB P1 . 7 
                      3170     PWM_CFET_DAMPED_EXIT:  
01AB    01DB          3171     	AJMP	T0_INT_PWM_ON_EXIT
                      3172     
                      3173     
                      3174     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3175     ;
                      3176     ; Timer2 interrupt routine
                      3177     ;
                      3178     ; No assumptions
                      3179     ;
                      3180     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3181     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
01AD    C2AF          3182     	CLR	EA
01AF    C2AD          3183     	CLR	ET2			; Disable timer2 interrupts
01B1    53E6EF        3184     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
01B4    C0D0          3185     	PUSH	PSW			; Preserve registers through interrupt
01B6    C0E0          3186     	PUSH	ACC
01B8    D2D3          3187     	SETB	PSW.3		; Select register bank 1 for interrupt routines
01BA    D2AF          3188     	SETB	EA
                      3189     IF MCU_48MHZ == 1
01BC    E57A          3190     	MOV	A, CLOCK_SET_AT_48MHZ
01BE    6009          3191     	JZ 	T2_INT_START
                      3192     
                      3193     	; Check skip variable
01C0    E577          3194     	MOV	A, SKIP_T2_INT
01C2    6005          3195     	JZ	T2_INT_START				; Execute this interrupt
                      3196     
01C4    757700        3197     	MOV	SKIP_T2_INT, #0
01C7    4152          3198     	AJMP	T2_INT_EXIT
                      3199     
                      3200     T2_INT_START: 
01C9    757701        3201     	MOV	SKIP_T2_INT, #1			; Skip next interrupt
                      3202     ENDIF
                      3203     	; Clear low byte interrupt flag
01CC    C2CE          3204     	CLR	TF2L						; Clear interrupt flag
                      3205     	; Check RC pulse timeout counter
01CE    E52A          3206     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
01D0    6007          3207     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      3208     
                      3209     	; Decrement timeout counter (if PWM)
01D2    207449        3210     JB FLAGS2 . 4 , T2_INT_SKIP_START 
                      3211     
01D5    152A          3212     	DEC	RCP_TIMEOUT_CNT			; No - decrement
01D7    411E          3213     	AJMP	T2_INT_SKIP_START
                      3214     
                      3215     T2_INT_PULSES_ABSENT: 
                      3216     	; Timeout counter has reached zero, pulses are absent
01D9    7800          3217     MOV R0 , # 0 
01DB    7900          3218     MOV R1 , # 0 
01DD    20742E        3219     JB FLAGS2 . 4 , T2_INT_PULSES_ABSENT_NO_MAX 
                      3220     
                      3221     	READ_RCP_INT 					; Look at value of Rcp_In
01E0    E580          3221+1   MOV A , P0 
01E2    307E01        3221+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
01E5    F4            3221+1   CPL A  ; YES - INVERT
01E6    30E502        3222     JNB ACC . 5 , ( $+5 ) 
01E9    78FF          3223     MOV R0 , # 255 
                      3224     	RCP_INT_FIRST 					; Set interrupt trig to first again
01EB    53DACF        3224+1   ANL PCA0CPM0 , # 0CFH 
01EE    207E03        3224+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
01F1    43DA20        3224+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
01F4    307E03        3224+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
01F7    43DA10        3224+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3225     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
01FA    C2D8          3225+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
01FC    C271          3226     CLR FLAGS2 . 1 
                      3227     	READ_RCP_INT 					; Look once more at value of Rcp_In
01FE    E580          3227+1   MOV A , P0 
0200    307E01        3227+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0203    F4            3227+1   CPL A  ; YES - INVERT
0204    30E502        3228     JNB ACC . 5 , ( $+5 ) 
0207    79FF          3229     MOV R1 , # 255 
0209    C3            3230     	CLR	C
020A    E8            3231     MOV A , R0 
020B    99            3232     SUBB A , R1 
020C    70CB          3233     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      3234     
                      3235     T2_INT_PULSES_ABSENT_NO_MAX: 
020E    306103        3236     JNB FLAGS0 . 1 , ( $+6 ) 
                      3237     
0211    752A40        3238     MOV RCP_TIMEOUT_CNT , # 64 
                      3239     
0214    207403        3240     JB FLAGS2 . 4 , T2_INT_PPM_TIMEOUT_SET 
                      3241     
0217    752A40        3242     MOV RCP_TIMEOUT_CNT , # 64 
                      3243     
                      3244     T2_INT_PPM_TIMEOUT_SET: 
021A    885C          3245     MOV NEW_RCP , R0 
021C    D270          3246     SETB FLAGS2 . 0 
                      3247     
                      3248     T2_INT_SKIP_START: 
021E    20740D        3249     JB FLAGS2 . 4 , T2_INT_RCP_UPDATE_START 
                      3250     
                      3251     	; Check RC pulse skip counter
0221    E52B          3252     	MOV	A, RCP_SKIP_CNT			
0223    6004          3253     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      3254     	
                      3255     	; Decrement skip counter (only if edge counter is zero)
0225    152B          3256     	DEC	RCP_SKIP_CNT				; Decrement
0227    412E          3257     	AJMP	T2_INT_RCP_UPDATE_START
                      3258     
                      3259     T2_INT_SKIP_END: 
                      3260     	; Skip counter has reached zero, start looking for RC pulses again
                      3261     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0229    43DA01        3261+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      3262     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
022C    C2D8          3262+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3263     	
                      3264     T2_INT_RCP_UPDATE_START: 
                      3265     	; Process updated RC pulse
022E    207002        3266     JB FLAGS2 . 0 , ( $+5 ) 
0231    4141          3267     	AJMP	T2_INT_CURRENT_PWM_UPDATE	; No - update pwm limits and exit
                      3268     
0233    A85C          3269     MOV R0 , NEW_RCP 
0235    206102        3270     JB FLAGS0 . 1 , ( $+5 ) 
                      3271     
0238    C270          3272     CLR FLAGS2 . 0 
                      3273     
                      3274     	; Use a gain of 1.0625x for pwm input if not governor mode
023A    207402        3275     JB FLAGS2 . 4 , T2_INT_PWM_MIN_RUN 
                      3276     
                      3277     IF MODE == 0	; Main - do not adjust gain
023D    413F          3278     	AJMP	T2_INT_PWM_MIN_RUN
                      3279     ELSE
                               
                               IF MODE == 2	; Multi 
                               	MOV	TEMP2, #PGM_GOV_MODE		; Closed loop mode?
                               	CJNE	@TEMP2, #4, T2_INT_PWM_MIN_RUN; Yes - branch
                               ENDIF
                               
                               	; Limit the maximum value to avoid wrap when scaled to pwm range
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
                               	JC	T2_INT_RCP_UPDATE_MULT
                               
                               	MOV	A, #240			; Set requested pwm to max
                               	MOV	TEMP1, A		
                               
                               T2_INT_RCP_UPDATE_MULT:	
                               	; Multiply by 1.0625 (optional adjustment gyro gain)
                               	MOV	A, TEMP1
                               	SWAP	A			; After this "0.0625"
                               	ANL	A, #0FH
                               	ADD	A, TEMP1
                               	MOV	TEMP1, A		
                               	; Adjust tail gain
                               	MOV	TEMP2, #PGM_MOTOR_GAIN
                               	CJNE	@TEMP2, #3, ($+5)			; Is gain 1?
                               	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                               
                               	CLR	C
                               	RRC	A			; After this "0.5"
                               	CLR	C
                               	RRC	A			; After this "0.25"
                               	MOV	BIT_ACCESS_INT, @TEMP2				; (Temp2 has #Pgm_Motor_Gain)
                               	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                               
                               	CLR	C
                               	RRC	A			; After this "0.125"
                               
                               T2_INT_RCP_GAIN_CORR:
                               	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                               
                               	CLR	C
                               	XCH	A, TEMP1
                               	SUBB	A, TEMP1					; Apply negative correction
                               	MOV	TEMP1, A
                               	AJMP	T2_INT_PWM_MIN_RUN
                               
                               T2_INT_RCP_GAIN_POS:
                               	ADD	A, TEMP1					; Apply positive correction
                               	MOV	TEMP1, A
                               	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                               
                               	MOV	A, #0FFH					; Yes - limit
                               	MOV	TEMP1, A
                               ENDIF
                      3334     
                      3335     T2_INT_PWM_MIN_RUN:  
                      3336     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      3346     
                      3347     T2_INT_PWM_UPDATE:  
                      3348     	; Update requested_pwm
023F    8822          3349     MOV REQUESTED_PWM , R0 
                      3350     IF MODE >= 1	; Tail or multi
                               	; Boost pwm during direct start
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JZ	T2_INT_CURRENT_PWM_UPDATE
                               
                               	MOV	A, STARTUP_CNT				; Add an extra power boost during start
                               	CLR	C
                               	RRC	A
                               	CLR	C
                               	RRC	A
                               	ADD	A, REQUESTED_PWM			
                               	MOV	REQUESTED_PWM, A
                               	JNC	($+5)
                               
                               	MOV	REQUESTED_PWM, #0FFH
                               
                               ENDIF
                      3368     T2_INT_CURRENT_PWM_UPDATE:  
                      3369     IF MODE == 0 OR MODE == 2	; Main or multi
0241    7882          3370     MOV R0 , # PGM_GOV_MODE 
0243    B60403        3371     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      3372     ENDIF
                      3373     
0246    852224        3374     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      3375     IF MODE >= 1	; Tail or multi
                               	; Set current_pwm_limited
                               	MOV	TEMP1, CURRENT_PWM			; Default not limited
                               	CLR	C
                               	MOV	A, CURRENT_PWM				; Check against limit
                               	SUBB	A, PWM_LIMIT
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT			; Limit pwm
                               
                               IF MODE == 2	; Multi
                               	; Limit pwm for low rpms
                               	CLR	C
                               	MOV	A, TEMP1					; Check against limit
                               	SUBB	A, PWM_LIMIT_BY_RPM
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT_BY_RPM		; Limit pwm
                               
                               ENDIF
                               	MOV	CURRENT_PWM_LIMITED, TEMP1
                               	; Dither
                               	MOV	A, PWM_DITHER_DECODED		; Load pwm dither
                               	JNZ	($+4)					; If active - branch
                               	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                               
                               	CLR	C
                               	MOV	A, TEMP1
                               	MOV	TEMP3, PWM_DITHER_DECODED				
                               	SUBB	A, TEMP3					; Calculate pwm minus dither value
                               	JNC	T2_INT_CURRENT_PWM_FULL_DITHER; If pwm more than dither value, then do full dither
                               
                               	MOV	A, TEMP1					; Set dither level to current pwm
                               	MOV	TEMP3, A				
                               	CLR	A						; Set pwm minus dither
                               
                               T2_INT_CURRENT_PWM_FULL_DITHER:
                               	MOV	TEMP2, A					; Load pwm minus dither value
                               	MOV	A, TEMP3					; Load dither	
                               	CLR	C
                               	RLC	A						; Shift left once
                               	MOV	TEMP4, A
                               	MOV	A, RANDOM					; Load random number
                               	CPL	A						; Invert to create proper DC bias in random code
                               	ANL	A, TEMP4					; And with double dither value
                               	ADD	A, TEMP2					; Add pwm minus dither
                               	JC	T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER	; If dither cause power above max - branch and increase excess 
                               
                               	ADD	A, PWM_DITHER_EXCESS_POWER	; Add excess power from previous cycles
                               	MOV	TEMP1, A
                               	MOV	A, PWM_DITHER_EXCESS_POWER	; Decrement excess power
                               	JZ	($+4)
                               	DEC	PWM_DITHER_EXCESS_POWER
                               	JC	T2_INT_CURRENT_PWM_DITHER_MAX_POWER; If dither cause power above max - branch
                               
                               	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                               
                               T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER:
                               	INC	TEMP3					; Add one to dither in order to always reach max power
                               	CLR	C
                               	MOV	A, PWM_DITHER_EXCESS_POWER
                               	SUBB	A, TEMP3					; Limit excess power 
                               	JNC	($+4)
                               	INC	PWM_DITHER_EXCESS_POWER
                               
                               T2_INT_CURRENT_PWM_DITHER_MAX_POWER:
                               	MOV	TEMP1, #255				; Set power to max
                               
                               T2_INT_CURRENT_PWM_NO_DITHER:
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               IF DAMPED_MODE_ENABLE == 1
                               	; Skip damping fet switching for high throttle
                               	CLR	FLAGS1.SKIP_DAMP_ON
                               	CLR	C
                               	MOV	A, CURRENT_PWM_LIM_DITH
                               	SUBB	A, #248
                               	JC	T2_INT_PWM_EXIT
                               	SETB	FLAGS1.SKIP_DAMP_ON
                               ENDIF
                               ENDIF
                      3455     T2_INT_PWM_EXIT: 	
                      3456     	; Set demag enabled if pwm is above limit
0249    C3            3457     	CLR	C
024A    E525          3458     	MOV	A, CURRENT_PWM_LIMITED	
024C    9440          3459     	SUBB	A, #40H					; Set if above 25%
024E    4002          3460     	JC	($+4)
                      3461     
0250    D264          3462     SETB FLAGS0 . 4 
                      3463     
                      3464     T2_INT_EXIT: 	
                      3465     	; Check if high byte flag is set
0252    20CF0A        3466     	JB	TF2H, T2H_INT		
0255    D0E0          3467     	POP	ACC			; Restore preserved registers
0257    D0D0          3468     	POP	PSW
0259    43E610        3469     	ORL	EIE1, #10H	; Enable PCA0 interrupts
025C    D2AD          3470     	SETB	ET2			; Enable timer2 interrupts
025E    32            3471     	RETI
                      3472     
                      3473     T2H_INT: 
                      3474     IF MCU_48MHZ == 1
025F    E57A          3475     	MOV	A, CLOCK_SET_AT_48MHZ
0261    6009          3476     	JZ 	T2H_INT_START
                      3477     
                      3478     	; Check skip variable
0263    E578          3479     	MOV	A, SKIP_T2H_INT
0265    6005          3480     	JZ	T2H_INT_START				; Execute this interrupt
                      3481     
0267    757800        3482     	MOV	SKIP_T2H_INT, #0
026A    613D          3483     	AJMP	T2H_INT_EXIT
                      3484     
                      3485     T2H_INT_START: 
026C    757801        3486     	MOV	SKIP_T2H_INT, #1			; Skip next interrupt
                      3487     ENDIF
                      3488     	; High byte interrupt (happens every 32ms)
026F    C2CF          3489     	CLR	TF2H					; Clear interrupt flag
0271    7802          3490     MOV R0 , # 2 
                      3491     	; Check RC pulse timeout counter (used here for PPM only)
0273    E52A          3492     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
0275    6005          3493     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      3494     
                      3495     	; Decrement timeout counter (if PPM)
0277    307402        3496     JNB FLAGS2 . 4 , T2H_INT_RCP_STOP_CHECK 
                      3497     
027A    152A          3498     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      3499     
                      3500     T2H_INT_RCP_STOP_CHECK: 
                      3501     	; Check RC pulse against stop value
027C    C3            3502     	CLR	C
027D    E55C          3503     	MOV	A, NEW_RCP				; Load new pulse value
027F    9401          3504     SUBB A , # 1 
0281    4005          3505     	JC	T2H_INT_RCP_STOP
                      3506     
                      3507     	; RC pulse higher than stop value, reset stop counter
0283    755F00        3508     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0286    4199          3509     	AJMP	T2H_INT_RCP_GOV_PWM
                      3510     
                      3511     T2H_INT_RCP_STOP: 	
                      3512     	; RC pulse less than stop value
0288    756000        3513     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
028B    756900        3514     	MOV	SPOOLUP_LIMIT_CNT, #0
028E    E55F          3515     	MOV	A, RCP_STOP_CNT			; Increment stop counter
0290    2401          3516     	ADD	A, #1
0292    F55F          3517     	MOV	RCP_STOP_CNT, A
0294    5003          3518     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      3519     
0296    755FFF        3520     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      3521     
                      3522     T2H_INT_RCP_GOV_PWM: 
                      3523     IF MODE == 0	; Main
                      3524     	; Update governor variables
0299    7982          3525     MOV R1 , # PGM_GOV_MODE 
029B    B7020D        3526     CJNE @ R1 , # 2 , T2H_INT_RCP_GOV_BY_SETUP 
                      3527     
029E    306D1D        3528     JNB FLAGS1 . 5 , T2H_INT_RCP_GOV_BY_TX 
                      3529     
02A1    C3            3530     	CLR	C
02A2    E522          3531     	MOV	A, REQUESTED_PWM
02A4    9432          3532     	SUBB	A, #50						; Is requested pwm below 20%?
02A6    4016          3533     	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                      3534     
02A8    854A22        3535     	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                      3536     
                      3537     T2H_INT_RCP_GOV_BY_SETUP: 
02AB    7982          3538     MOV R1 , # PGM_GOV_MODE 
02AD    B7030E        3539     CJNE @ R1 , # 3 , T2H_INT_RCP_GOV_BY_TX 
                      3540     
02B0    306D0B        3541     JNB FLAGS1 . 5 , T2H_INT_RCP_GOV_BY_TX 
                      3542     
02B3    C3            3543     	CLR	C
02B4    E522          3544     	MOV	A, REQUESTED_PWM
02B6    9432          3545     	SUBB	A, #50						; Is requested pwm below 20%?
02B8    4004          3546     	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                      3547     
02BA    798E          3548     MOV R1 , # PGM_GOV_SETUP_TARGET 
02BC    8722          3549     MOV REQUESTED_PWM , @ R1 
                      3550     
                      3551     T2H_INT_RCP_GOV_BY_TX: 
02BE    C3            3552     	CLR	C
02BF    E523          3553     	MOV	A, GOVERNOR_REQ_PWM
02C1    9522          3554     	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
02C3    6008          3555     	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                      3556     
02C5    4004          3557     	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                      3558     
02C7    1523          3559     	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
02C9    41CD          3560     	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                      3561     
                      3562     T2H_INT_RCP_GOV_PWM_INC: 
02CB    0523          3563     	INC	GOVERNOR_REQ_PWM				; Increment
                      3564     
                      3565     T2H_INT_RCP_GOV_PWM_DONE: 
02CD    D8CA          3566     DJNZ R0 , T2H_INT_RCP_GOV_PWM 
                      3567     
02CF    0569          3568     	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
02D1    E569          3569     	MOV	A, SPOOLUP_LIMIT_CNT
02D3    7002          3570     	JNZ	($+4)						; Wrapped?
                      3571     
02D5    1569          3572     	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                      3573     
02D7    D56A63        3574     	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_EXIT	; Jump if skip count is not reached
                      3575     
02DA    756A01        3576     	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
02DD    7805          3577     MOV R0 , # 5 
02DF    C3            3578     	CLR	C
02E0    E569          3579     	MOV	A, SPOOLUP_LIMIT_CNT
02E2    956B          3580     	SUBB	A, MAIN_SPOOLUP_TIME_3X			; No spoolup until 3*N*32ms
                      3581     
02E4    4057          3582     	JC	T2H_INT_EXIT
                      3583     
02E6    C3            3584     	CLR	C
02E7    E569          3585     	MOV	A, SPOOLUP_LIMIT_CNT
02E9    956C          3586     	SUBB	A, MAIN_SPOOLUP_TIME_10X			; Slow spoolup until "100"*N*32ms
02EB    5008          3587     	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                      3588     
02ED    7801          3589     MOV R0 , # 1 
02EF    756A03        3590     	MOV	SPOOLUP_LIMIT_SKIP, #3			
02F2    020301        3591     	JMP	T2H_INT_RCP_SET_LIMIT
                      3592     
                      3593     T2H_INT_RCP_LIMIT_MIDDLE_RAMP: 
02F5    C3            3594     	CLR	C
02F6    E569          3595     	MOV	A, SPOOLUP_LIMIT_CNT
02F8    956D          3596     	SUBB	A, MAIN_SPOOLUP_TIME_15X			; Faster spoolup until "150"*N*32ms
02FA    5005          3597     	JNC	T2H_INT_RCP_SET_LIMIT
                      3598     
02FC    7801          3599     MOV R0 , # 1 
02FE    756A01        3600     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      3601     
                      3602     T2H_INT_RCP_SET_LIMIT: 
                      3603     	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
0301    C3            3604     	CLR	C
0302    E562          3605     	MOV	A, PWM_LIMIT_SPOOLUP
0304    9524          3606     	SUBB	A, CURRENT_PWM
0306    401E          3607     	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                      3608     
0308    7982          3609     MOV R1 , # PGM_GOV_MODE 
030A    B70402        3610     CJNE @ R1 , # 4 , ( $+5 ) 
030D    6132          3611     	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                      3612     
030F    206D14        3613     JB FLAGS1 . 5 , T2H_INT_RCP_INC_LIMIT 
                      3614     
0312    852462        3615     	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
0315    E569          3616     	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
0317    04            3617     	INC	A
0318    6003          3618     	JZ	($+5)
                      3619     
031A    856B69        3620     	MOV	SPOOLUP_LIMIT_CNT, MAIN_SPOOLUP_TIME_3X	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                      3621     
031D    756A01        3622     	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
0320    75233C        3623     	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                      3624     									; 20=Fail on jerk when governor activates
                      3625     									; 30=Ok
                      3626     									; 100=Fail on small governor settling overshoot on low headspeeds
                      3627     									; 200=Fail on governor settling overshoot
0323    02033D        3628     	JMP	T2H_INT_EXIT					; Exit
                      3629     
                      3630     T2H_INT_RCP_INC_LIMIT: 
0326    E562          3631     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
0328    28            3632     ADD A , R0 
0329    5005          3633     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      3634     
032B    7562FF        3635     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
032E    6132          3636     	AJMP	T2H_INT_RCP_BAILOUT_ARM
                      3637     
                      3638     T2H_INT_RCP_NO_LIMIT: 
0330    F562          3639     	MOV	PWM_LIMIT_SPOOLUP, A
                      3640     T2H_INT_RCP_BAILOUT_ARM: 
0332    E562          3641     	MOV	A, PWM_LIMIT_SPOOLUP
0334    04            3642     	INC	A
0335    7006          3643     	JNZ	T2H_INT_EXIT
                      3644     
0337    7560FF        3645     	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
033A    7569FF        3646     	MOV	SPOOLUP_LIMIT_CNT, #255			
                      3647     
                      3648     ENDIF
                      3649     T2H_INT_EXIT: 
033D    D0E0          3650     	POP	ACC			; Restore preserved registers
033F    D0D0          3651     	POP	PSW
0341    43E610        3652     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0344    D2AD          3653     	SETB	ET2			; Enable timer2 interrupts
0346    32            3654     	RETI
                      3655     
                      3656     
                      3657     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3658     ;
                      3659     ; Timer3 interrupt routine
                      3660     ;
                      3661     ; No assumptions
                      3662     ;
                      3663     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3664     T3_INT: 	; Used for commutation timing
0347    C2AF          3665     	CLR 	EA				; Disable all interrupts
0349    C0D0          3666     	PUSH	PSW				; Preserve registers through interrupt
034B    53E67F        3667     	ANL	EIE1, #7FH		; Disable timer3 interrupts
034E    C260          3668     CLR FLAGS0 . 0 
                      3669     	; Set up next wait
0350    759100        3670     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
0353    855394        3671     	MOV	TMR3L, NEXT_WT_START_L	; Set wait value	
0356    855495        3672     	MOV	TMR3H, NEXT_WT_START_H
0359    759104        3673     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
035C    D0D0          3674     	POP	PSW
035E    D2AF          3675     	SETB	EA				; Enable all interrupts
0360    32            3676     	RETI
                      3677     
                      3678     
                      3679     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3680     ;
                      3681     ; PCA interrupt routine
                      3682     ;
                      3683     ; No assumptions
                      3684     ;
                      3685     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3686     PCA_INT: 	; Used for RC pulse timing
0361    C2AF          3687     	CLR	EA
0363    53E6EF        3688     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
0366    C2AD          3689     	CLR	ET2			; Disable timer2 interrupts
0368    C0D0          3690     	PUSH	PSW			; Preserve registers through interrupt
036A    C0E0          3691     	PUSH	ACC
036C    C0F0          3692     	PUSH	B
036E    D2D3          3693     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0370    D2AF          3694     	SETB	EA
                      3695     	; Get the PCA counter values
                      3696     	GET_RCP_CAPTURE_VALUES
0372    A8FB          3696+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0374    A9FC          3696+1   MOV R1 , PCA0CPH0 
                      3696+1   IF 1 ==1 
0376    E57A          3696+1   MOV A , CLOCK_SET_AT_48MHZ 
0378    6007          3696+1   JZ GET_RCP_END 
037A    C3            3696+1   CLR C 
037B    E9            3696+1   MOV A , R1 
037C    13            3696+1   RRC A 
037D    F9            3696+1   MOV R1 , A 
037E    E8            3696+1   MOV A , R0 
037F    13            3696+1   RRC A 
0380    F8            3696+1   MOV R0 , A 
                      3696+1   GET_RCP_END:  
                      3696+1   ENDIF 
                      3697     	; Clear interrupt flag
                      3698     	RCP_CLEAR_INT_FLAG 				
0381    C2D8          3698+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3699     	; Check which edge it is
0383    307102        3700     JNB FLAGS2 . 1 , ( $+5 ) 
0386    61D3          3701     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      3702     
                      3703     	RCP_INT_SECOND					; Yes - set second edge trig
0388    53DACF        3703+1   ANL PCA0CPM0 , # 0CFH 
038B    207E03        3703+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
038E    43DA10        3703+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
0391    307E03        3703+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0394    43DA20        3703+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0397    D271          3704     SETB FLAGS2 . 1 
                      3705     	; Read RC signal level
                      3706     	READ_RCP_INT			
0399    E580          3706+1   MOV A , P0 
039B    307E01        3706+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
039E    F4            3706+1   CPL A  ; YES - INVERT
                      3707     	; Test RC signal level
039F    20E502        3708     JB ACC . 5 , ( $+5 ) 
03A2    61AA          3709     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      3710     
                      3711     	; RC pulse was high, store RC pulse start timestamp
03A4    8827          3712     MOV RCP_PREV_EDGE_L , R0 
03A6    8928          3713     MOV RCP_PREV_EDGE_H , R1 
03A8    A1B2          3714     	AJMP	PCA_INT_EXIT				; Exit
                      3715     
                      3716     PCA_INT_FAIL_MINIMUM: 
                      3717     	; Prepare for next interrupt
                      3718     	RCP_INT_FIRST					; Set interrupt trig to first again
03AA    53DACF        3718+1   ANL PCA0CPM0 , # 0CFH 
03AD    207E03        3718+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03B0    43DA20        3718+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03B3    307E03        3718+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03B6    43DA10        3718+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3719     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03B9    C2D8          3719+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03BB    C271          3720     CLR FLAGS2 . 1 
03BD    307402        3721     JNB FLAGS2 . 4 , ( $+5 ) 
                      3722     
03C0    A19E          3723     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      3724     
03C2    7800          3725     MOV R0 , # 0 
                      3726     	READ_RCP_INT 					; Test RC signal level again
03C4    E580          3726+1   MOV A , P0 
03C6    307E01        3726+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
03C9    F4            3726+1   CPL A  ; YES - INVERT
03CA    30E502        3727     JNB ACC . 5 , ( $+5 ) 
                      3728     
03CD    A19E          3729     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      3730     
03CF    885C          3731     MOV NEW_RCP , R0 
03D1    A186          3732     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      3733     
                      3734     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      3735     	; Prepare for next interrupt
                      3736     	RCP_INT_FIRST 					; Set first edge trig
03D3    53DACF        3736+1   ANL PCA0CPM0 , # 0CFH 
03D6    207E03        3736+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03D9    43DA20        3736+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03DC    307E03        3736+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03DF    43DA10        3736+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03E2    C271          3737     CLR FLAGS2 . 1 
                      3738     	; Check if pwm frequency shall be measured
03E4    206102        3739     JB FLAGS0 . 1 , ( $+5 ) 
03E7    81AC          3740     	AJMP	PCA_INT_FALL				; No - skip measurements
                      3741     
                      3742     	; Set second edge trig only during pwm frequency measurement
                      3743     	RCP_INT_SECOND 				; Set second edge trig
03E9    53DACF        3743+1   ANL PCA0CPM0 , # 0CFH 
03EC    207E03        3743+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03EF    43DA10        3743+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03F2    307E03        3743+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03F5    43DA20        3743+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      3744     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03F8    C2D8          3744+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03FA    D271          3745     SETB FLAGS2 . 1 
                      3746     	; Store edge data to RAM
03FC    8857          3747     MOV RCP_EDGE_L , R0 
03FE    8958          3748     MOV RCP_EDGE_H , R1 
                      3749     	; Calculate pwm frequency
0400    C3            3750     	CLR	C
0401    E8            3751     MOV A , R0 
0402    9555          3752     	SUBB	A, RCP_PREPREV_EDGE_L	
0404    F8            3753     MOV R0 , A 
0405    E9            3754     MOV A , R1 
0406    9556          3755     	SUBB	A, RCP_PREPREV_EDGE_H
0408    F9            3756     MOV R1 , A 
0409    7B00          3757     MOV R3 , # 0 
040B    7E08          3758     MOV R6 , # 8 
040D    7A00          3759     MOV R2 , # 0 
                      3760     	; Check if pulse is too short
040F    C3            3761     	CLR	C
0410    E8            3762     MOV A , R0 
0411    948C          3763     	SUBB	A, #LOW(140)				; If pulse below 70us, not accepted
0413    E9            3764     MOV A , R1 
0414    9400          3765     	SUBB	A, #HIGH(140)
0416    5005          3766     	JNC	PCA_INT_CHECK_12KHZ
                      3767     
0418    755B00        3768     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0	; Set not accepted 
041B    819E          3769     	AJMP	PCA_INT_STORE_DATA
                      3770     
                      3771     PCA_INT_CHECK_12KHZ: 
041D    8821          3772     MOV BIT_ACCESS_INT , R0 
041F    78A2          3773     MOV R0 , # PGM_ENABLE_PWM_INPUT 
0421    E6            3774     MOV A , @ R0 
0422    A821          3775     MOV R0 , BIT_ACCESS_INT 
0424    6055          3776     	JZ	PCA_INT_RESTORE_EDGE		; If it is not - branch
                      3777     
                      3778     	; Check if pwm frequency is 12kHz
0426    C3            3779     	CLR	C
0427    E8            3780     MOV A , R0 
0428    94C8          3781     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
042A    E9            3782     MOV A , R1 
042B    9400          3783     	SUBB	A, #HIGH(200)
042D    5008          3784     	JNC	PCA_INT_CHECK_8KHZ
                      3785     
042F    E4            3786     	CLR	A
0430    D2E4          3787     SETB ACC . 4 
0432    FB            3788     MOV R3 , A 
0433    7A0A          3789     MOV R2 , # 10 
0435    8179          3790     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3791     
                      3792     PCA_INT_CHECK_8KHZ: 
                      3793     	; Check if pwm frequency is 8kHz
0437    C3            3794     	CLR	C
0438    E8            3795     MOV A , R0 
0439    9468          3796     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
043B    E9            3797     MOV A , R1 
043C    9401          3798     	SUBB	A, #HIGH(360)
043E    5008          3799     	JNC	PCA_INT_CHECK_4KHZ
                      3800     
0440    E4            3801     	CLR	A
0441    D2E3          3802     SETB ACC . 3 
0443    FB            3803     MOV R3 , A 
0444    7A0F          3804     MOV R2 , # 15 
0446    8179          3805     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3806     
                      3807     PCA_INT_CHECK_4KHZ: 
                      3808     	; Check if pwm frequency is 4kHz
0448    C3            3809     	CLR	C
0449    E8            3810     MOV A , R0 
044A    94D0          3811     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
044C    E9            3812     MOV A , R1 
044D    9402          3813     	SUBB	A, #HIGH(720)
044F    5008          3814     	JNC	PCA_INT_CHECK_2KHZ
                      3815     
0451    E4            3816     	CLR	A
0452    D2E2          3817     SETB ACC . 2 
0454    FB            3818     MOV R3 , A 
0455    7A1E          3819     MOV R2 , # 30 
0457    8179          3820     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3821     
                      3822     PCA_INT_CHECK_2KHZ: 
                      3823     	; Check if pwm frequency is 2kHz
0459    C3            3824     	CLR	C
045A    E8            3825     MOV A , R0 
045B    94A0          3826     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
045D    E9            3827     MOV A , R1 
045E    9405          3828     	SUBB	A, #HIGH(1440)
0460    5008          3829     	JNC	PCA_INT_CHECK_1KHZ
                      3830     
0462    E4            3831     	CLR	A
0463    D2E1          3832     SETB ACC . 1 
0465    FB            3833     MOV R3 , A 
0466    7A3C          3834     MOV R2 , # 60 
0468    8179          3835     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3836     
                      3837     PCA_INT_CHECK_1KHZ: 
                      3838     	; Check if pwm frequency is 1kHz
046A    C3            3839     	CLR	C
046B    E8            3840     MOV A , R0 
046C    9498          3841     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
046E    E9            3842     MOV A , R1 
046F    9408          3843     	SUBB	A, #HIGH(2200)
0471    5008          3844     	JNC	PCA_INT_RESTORE_EDGE
                      3845     
0473    E4            3846     	CLR	A
0474    D2E0          3847     SETB ACC . 0 
0476    FB            3848     MOV R3 , A 
0477    7A78          3849     MOV R2 , # 120 
                      3850     
                      3851     PCA_INT_RESTORE_EDGE_SET_MSB: 
0479    7E00          3852     MOV R6 , # 0 
                      3853     PCA_INT_RESTORE_EDGE: 
                      3854     	; Calculate difference between this period and previous period
047B    C3            3855     	CLR	C
047C    E8            3856     MOV A , R0 
047D    9559          3857     	SUBB	A, RCP_PREV_PERIOD_L
047F    FC            3858     MOV R4 , A 
0480    E9            3859     MOV A , R1 
0481    955A          3860     	SUBB	A, RCP_PREV_PERIOD_H
0483    FD            3861     MOV R5 , A 
                      3862     	; Make positive
0484    30E70A        3863     	JNB	ACC.7, PCA_INT_CHECK_DIFF
0487    EC            3864     MOV A , R4 
0488    F4            3865     	CPL	A
0489    2401          3866     	ADD	A, #1
048B    FC            3867     MOV R4 , A 
048C    ED            3868     MOV A , R5 
048D    F4            3869     	CPL	A
048E    3400          3870     	ADDC	A, #0
0490    FD            3871     MOV R5 , A 
                      3872     
                      3873     PCA_INT_CHECK_DIFF: 
                      3874     	; Check difference
0491    755B00        3875     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0494    C3            3876     	CLR	C
0495    EC            3877     MOV A , R4 
0496    9A            3878     SUBB A , R2 
0497    ED            3879     MOV A , R5 
0498    9E            3880     SUBB A , R6 
0499    5003          3881     	JNC	PCA_INT_STORE_DATA
                      3882     
049B    755B01        3883     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      3884     
                      3885     PCA_INT_STORE_DATA: 
                      3886     	; Store previous period
049E    8859          3887     MOV RCP_PREV_PERIOD_L , R0 
04A0    895A          3888     MOV RCP_PREV_PERIOD_H , R1 
                      3889     	; Store pre previous edge
04A2    855755        3890     	MOV	RCP_PREPREV_EDGE_L, RCP_EDGE_L
04A5    855856        3891     	MOV	RCP_PREPREV_EDGE_H, RCP_EDGE_H
04A8    7802          3892     MOV R0 , # 2 
04AA    A186          3893     	AJMP	PCA_INT_LIMITED
                      3894     
                      3895     PCA_INT_FALL: 
                      3896     	; RC pulse edge was second, calculate new pulse length
04AC    C3            3897     	CLR	C
04AD    E8            3898     MOV A , R0 
04AE    9527          3899     	SUBB	A, RCP_PREV_EDGE_L	
04B0    F8            3900     MOV R0 , A 
04B1    E9            3901     MOV A , R1 
04B2    9528          3902     	SUBB	A, RCP_PREV_EDGE_H
04B4    F9            3903     MOV R1 , A 
04B5    307C02        3904     JNB FLAGS3 . 4 , ( $+5 ) 
04B8    A16A          3905     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3906     
04BA    307B02        3907     JNB FLAGS3 . 3 , ( $+5 ) 
04BD    A16A          3908     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3909     
04BF    307A02        3910     JNB FLAGS3 . 2 , ( $+5 ) 
04C2    A163          3911     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3912     
04C4    207502        3913     JB FLAGS2 . 5 , ( $+5 ) 
04C7    81CF          3914     	AJMP	PCA_INT_FALL_NOT_ONESHOT
                      3915     
04C9    E9            3916     MOV A , R1 
04CA    FD            3917     MOV R5 , A 
04CB    E8            3918     MOV A , R0 
04CC    FC            3919     MOV R4 , A 
04CD    81EE          3920     	AJMP	PCA_INT_FALL_CHECK_RANGE
                      3921     
                      3922     PCA_INT_FALL_NOT_ONESHOT: 
04CF    E9            3923     MOV A , R1 
04D0    C3            3924     	CLR	C
04D1    13            3925     	RRC	A
04D2    F9            3926     MOV R1 , A 
04D3    E8            3927     MOV A , R0 
04D4    13            3928     	RRC	A
04D5    F8            3929     MOV R0 , A 
                      3930     
04D6    307902        3931     JNB FLAGS3 . 1 , ( $+5 ) 
04D9    A163          3932     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3933     
04DB    E9            3934     MOV A , R1 
04DC    C3            3935     	CLR	C
04DD    13            3936     	RRC	A
04DE    F9            3937     MOV R1 , A 
04DF    E8            3938     MOV A , R0 
04E0    13            3939     	RRC	A
04E1    F8            3940     MOV R0 , A 
                      3941     
04E2    307802        3942     JNB FLAGS3 . 0 , ( $+5 ) 
04E5    A163          3943     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3944     
04E7    E9            3945     MOV A , R1 
04E8    C3            3946     	CLR	C
04E9    13            3947     	RRC	A
04EA    FD            3948     MOV R5 , A 
04EB    E8            3949     MOV A , R0 
04EC    13            3950     	RRC	A
04ED    FC            3951     MOV R4 , A 
                      3952     PCA_INT_FALL_CHECK_RANGE: 
                      3953     	; Skip range limitation if pwm frequency measurement
04EE    206126        3954     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      3955     
                      3956     	; Check if 2160us or above (in order to ignore false pulses)
04F1    C3            3957     	CLR	C
04F2    EC            3958     MOV A , R4 
04F3    941C          3959     	SUBB	A, #28
04F5    ED            3960     MOV A , R5 
04F6    9402          3961     	SUBB A, #2
04F8    4002          3962     	JC	($+4)						; No - proceed
                      3963     
04FA    A105          3964     	AJMP	PCA_INT_PPM_OUTSIDE_RANGE		; Yes - ignore pulse
                      3965     
                      3966     PCA_INT_PPM_BELOW_FULL_RANGE: 
                      3967     	; Check if below 800us (in order to ignore false pulses)
04FC    ED            3968     MOV A , R5 
04FD    7018          3969     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      3970     
04FF    C3            3971     	CLR	C
0500    EC            3972     MOV A , R4 
0501    94C8          3973     	SUBB	A, #200
0503    5012          3974     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      3975     
                      3976     PCA_INT_PPM_OUTSIDE_RANGE: 
0505    0529          3977     	INC	RCP_OUTSIDE_RANGE_CNT
0507    C3            3978     	CLR	C
0508    E529          3979     	MOV	A, RCP_OUTSIDE_RANGE_CNT
050A    940A          3980     	SUBB	A, #10						; Allow a given number of outside pulses
050C    5002          3981     	JNC	($+4)			
050E    A19E          3982     	AJMP	PCA_INT_SET_TIMEOUT				; If below limit - ignore pulse
                      3983     
0510    755C00        3984     	MOV	NEW_RCP, #0					; Set pulse length to zero
0513    D270          3985     SETB FLAGS2 . 0 
0515    A19E          3986     	AJMP	PCA_INT_SET_TIMEOUT			
                      3987     
                      3988     PCA_INT_PPM_CHECK_FULL_RANGE: 
0517    E529          3989     	MOV	A, RCP_OUTSIDE_RANGE_CNT
0519    6002          3990     	JZ	($+4)
                      3991     
051B    1529          3992     	DEC	RCP_OUTSIDE_RANGE_CNT
                      3993     
                      3994     	; Calculate "1000us" plus throttle minimum
                      3995     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION			; Check if bidirectional operation (store in Temp2)
                               	MOV	A, @TEMP1				
                               	MOV	TEMP2, A				
                               ENDIF
051D    7400          4000     	MOV	A, #0						; Set 1000us as default minimum
051F    207F03        4001     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      4002     
0522    7896          4003     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      4004     IF MODE >= 1	; Tail or multi
                               	CJNE	TEMP2, #3, ($+5)
                               
                               	MOV	TEMP1, #PGM_PPM_CENTER_THROTTLE	; Center throttle value is in 4us units
                               ENDIF
0524    E6            4009     MOV A , @ R0 
                      4010     
                      4011     PCA_INT_PPM_CALCULATE: 
0525    24FA          4012     	ADD	A, #250						; Add 1000us to minimum
0527    FE            4013     MOV R6 , A 
0528    E4            4014     	CLR	A
0529    3400          4015     	ADDC	A, #0
052B    FF            4016     MOV R7 , A 
                      4017     
052C    C3            4018     	CLR	C
052D    EC            4019     MOV A , R4 
052E    9E            4020     SUBB A , R6 
052F    FC            4021     MOV R4 , A 
0530    ED            4022     MOV A , R5 
0531    9F            4023     SUBB A , R7 
0532    FD            4024     MOV R5 , A 
                      4025     IF MODE >= 1	; Tail or multi
                               	MOV	BIT_ACCESS_INT.0, C
                               	CJNE	TEMP2, #3, PCA_INT_PPM_BIDIR_DIR_SET; If not bidirectional operation - branch
                               
                               	MOV	C, BIT_ACCESS_INT.0
                               	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                               
                               PCA_INT_PPM_BIDIR_REV:
                               	JB	FLAGS2.RCP_DIR_REV, PCA_INT_PPM_BIDIR_DIR_SET	; If same direction - branch
                               
                               	SETB	FLAGS2.RCP_DIR_REV
                               	AJMP	PCA_INT_PPM_BIDIR_DIR_SET
                               
                               PCA_INT_PPM_BIDIR_FWD:
                               	JNB	FLAGS2.RCP_DIR_REV, PCA_INT_PPM_BIDIR_DIR_SET	; If same direction - branch
                               
                               	CLR	FLAGS2.RCP_DIR_REV
                               
                               PCA_INT_PPM_BIDIR_DIR_SET:
                               	MOV	C, BIT_ACCESS_INT.0
                               ENDIF
0533    5006          4046     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      4047     
                      4048     IF MODE >= 1	; Tail or multi
                               	CJNE	TEMP2, #3, PCA_INT_PPM_UNIDIR_NEG 	; If not bidirectional operation - branch
                               
                               	MOV	A, TEMP5						; Change sign		
                               	CPL	A
                               	ADD	A, #1
                               	MOV	TEMP5, A
                               	MOV	A, TEMP6							
                               	CPL	A
                               	ADDC	A, #0
                               	MOV	TEMP6, A
                               	JMP	PCA_INT_PPM_NEG_CHECKED
                               
                               PCA_INT_PPM_UNIDIR_NEG:
                               ENDIF
0535    7800          4063     MOV R0 , # 0 
0537    7900          4064     MOV R1 , # 0 
0539    A16A          4065     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4066     
                      4067     PCA_INT_PPM_NEG_CHECKED: 
                      4068     IF MODE >= 1	; Tail or multi
                               	CJNE	TEMP2, #3, PCA_INT_PPM_BIDIR_DONE	; If not bidirectional operation - branch
                               
                               	MOV	A, TEMP5						; Multiply value by 2
                               	RLC	A
                               	MOV	TEMP5 A
                               	MOV	A, TEMP6
                               	RLC	A
                               	MOV	TEMP6 A
                               	CLR	C							; Subtract deadband
                               	MOV	A, TEMP5
                               	SUBB	A, #10		
                               	MOV	TEMP5, A
                               	MOV	A, TEMP6
                               	SUBB	A, #0
                               	MOV	TEMP6, A
                               	JNC	PCA_INT_PPM_BIDIR_DONE
                               
                               	MOV	TEMP5, #RCP_MIN
                               	MOV	TEMP6, #0
                               
                               PCA_INT_PPM_BIDIR_DONE:
                               ENDIF
053B    C3            4091     	CLR	C							; Check that RC pulse is within legal range (max 255)
053C    EC            4092     MOV A , R4 
053D    94FF          4093     SUBB A , # 255 
053F    ED            4094     MOV A , R5 
0540    9400          4095     	SUBB	A, #0
0542    4006          4096     	JC	PCA_INT_PPM_MAX_CHECKED
                      4097     
0544    78FF          4098     MOV R0 , # 255 
0546    7900          4099     MOV R1 , # 0 
0548    A16A          4100     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4101     
                      4102     PCA_INT_PPM_MAX_CHECKED: 
054A    EC            4103     MOV A , R4 
054B    8572F0        4104     	MOV	B, PPM_THROTTLE_GAIN
054E    A4            4105     	MUL	AB
054F    C5F0          4106     	XCH	A, B
0551    A2F7          4107     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0553    33            4108     	RLC	A
0554    F8            4109     MOV R0 , A 
0555    7900          4110     MOV R1 , # 0 
0557    4003          4111     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      4112     	
0559    020586        4113     	JMP	PCA_INT_LIMITED			
                      4114     
                      4115     PCA_INT_PPM_LIMIT_AFTER_MULT: 
055C    78FF          4116     MOV R0 , # 255 
055E    7900          4117     MOV R1 , # 0 
0560    020586        4118     	JMP	PCA_INT_LIMITED			
                      4119     
                      4120     PCA_INT_PWM_DIVIDE: 
0563    E9            4121     MOV A , R1 
0564    C3            4122     	CLR	C
0565    13            4123     	RRC	A
0566    F9            4124     MOV R1 , A 
0567    E8            4125     MOV A , R0 
0568    13            4126     	RRC	A
0569    F8            4127     MOV R0 , A 
                      4128     
                      4129     PCA_INT_PWM_DIVIDE_DONE: 
056A    307C0E        4130     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
056D    E9            4131     MOV A , R1 
056E    6002          4132     	JZ	($+4)
                      4133     
0570    78FF          4134     MOV R0 , # 255 
                      4135     
0572    C3            4136     	CLR	C
0573    E8            4137     MOV A , R0 
0574    13            4138     	RRC	A
0575    38            4139     ADDC A , R0 
0576    F8            4140     MOV R0 , A 
0577    E4            4141     	CLR	A
0578    3400          4142     	ADDC	A, #0
057A    F9            4143     MOV R1 , A 
                      4144     
                      4145     PCA_INT_CHECK_LEGAL_RANGE: 
                      4146     	; Check that RC pulse is within legal range
057B    C3            4147     	CLR	C
057C    E8            4148     MOV A , R0 
057D    94FF          4149     SUBB A , # 255 
057F    E9            4150     MOV A , R1 
0580    9400          4151     	SUBB	A, #0
0582    4002          4152     	JC	PCA_INT_LIMITED
                      4153     
0584    78FF          4154     MOV R0 , # 255 
                      4155     
                      4156     PCA_INT_LIMITED: 
                      4157     	; RC pulse value accepted
0586    885C          4158     MOV NEW_RCP , R0 
0588    D270          4159     SETB FLAGS2 . 0 
058A    206102        4160     JB FLAGS0 . 1 , ( $+5 ) 
                      4161     
058D    A19E          4162     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      4163     
058F    741F          4164     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0591    F4            4165     	CPL	A
0592    552F          4166     	ANL	A, FLAGS3					; Clear all pwm frequency flags
0594    4B            4167     ORL A , R3 
0595    F52F          4168     	MOV	FLAGS3, A
0597    C274          4169     CLR FLAGS2 . 4 
0599    EB            4170     MOV A , R3 
059A    7002          4171     	JNZ	PCA_INT_SET_TIMEOUT
                      4172     
059C    D274          4173     SETB FLAGS2 . 4 
                      4174     
                      4175     PCA_INT_SET_TIMEOUT: 
059E    752A40        4176     MOV RCP_TIMEOUT_CNT , # 64 
05A1    307403        4177     JNB FLAGS2 . 4 , PCA_INT_PPM_TIMEOUT_SET 
                      4178     
05A4    752A0A        4179     MOV RCP_TIMEOUT_CNT , # 10 
                      4180     
                      4181     PCA_INT_PPM_TIMEOUT_SET: 
05A7    306102        4182     JNB FLAGS0 . 1 , ( $+5 ) 
                      4183     
05AA    A1B2          4184     	AJMP PCA_INT_EXIT				; Yes - exit
                      4185     
05AC    207403        4186     JB FLAGS2 . 4 , PCA_INT_EXIT 
                      4187     
                      4188     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
05AF    53DAFE        4188+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      4189     
                      4190     PCA_INT_EXIT: 	; Exit interrupt routine	
05B2    207403        4191     JB FLAGS2 . 4 , ( $+6 ) 
                      4192     
05B5    752B20        4193     MOV RCP_SKIP_CNT , # 32 
                      4194     
05B8    D0F0          4195     	POP	B			; Restore preserved registers
05BA    D0E0          4196     	POP	ACC			
05BC    D0D0          4197     	POP	PSW
05BE    D2AD          4198     	SETB	ET2			; Enable timer2 interrupts
05C0    43E610        4199     	ORL	EIE1, #10H	; Enable PCA0 interrupts
05C3    32            4200     	RETI
                      4201     
                      4202     
                      4203     
                      4204     
                      4205     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4206     ;
                      4207     ; Wait xms ~(x*4*250)  (Different entry points)	
                      4208     ;
                      4209     ; No assumptions
                      4210     ;
                      4211     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4212     WAIT1MS: 	
05C4    7901          4213     MOV R1 , # 1 
05C6    0205E2        4214     	JMP	WAITXMS_O
                      4215     
                      4216     WAIT3MS: 	
05C9    7903          4217     MOV R1 , # 3 
05CB    0205E2        4218     	JMP	WAITXMS_O
                      4219     
                      4220     WAIT10MS: 	
05CE    790A          4221     MOV R1 , # 10 
05D0    0205E2        4222     	JMP	WAITXMS_O
                      4223     
                      4224     WAIT30MS: 	
05D3    791E          4225     MOV R1 , # 30 
05D5    0205E2        4226     	JMP	WAITXMS_O
                      4227     
                      4228     WAIT100MS: 	
05D8    7964          4229     MOV R1 , # 100 
05DA    0205E2        4230     	JMP	WAITXMS_O
                      4231     
                      4232     WAIT200MS: 	
05DD    79C8          4233     MOV R1 , # 200 
05DF    0205E2        4234     	JMP	WAITXMS_O
                      4235     
                      4236     WAITXMS_O: 	; Outer loop
05E2    7817          4237     MOV R0 , # 23 
                      4238     WAITXMS_M: 	; Middle loop
05E4    E4            4239     	CLR	A
05E5    D5E0FD        4240      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
05E8    D8FA          4241     DJNZ R0 , WAITXMS_M 
05EA    D9F6          4242     DJNZ R1 , WAITXMS_O 
05EC    22            4243     	RET
                      4244     
                      4245     
                      4246     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4247     ;
                      4248     ; Beeper routines (4 different entry points) 
                      4249     ;
                      4250     ; No assumptions
                      4251     ;
                      4252     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4253     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
05ED    7A14          4254     MOV R2 , # 20 
05EF    7B78          4255     MOV R3 , # 120 
05F1    020609        4256     	JMP	BEEP
                      4257     
                      4258     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
05F4    7A10          4259     MOV R2 , # 16 
05F6    7B8C          4260     MOV R3 , # 140 
05F8    020609        4261     	JMP	BEEP
                      4262     
                      4263     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
05FB    7A0D          4264     MOV R2 , # 13 
05FD    7BB4          4265     MOV R3 , # 180 
05FF    020609        4266     	JMP	BEEP
                      4267     
                      4268     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0602    7A0B          4269     MOV R2 , # 11 
0604    7BC8          4270     MOV R3 , # 200 
0606    020609        4271     	JMP	BEEP
                      4272     
                      4273     BEEP: 	; Beep loop start
0609    7902          4274     MOV R1 , # 2 
                      4275     BEEP_ONOFF: 
060B    B27D          4276     CPL FLAGS3 . 5 
060D    E4            4277     	CLR	A
                      4278     	BPFET_OFF			; BpFET off
060E    C295          4278+1   CLR P1 . 5 
0610    D5E0FD        4279     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      4280     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
0613    D294          4280+1   SETB P1 . 4 
0615    D5E0FD        4281     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      4282     	BNFET_OFF			; BnFET off again
0618    C294          4282+1   CLR P1 . 4 
061A    D5E0FD        4283     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      4284     	BPFET_ON			; BpFET on
061D    D295          4284+1   SETB P1 . 5 
061F    D5E0FD        4285     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      4286     	; Turn on nfet
                      4287     	ANFET_ON			; AnFET on
0622    D293          4287+1   SETB P1 . 3 
0624    E573          4288     	MOV	A, BEEP_STRENGTH
0626    D5E0FD        4289     	DJNZ	ACC, $		
                      4290     	; Turn off nfet
                      4291     	ANFET_OFF			; AnFET off
0629    C293          4291+1   CLR P1 . 3 
062B    7496          4292     	MOV	A, #150		; 25s off
062D    D5E0FD        4293     	DJNZ	ACC, $		
0630    D9D9          4294     DJNZ R1 , BEEP_ONOFF 
                      4295     	; Copy variable
0632    EA            4296     MOV A , R2 
0633    F8            4297     MOV R0 , A 
                      4298     BEEP_OFF: 		; Fets off loop
0634    D5E0FD        4299     	DJNZ	ACC, $
0637    D8FB          4300     DJNZ R0 , BEEP_OFF 
0639    DBCE          4301     DJNZ R3 , BEEP 
                      4302     	BPFET_OFF			; BpFET off
063B    C295          4302+1   CLR P1 . 5 
063D    22            4303     	RET
                      4304     
                      4305     
                      4306     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4307     ;
                      4308     ; Division 16bit unsigned by 16bit unsigned
                      4309     ;
                      4310     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      4311     ; Result will be in Temp2/Temp1
                      4312     ;
                      4313     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4314     DIV_U16_BY_U16: 	
063E    C3            4315     	CLR	C       
063F    7C00          4316     MOV R4 , # 0 
0641    7D00          4317     MOV R5 , # 0 
0643    75F000        4318     	MOV	B, #0
                      4319     DIV_U16_BY_U16_DIV1: 
0646    05F0          4320     	INC	B      			; Increment counter for each left shift
0648    EA            4321     MOV A , R2 
0649    33            4322     	RLC	A      		
064A    FA            4323     MOV R2 , A 
064B    EB            4324     MOV A , R3 
064C    33            4325     	RLC	A      	  	
064D    FB            4326     MOV R3 , A 
064E    50F6          4327     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      4328     DIV_U16_BY_U16_DIV2:         
0650    EB            4329     MOV A , R3 
0651    13            4330     	RRC	A      
0652    FB            4331     MOV R3 , A 
0653    EA            4332     MOV A , R2 
0654    13            4333     	RRC	A      
0655    FA            4334     MOV R2 , A 
0656    C3            4335     	CLR	C      
0657    E9            4336     MOV A , R1 
0658    FF            4337     MOV R7 , A 
0659    E8            4338     MOV A , R0 
065A    FE            4339     MOV R6 , A 
065B    E8            4340     MOV A , R0 
065C    9A            4341     SUBB A , R2 
065D    F8            4342     MOV R0 , A 
065E    E9            4343     MOV A , R1 
065F    9B            4344     SUBB A , R3 
0660    F9            4345     MOV R1 , A 
0661    5004          4346     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
0663    EF            4347     MOV A , R7 
0664    F9            4348     MOV R1 , A 
0665    EE            4349     MOV A , R6 
0666    F8            4350     MOV R0 , A 
                      4351     DIV_U16_BY_U16_DIV3: 
0667    B3            4352     	CPL	C      			; Invert carry, so it can be directly copied into result
0668    EC            4353     MOV A , R4 
0669    33            4354     	RLC	A      			; Shift carry flag into temporary result
066A    FC            4355     MOV R4 , A 
066B    ED            4356     MOV A , R5 
066C    33            4357     	RLC	A
066D    FD            4358     MOV R5 , A 
066E    D5F0DF        4359     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
0671    ED            4360     MOV A , R5 
0672    F9            4361     MOV R1 , A 
0673    EC            4362     MOV A , R4 
0674    F8            4363     MOV R0 , A 
0675    22            4364     	RET
                      4365     
                      4366     
                      4367     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4368     ;
                      4369     ; Multiplication 16bit signed by 8bit unsigned
                      4370     ;
                      4371     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      4372     ; Result will be in Temp2/Temp1. Result will divided by 16
                      4373     ;
                      4374     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4375     MULT_S16_BY_U8_DIV_16: 
0676    E8            4376     MOV A , R0 
0677    89F0          4377     MOV B , R1 
0679    8A20          4378     MOV BIT_ACCESS , R2 
067B    D2D4          4379     	SETB	PSW.4		; Select register bank 2 for math routines
067D    F8            4380     MOV R0 , A 
067E    A9F0          4381     MOV R1 , B 
0680    7B00          4382     MOV R3 , # 0 
0682    30F70B        4383     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      4384     
0685    7BFF          4385     MOV R3 , # 0FFH 
0687    F4            4386     	CPL	A
0688    2401          4387     	ADD	A, #1
068A    F8            4388     MOV R0 , A 
068B    E9            4389     MOV A , R1 
068C    F4            4390     	CPL	A
068D    3400          4391     	ADDC	A, #0
068F    F9            4392     MOV R1 , A 
                      4393     MULT_S16_BY_U8_POSITIVE: 
0690    E8            4394     MOV A , R0 
0691    8520F0        4395     	MOV	B, BIT_ACCESS
0694    A4            4396     	MUL	AB
0695    ADF0          4397     MOV R5 , B 
0697    F8            4398     MOV R0 , A 
0698    E9            4399     MOV A , R1 
0699    8520F0        4400     	MOV	B, BIT_ACCESS
069C    A4            4401     	MUL	AB
069D    AFF0          4402     MOV R7 , B 
069F    FE            4403     MOV R6 , A 
06A0    ED            4404     MOV A , R5 
06A1    2E            4405     ADD A , R6 
06A2    F9            4406     MOV R1 , A 
06A3    7400          4407     	MOV	A, #0
06A5    3F            4408     ADDC A , R7 
06A6    FA            4409     MOV R2 , A 
06A7    7C04          4410     MOV R4 , # 4 
                      4411     MULT_S16_BY_U8_DIV_LOOP: 
06A9    C3            4412     	CLR	C			; Rotate right 
06AA    EA            4413     MOV A , R2 
06AB    13            4414     	RRC	A
06AC    FA            4415     MOV R2 , A 
06AD    E9            4416     MOV A , R1 
06AE    13            4417     	RRC	A
06AF    F9            4418     MOV R1 , A 
06B0    E8            4419     MOV A , R0 
06B1    13            4420     	RRC	A
06B2    F8            4421     MOV R0 , A 
06B3    DCF4          4422     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      4423     
06B5    8BF0          4424     MOV B , R3 
06B7    30F70A        4425     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      4426     
06BA    E8            4427     MOV A , R0 
06BB    F4            4428     	CPL	A
06BC    2401          4429     	ADD	A, #1
06BE    F8            4430     MOV R0 , A 
06BF    E9            4431     MOV A , R1 
06C0    F4            4432     	CPL	A
06C1    3400          4433     	ADDC	A, #0
06C3    F9            4434     MOV R1 , A 
                      4435     
                      4436     MULT_S16_BY_U8_EXIT: 
06C4    E8            4437     MOV A , R0 
06C5    89F0          4438     MOV B , R1 
06C7    C2D4          4439     	CLR	PSW.4		; Select normal register bank
06C9    F8            4440     MOV R0 , A 
06CA    A9F0          4441     MOV R1 , B 
06CC    22            4442     	RET
                      4443     
                      4444     
                      4445     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4446     ;
                      4447     ; Calculate governor routines
                      4448     ;
                      4449     ; No assumptions
                      4450     ;
                      4451     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      4452     ; The governor task is split into several routines in order to distribute processing time
                      4453     ;
                      4454     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4455     ; First governor routine - calculate governor target
                      4456     IF MODE == 0	; Main
                      4457     CALC_GOVERNOR_TARGET: 
06CD    7882          4458     MOV R0 , # PGM_GOV_MODE 
06CF    B60403        4459     CJNE @ R0 , # 4 , GOVERNOR_SPEED_CHECK 
06D2    02076C        4460     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      4461     
                      4462     GOVERNOR_SPEED_CHECK: 
                      4463     	; Stop governor for stop RC pulse	
06D5    C3            4464     	CLR	C
06D6    E55C          4465     	MOV	A, NEW_RCP				; Check RC pulse against stop value
06D8    9419          4466     	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
06DA    401E          4467     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      4468     
06DC    E52D          4469     	MOV	A, FLAGS1
06DE    5406          4470     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
06E0    7018          4471     	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                      4472     
                      4473     	; Skip speed check if governor is already active
06E2    206D36        4474     JB FLAGS1 . 5 , GOVERNOR_TARGET_CALC 
                      4475     
                      4476     	; Check speed (do not run governor for low speeds)
06E5    7805          4477     MOV R0 , # 05H 
06E7    7994          4478     MOV R1 , # PGM_GOV_RANGE 
06E9    E7            4479     MOV A , @ R1 
06EA    14            4480     	DEC	A
06EB    6007          4481     	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                      4482     
06ED    780A          4483     MOV R0 , # 0AH 
06EF    14            4484     	DEC	A
06F0    6002          4485     	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                      4486     	
06F2    7812          4487     MOV R0 , # 12H 
                      4488     
                      4489     GOVERNOR_ACT_LIM_SET: 
06F4    C3            4490     	CLR	C
06F5    E53E          4491     	MOV	A, COMM_PERIOD4X_H
06F7    98            4492     SUBB A , R0 
06F8    401F          4493     	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                      4494     
                      4495     GOVERNOR_DEACTIVATE: 
06FA    306D09        4496     JNB FLAGS1 . 5 , GOVERNOR_FIRST_DEACTIVATE_DONE 
                      4497      
06FD    856462        4498     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
0700    7569FF        4499     	MOV	SPOOLUP_LIMIT_CNT, #255
0703    756A01        4500     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      4501     
                      4502     GOVERNOR_FIRST_DEACTIVATE_DONE: 
0706    852224        4503     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0709    E4            4504     	CLR	A
070A    F542          4505     	MOV	GOV_TARGET_L, A			; Set target to zero
070C    F543          4506     	MOV	GOV_TARGET_H, A
070E    F544          4507     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
0710    F545          4508     	MOV	GOV_INTEGRAL_H, A
0712    F546          4509     	MOV	GOV_INTEGRAL_X, A
0714    C26D          4510     CLR FLAGS1 . 5 
0716    02076C        4511     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      4512     
                      4513     GOVERNOR_ACTIVATE: 
0719    D26D          4514     SETB FLAGS1 . 5 
                      4515     
                      4516     GOVERNOR_TARGET_CALC: 
                      4517     	; Governor calculations
071B    7994          4518     MOV R1 , # PGM_GOV_RANGE 
071D    E7            4519     MOV A , @ R1 
071E    14            4520     	DEC	A
071F    7013          4521     	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                      4522     
0721    E523          4523     	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
0723    F4            4524     	CPL	A					; Calculate 255-pwm (invert pwm) 
                      4525     	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
0724    33            4526     	RLC	A					; Msb to carry
0725    33            4527     	RLC	A					; To bit0
0726    F9            4528     MOV R1 , A 
0727    13            4529     	RRC	A					
0728    F8            4530     MOV R0 , A 
0729    E9            4531     MOV A , R1 
072A    5401          4532     	ANL	A, #01H				; Calculate H byte
072C    04            4533     	INC	A					; Add 1
072D    F9            4534     MOV R1 , A 
072E    E8            4535     MOV A , R0 
072F    54FE          4536     	ANL	A, #0FEH				; Calculate L byte
0731    020760        4537     	JMP	CALC_GOVERNOR_SUBTRACT_025
                      4538     
                      4539     CALC_GOVERNOR_TARGET_MIDDLE: 
0734    E7            4540     MOV A , @ R1 
0735    14            4541     	DEC	A
0736    14            4542     	DEC	A
0737    7014          4543     	JNZ	CALC_GOVERNOR_TARGET_LOW
                      4544     
0739    E523          4545     	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
073B    F4            4546     	CPL	A					; Calculate 255-pwm (invert pwm) 
                      4547     	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
073C    33            4548     	RLC	A					; Msb to carry
073D    33            4549     	RLC	A					; To bit0
073E    33            4550     	RLC	A					; To bit1
073F    F9            4551     MOV R1 , A 
0740    13            4552     	RRC	A					
0741    F8            4553     MOV R0 , A 
0742    E9            4554     MOV A , R1 
0743    5403          4555     	ANL	A, #03H				; Calculate H byte
0745    04            4556     	INC	A					; Add 1
0746    F9            4557     MOV R1 , A 
0747    E8            4558     MOV A , R0 
0748    54FC          4559     	ANL	A, #0FCH				; Calculate L byte
074A    020768        4560     	JMP	CALC_GOVERNOR_STORE_TARGET
                      4561     
                      4562     CALC_GOVERNOR_TARGET_LOW: 
074D    E523          4563     	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
074F    F4            4564     	CPL	A					; Calculate 255-pwm (invert pwm) 
                      4565     	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
0750    33            4566     	RLC	A					; Msb to carry
0751    33            4567     	RLC	A					; To bit0
0752    33            4568     	RLC	A					; To bit1
0753    33            4569     	RLC	A					; To bit2
0754    F9            4570     MOV R1 , A 
0755    13            4571     	RRC	A					
0756    F8            4572     MOV R0 , A 
0757    E9            4573     MOV A , R1 
0758    5407          4574     	ANL	A, #07H				; Calculate H byte
075A    04            4575     	INC	A					; Add 1
075B    04            4576     	INC	A					; Add 1 more
075C    F9            4577     MOV R1 , A 
075D    E8            4578     MOV A , R0 
075E    54F8          4579     	ANL	A, #0F8H				; Calculate L byte
                      4580     CALC_GOVERNOR_SUBTRACT_025: 
0760    C3            4581     	CLR	C
0761    9440          4582     	SUBB	A, #40H				; Subtract 0.25
0763    F8            4583     MOV R0 , A 
0764    E9            4584     MOV A , R1 
0765    9400          4585     	SUBB	A, #0
0767    F9            4586     MOV R1 , A 
                      4587     CALC_GOVERNOR_STORE_TARGET: 
                      4588     	; Store governor target
0768    8842          4589     MOV GOV_TARGET_L , R0 
076A    8943          4590     MOV GOV_TARGET_H , R1 
                      4591     CALC_GOVERNOR_TARGET_EXIT: 
076C    22            4592     	RET						
                      4593     ENDIF
                      4594     IF MODE == 1	; Tail
                               CALC_GOVERNOR_TARGET:
                               	RET						
                               ENDIF
                      4598     IF MODE == 2	; Multi
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Closed loop mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_TARGET_CALC	; Yes - branch
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_TARGET_CALC:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #RCP_STOP				; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	JMP	GOVERNOR_ACTIVATE			; No - activate
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	CLR	FLAGS1.GOV_ACTIVE
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	TEMP1, #PGM_GOV_MODE		; Store gov mode
                               	MOV	A, @TEMP1
                               	MOV	TEMP5, A
                               	SETB	FLAGS1.GOV_ACTIVE
                               	MOV	A, REQUESTED_PWM			; Load requested pwm
                               	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                               	; Calculate comm period target 2*(51000/Requested_Pwm)
                               	MOV	TEMP1, #38H				; Load 51000
                               	MOV	TEMP2, #0C7H
                               	MOV	TEMP3, COMM_PERIOD4X_L		; Load comm period
                               	MOV	TEMP4, COMM_PERIOD4X_H		
                               	; Set speed range 
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 200k eRPM range here
                               	; Check range
                               	MOV	A, TEMP5
                               	DEC	A
                               	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                               GOVERNOR_ACTIVATE_100K:
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 100k eRPM range here
                               	MOV	A, TEMP5					; Check range again
                               	DEC	A
                               	DEC	A
                               	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                               GOVERNOR_ACTIVATE_50K:
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 50k eRPM range here
                               GOVERNOR_ACTIVATE_RANGE_SET:
                               	CALL	DIV_U16_BY_U16
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      4676     
                      4677     
                      4678     ; Second governor routine - calculate governor proportional error
                      4679     CALC_GOVERNOR_PROP_ERROR: 
                      4680     IF MODE <= 1	; Main or tail
                      4681     	; Load comm period and divide by 2
076D    C3            4682     	CLR	C
076E    E53E          4683     	MOV	A, COMM_PERIOD4X_H
0770    13            4684     	RRC	A
0771    F9            4685     MOV R1 , A 
0772    E53D          4686     	MOV	A, COMM_PERIOD4X_L
0774    13            4687     	RRC	A
0775    F8            4688     MOV R0 , A 
                      4689     	; Calculate error
0776    C3            4690     	CLR	C
0777    E542          4691     	MOV	A, GOV_TARGET_L
0779    98            4692     SUBB A , R0 
077A    F8            4693     MOV R0 , A 
077B    E543          4694     	MOV	A, GOV_TARGET_H
077D    99            4695     SUBB A , R1 
077E    F9            4696     MOV R1 , A 
                      4697     ENDIF
                      4698     IF MODE == 2	; Multi
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, GOVERNOR_REQ_PWM
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               ENDIF
                      4708     	; Check error and limit
077F    500C          4709     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      4710     
0781    C3            4711     	CLR	C
0782    E8            4712     MOV A , R0 
0783    9480          4713     	SUBB	A, #80H					; Is error too negative?
0785    E9            4714     MOV A , R1 
0786    94FF          4715     	SUBB	A, #0FFH
0788    4016          4716     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
078A    0207A4        4717     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4718     
                      4719     GOVERNOR_CHECK_PROP_LIMIT_POS: 
078D    C3            4720     	CLR	C
078E    E8            4721     MOV A , R0 
078F    947F          4722     	SUBB	A, #7FH					; Is error too positive?
0791    E9            4723     MOV A , R1 
0792    9400          4724     	SUBB	A, #00H
0794    5003          4725     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
0796    0207A4        4726     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4727     
                      4728     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0799    787F          4729     MOV R0 , # 7FH 
079B    7900          4730     MOV R1 , # 00H 
079D    0207A4        4731     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4732     
                      4733     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
07A0    7880          4734     MOV R0 , # 80H 
07A2    79FF          4735     MOV R1 , # 0FFH 
                      4736     
                      4737     GOVERNOR_STORE_PROP_ERROR: 
                      4738     	; Store proportional
07A4    8847          4739     MOV GOV_PROPORTIONAL_L , R0 
07A6    8948          4740     MOV GOV_PROPORTIONAL_H , R1 
                      4741     CALC_GOVERNOR_PROP_ERROR_EXIT: 
07A8    22            4742     	RET						
                      4743     
                      4744     
                      4745     ; Third governor routine - calculate governor integral error
                      4746     CALC_GOVERNOR_INT_ERROR: 
                      4747     	; Add proportional to integral
07A9    E547          4748     	MOV	A, GOV_PROPORTIONAL_L
07AB    2544          4749     	ADD	A, GOV_INTEGRAL_L
07AD    F8            4750     MOV R0 , A 
07AE    E548          4751     	MOV	A, GOV_PROPORTIONAL_H
07B0    3545          4752     	ADDC	A, GOV_INTEGRAL_H
07B2    F9            4753     MOV R1 , A 
07B3    854820        4754     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
07B6    E4            4755     	CLR	A
07B7    300701        4756     	JNB	BIT_ACCESS.7, ($+4)			
07BA    F4            4757     	CPL	A
07BB    3546          4758     	ADDC	A, GOV_INTEGRAL_X
07BD    FA            4759     MOV R2 , A 
                      4760     	; Check integral and limit
07BE    30E709        4761     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      4762     
07C1    C3            4763     	CLR	C
07C2    EA            4764     MOV A , R2 
07C3    94F0          4765     	SUBB	A, #0F0H					; Is error too negative?
07C5    4015          4766     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
07C7    0207E2        4767     	JMP	GOVERNOR_CHECK_PWM
                      4768     
                      4769     GOVERNOR_CHECK_INT_LIMIT_POS: 
07CA    C3            4770     	CLR	C
07CB    EA            4771     MOV A , R2 
07CC    940F          4772     	SUBB	A, #0FH					; Is error too positive?
07CE    5003          4773     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
07D0    0207E2        4774     	JMP	GOVERNOR_CHECK_PWM
                      4775     
                      4776     GOVERNOR_LIMIT_INT_ERROR_POS: 
07D3    78FF          4777     MOV R0 , # 0FFH 
07D5    79FF          4778     MOV R1 , # 0FFH 
07D7    7A0F          4779     MOV R2 , # 0FH 
07D9    0207E2        4780     	JMP	GOVERNOR_CHECK_PWM
                      4781     
                      4782     GOVERNOR_LIMIT_INT_ERROR_NEG: 
07DC    7800          4783     MOV R0 , # 00H 
07DE    7900          4784     MOV R1 , # 00H 
07E0    7AF0          4785     MOV R2 , # 0F0H 
                      4786     
                      4787     GOVERNOR_CHECK_PWM: 
                      4788     	; Check current pwm
07E2    C3            4789     	CLR	C
07E3    E524          4790     	MOV	A, CURRENT_PWM
07E5    9561          4791     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
07E7    500A          4792     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      4793     
07E9    C3            4794     	CLR	C
07EA    7401          4795     	MOV	A, #1
07EC    9524          4796     	SUBB	A, CURRENT_PWM				; Is current pwm at minimum?
07EE    500B          4797     	JNC	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      4798     
07F0    020800        4799     	JMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      4800     
                      4801     GOVERNOR_INT_MAX_PWM: 
07F3    E548          4802     	MOV	A, GOV_PROPORTIONAL_H
07F5    20E70E        4803     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      4804     
07F8    020800        4805     	JMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      4806     
                      4807     GOVERNOR_INT_MIN_PWM: 
07FB    E548          4808     	MOV	A, GOV_PROPORTIONAL_H
07FD    30E706        4809     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      4810     
                      4811     GOVERNOR_STORE_INT_ERROR: 
                      4812     	; Store integral
0800    8844          4813     MOV GOV_INTEGRAL_L , R0 
0802    8945          4814     MOV GOV_INTEGRAL_H , R1 
0804    8A46          4815     MOV GOV_INTEGRAL_X , R2 
                      4816     CALC_GOVERNOR_INT_ERROR_EXIT: 
0806    22            4817     	RET						
                      4818     
                      4819     
                      4820     ; Fourth governor routine - calculate governor proportional correction
                      4821     CALC_GOVERNOR_PROP_CORRECTION: 
                      4822     	; Load proportional gain
0807    78A4          4823     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0809    E6            4824     MOV A , @ R0 
080A    FA            4825     MOV R2 , A 
                      4826     	; Load proportional
080B    C3            4827     	CLR	C
080C    E547          4828     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
080E    33            4829     	RLC	A
080F    F8            4830     MOV R0 , A 
0810    E548          4831     	MOV	A, GOV_PROPORTIONAL_H
0812    33            4832     	RLC	A
0813    F9            4833     MOV R1 , A 
                      4834     	; Apply gain
0814    120676        4835     	CALL	MULT_S16_BY_U8_DIV_16
                      4836     	; Check error and limit (to low byte)
0817    E9            4837     MOV A , R1 
0818    30E70B        4838     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      4839     
081B    C3            4840     	CLR	C
081C    E8            4841     MOV A , R0 
081D    9480          4842     	SUBB	A, #80H					; Is error too negative?
081F    E9            4843     MOV A , R1 
0820    94FF          4844     	SUBB	A, #0FFH
0822    4013          4845     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0824    013B          4846     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4847     
                      4848     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0826    C3            4849     	CLR	C
0827    E8            4850     MOV A , R0 
0828    947F          4851     	SUBB	A, #7FH					; Is error too positive?
082A    E9            4852     MOV A , R1 
082B    9400          4853     	SUBB	A, #00H
082D    5002          4854     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
082F    013B          4855     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4856     
                      4857     GOVERNOR_LIMIT_PROP_CORR_POS: 
0831    787F          4858     MOV R0 , # 7FH 
0833    7900          4859     MOV R1 , # 00H 
0835    013B          4860     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4861     
                      4862     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0837    7880          4863     MOV R0 , # 80H 
0839    79FF          4864     MOV R1 , # 0FFH 
                      4865     
                      4866     GOVERNOR_APPLY_PROP_CORR: 
                      4867     	; Test proportional sign
083B    E8            4868     MOV A , R0 
083C    20E715        4869     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      4870     
                      4871     	; Subtract positive proportional
083F    C3            4872     	CLR	C
0840    E523          4873     	MOV	A, GOVERNOR_REQ_PWM
0842    98            4874     SUBB A , R0 
0843    F8            4875     MOV R0 , A 
                      4876     	; Check result
0844    4009          4877     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      4878     
0846    C3            4879     	CLR	C
0847    E8            4880     MOV A , R0 
0848    9401          4881     	SUBB	A, #1
084A    4003          4882     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
084C    020862        4883     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4884     
                      4885     GOVERNOR_CORR_PROP_MIN_PWM: 
084F    7801          4886     MOV R0 , # 1 
0851    020862        4887     	JMP	GOVERNOR_STORE_PROP_CORR
                      4888     
                      4889     GOVERNOR_CORR_NEG_PROP: 
                      4890     	; Add negative proportional
0854    E8            4891     MOV A , R0 
0855    F4            4892     	CPL	A
0856    2401          4893     	ADD	A, #1
0858    2523          4894     	ADD	A, GOVERNOR_REQ_PWM
085A    F8            4895     MOV R0 , A 
                      4896     	; Check result
085B    4003          4897     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
085D    020862        4898     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4899     
                      4900     GOVERNOR_CORR_PROP_MAX_PWM: 
0860    78FF          4901     MOV R0 , # 255 
                      4902     GOVERNOR_STORE_PROP_CORR: 
                      4903     	; Store proportional pwm
0862    8849          4904     MOV GOV_PROP_PWM , R0 
                      4905     CALC_GOVERNOR_PROP_CORR_EXIT: 
0864    22            4906     	RET
                      4907     
                      4908     
                      4909     ; Fifth governor routine - calculate governor integral correction
                      4910     CALC_GOVERNOR_INT_CORRECTION: 
                      4911     	; Load integral gain
0865    78A5          4912     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0867    E6            4913     MOV A , @ R0 
0868    FA            4914     MOV R2 , A 
                      4915     	; Load integral
0869    A845          4916     MOV R0 , GOV_INTEGRAL_H 
086B    A946          4917     MOV R1 , GOV_INTEGRAL_X 
                      4918     	; Apply gain
086D    120676        4919     	CALL	MULT_S16_BY_U8_DIV_16
                      4920     	; Check integral and limit
0870    E9            4921     MOV A , R1 
0871    30E70C        4922     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      4923     
0874    C3            4924     	CLR	C
0875    E8            4925     MOV A , R0 
0876    9401          4926     	SUBB	A, #01H					; Is integral too negative?
0878    E9            4927     MOV A , R1 
0879    94FF          4928     	SUBB	A, #0FFH
087B    4016          4929     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
087D    020897        4930     	JMP	GOVERNOR_APPLY_INT_CORR
                      4931     
                      4932     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0880    C3            4933     	CLR	C
0881    E8            4934     MOV A , R0 
0882    94FF          4935     	SUBB	A, #0FFH					; Is integral too positive?
0884    E9            4936     MOV A , R1 
0885    9400          4937     	SUBB	A, #00H
0887    5003          4938     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0889    020897        4939     	JMP	GOVERNOR_APPLY_INT_CORR
                      4940     
                      4941     GOVERNOR_LIMIT_INT_CORR_POS: 
088C    78FF          4942     MOV R0 , # 0FFH 
088E    7900          4943     MOV R1 , # 00H 
0890    020897        4944     	JMP	GOVERNOR_APPLY_INT_CORR
                      4945     
                      4946     GOVERNOR_LIMIT_INT_CORR_NEG: 
0893    7801          4947     MOV R0 , # 01H 
0895    79FF          4948     MOV R1 , # 0FFH 
                      4949     
                      4950     GOVERNOR_APPLY_INT_CORR: 
                      4951     	; Test integral sign
0897    E9            4952     MOV A , R1 
0898    20E715        4953     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      4954     
                      4955     	; Subtract positive integral
089B    C3            4956     	CLR	C
089C    E549          4957     	MOV	A, GOV_PROP_PWM
089E    98            4958     SUBB A , R0 
089F    F8            4959     MOV R0 , A 
                      4960     	; Check result
08A0    4009          4961     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      4962     
08A2    C3            4963     	CLR	C
08A3    E8            4964     MOV A , R0 
08A4    9401          4965     	SUBB	A, #1
08A6    4003          4966     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
08A8    0208BE        4967     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4968     
                      4969     GOVERNOR_CORR_INT_MIN_PWM: 
08AB    7801          4970     MOV R0 , # 1 
08AD    0208BE        4971     	JMP	GOVERNOR_STORE_INT_CORR
                      4972     
                      4973     GOVERNOR_CORR_NEG_INT: 
                      4974     	; Add negative integral
08B0    E8            4975     MOV A , R0 
08B1    F4            4976     	CPL	A
08B2    2401          4977     	ADD	A, #1
08B4    2549          4978     	ADD	A, GOV_PROP_PWM
08B6    F8            4979     MOV R0 , A 
                      4980     	; Check result
08B7    4003          4981     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
08B9    0208BE        4982     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4983     
                      4984     GOVERNOR_CORR_INT_MAX_PWM: 
08BC    78FF          4985     MOV R0 , # 255 
                      4986     GOVERNOR_STORE_INT_CORR: 
                      4987     	; Store current pwm
08BE    8824          4988     MOV CURRENT_PWM , R0 
                      4989     CALC_GOVERNOR_INT_CORR_EXIT: 
08C0    22            4990     	RET
                      4991     
                      4992     
                      4993     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4994     ;
                      4995     ; Set pwm limit low rpm
                      4996     ;
                      4997     ; No assumptions
                      4998     ;
                      4999     ; Sets power limit for low rpms and disables demag for low rpms
                      5000     ;
                      5001     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5002     SET_PWM_LIMIT_LOW_RPM: 
                      5003     	; Set pwm limit and demag disable for low rpms
08C1    78FF          5004     MOV R0 , # 0FFH 
08C3    C264          5005     CLR FLAGS0 . 4 
08C5    20693D        5006     JB FLAGS1 . 1 , SET_PWM_LIMIT_LOW_RPM_EXIT 
08C8    206A12        5007     JB FLAGS1 . 2 , SET_PWM_DEMAG_DONE 
                      5008     
08CB    D264          5009     SETB FLAGS0 . 4 
08CD    C3            5010     	CLR	C
08CE    E53E          5011     	MOV	A, COMM_PERIOD4X_H
08D0    940A          5012     	SUBB	A, #0AH						; ~31250 eRPM
08D2    4009          5013     	JC	SET_PWM_DEMAG_DONE				; If speed above - branch
                      5014     
08D4    C3            5015     	CLR	C
08D5    E525          5016     	MOV	A, CURRENT_PWM_LIMITED	
08D7    9440          5017     	SUBB	A, #40H						; Do not disable if pwm above 25%
08D9    5002          5018     	JNC	SET_PWM_DEMAG_DONE
                      5019     
08DB    C264          5020     CLR FLAGS0 . 4 
                      5021     
                      5022     SET_PWM_DEMAG_DONE: 
08DD    79A1          5023     MOV R1 , # PGM_ENABLE_POWER_PROT 
08DF    E7            5024     MOV A , @ R1 
08E0    6023          5025     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Exit if disabled
                      5026     
08E2    E53E          5027     	MOV	A, COMM_PERIOD4X_H
08E4    601F          5028     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Avoid divide by zero
                      5029     
08E6    74FF          5030     	MOV	A, #255						; Divide 255 by Comm_Period4x_H
08E8    853EF0        5031     	MOV	B, COMM_PERIOD4X_H
08EB    84            5032     	DIV	AB
08EC    8538F0        5033     	MOV	B, LOW_RPM_PWR_SLOPE			; Multiply by slope
08EF    306A03        5034     JNB FLAGS1 . 2 , ( $+6 ) 
08F2    75F005        5035     	MOV	B, #5
08F5    A4            5036     	MUL	AB
08F6    F8            5037     MOV R0 , A 
08F7    C5F0          5038     	XCH	A, B
08F9    6002          5039     	JZ	($+4)						; Limit to max
                      5040     	
08FB    78FF          5041     MOV R0 , # 0FFH 
                      5042     
08FD    C3            5043     	CLR	C
08FE    E8            5044     MOV A , R0 
08FF    9564          5045     	SUBB	A, PWM_SPOOLUP_BEG
0901    5002          5046     	JNC	SET_PWM_LIMIT_LOW_RPM_EXIT
                      5047     
0903    A864          5048     MOV R0 , PWM_SPOOLUP_BEG 
                      5049     
                      5050     SET_PWM_LIMIT_LOW_RPM_EXIT: 
0905    8863          5051     MOV PWM_LIMIT_BY_RPM , R0 
0907    22            5052     	RET
                      5053     	
                      5054     
                      5055     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5056     ;
                      5057     ; Set pwm limit high rpm
                      5058     ;
                      5059     ; No assumptions
                      5060     ;
                      5061     ; Sets power limit for high rpms
                      5062     ;
                      5063     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5064     SET_PWM_LIMIT_HIGH_RPM: 
                      5065     IF MCU_48MHZ == 1
0908    C3            5066     	CLR	C
0909    E53D          5067     	MOV	A, COMM_PERIOD4X_L
090B    94C8          5068     	SUBB	A, #0C8H				; Limit Comm_Period to 200, which is 400k erpm
090D    E53E          5069     	MOV	A, COMM_PERIOD4X_H
090F    9400          5070     	SUBB	A, #00H
                      5071     ELSE
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_L
                               	SUBB	A, #40H				; Limit Comm_Period to 320, which is 250k erpm
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, #01H
                               ENDIF
0911    E563          5078     	MOV	A, PWM_LIMIT_BY_RPM
0913    5003          5079     	JNC	SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT
                      5080     	
0915    14            5081     	DEC	A
0916    2119          5082     	AJMP	SET_PWM_LIMIT_HIGH_RPM_STORE
                      5083     	
                      5084     SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT: 
0918    04            5085     	INC	A
                      5086     SET_PWM_LIMIT_HIGH_RPM_STORE: 
0919    6002          5087     	JZ	($+4)
                      5088     
091B    F563          5089     	MOV	PWM_LIMIT_BY_RPM, A
                      5090     
091D    22            5091     	RET
                      5092     
                      5093     
                      5094     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5095     ;
                      5096     ; Measure lipo cells
                      5097     ;
                      5098     ; No assumptions
                      5099     ;
                      5100     ; Measure voltage and calculate lipo cells
                      5101     ;
                      5102     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5103     MEASURE_LIPO_CELLS: 
                      5104     IF MODE >= 1	; Tail or multi
                               	; If not supported, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      5108     IF MODE == 0	; Main
                      5109     	; Load programmed low voltage limit
091E    7883          5110     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0920    E6            5111     MOV A , @ R0 
0921    F520          5112     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      5113     	; Set commutation to BpFET on
0923    120FB0        5114     	CALL	COMM5COMM6			
                      5115     	; Start adc
                      5116     	START_ADC 
0926    75E890        5116+1   MOV ADC0CN , # 90H  ; ADC START
                      5117     	; Wait for ADC reference to settle, and then start again
0929    1205C4        5118     	CALL	WAIT1MS
                      5119     	START_ADC
092C    75E890        5119+1   MOV ADC0CN , # 90H  ; ADC START
                      5120     	; Wait for ADC conversion to complete
                      5121     MEASURE_LIPO_WAIT_ADC: 
                      5122     	GET_ADC_STATUS 
092F    E5E8          5122+1   MOV A , ADC0CN 
0931    20ECFB        5123     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      5124     	; Read ADC result
                      5125     	READ_ADC_RESULT
0934    A8BD          5125+1   MOV R0 , ADC0L 
0936    A9BE          5125+1   MOV R1 , ADC0H 
                      5126     	; Stop ADC
                      5127     	STOP_ADC
                      5128     	; Switch power off
0938    12104A        5129     	CALL	SWITCH_POWER_OFF		
                      5130     	; Set limit step
093B    756E00        5131     MOV LIPO_ADC_LIMIT_L , # 0 
093E    756F00        5132     MOV LIPO_ADC_LIMIT_H , # 0 
0941    C3            5133     	CLR	C
0942    7400          5134     MOV A , # 0 
0944    13            5135     	RRC	A
0945    FD            5136     MOV R5 , A 
0946    7400          5137     MOV A , # 0 
0948    6066          5138     	JZ	MEASURE_LIPO_EXIT		; Exit if disabled
                      5139     
094A    13            5140     	RRC	A
094B    FC            5141     MOV R4 , A 
094C    7400          5142     MOV A , # 0 
094E    2C            5143     ADD A , R4 
094F    FC            5144     MOV R4 , A 
0950    7400          5145     MOV A , # 0 
0952    3D            5146     ADDC A , R5 
0953    FD            5147     MOV R5 , A 
0954    EC            5148     MOV A , R4 
0955    FA            5149     MOV R2 , A 
0956    ED            5150     MOV A , R5 
0957    FB            5151     MOV R3 , A 
                      5152     MEASURE_LIPO_CELL_LOOP: 
                      5153     	; Check voltage against xS lower limit
0958    C3            5154     	CLR	C
0959    E8            5155     MOV A , R0 
095A    9A            5156     SUBB A , R2 
095B    E9            5157     MOV A , R1 
095C    9B            5158     SUBB A , R3 
095D    4014          5159     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      5160     
                      5161     	; Set xS voltage limit
095F    E56E          5162     	MOV	A, LIPO_ADC_LIMIT_L		
0961    2400          5163     ADD A , # 0 
0963    F56E          5164     	MOV	LIPO_ADC_LIMIT_L, A
0965    E56F          5165     	MOV	A, LIPO_ADC_LIMIT_H		
0967    3400          5166     ADDC A , # 0 
0969    F56F          5167     	MOV	LIPO_ADC_LIMIT_H, A
                      5168     	; Set (x+1)S lower limit
096B    EA            5169     MOV A , R2 
096C    2C            5170     ADD A , R4 
096D    FA            5171     MOV R2 , A 
096E    EB            5172     MOV A , R3 
096F    3D            5173     ADDC A , R5 
0970    FB            5174     MOV R3 , A 
0971    80E5          5175     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      5176     
                      5177     MEASURE_LIPO_ADJUST: 
0973    AE6E          5178     MOV R6 , LIPO_ADC_LIMIT_L 
0975    AF6F          5179     MOV R7 , LIPO_ADC_LIMIT_H 
                      5180     	; Calculate 3.125%
0977    C3            5181     	CLR	C
0978    E56F          5182     	MOV	A, LIPO_ADC_LIMIT_H
097A    13            5183     	RRC	A
097B    F9            5184     MOV R1 , A 
097C    E56E          5185     	MOV	A, LIPO_ADC_LIMIT_L	
097E    13            5186     	RRC	A
097F    F8            5187     MOV R0 , A 
0980    C3            5188     	CLR	C
0981    E9            5189     MOV A , R1 
0982    13            5190     	RRC	A
0983    F9            5191     MOV R1 , A 
0984    E8            5192     MOV A , R0 
0985    13            5193     	RRC	A
0986    F8            5194     MOV R0 , A 
                      5195     	; Divide three times to get to 3.125%
0987    7A03          5196     MOV R2 , # 3 
                      5197     MEASURE_LIPO_DIVIDE_LOOP: 
0989    C3            5198     	CLR	C
098A    E9            5199     MOV A , R1 
098B    13            5200     	RRC	A
098C    F9            5201     MOV R1 , A 
098D    E8            5202     MOV A , R0 
098E    13            5203     	RRC	A
098F    F8            5204     MOV R0 , A 
0990    DAF7          5205     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      5206     
                      5207     	; Add the programmed number of 0.1V (or 3.125% increments)
0992    AA20          5208     MOV R2 , BIT_ACCESS 
0994    1A            5209     DEC R2 
0995    7009          5210     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      5211     
0997    756E00        5212     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
099A    756F00        5213     	MOV	LIPO_ADC_LIMIT_H, #0
099D    0209B0        5214     	JMP	MEASURE_LIPO_EXIT	
                      5215     
                      5216     MEASURE_LIPO_LIMIT_ON: 
09A0    1A            5217     DEC R2 
09A1    EA            5218     MOV A , R2 
09A2    6008          5219     	JZ	MEASURE_LIPO_UPDATE
                      5220     
                      5221     MEASURE_LIPO_ADD_LOOP: 
09A4    EE            5222     MOV A , R6 
09A5    28            5223     ADD A , R0 
09A6    FE            5224     MOV R6 , A 
09A7    EF            5225     MOV A , R7 
09A8    39            5226     ADDC A , R1 
09A9    FF            5227     MOV R7 , A 
09AA    DAF8          5228     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      5229     
                      5230     MEASURE_LIPO_UPDATE: 
                      5231     	; Set ADC limit
09AC    8E6E          5232     MOV LIPO_ADC_LIMIT_L , R6 
09AE    8F6F          5233     MOV LIPO_ADC_LIMIT_H , R7 
                      5234     ENDIF
                      5235     MEASURE_LIPO_EXIT: 
09B0    22            5236     	RET
                      5237     
                      5238     
                      5239     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5240     ;
                      5241     ; Start ADC conversion
                      5242     ;
                      5243     ; No assumptions
                      5244     ;
                      5245     ; Start conversion used for measuring power supply voltage
                      5246     ;
                      5247     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5248     START_ADC_CONVERSION: 
                      5249     	; Start adc
                      5250     	START_ADC 
09B1    75E890        5250+1   MOV ADC0CN , # 90H  ; ADC START
09B4    22            5251     	RET
                      5252     
                      5253     
                      5254     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5255     ;
                      5256     ; Check temperature, power supply voltage and limit power
                      5257     ;
                      5258     ; No assumptions
                      5259     ;
                      5260     ; Used to limit main motor power in order to maintain the required voltage
                      5261     ;
                      5262     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5263     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      5264     	; Load programmed low voltage limit
09B5    7883          5265     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
09B7    E6            5266     MOV A , @ R0 
09B8    FF            5267     MOV R7 , A 
                      5268     	; Wait for ADC conversion to complete
                      5269     	GET_ADC_STATUS 
09B9    E5E8          5269+1   MOV A , ADC0CN 
09BB    20ECF7        5270     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      5271     	; Read ADC result
                      5272     	READ_ADC_RESULT
09BE    A8BD          5272+1   MOV R0 , ADC0L 
09C0    A9BE          5272+1   MOV R1 , ADC0H 
                      5273     	; Stop ADC
                      5274     	STOP_ADC
                      5275     
09C2    0570          5276     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
09C4    C3            5277     	CLR	C
09C5    E570          5278     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
09C7    9408          5279     SUBB A , # 8 
09C9    4052          5280     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      5281     
09CB    757000        5282     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
09CE    E9            5283     MOV A , R1 
09CF    FA            5284     MOV R2 , A 
09D0    79A0          5285     MOV R1 , # PGM_ENABLE_TEMP_PROT 
09D2    E7            5286     MOV A , @ R1 
09D3    6044          5287     	JZ	TEMP_CHECK_EXIT			; No - branch
                      5288     
09D5    EA            5289     MOV A , R2 
09D6    7007          5290     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      5291     
09D8    E571          5292     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
09DA    601B          5293     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
09DC    0209EB        5294     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      5295     
                      5296     TEMP_AVERAGE_INC_DEC: 
09DF    C3            5297     	CLR	C
09E0    E8            5298     MOV A , R0 
09E1    9571          5299     	SUBB	A, CURRENT_AVERAGE_TEMP
09E3    6010          5300     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      5301     
09E5    E571          5302     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
09E7    5006          5303     	JNC	TEMP_AVERAGE_INC				
                      5304     
09E9    600C          5305     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      5306     TEMP_AVERAGE_DEC: 
09EB    14            5307     	DEC	A						; Decrement average
09EC    0209F7        5308     	JMP	TEMP_AVERAGE_UPDATED
                      5309     
                      5310     TEMP_AVERAGE_INC: 
09EF    04            5311     	INC	A						; Increment average
09F0    60F9          5312     	JZ	TEMP_AVERAGE_DEC
09F2    0209F7        5313     	JMP	TEMP_AVERAGE_UPDATED
                      5314     
                      5315     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
09F5    E571          5316     	MOV	A, CURRENT_AVERAGE_TEMP
                      5317     TEMP_AVERAGE_UPDATED: 
09F7    F571          5318     	MOV	CURRENT_AVERAGE_TEMP, A
09F9    C3            5319     	CLR	C
09FA    9472          5320     SUBB A , # 114 
09FC    401B          5321     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5322     
09FE    7561C0        5323     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      5324     
0A01    C3            5325     	CLR	C
0A02    9404          5326     SUBB A , # 4 
0A04    4013          5327     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5328     
0A06    756180        5329     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      5330     
0A09    C3            5331     	CLR	C
0A0A    9404          5332     SUBB A , # 4 
0A0C    400B          5333     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5334     
0A0E    756140        5335     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      5336     
0A11    C3            5337     	CLR	C
0A12    9404          5338     SUBB A , # 4 
0A14    4003          5339     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5340     
0A16    756100        5341     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      5342     
                      5343     TEMP_CHECK_EXIT: 
                      5344     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0A19    75BB09        5344+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0A1C    22            5345     	RET
                      5346     
                      5347     CHECK_VOLTAGE_START: 
                      5348     IF MODE == 0	; Main 
                      5349     	; Check if low voltage limiting is enabled
0A1D    EF            5350     MOV A , R7 
0A1E    C3            5351     	CLR	C
0A1F    9401          5352     	SUBB	A, #1					; Is low voltage limit disabled?
0A21    601F          5353     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      5354     
0A23    7400          5355     MOV A , # 0 
0A25    601B          5356     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      5357     
                      5358     	; Check if ADC is saturated
0A27    C3            5359     	CLR	C
0A28    E8            5360     MOV A , R0 
0A29    94FF          5361     	SUBB	A, #0FFH
0A2B    E9            5362     MOV A , R1 
0A2C    9403          5363     	SUBB	A, #03H
0A2E    5012          5364     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      5365     
                      5366     	; Check voltage against limit
0A30    C3            5367     	CLR	C
0A31    E8            5368     MOV A , R0 
0A32    956E          5369     	SUBB	A, LIPO_ADC_LIMIT_L
0A34    E9            5370     MOV A , R1 
0A35    956F          5371     	SUBB	A, LIPO_ADC_LIMIT_H
0A37    5009          5372     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      5373     
                      5374     	; Decrease pwm limit
0A39    E561          5375     	MOV  A, PWM_LIMIT
0A3B    600C          5376     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      5377     
0A3D    1561          5378     	DEC	PWM_LIMIT					; Decrement limit
0A3F    020A49        5379     	JMP	CHECK_VOLTAGE_LIM
                      5380     
                      5381     CHECK_VOLTAGE_GOOD: 
                      5382     	; Increase pwm limit
0A42    E561          5383     	MOV  A, PWM_LIMIT
0A44    F4            5384     	CPL	A			
0A45    6002          5385     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      5386     
0A47    0561          5387     	INC	PWM_LIMIT					; Increment limit
                      5388     
                      5389     CHECK_VOLTAGE_LIM: 
0A49    A861          5390     MOV R0 , PWM_LIMIT 
0A4B    C3            5391     	CLR	C
0A4C    E524          5392     	MOV	A, CURRENT_PWM
0A4E    98            5393     SUBB A , R0 
0A4F    5002          5394     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      5395     
0A51    A824          5396     MOV R0 , CURRENT_PWM 
                      5397     
                      5398     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      5399     	; Slow spoolup
0A53    C3            5400     	CLR	C
0A54    E8            5401     MOV A , R0 
0A55    9562          5402     	SUBB	A, PWM_LIMIT_SPOOLUP
0A57    400A          5403     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      5404     
0A59    A862          5405     MOV R0 , PWM_LIMIT_SPOOLUP 
0A5B    E562          5406     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0A5D    F4            5407     	CPL	A
0A5E    6003          5408     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      5409      
0A60    856261        5410     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      5411     
                      5412     CHECK_VOLTAGE_EXIT: 
0A63    8825          5413     MOV CURRENT_PWM_LIMITED , R0 
0A65    8826          5414     MOV CURRENT_PWM_LIM_DITH , R0 
                      5415     ENDIF
                      5416     IF MODE == 1	; Tail
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               ENDIF
                      5426     IF MODE == 2	; Multi
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	ADD	A, #16			
                               	JNC	($+4)					; If not max - branch
                               
                               	MOV	A, #255
                               
                               	MOV	PWM_LIMIT, A				; Increment limit 
                               	; Set current pwm limited if closed loop mode
                               	MOV	TEMP2, #PGM_GOV_MODE		; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)			
                               	AJMP	CHECK_VOLTAGE_PWM_DONE		; No - branch
                               
                               	CLR	C
                               	MOV	TEMP1, PWM_LIMIT			; Set limit
                               	MOV	A, CURRENT_PWM
                               	SUBB	A, TEMP1
                               	JNC	CHECK_VOLTAGE_LOW_RPM		; If current pwm above limit - branch and limit	
                               
                               	MOV	TEMP1, CURRENT_PWM			; Set current pwm (no limiting)
                               
                               CHECK_VOLTAGE_LOW_RPM:
                               	; Limit pwm for low rpms
                               	CLR	C
                               	MOV	A, TEMP1					; Check against limit
                               	SUBB	A, PWM_LIMIT_BY_RPM
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT_BY_RPM		; Limit pwm
                               
                               	MOV  CURRENT_PWM_LIMITED, TEMP1
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               CHECK_VOLTAGE_PWM_DONE:
                               ENDIF
                      5461     	; Set adc mux for next conversion
0A67    E570          5462     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0A69    B40703        5463     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      5464     
                      5465     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0A6C    75BB10        5465+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5466     
                      5467     CHECK_VOLTAGE_RET: 
0A6F    22            5468     	RET
                      5469     
                      5470     
                      5471     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5472     ;
                      5473     ; Set startup PWM routine
                      5474     ;
                      5475     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      5476     ;
                      5477     ; Used for pwm control during startup
                      5478     ;
                      5479     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5480     SET_STARTUP_PWM: 	
                      5481     	; Adjust startup power
0A70    7432          5482     MOV A , # 50 
0A72    79A6          5483     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0A74    87F0          5484     MOV B , @ R1 
0A76    A4            5485     	MUL	AB
0A77    C5F0          5486     	XCH	A, B
0A79    A2F7          5487     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0A7B    33            5488     	RLC	A
0A7C    F8            5489     MOV R0 , A 
0A7D    C3            5490     	CLR	C
0A7E    E8            5491     MOV A , R0 
0A7F    9561          5492     	SUBB	A, PWM_LIMIT	
0A81    4002          5493     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      5494     
0A83    A861          5495     MOV R0 , PWM_LIMIT 
                      5496     
                      5497     STARTUP_PWM_SET_PWM: 
                      5498     	; Set pwm variables
0A85    8822          5499     MOV REQUESTED_PWM , R0 
0A87    8824          5500     MOV CURRENT_PWM , R0 
0A89    8825          5501     MOV CURRENT_PWM_LIMITED , R0 
0A8B    8826          5502     MOV CURRENT_PWM_LIM_DITH , R0 
0A8D    8864          5503     MOV PWM_SPOOLUP_BEG , R0 
0A8F    22            5504     	RET
                      5505     
                      5506     
                      5507     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5508     ;
                      5509     ; Initialize timing routine
                      5510     ;
                      5511     ; No assumptions
                      5512     ;
                      5513     ; Part of initialization before motor start
                      5514     ;
                      5515     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5516     INITIALIZE_TIMING:  
0A90    753D00        5517     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0A93    753EF0        5518     	MOV	COMM_PERIOD4X_H, #0F0H
0A96    22            5519     	RET
                      5520     
                      5521     
                      5522     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5523     ;
                      5524     ; Calculate next commutation timing routine
                      5525     ;
                      5526     ; No assumptions
                      5527     ;
                      5528     ; Called immediately after each commutation
                      5529     ; Also sets up timer 3 to wait advance timing
                      5530     ; Two entry points are used
                      5531     ;
                      5532     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5533     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
                      5534     	; Read commutation time
0A97    75C820        5535     	MOV	TMR2CN, #20H		; Timer2 disabled
0A9A    A8CC          5536     MOV R0 , TMR2L 
0A9C    A9CD          5537     MOV R1 , TMR2H 
0A9E    75C824        5538     	MOV	TMR2CN, #24H		; Timer2 enabled
                      5539     IF MCU_48MHZ == 1
0AA1    C3            5540     	CLR	C
0AA2    E9            5541     MOV A , R1 
0AA3    13            5542     	RRC	A
0AA4    F9            5543     MOV R1 , A 
0AA5    E8            5544     MOV A , R0 
0AA6    13            5545     	RRC	A
0AA7    F8            5546     MOV R0 , A 
                      5547     ENDIF
                      5548     	; Calculate this commutation time
0AA8    AA39          5549     MOV R2 , PREV_COMM_L 
0AAA    AB3A          5550     MOV R3 , PREV_COMM_H 
0AAC    8839          5551     MOV PREV_COMM_L , R0 
0AAE    893A          5552     MOV PREV_COMM_H , R1 
0AB0    C3            5553     	CLR	C
0AB1    E8            5554     MOV A , R0 
0AB2    9A            5555     SUBB A , R2 
0AB3    F8            5556     MOV R0 , A 
0AB4    E9            5557     MOV A , R1 
0AB5    9B            5558     SUBB A , R3 
                      5559     IF MCU_48MHZ == 1
0AB6    547F          5560     	ANL	A, #7FH
                      5561     ENDIF
0AB8    F9            5562     MOV R1 , A 
0AB9    306702        5563     JNB FLAGS0 . 7 , ( $+5 ) 
0ABC    6196          5564     	AJMP	CALC_NEXT_COMM_TIMING_FAST
                      5565     
0ABE    306933        5566     JNB FLAGS1 . 1 , CALC_NEXT_COMM_STARTUP_DONE 
                      5567     
0AC1    AC3B          5568     MOV R4 , PREV_PREV_COMM_L 
0AC3    AD3C          5569     MOV R5 , PREV_PREV_COMM_H 
0AC5    8A3B          5570     MOV PREV_PREV_COMM_L , R2 
0AC7    8B3C          5571     MOV PREV_PREV_COMM_H , R3 
0AC9    C3            5572     	CLR	C
0ACA    EB            5573     MOV A , R3 
0ACB    9D            5574     SUBB A , R5 
                      5575     IF MCU_48MHZ == 1
0ACC    547F          5576     	ANL	A, #7FH
                      5577     ENDIF
0ACE    FB            5578     MOV R3 , A 
0ACF    C3            5579     	CLR	C
0AD0    E9            5580     MOV A , R1 
0AD1    9B            5581     SUBB A , R3 
0AD2    F53F          5582     	MOV	COMM_DIFF, A
0AD4    A839          5583     MOV R0 , PREV_COMM_L 
0AD6    A93A          5584     MOV R1 , PREV_COMM_H 
0AD8    C3            5585     	CLR	C
0AD9    E8            5586     MOV A , R0 
0ADA    9C            5587     SUBB A , R4 
0ADB    F8            5588     MOV R0 , A 
0ADC    E9            5589     MOV A , R1 
0ADD    9D            5590     SUBB A , R5 
                      5591     IF MCU_48MHZ == 1
0ADE    547F          5592     	ANL	A, #7FH
                      5593     ENDIF
0AE0    F9            5594     MOV R1 , A 
                      5595     
0AE1    C3            5596     	CLR	C
0AE2    E53E          5597     	MOV	A, COMM_PERIOD4X_H		; Average with previous and save
0AE4    13            5598     	RRC	A
0AE5    FB            5599     MOV R3 , A 
0AE6    E53D          5600     	MOV	A, COMM_PERIOD4X_L
0AE8    13            5601     	RRC	A
0AE9    FA            5602     MOV R2 , A 
0AEA    E8            5603     MOV A , R0 
0AEB    2A            5604     ADD A , R2 
0AEC    F53D          5605     	MOV	COMM_PERIOD4X_L, A
0AEE    E9            5606     MOV A , R1 
0AEF    3B            5607     ADDC A , R3 
0AF0    F53E          5608     	MOV	COMM_PERIOD4X_H, A
0AF2    613E          5609     	AJMP	CALC_NEW_WAIT_TIMES_SETUP
                      5610     
                      5611     CALC_NEXT_COMM_STARTUP_DONE: 
                      5612     	; Calculate new commutation time 
0AF4    AA3D          5613     MOV R2 , COMM_PERIOD4X_L 
0AF6    AB3E          5614     MOV R3 , COMM_PERIOD4X_H 
0AF8    AC3D          5615     MOV R4 , COMM_PERIOD4X_L 
0AFA    AD3E          5616     MOV R5 , COMM_PERIOD4X_H 
0AFC    7E04          5617     MOV R6 , # 4 
0AFE    7F02          5618     MOV R7 , # 2 
0B00    C3            5619     	CLR	C
0B01    EB            5620     MOV A , R3 
0B02    9404          5621     	SUBB	A, #04H
0B04    4002          5622     	JC	($+4)
                      5623     
0B06    1E            5624     DEC R6 
0B07    1F            5625     DEC R7 
                      5626     
0B08    C3            5627     	CLR	C
0B09    EB            5628     MOV A , R3 
0B0A    9408          5629     	SUBB	A, #08H
0B0C    4002          5630     	JC	($+4)
                      5631     
0B0E    1E            5632     DEC R6 
0B0F    1F            5633     DEC R7 
                      5634     
                      5635     CALC_NEXT_COMM_AVG_PERIOD_DIV: 
0B10    C3            5636     	CLR	C
0B11    ED            5637     MOV A , R5 
0B12    13            5638     	RRC	A					; Divide by 2
0B13    FD            5639     MOV R5 , A 
0B14    EC            5640     MOV A , R4 
0B15    13            5641     	RRC	A
0B16    FC            5642     MOV R4 , A 
0B17    DEF7          5643     DJNZ R6 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      5644     
0B19    C3            5645     	CLR	C
0B1A    EA            5646     MOV A , R2 
0B1B    9C            5647     SUBB A , R4 
0B1C    FA            5648     MOV R2 , A 
0B1D    EB            5649     MOV A , R3 
0B1E    9D            5650     SUBB A , R5 
0B1F    FB            5651     MOV R3 , A 
0B20    EF            5652     MOV A , R7 
0B21    6009          5653     	JZ	CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE
                      5654     
                      5655     CALC_NEXT_COMM_NEW_PERIOD_DIV: 
0B23    C3            5656     	CLR	C
0B24    E9            5657     MOV A , R1 
0B25    13            5658     	RRC	A					; Divide by 2
0B26    F9            5659     MOV R1 , A 
0B27    E8            5660     MOV A , R0 
0B28    13            5661     	RRC	A
0B29    F8            5662     MOV R0 , A 
0B2A    DFF7          5663     DJNZ R7 , CALC_NEXT_COMM_NEW_PERIOD_DIV 
                      5664     
                      5665     CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE: 
0B2C    EA            5666     MOV A , R2 
0B2D    28            5667     ADD A , R0 
0B2E    FA            5668     MOV R2 , A 
0B2F    EB            5669     MOV A , R3 
0B30    39            5670     ADDC A , R1 
0B31    FB            5671     MOV R3 , A 
0B32    8A3D          5672     MOV COMM_PERIOD4X_L , R2 
0B34    8B3E          5673     MOV COMM_PERIOD4X_H , R3 
0B36    5006          5674     	JNC	CALC_NEW_WAIT_TIMES_SETUP; If period larger than 0xffff - go to slow case
                      5675     
0B38    7BFF          5676     MOV R3 , # 0FFH 
0B3A    8B3D          5677     MOV COMM_PERIOD4X_L , R3 
0B3C    8B3E          5678     MOV COMM_PERIOD4X_H , R3 
                      5679     
                      5680     CALC_NEW_WAIT_TIMES_SETUP: 	
                      5681     	; Set high rpm bit (if above 156k erpm)
0B3E    C3            5682     	CLR	C
0B3F    EB            5683     MOV A , R3 
0B40    9402          5684     	SUBB	A, #2
0B42    5002          5685     	JNC	($+4)
                      5686     
0B44    D267          5687     SETB FLAGS0 . 7 
                      5688     	
                      5689     	; Load programmed commutation timing
0B46    306904        5690     JNB FLAGS1 . 1 , CALC_NEW_WAIT_PER_STARTUP_DONE 
                      5691     
0B49    7F03          5692     MOV R7 , # 3 
0B4B    6169          5693     	AJMP	CALC_NEW_WAIT_PER_DEMAG_DONE
                      5694     
                      5695     CALC_NEW_WAIT_PER_STARTUP_DONE: 
0B4D    7892          5696     MOV R0 , # PGM_COMM_TIMING 
0B4F    E6            5697     MOV A , @ R0 
0B50    FF            5698     MOV R7 , A 
0B51    C3            5699     	CLR	C
0B52    E536          5700     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0B54    9482          5701     	SUBB	A, #130
0B56    4011          5702     	JC	CALC_NEW_WAIT_PER_DEMAG_DONE
                      5703     
0B58    0F            5704     INC R7 
                      5705     
0B59    C3            5706     	CLR	C
0B5A    E536          5707     	MOV	A, DEMAG_DETECTED_METRIC
0B5C    94A0          5708     	SUBB	A, #160
0B5E    4001          5709     	JC	($+3)
                      5710     
0B60    0F            5711     INC R7 
                      5712     
0B61    C3            5713     	CLR	C
0B62    EF            5714     MOV A , R7 
0B63    9406          5715     	SUBB	A, #6
0B65    4002          5716     	JC	($+4)
                      5717     
0B67    7F05          5718     MOV R7 , # 5 
                      5719     
                      5720     CALC_NEW_WAIT_PER_DEMAG_DONE: 
                      5721     	; Set timing reduction
                      5722     IF MCU_48MHZ == 0
                               	MOV	TEMP7, #4
                               ELSE
0B69    7E01          5725     MOV R6 , # 1 
                      5726     ENDIF
                      5727     	; Load current commutation timing
0B6B    E53E          5728     	MOV	A, COMM_PERIOD4X_H		; Divide 4 times
0B6D    C4            5729     	SWAP	A
0B6E    540F          5730     	ANL	A, #00FH
0B70    F9            5731     MOV R1 , A 
0B71    E53E          5732     	MOV	A, COMM_PERIOD4X_H
0B73    C4            5733     	SWAP	A
0B74    54F0          5734     	ANL	A, #0F0H
0B76    F8            5735     MOV R0 , A 
0B77    E53D          5736     	MOV	A, COMM_PERIOD4X_L
0B79    C4            5737     	SWAP	A
0B7A    540F          5738     	ANL	A, #00FH
0B7C    28            5739     ADD A , R0 
0B7D    F8            5740     MOV R0 , A 
                      5741     
0B7E    C3            5742     	CLR	C
0B7F    E8            5743     MOV A , R0 
0B80    9E            5744     SUBB A , R6 
0B81    FA            5745     MOV R2 , A 
0B82    E9            5746     MOV A , R1 
0B83    9400          5747     	SUBB	A, #0
0B85    FB            5748     MOV R3 , A 
0B86    4009          5749     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      5750     
0B88    C3            5751     	CLR	C
0B89    EA            5752     MOV A , R2 
0B8A    9402          5753     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0B8C    EB            5754     MOV A , R3 
0B8D    9400          5755     	SUBB	A, #0
0B8F    5004          5756     	JNC	CALC_NEW_WAIT_TIMES_EXIT	; Check that result is still above minumum
                      5757     
                      5758     LOAD_MIN_TIME: 
0B91    7A02          5759     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0B93    E4            5760     	CLR	A
0B94    FB            5761     MOV R3 , A 
                      5762     
                      5763     CALC_NEW_WAIT_TIMES_EXIT: 	
0B95    22            5764     	RET
                      5765     
                      5766     
                      5767     ; Fast calculation (Comm_Period4x_H less than 2)
                      5768     CALC_NEXT_COMM_TIMING_FAST: 			
                      5769     	; Calculate new commutation time
0B96    AA3D          5770     MOV R2 , COMM_PERIOD4X_L 
0B98    AB3E          5771     MOV R3 , COMM_PERIOD4X_H 
0B9A    EB            5772     MOV A , R3 
0B9B    C4            5773     	SWAP	A
0B9C    FE            5774     MOV R6 , A 
0B9D    EA            5775     MOV A , R2 
0B9E    C4            5776     	SWAP A
0B9F    540F          5777     	ANL	A, #0FH
0BA1    4E            5778     ORL A , R6 
0BA2    FC            5779     MOV R4 , A 
0BA3    C3            5780     	CLR	C
0BA4    EA            5781     MOV A , R2 
0BA5    9C            5782     SUBB A , R4 
0BA6    FA            5783     MOV R2 , A 
0BA7    EB            5784     MOV A , R3 
0BA8    9400          5785     	SUBB	A, #0
0BAA    FB            5786     MOV R3 , A 
0BAB    C3            5787     	CLR	C
0BAC    E8            5788     MOV A , R0 
0BAD    13            5789     	RRC	A					; Divide by 2 2 times
0BAE    C3            5790     	CLR	C
0BAF    13            5791     	RRC	A
0BB0    F8            5792     MOV R0 , A 
0BB1    EA            5793     MOV A , R2 
0BB2    28            5794     ADD A , R0 
0BB3    FA            5795     MOV R2 , A 
0BB4    EB            5796     MOV A , R3 
0BB5    3400          5797     	ADDC	A, #0
0BB7    FB            5798     MOV R3 , A 
0BB8    8A3D          5799     MOV COMM_PERIOD4X_L , R2 
0BBA    8B3E          5800     MOV COMM_PERIOD4X_H , R3 
0BBC    C3            5801     	CLR	C
0BBD    EB            5802     MOV A , R3 
0BBE    9402          5803     	SUBB	A, #2
0BC0    4002          5804     	JC	($+4)
                      5805     
0BC2    C267          5806     CLR FLAGS0 . 7 
                      5807     	
                      5808     IF MCU_48MHZ == 0
                               	MOV	TEMP1, #4				; Set timing reduction
                               ELSE
0BC4    7801          5811     MOV R0 , # 1 
                      5812     ENDIF
0BC6    EB            5813     MOV A , R3 
0BC7    C4            5814     	SWAP	A
0BC8    FE            5815     MOV R6 , A 
0BC9    7B00          5816     MOV R3 , # 0 
0BCB    EA            5817     MOV A , R2 
0BCC    C4            5818     	SWAP A
0BCD    540F          5819     	ANL	A, #0FH
0BCF    4E            5820     ORL A , R6 
0BD0    FA            5821     MOV R2 , A 
0BD1    C3            5822     	CLR	C
0BD2    EA            5823     MOV A , R2 
0BD3    98            5824     SUBB A , R0 
0BD4    FA            5825     MOV R2 , A 
0BD5    4005          5826     	JC	LOAD_MIN_TIME_FAST		; Check that result is still positive
                      5827     
0BD7    C3            5828     	CLR	C
0BD8    9402          5829     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0BDA    5002          5830     	JNC	CALC_NEW_WAIT_TIMES_FAST_DONE	; Check that result is still above minumum
                      5831     
                      5832     LOAD_MIN_TIME_FAST: 
0BDC    7A02          5833     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
                      5834     
                      5835     CALC_NEW_WAIT_TIMES_FAST_DONE: 	
0BDE    7892          5836     MOV R0 , # PGM_COMM_TIMING 
0BE0    E6            5837     MOV A , @ R0 
0BE1    FF            5838     MOV R7 , A 
0BE2    22            5839     	RET
                      5840     
                      5841     
                      5842     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5843     ;
                      5844     ; Wait advance timing routine
                      5845     ;
                      5846     ; No assumptions
                      5847     ; NOTE: Be VERY careful if using temp registers. They are passed over this routine
                      5848     ;
                      5849     ; Waits for the advance timing to elapse and sets up the next zero cross wait
                      5850     ;
                      5851     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5852     WAIT_ADVANCE_TIMING: 	
0BE3    306002        5853     JNB FLAGS0 . 0 , ( $+5 ) 
0BE6    61E3          5854     	AJMP	WAIT_ADVANCE_TIMING
                      5855     
                      5856     	; Setup next wait time
0BE8    854F53        5857     	MOV	NEXT_WT_START_L, WT_ZC_TOUT_START_L
0BEB    855054        5858     	MOV	NEXT_WT_START_H, WT_ZC_TOUT_START_H
0BEE    D260          5859     SETB FLAGS0 . 0 
0BF0    43E680        5860     	ORL	EIE1, #80H	; Enable timer3 interrupts
0BF3    22            5861     	RET
                      5862     
                      5863     
                      5864     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5865     ;
                      5866     ; Calculate new wait times routine
                      5867     ;
                      5868     ; No assumptions
                      5869     ;
                      5870     ; Calculates new wait times
                      5871     ;
                      5872     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5873     CALC_NEW_WAIT_TIMES: 	
0BF4    C3            5874     	CLR	C
0BF5    E4            5875     	CLR	A
0BF6    9A            5876     SUBB A , R2 
0BF7    F8            5877     MOV R0 , A 
0BF8    E4            5878     	CLR	A
0BF9    9B            5879     SUBB A , R3 
0BFA    F9            5880     MOV R1 , A 
                      5881     IF MCU_48MHZ == 1
0BFB    C3            5882     	CLR	C
0BFC    E8            5883     MOV A , R0 
0BFD    33            5884     	RLC	A
0BFE    F8            5885     MOV R0 , A 
0BFF    E9            5886     MOV A , R1 
0C00    33            5887     	RLC	A
0C01    F9            5888     MOV R1 , A 
                      5889     ENDIF
0C02    306702        5890     JNB FLAGS0 . 7 , ( $+5 ) 
0C05    8183          5891     	AJMP	CALC_NEW_WAIT_TIMES_FAST
                      5892     
0C07    E8            5893     MOV A , R0 
0C08    FA            5894     MOV R2 , A 
0C09    E9            5895     MOV A , R1 
0C0A    FB            5896     MOV R3 , A 
0C0B    D3            5897     	SETB	C					; Negative numbers - set carry
0C0C    E9            5898     MOV A , R1 
0C0D    13            5899     	RRC	A					; Divide by 2
0C0E    FD            5900     MOV R5 , A 
0C0F    E8            5901     MOV A , R0 
0C10    13            5902     	RRC	A
0C11    FC            5903     MOV R4 , A 
0C12    884F          5904     MOV WT_ZC_TOUT_START_L , R0 
0C14    8950          5905     MOV WT_ZC_TOUT_START_H , R1 
0C16    C3            5906     	CLR	C
0C17    EF            5907     MOV A , R7 
0C18    9403          5908     	SUBB	A, #3				; Is timing normal?
0C1A    6037          5909     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      5910     
0C1C    EF            5911     MOV A , R7 
0C1D    20E00D        5912     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      5913     
0C20    E8            5914     MOV A , R0 
0C21    2C            5915     ADD A , R4 
0C22    F8            5916     MOV R0 , A 
0C23    E9            5917     MOV A , R1 
0C24    3D            5918     ADDC A , R5 
0C25    F9            5919     MOV R1 , A 
0C26    EC            5920     MOV A , R4 
0C27    FA            5921     MOV R2 , A 
0C28    ED            5922     MOV A , R5 
0C29    FB            5923     MOV R3 , A 
0C2A    020C40        5924     	JMP	STORE_TIMES_UP_OR_DOWN
                      5925     
                      5926     ADJUST_TIMING_TWO_STEPS: 
0C2D    E8            5927     MOV A , R0 
0C2E    28            5928     ADD A , R0 
0C2F    F8            5929     MOV R0 , A 
0C30    E9            5930     MOV A , R1 
0C31    39            5931     ADDC A , R1 
0C32    F9            5932     MOV R1 , A 
0C33    C3            5933     	CLR	C
0C34    E8            5934     MOV A , R0 
0C35    2402          5935     	ADD	A, #(COMM_TIME_MIN SHL 1)
0C37    F8            5936     MOV R0 , A 
0C38    E9            5937     MOV A , R1 
0C39    3400          5938     	ADDC	A, #0
0C3B    F9            5939     MOV R1 , A 
0C3C    7AFE          5940     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
0C3E    7BFF          5941     MOV R3 , # 0FFH 
                      5942     
                      5943     STORE_TIMES_UP_OR_DOWN: 
0C40    C3            5944     	CLR	C
0C41    EF            5945     MOV A , R7 
0C42    9403          5946     	SUBB	A, #3					; Is timing higher than normal?
0C44    400D          5947     	JC	STORE_TIMES_DECREASE		; No - branch
                      5948     
                      5949     STORE_TIMES_INCREASE: 
0C46    8A51          5950     MOV WT_COMM_START_L , R2 
0C48    8B52          5951     MOV WT_COMM_START_H , R3 
0C4A    884B          5952     MOV WT_ADV_START_L , R0 
0C4C    894C          5953     MOV WT_ADV_START_H , R1 
0C4E    8C4D          5954     MOV WT_ZC_SCAN_START_L , R4 
0C50    8D4E          5955     MOV WT_ZC_SCAN_START_H , R5 
0C52    22            5956     	RET
                      5957     
                      5958     STORE_TIMES_DECREASE: 
0C53    8851          5959     MOV WT_COMM_START_L , R0 
0C55    8952          5960     MOV WT_COMM_START_H , R1 
0C57    8A4B          5961     MOV WT_ADV_START_L , R2 
0C59    8B4C          5962     MOV WT_ADV_START_H , R3 
0C5B    8C4D          5963     MOV WT_ZC_SCAN_START_L , R4 
0C5D    8D4E          5964     MOV WT_ZC_SCAN_START_H , R5 
0C5F    306920        5965     JNB FLAGS1 . 1 , STORE_TIMES_EXIT 
                      5966     
0C62    C3            5967     	CLR	C
0C63    E533          5968     	MOV	A, STARTUP_CNT			
0C65    9403          5969     	SUBB	A, #3
0C67    4019          5970     	JC	STORE_TIMES_EXIT
                      5971     
0C69    E53F          5972     	MOV	A, COMM_DIFF			; Compensate commutation wait for comparator offset
0C6B    A2E7          5973     	MOV	C, ACC.7
0C6D    13            5974     	RRC	A
0C6E    F8            5975     MOV R0 , A 
0C6F    E552          5976     	MOV	A, WT_COMM_START_H
0C71    F4            5977     	CPL	A
0C72    2401          5978     	ADD	A, #1
0C74    38            5979     ADDC A , R0 
0C75    400B          5980     	JC	STORE_TIMES_EXIT
0C77    20E708        5981     	JB	ACC.7, STORE_TIMES_EXIT
                      5982     
0C7A    7551FF        5983     	MOV	WT_COMM_START_L, #0FFH
0C7D    F4            5984     	CPL	A
0C7E    2401          5985     	ADD	A, #1
0C80    F552          5986     	MOV	WT_COMM_START_H, A 
                      5987     
                      5988     STORE_TIMES_EXIT: 
0C82    22            5989     	RET
                      5990     
                      5991     
                      5992     CALC_NEW_WAIT_TIMES_FAST: 	
0C83    E8            5993     MOV A , R0 
0C84    FA            5994     MOV R2 , A 
0C85    D3            5995     	SETB	C					; Negative numbers - set carry
0C86    E8            5996     MOV A , R0 
0C87    13            5997     	RRC	A
0C88    FC            5998     MOV R4 , A 
0C89    884F          5999     MOV WT_ZC_TOUT_START_L , R0 
0C8B    C3            6000     	CLR	C
0C8C    EF            6001     MOV A , R7 
0C8D    9403          6002     	SUBB	A, #3				; Is timing normal?
0C8F    601F          6003     	JZ	STORE_TIMES_DECREASE_FAST; Yes - branch
                      6004     
0C91    EF            6005     MOV A , R7 
0C92    20E007        6006     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS_FAST	; If an odd number - branch
                      6007     
0C95    E8            6008     MOV A , R0 
0C96    2C            6009     ADD A , R4 
0C97    F8            6010     MOV R0 , A 
0C98    EC            6011     MOV A , R4 
0C99    FA            6012     MOV R2 , A 
0C9A    81A3          6013     	AJMP	STORE_TIMES_UP_OR_DOWN_FAST
                      6014     
                      6015     ADJUST_TIMING_TWO_STEPS_FAST: 
0C9C    E8            6016     MOV A , R0 
0C9D    28            6017     ADD A , R0 
0C9E    2402          6018     	ADD	A, #(COMM_TIME_MIN SHL 1)
0CA0    F8            6019     MOV R0 , A 
0CA1    7AFE          6020     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
                      6021     
                      6022     STORE_TIMES_UP_OR_DOWN_FAST: 
0CA3    C3            6023     	CLR	C
0CA4    EF            6024     MOV A , R7 
0CA5    9403          6025     	SUBB	A, #3				; Is timing higher than normal?
0CA7    4007          6026     	JC	STORE_TIMES_DECREASE_FAST; No - branch
                      6027     
                      6028     STORE_TIMES_INCREASE_FAST: 
0CA9    8A51          6029     MOV WT_COMM_START_L , R2 
0CAB    884B          6030     MOV WT_ADV_START_L , R0 
0CAD    8C4D          6031     MOV WT_ZC_SCAN_START_L , R4 
0CAF    22            6032     	RET
                      6033     
                      6034     STORE_TIMES_DECREASE_FAST: 
0CB0    8851          6035     MOV WT_COMM_START_L , R0 
0CB2    8A4B          6036     MOV WT_ADV_START_L , R2 
0CB4    8C4D          6037     MOV WT_ZC_SCAN_START_L , R4 
0CB6    22            6038     	RET
                      6039     
                      6040     
                      6041     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6042     ;
                      6043     ; Wait before zero cross scan routine
                      6044     ;
                      6045     ; No assumptions
                      6046     ;
                      6047     ; Waits for the zero cross scan wait time to elapse
                      6048     ; Also sets up timer 3 for the zero cross scan timeout time
                      6049     ;
                      6050     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6051     WAIT_BEFORE_ZC_SCAN: 	
                      6052     	; Calculate random number
0CB7    E568          6053     	MOV	A, RANDOM
0CB9    C3            6054     	CLR	C
0CBA    33            6055     	RLC	A
0CBB    5002          6056     	JNC	WAIT_BEFORE_ZC_SCAN_RAND
                      6057     
0CBD    646B          6058     	XRL	A, #06BH		; Sequence length of 35, when initialized to 1
                      6059     
                      6060     WAIT_BEFORE_ZC_SCAN_RAND:           
0CBF    F568          6061     	MOV	RANDOM, A
                      6062     
                      6063     WAIT_BEFORE_ZC_SCAN_WAIT:           
0CC1    306002        6064     JNB FLAGS0 . 0 , ( $+5 ) 
0CC4    81C1          6065     	AJMP	WAIT_BEFORE_ZC_SCAN_WAIT
                      6066     
0CC6    D260          6067     SETB FLAGS0 . 0 
0CC8    43E680        6068     	ORL	EIE1, #80H			; Enable timer3 interrupts
0CCB    E52D          6069     	MOV	A, FLAGS1
0CCD    5406          6070     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0CCF    6029          6071     	JZ	WAIT_BEFORE_ZC_SCAN_EXIT		
                      6072     
0CD1    A83D          6073     MOV R0 , COMM_PERIOD4X_L 
0CD3    A93E          6074     MOV R1 , COMM_PERIOD4X_H 
0CD5    C3            6075     	CLR	C
0CD6    E9            6076     MOV A , R1 
0CD7    13            6077     	RRC	A
0CD8    F9            6078     MOV R1 , A 
0CD9    E8            6079     MOV A , R0 
0CDA    13            6080     	RRC	A
0CDB    F8            6081     MOV R0 , A 
                      6082     IF MCU_48MHZ == 1
0CDC    C3            6083     	CLR	C
0CDD    E8            6084     MOV A , R0 
0CDE    33            6085     	RLC	A
0CDF    F8            6086     MOV R0 , A 
0CE0    E9            6087     MOV A , R1 
0CE1    33            6088     	RLC	A
0CE2    F9            6089     MOV R1 , A 
                      6090     ENDIF
0CE3    53E67F        6091     	ANL	EIE1, #7FH			; Disable timer3 interrupts
0CE6    759100        6092     	MOV	TMR3CN, #00H			; Timer3 disabled and interrupt flag cleared
0CE9    C3            6093     	CLR	C
0CEA    E4            6094     	CLR	A
0CEB    98            6095     SUBB A , R0 
0CEC    F594          6096     	MOV	TMR3L, A
0CEE    E4            6097     	CLR	A
0CEF    99            6098     SUBB A , R1 
0CF0    F595          6099     	MOV	TMR3H, A
0CF2    759104        6100     	MOV	TMR3CN, #04H			; Timer3 enabled and interrupt flag cleared
                      6101     
0CF5    D260          6102     SETB FLAGS0 . 0 
0CF7    43E680        6103     	ORL	EIE1, #80H			; Enable timer3 interrupts
                      6104     
                      6105     WAIT_BEFORE_ZC_SCAN_EXIT:           
0CFA    22            6106     	RET
                      6107     
                      6108     
                      6109     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6110     ;
                      6111     ; Wait for comparator to go low/high routines
                      6112     ;
                      6113     ; No assumptions
                      6114     ;
                      6115     ; Waits for the zero cross scan wait time to elapse
                      6116     ; Then scans for comparator going low/high
                      6117     ;
                      6118     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6119     WAIT_FOR_COMP_OUT_LOW: 
0CFB    D265          6120     SETB FLAGS0 . 5 
0CFD    754100        6121     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0D00    752000        6122     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0D03    306B03        6123     JNB FLAGS1 . 3 , ( $+6 ) 
0D06    752040        6124     	MOV	BIT_ACCESS, #40H		
0D09    020D1A        6125     	JMP	WAIT_FOR_COMP_OUT_START
                      6126     
                      6127     WAIT_FOR_COMP_OUT_HIGH: 
0D0C    D265          6128     SETB FLAGS0 . 5 
0D0E    754100        6129     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0D11    752040        6130     	MOV	BIT_ACCESS, #40H			; Desired comparator output
0D14    306B03        6131     JNB FLAGS1 . 3 , ( $+6 ) 
0D17    752000        6132     	MOV	BIT_ACCESS, #00H		
                      6133     
                      6134     WAIT_FOR_COMP_OUT_START: 
0D1A    D2AF          6135     	SETB	EA						; Enable interrupts
                      6136     	; Set number of comparator readings
0D1C    7801          6137     MOV R0 , # 1 
0D1E    206722        6138     JB FLAGS0 . 7 , COMP_WAIT_ON_COMP_ABLE 
                      6139     
0D21    E52D          6140     	MOV	A, FLAGS1					; Clear demag detected flag if start phases
0D23    5406          6141     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0D25    6002          6142     	JZ	($+4)
                      6143     		
0D27    C265          6144     CLR FLAGS0 . 5 
                      6145     
0D29    C3            6146     	CLR	C						; Set number of readings higher for lower speeds
0D2A    E53E          6147     	MOV 	A, COMM_PERIOD4X_H			
0D2C    9405          6148     	SUBB	A, #05H
0D2E    4013          6149     	JC	COMP_WAIT_ON_COMP_ABLE
                      6150     
0D30    7802          6151     MOV R0 , # 2 
                      6152     
0D32    9405          6153     	SUBB	A, #05H
0D34    4008          6154     	JC	COMP_WAIT_NO_OF_READINGS
                      6155     
0D36    7803          6156     MOV R0 , # 3 
                      6157     
0D38    9405          6158     	SUBB	A, #05H					; Set number of consecutive readings higher for lower speeds
0D3A    4002          6159     	JC	COMP_WAIT_NO_OF_READINGS
                      6160     
0D3C    7806          6161     MOV R0 , # 6 
                      6162     
                      6163     COMP_WAIT_NO_OF_READINGS: 
0D3E    306902        6164     JNB FLAGS1 . 1 , ( $+5 ) 
0D41    780A          6165     MOV R0 , # 10 
                      6166     
                      6167     COMP_WAIT_ON_COMP_ABLE: 
0D43    206009        6168     JB FLAGS0 . 0 , COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT 
                      6169     
0D46    E541          6170     	MOV	A, COMPARATOR_READ_CNT			; Check that comparator has been read
0D48    6005          6171     	JZ	COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT	; If not read - branch
                      6172     
0D4A    D2AF          6173     	SETB	EA							; Enable interrupts
0D4C    D26C          6174     SETB FLAGS1 . 4 
0D4E    22            6175     	RET								; Yes - return
                      6176     
                      6177     
                      6178     COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT: 
0D4F    D2AF          6179     	SETB	EA							; Enable interrupts
0D51    00            6180     	NOP								; Allocate only just enough time to capture interrupt
0D52    00            6181     	NOP
0D53    C2AF          6182     	CLR	EA							; Disable interrupts
0D55    20672A        6183     JB FLAGS0 . 7 , COMP_WAIT_READ_COMP 
                      6184     
0D58    E53E          6185     	MOV	A, COMM_PERIOD4X_H				; Reduce required distance to pwm transition for higher speeds
0D5A    C3            6186     	CLR	C
0D5B    FB            6187     MOV R3 , A 
0D5C    940F          6188     	SUBB	A, #0FH
0D5E    4002          6189     	JC	($+4)
                      6190     
0D60    7B0F          6191     MOV R3 , # 0FH 
                      6192     
0D62    EB            6193     MOV A , R3 
0D63    2405          6194     	ADD	A, #5
0D65    307301        6195     JNB FLAGS2 . 3 , ( $+4 ) 
                      6196     
0D68    23            6197     	RL	A
                      6198     
0D69    306A02        6199     JNB FLAGS1 . 2 , ( $+5 ) 
0D6C    7428          6200     	MOV	A, #40
                      6201     
0D6E    206201        6202     JB FLAGS0 . 2 , ( $+4 ) 
                      6203     
0D71    23            6204     	RL	A
                      6205     
0D72    F9            6206     MOV R1 , A 
0D73    306902        6207     JNB FLAGS1 . 1 , ( $+5 ) 
0D76    7982          6208     MOV R1 , # 130 
                      6209     
                      6210     IF MCU_48MHZ == 0
                               	MOV	A, TL1
                               ELSE
0D78    E58D          6213     	MOV	A, TH1
0D7A    13            6214     	RRC	A
0D7B    E58B          6215     	MOV	A, TL1
0D7D    13            6216     	RRC	A
                      6217     ENDIF
0D7E    C3            6218     	CLR	C
0D7F    99            6219     SUBB A , R1 
0D80    40C1          6220     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle
                      6221     
                      6222     COMP_WAIT_READ_COMP: 
0D82    0541          6223     	INC	COMPARATOR_READ_CNT			; Increment comparator read count
                      6224     	READ_COMP_OUT					; Read comparator output
0D84    E59B          6224+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0D86    F4            6224+1   CPL A 
0D87    5440          6225     	ANL	A, #40H
0D89    B52002        6226     	CJNE	A, BIT_ACCESS, COMP_READ_WRONG
0D8C    A1DB          6227     	AJMP	COMP_READ_OK
                      6228     	
                      6229     COMP_READ_WRONG: 
0D8E    306914        6230     JNB FLAGS1 . 1 , COMP_READ_WRONG_NOT_STARTUP 
                      6231     
0D91    08            6232     INC R0 
0D92    C3            6233     	CLR	C
0D93    E8            6234     MOV A , R0 
0D94    940A          6235     	SUBB	A, #10					; If above initial requirement - go back and restart
0D96    4002          6236     	JC	($+4)
0D98    A11A          6237     	AJMP	WAIT_FOR_COMP_OUT_START
                      6238     
0D9A    C3            6239     	CLR	C
0D9B    E533          6240     	MOV	A, STARTUP_CNT				; For the first commutations - go back and restart
0D9D    9406          6241     	SUBB	A, #6
0D9F    5002          6242     	JNC	($+4)
0DA1    A11A          6243     	AJMP	WAIT_FOR_COMP_OUT_START
                      6244     
0DA3    A143          6245     	AJMP	COMP_WAIT_ON_COMP_ABLE		; If below initial requirement - continue to look for good ones
                      6246     
                      6247     COMP_READ_WRONG_NOT_STARTUP: 
0DA5    206502        6248     JB FLAGS0 . 5 , ( $+5 ) 
0DA8    A11A          6249     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct, and timeout already extended - go back and restart
                      6250     
0DAA    C265          6251     CLR FLAGS0 . 5 
0DAC    53E67F        6252     	ANL	EIE1, #7FH				; Disable timer3 interrupts
0DAF    759100        6253     	MOV	TMR3CN, #00H				; Timer3 disabled and interrupt flag cleared
0DB2    306710        6254     JNB FLAGS0 . 7 , COMP_READ_WRONG_LOW_RPM 
                      6255     
0DB5    759400        6256     	MOV	TMR3L, #00H				; Set timeout to 256us
                      6257     IF MCU_48MHZ == 1
0DB8    7595FC        6258     	MOV	TMR3H, #0FCH
                      6259     ELSE
                               	MOV	TMR3H, #0FEH
                               ENDIF
                      6262     COMP_READ_WRONG_TIMEOUT_SET: 
0DBB    759104        6263     	MOV	TMR3CN, #04H				; Timer3 enabled and interrupt flag cleared
0DBE    D260          6264     SETB FLAGS0 . 0 
0DC0    43E680        6265     	ORL	EIE1, #80H				; Enable timer3 interrupts
0DC3    A11A          6266     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      6267     
                      6268     COMP_READ_WRONG_LOW_RPM: 
0DC5    AE3D          6269     MOV R6 , COMM_PERIOD4X_L 
0DC7    AF3E          6270     MOV R7 , COMM_PERIOD4X_H 
                      6271     IF MCU_48MHZ == 1
0DC9    C3            6272     	CLR	C
0DCA    EE            6273     MOV A , R6 
0DCB    33            6274     	RLC	A
0DCC    FE            6275     MOV R6 , A 
0DCD    EF            6276     MOV A , R7 
0DCE    33            6277     	RLC	A
0DCF    FF            6278     MOV R7 , A 
                      6279     ENDIF
0DD0    C3            6280     	CLR	C
0DD1    E4            6281     	CLR	A
0DD2    9E            6282     SUBB A , R6 
0DD3    F594          6283     	MOV	TMR3L, A
0DD5    E4            6284     	CLR	A
0DD6    9F            6285     SUBB A , R7 
0DD7    F595          6286     	MOV	TMR3H, A
0DD9    A1BB          6287     	AJMP	COMP_READ_WRONG_TIMEOUT_SET
                      6288     
                      6289     COMP_READ_OK: 
0DDB    C3            6290     	CLR	C
0DDC    E533          6291     	MOV	A, STARTUP_CNT				; Force a timeout for the first commutations			
0DDE    9402          6292     	SUBB	A, #2
0DE0    5002          6293     	JNC	($+4)
0DE2    A11A          6294     	AJMP	WAIT_FOR_COMP_OUT_START
                      6295     
0DE4    306502        6296     JNB FLAGS0 . 5 , ( $+5 ) 
0DE7    A11A          6297     	AJMP	WAIT_FOR_COMP_OUT_START
                      6298     
0DE9    D802          6299     DJNZ R0 , COMP_READ_OK_JMP 
0DEB    A1EF          6300     	AJMP	($+4)
                      6301     
                      6302     COMP_READ_OK_JMP: 
0DED    A143          6303     	AJMP	COMP_WAIT_ON_COMP_ABLE	
                      6304     
0DEF    C26C          6305     CLR FLAGS1 . 4 
0DF1    22            6306     	RET							
                      6307     
                      6308     
                      6309     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6310     ;
                      6311     ; Evaluate comparator integrity
                      6312     ;
                      6313     ; No assumptions
                      6314     ;
                      6315     ; Checks comparator signal behaviour versus expected behaviour
                      6316     ;
                      6317     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6318     EVALUATE_COMPARATOR_INTEGRITY: 
0DF2    E52D          6319     	MOV	A, FLAGS1
0DF4    5406          6320     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0DF6    6008          6321     	JZ	EVAL_COMP_CHECK_TIMEOUT
                      6322     
0DF8    206A02        6323     JB FLAGS1 . 2 , ( $+5 ) 
0DFB    0533          6324     	INC	STARTUP_CNT					; Increment counter
0DFD    020E10        6325     	JMP	EVAL_COMP_EXIT
                      6326     
                      6327     EVAL_COMP_CHECK_TIMEOUT: 
0E00    306C0D        6328     JNB FLAGS1 . 4 , EVAL_COMP_EXIT 
0E03    206B0A        6329     JB FLAGS1 . 3 , EVAL_COMP_EXIT 
0E06    206507        6330     JB FLAGS0 . 5 , EVAL_COMP_EXIT 
0E09    1581          6331     	DEC	SP								; Routine exit without "ret" command
0E0B    1581          6332     	DEC	SP
0E0D    0216F0        6333     	LJMP	RUN_TO_WAIT_FOR_POWER_ON_FAIL			; Yes - exit run mode
                      6334     
                      6335     EVAL_COMP_EXIT: 
0E10    22            6336     	RET
                      6337     
                      6338     
                      6339     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6340     ;
                      6341     ; Setup commutation timing routine
                      6342     ;
                      6343     ; No assumptions
                      6344     ;
                      6345     ; Sets up and starts wait from commutation to zero cross
                      6346     ;
                      6347     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6348     SETUP_COMM_WAIT:  
0E11    53E67F        6349     	ANL	EIE1, #7FH		; Disable timer3 interrupts
0E14    759100        6350     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
0E17    855194        6351     	MOV	TMR3L, WT_COMM_START_L
0E1A    855295        6352     	MOV	TMR3H, WT_COMM_START_H
0E1D    759104        6353     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
                      6354     	; Setup next wait time
0E20    854B53        6355     	MOV	NEXT_WT_START_L, WT_ADV_START_L
0E23    854C54        6356     	MOV	NEXT_WT_START_H, WT_ADV_START_H
0E26    D260          6357     SETB FLAGS0 . 0 
0E28    43E680        6358     	ORL	EIE1, #80H		; Enable timer3 interrupts
0E2B    D2AF          6359     	SETB	EA				; Enable interrupts again
0E2D    22            6360     	RET
                      6361     
                      6362     
                      6363     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6364     ;
                      6365     ; Wait for commutation routine
                      6366     ;
                      6367     ; No assumptions
                      6368     ;
                      6369     ; Waits from zero cross to commutation 
                      6370     ;
                      6371     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6372     WAIT_FOR_COMM:  
                      6373     	; Update demag metric
0E2E    7800          6374     MOV R0 , # 0 
0E30    306405        6375     JNB FLAGS0 . 4 , ( $+8 ) 
0E33    306502        6376     JNB FLAGS0 . 5 , ( $+5 ) 
                      6377     
0E36    7801          6378     MOV R0 , # 1 
                      6379     
0E38    E536          6380     	MOV	A, DEMAG_DETECTED_METRIC	; Sliding average of 8, 256 when demag and 0 when not. Limited to minimum 120
0E3A    75F007        6381     	MOV	B, #7
0E3D    A4            6382     	MUL	AB					; Multiply by 7
0E3E    F9            6383     MOV R1 , A 
0E3F    E5F0          6384     	MOV	A, B					; Add new value for current demag status
0E41    28            6385     ADD A , R0 
0E42    F5F0          6386     	MOV	B, A
0E44    E9            6387     MOV A , R1 
0E45    A2F0          6388     	MOV	C, B.0				; Divide by 8
0E47    13            6389     	RRC	A					
0E48    A2F1          6390     	MOV	C, B.1
0E4A    13            6391     	RRC	A
0E4B    A2F2          6392     	MOV	C, B.2
0E4D    13            6393     	RRC	A
0E4E    F536          6394     	MOV	DEMAG_DETECTED_METRIC, A
0E50    C3            6395     	CLR	C
0E51    9478          6396     	SUBB	A, #120				; Limit to minimum 120
0E53    5003          6397     	JNC	($+5)
                      6398     
0E55    753678        6399     	MOV	DEMAG_DETECTED_METRIC, #120
                      6400     
0E58    C3            6401     	CLR	C
0E59    E536          6402     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0E5B    9537          6403     	SUBB	A, DEMAG_PWR_OFF_THRESH
0E5D    4008          6404     	JC	WAIT_FOR_COMM_WAIT		; Cut power if many consecutive demags. This will help retain sync during hard accelerations
                      6405     
0E5F    D266          6406     SETB FLAGS0 . 6 
                      6407     	ALL_NFETS_OFF
0E61    C293          6407+1   CLR P1 . 3 
0E63    C297          6407+1   CLR P1 . 7 
0E65    C294          6407+1   CLR P1 . 4 
                      6408     
                      6409     WAIT_FOR_COMM_WAIT: 
0E67    306002        6410     JNB FLAGS0 . 0 , ( $+5 ) 
0E6A    C167          6411     	AJMP	WAIT_FOR_COMM_WAIT					
                      6412     
                      6413     	; Setup next wait time
0E6C    854D53        6414     	MOV	NEXT_WT_START_L, WT_ZC_SCAN_START_L
0E6F    854E54        6415     	MOV	NEXT_WT_START_H, WT_ZC_SCAN_START_H
0E72    D260          6416     SETB FLAGS0 . 0 
0E74    43E680        6417     	ORL	EIE1, #80H			; Enable timer3 interrupts
0E77    22            6418     	RET
                      6419     
                      6420     
                      6421     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6422     ;
                      6423     ; Commutation routines
                      6424     ;
                      6425     ; No assumptions
                      6426     ;
                      6427     ; Performs commutation switching 
                      6428     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      6429     ;
                      6430     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6431     ; Comm phase 1 to comm phase 2
                      6432     COMM1COMM2: 	
                      6433     	SET_RPM_OUT
0E78    207D11        6434     JB FLAGS3 . 5 , COMM12_REV 
                      6435     
0E7B    C2AF          6436     	CLR 	EA					; Disable all interrupts
0E7D    754002        6437     	MOV	COMM_PHASE, #2
                      6438     	BPFET_OFF 				; Turn off pfet
0E80    C295          6438+1   CLR P1 . 5 
                      6439     	APFET_ON					; Turn on pfet
0E82    D292          6439+1   SETB P1 . 2 
0E84    D2AF          6440     	SETB	EA
                      6441     	SET_COMP_PHASE_B 			; Set comparator phase
0E86    759F80        6441+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E89    021047        6442     	JMP	COMM_EXIT
                      6443     
                      6444     COMM12_REV: 	
0E8C    C2AF          6445     	CLR 	EA					; Disable all interrupts
0E8E    754002        6446     	MOV	COMM_PHASE, #2
                      6447     	BPFET_OFF 				; Turn off pfet
0E91    C295          6447+1   CLR P1 . 5 
                      6448     	CPFET_ON					; Turn on pfet (reverse)
0E93    D296          6448+1   SETB P1 . 6 
0E95    D2AF          6449     	SETB	EA
                      6450     	SET_COMP_PHASE_B 			; Set comparator phase
0E97    759F80        6450+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E9A    021047        6451     	JMP	COMM_EXIT
                      6452     
                      6453     
                      6454     ; Comm phase 2 to comm phase 3
                      6455     COMM2COMM3: 	
                      6456     	CLEAR_RPM_OUT
0E9D    307243        6457     JNB FLAGS2 . 2 , COMM23_NONDAMP 
                      6458     
                      6459     	; Comm2Comm3 Damped
0EA0    207D20        6460     JB FLAGS3 . 5 , COMM23_DAMP_REV 
                      6461     
0EA3    C2AF          6462     	CLR 	EA					; Disable all interrupts
0EA5    754003        6463     	MOV	COMM_PHASE, #3
0EA8    90018B        6464     	MOV	DPTR, #PWM_BFET_DAMPED	
0EAB    757B20        6465     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6466     	CNFET_OFF					; Turn off fets
0EAE    C297          6466+1   CLR P1 . 7 
                      6467     	CPFET_OFF						
0EB0    C296          6467+1   CLR P1 . 6 
0EB2    306204        6468     JNB FLAGS0 . 2 , COMM23_NFET_OFF 
                      6469     	BNFET_ON					; Pwm on - turn on nfet
0EB5    D294          6469+1   SETB P1 . 4 
0EB7    C1BB          6470     	AJMP	COMM23_FETS_DONE
                      6471     COMM23_NFET_OFF: 
                      6472     	BPFET_ON					; Pwm off - switch damping fets	
0EB9    D295          6472+1   SETB P1 . 5 
                      6473     COMM23_FETS_DONE: 
0EBB    D2AF          6474     	SETB	EA
                      6475     	SET_COMP_PHASE_C 			; Set comparator phase
0EBD    759F89        6475+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0EC0    021047        6476     	LJMP	COMM_EXIT
                      6477     
                      6478     	; Comm2Comm3 Damped reverse
                      6479     COMM23_DAMP_REV: 
0EC3    C2AF          6480     	CLR 	EA					; Disable all interrupts
0EC5    754003        6481     	MOV	COMM_PHASE, #3
0EC8    90018B        6482     	MOV	DPTR, #PWM_BFET_DAMPED	
0ECB    757B20        6483     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6484     	ANFET_OFF					; Turn off fets (reverse)
0ECE    C293          6484+1   CLR P1 . 3 
                      6485     	APFET_OFF						
0ED0    C292          6485+1   CLR P1 . 2 
0ED2    306204        6486     JNB FLAGS0 . 2 , COMM23_NFET_OFF_REV 
                      6487     	BNFET_ON					; Pwm on - turn on nfet
0ED5    D294          6487+1   SETB P1 . 4 
0ED7    C1DB          6488     	AJMP	COMM23_FETS_DONE_REV
                      6489     COMM23_NFET_OFF_REV: 
                      6490     	BPFET_ON					; Pwm off - switch damping fets	
0ED9    D295          6490+1   SETB P1 . 5 
                      6491     COMM23_FETS_DONE_REV: 
0EDB    D2AF          6492     	SETB	EA
                      6493     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0EDD    759F81        6493+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0EE0    021047        6494     	LJMP	COMM_EXIT
                      6495     
                      6496     	; Comm2Comm3 Non-damped
                      6497     COMM23_NONDAMP: 
0EE3    207D17        6498     JB FLAGS3 . 5 , COMM23_NONDAMP_REV 
                      6499     
0EE6    C2AF          6500     	CLR 	EA					; Disable all interrupts
0EE8    754003        6501     	MOV	COMM_PHASE, #3
0EEB    900166        6502     	MOV	DPTR, #PWM_BFET	
                      6503     	CNFET_OFF					; Turn off nfet
0EEE    C297          6503+1   CLR P1 . 7 
0EF0    306202        6504     JNB FLAGS0 . 2 , COMM23_NFET_DONE 
                      6505     	BNFET_ON					; Yes - turn on nfet
0EF3    D294          6505+1   SETB P1 . 4 
                      6506     COMM23_NFET_DONE: 
0EF5    D2AF          6507     	SETB	EA
                      6508     	SET_COMP_PHASE_C 			; Set comparator phase
0EF7    759F89        6508+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0EFA    021047        6509     	LJMP	COMM_EXIT
                      6510     
                      6511     	; Comm2Comm3 Non-damped reverse
                      6512     COMM23_NONDAMP_REV: 
0EFD    C2AF          6513     	CLR 	EA					; Disable all interrupts
0EFF    754003        6514     	MOV	COMM_PHASE, #3
0F02    900166        6515     	MOV	DPTR, #PWM_BFET	
                      6516     	ANFET_OFF					; Turn off nfet (reverse)
0F05    C293          6516+1   CLR P1 . 3 
0F07    306202        6517     JNB FLAGS0 . 2 , COMM23_NFET_DONE_REV 
                      6518     	BNFET_ON					; Yes - turn on nfet
0F0A    D294          6518+1   SETB P1 . 4 
                      6519     COMM23_NFET_DONE_REV: 
0F0C    D2AF          6520     	SETB	EA
                      6521     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0F0E    759F81        6521+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F11    021047        6522     	LJMP	COMM_EXIT
                      6523     
                      6524     
                      6525     ; Comm phase 3 to comm phase 4
                      6526     COMM3COMM4: 	
                      6527     	SET_RPM_OUT
0F14    207D11        6528     JB FLAGS3 . 5 , COMM34_REV 
                      6529     
0F17    C2AF          6530     	CLR 	EA					; Disable all interrupts
0F19    754004        6531     	MOV	COMM_PHASE, #4
                      6532     	APFET_OFF 				; Turn off pfet
0F1C    C292          6532+1   CLR P1 . 2 
                      6533     	CPFET_ON					; Turn on pfet
0F1E    D296          6533+1   SETB P1 . 6 
0F20    D2AF          6534     	SETB	EA
                      6535     	SET_COMP_PHASE_A 			; Set comparator phase
0F22    759F81        6535+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F25    021047        6536     	JMP	COMM_EXIT
                      6537     
                      6538     COMM34_REV: 	
0F28    C2AF          6539     	CLR 	EA					; Disable all interrupts
0F2A    754004        6540     	MOV	COMM_PHASE, #4
                      6541     	CPFET_OFF 				; Turn off pfet (reverse)
0F2D    C296          6541+1   CLR P1 . 6 
                      6542     	APFET_ON					; Turn on pfet (reverse)
0F2F    D292          6542+1   SETB P1 . 2 
0F31    D2AF          6543     	SETB	EA
                      6544     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0F33    759F89        6544+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F36    021047        6545     	JMP	COMM_EXIT
                      6546     
                      6547     
                      6548     ; Comm phase 4 to comm phase 5
                      6549     COMM4COMM5: 	
                      6550     	CLEAR_RPM_OUT
0F39    307243        6551     JNB FLAGS2 . 2 , COMM45_NONDAMP 
                      6552     
                      6553     	; Comm4Comm5 Damped
0F3C    207D20        6554     JB FLAGS3 . 5 , COMM45_DAMP_REV 
                      6555     
0F3F    C2AF          6556     	CLR 	EA					; Disable all interrupts
0F41    754005        6557     	MOV	COMM_PHASE, #5
0F44    90017A        6558     	MOV	DPTR, #PWM_AFET_DAMPED	
0F47    757B04        6559     	MOV	DAMPINGFET, #(1 SHL APFET)
                      6560     	BNFET_OFF					; Turn off fets
0F4A    C294          6560+1   CLR P1 . 4 
                      6561     	BPFET_OFF						
0F4C    C295          6561+1   CLR P1 . 5 
0F4E    306204        6562     JNB FLAGS0 . 2 , COMM45_NFET_OFF 
                      6563     	ANFET_ON					; Pwm on - turn on nfet
0F51    D293          6563+1   SETB P1 . 3 
0F53    E157          6564     	AJMP	COMM45_FETS_DONE
                      6565     COMM45_NFET_OFF: 
                      6566     	APFET_ON					; Pwm off - switch damping fets	
0F55    D292          6566+1   SETB P1 . 2 
                      6567     COMM45_FETS_DONE: 
0F57    D2AF          6568     	SETB	EA
                      6569     	SET_COMP_PHASE_B 			; Set comparator phase
0F59    759F80        6569+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F5C    021047        6570     	LJMP	COMM_EXIT
                      6571     
                      6572     	; Comm4Comm5 Damped reverse
                      6573     COMM45_DAMP_REV: 
0F5F    C2AF          6574     	CLR 	EA					; Disable all interrupts
0F61    754005        6575     	MOV	COMM_PHASE, #5
0F64    90019C        6576     	MOV	DPTR, #PWM_CFET_DAMPED	; (reverse)
0F67    757B40        6577     	MOV	DAMPINGFET, #(1 SHL CPFET)	; (reverse)
                      6578     	BNFET_OFF					; Turn off fets
0F6A    C294          6578+1   CLR P1 . 4 
                      6579     	BPFET_OFF						
0F6C    C295          6579+1   CLR P1 . 5 
0F6E    306204        6580     JNB FLAGS0 . 2 , COMM45_NFET_OFF_REV 
                      6581     	CNFET_ON					; Pwm on - turn on nfet (reverse)
0F71    D297          6581+1   SETB P1 . 7 
0F73    E177          6582     	AJMP	COMM45_FETS_DONE_REV
                      6583     COMM45_NFET_OFF_REV: 
                      6584     	CPFET_ON					; Pwm off - switch damping fets (reverse)	
0F75    D296          6584+1   SETB P1 . 6 
                      6585     COMM45_FETS_DONE_REV: 
0F77    D2AF          6586     	SETB	EA
                      6587     	SET_COMP_PHASE_B 			; Set comparator phase
0F79    759F80        6587+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F7C    021047        6588     	LJMP	COMM_EXIT
                      6589     
                      6590     	; Comm4Comm5 Non-damped
                      6591     COMM45_NONDAMP: 
0F7F    207D17        6592     JB FLAGS3 . 5 , COMM45_NONDAMP_REV 
                      6593     
0F82    C2AF          6594     	CLR 	EA					; Disable all interrupts
0F84    754005        6595     	MOV	COMM_PHASE, #5
0F87    90015C        6596     	MOV	DPTR, #PWM_AFET	
                      6597     	BNFET_OFF					; Turn off nfet
0F8A    C294          6597+1   CLR P1 . 4 
0F8C    306202        6598     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      6599     	ANFET_ON					; Yes - turn on nfet
0F8F    D293          6599+1   SETB P1 . 3 
                      6600     COMM45_NFET_DONE: 
0F91    D2AF          6601     	SETB	EA
                      6602     	SET_COMP_PHASE_B 			; Set comparator phase
0F93    759F80        6602+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F96    021047        6603     	LJMP	COMM_EXIT
                      6604     
                      6605     	; Comm4Comm5 Non-damped reverse
                      6606     COMM45_NONDAMP_REV: 
0F99    C2AF          6607     	CLR 	EA					; Disable all interrupts
0F9B    754005        6608     	MOV	COMM_PHASE, #5
0F9E    900170        6609     	MOV	DPTR, #PWM_CFET		;  (reverse)
                      6610     	BNFET_OFF					; Turn off nfet
0FA1    C294          6610+1   CLR P1 . 4 
0FA3    3062EB        6611     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      6612     	CNFET_ON					; Yes - turn on nfet (reverse)
0FA6    D297          6612+1   SETB P1 . 7 
0FA8    D2AF          6613     	SETB	EA
                      6614     	SET_COMP_PHASE_B 			; Set comparator phase
0FAA    759F80        6614+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0FAD    021047        6615     	LJMP	COMM_EXIT
                      6616     
                      6617     
                      6618     ; Comm phase 5 to comm phase 6
                      6619     COMM5COMM6: 	
                      6620     	SET_RPM_OUT
0FB0    207D11        6621     JB FLAGS3 . 5 , COMM56_REV 
                      6622     
0FB3    C2AF          6623     	CLR 	EA					; Disable all interrupts
0FB5    754006        6624     	MOV	COMM_PHASE, #6
                      6625     	CPFET_OFF 				; Turn off pfet
0FB8    C296          6625+1   CLR P1 . 6 
                      6626     	BPFET_ON					; Turn on pfet
0FBA    D295          6626+1   SETB P1 . 5 
0FBC    D2AF          6627     	SETB	EA
                      6628     	SET_COMP_PHASE_C 			; Set comparator phase
0FBE    759F89        6628+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0FC1    021047        6629     	JMP	COMM_EXIT
                      6630     
                      6631     COMM56_REV: 
0FC4    C2AF          6632     	CLR 	EA					; Disable all interrupts
0FC6    754006        6633     	MOV	COMM_PHASE, #6
                      6634     	APFET_OFF 				; Turn off pfet (reverse)
0FC9    C292          6634+1   CLR P1 . 2 
                      6635     	BPFET_ON					; Turn on pfet
0FCB    D295          6635+1   SETB P1 . 5 
0FCD    D2AF          6636     	SETB	EA
                      6637     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0FCF    759F81        6637+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0FD2    021047        6638     	JMP	COMM_EXIT
                      6639     
                      6640     
                      6641     ; Comm phase 6 to comm phase 1
                      6642     COMM6COMM1: 	
                      6643     	CLEAR_RPM_OUT
0FD5    307242        6644     JNB FLAGS2 . 2 , COMM61_NONDAMP 
                      6645     
                      6646     	; Comm6Comm1 Damped
0FD8    207D20        6647     JB FLAGS3 . 5 , COMM61_DAMP_REV 
                      6648     
0FDB    C2AF          6649     	CLR 	EA					; Disable all interrupts
0FDD    754001        6650     	MOV	COMM_PHASE, #1
0FE0    90019C        6651     	MOV	DPTR, #PWM_CFET_DAMPED	
0FE3    757B40        6652     	MOV	DAMPINGFET, #(1 SHL CPFET)
                      6653     	ANFET_OFF					; Turn off fets
0FE6    C293          6653+1   CLR P1 . 3 
                      6654     	APFET_OFF						
0FE8    C292          6654+1   CLR P1 . 2 
0FEA    306204        6655     JNB FLAGS0 . 2 , COMM61_NFET_OFF 
                      6656     	CNFET_ON					; Pwm on - turn on nfet
0FED    D297          6656+1   SETB P1 . 7 
0FEF    E1F3          6657     	AJMP	COMM61_FETS_DONE
                      6658     COMM61_NFET_OFF: 
                      6659     	CPFET_ON					; Pwm off - switch damping fets	
0FF1    D296          6659+1   SETB P1 . 6 
                      6660     COMM61_FETS_DONE: 
0FF3    D2AF          6661     	SETB	EA
                      6662     	SET_COMP_PHASE_A 			; Set comparator phase
0FF5    759F81        6662+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0FF8    021047        6663     	LJMP	COMM_EXIT
                      6664     
                      6665     	; Comm6Comm1 Damped reverse
                      6666     COMM61_DAMP_REV: 
0FFB    C2AF          6667     	CLR 	EA					; Disable all interrupts
0FFD    754001        6668     	MOV	COMM_PHASE, #1
1000    90017A        6669     	MOV	DPTR, #PWM_AFET_DAMPED	; (reverse)	
1003    757B04        6670     	MOV	DAMPINGFET, #(1 SHL APFET)	; (reverse)
                      6671     	CNFET_OFF					; Turn off fets (reverse)
1006    C297          6671+1   CLR P1 . 7 
                      6672     	CPFET_OFF						
1008    C296          6672+1   CLR P1 . 6 
100A    306204        6673     JNB FLAGS0 . 2 , COMM61_NFET_OFF_REV 
                      6674     	ANFET_ON					; Pwm on - turn on nfet
100D    D293          6674+1   SETB P1 . 3 
100F    0113          6675     	AJMP	COMM61_FETS_DONE_REV
                      6676     COMM61_NFET_OFF_REV: 
                      6677     	APFET_ON					; Pwm off - switch damping fets (reverse)	
1011    D292          6677+1   SETB P1 . 2 
                      6678     COMM61_FETS_DONE_REV: 
1013    D2AF          6679     	SETB	EA
                      6680     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
1015    759F89        6680+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
1018    0147          6681     	AJMP	COMM_EXIT
                      6682     
                      6683     	; Comm6Comm1 Non-damped
                      6684     COMM61_NONDAMP: 
101A    207D16        6685     JB FLAGS3 . 5 , COMM61_NONDAMP_REV 
                      6686     
101D    C2AF          6687     	CLR 	EA					; Disable all interrupts
101F    754001        6688     	MOV	COMM_PHASE, #1
1022    900170        6689     	MOV	DPTR, #PWM_CFET	
                      6690     	ANFET_OFF					; Turn off nfet
1025    C293          6690+1   CLR P1 . 3 
1027    306202        6691     JNB FLAGS0 . 2 , COMM61_NFET_DONE 
                      6692     	CNFET_ON					; Yes - turn on nfet
102A    D297          6692+1   SETB P1 . 7 
                      6693     COMM61_NFET_DONE: 
102C    D2AF          6694     	SETB	EA
                      6695     	SET_COMP_PHASE_A 			; Set comparator phase
102E    759F81        6695+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
1031    0147          6696     	AJMP	COMM_EXIT
                      6697     
                      6698     	; Comm6Comm1 Non-damped reverse
                      6699     COMM61_NONDAMP_REV: 
1033    C2AF          6700     	CLR 	EA					; Disable all interrupts
1035    754001        6701     	MOV	COMM_PHASE, #1
1038    90015C        6702     	MOV	DPTR, #PWM_AFET		; (reverse)
                      6703     	CNFET_OFF					; Turn off nfet (reverse)
103B    C297          6703+1   CLR P1 . 7 
103D    306202        6704     JNB FLAGS0 . 2 , COMM61_NFET_DONE_REV 
                      6705     	ANFET_ON					; Yes - turn on nfet (reverse)
1040    D293          6705+1   SETB P1 . 3 
                      6706     COMM61_NFET_DONE_REV: 
1042    D2AF          6707     	SETB	EA
                      6708     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
1044    759F89        6708+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
                      6709     
                      6710     COMM_EXIT: 
1047    C266          6711     CLR FLAGS0 . 6 
1049    22            6712     	RET
                      6713     
                      6714     
                      6715     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6716     ;
                      6717     ; Switch power off routine
                      6718     ;
                      6719     ; No assumptions
                      6720     ;
                      6721     ; Switches all fets off 
                      6722     ;
                      6723     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6724     SWITCH_POWER_OFF: 
104A    90015A        6725     	MOV	DPTR, #PWM_NOFET	; Set DPTR register to pwm_nofet		
104D    757B00        6726     	MOV	DAMPINGFET, #0
                      6727     	ALL_NFETS_OFF			; Turn off all nfets
1050    C293          6727+1   CLR P1 . 3 
1052    C297          6727+1   CLR P1 . 7 
1054    C294          6727+1   CLR P1 . 4 
                      6728     	ALL_PFETS_OFF			; Turn off all pfets
1056    C292          6728+1   CLR P1 . 2 
1058    C296          6728+1   CLR P1 . 6 
105A    C295          6728+1   CLR P1 . 5 
105C    C262          6729     CLR FLAGS0 . 2 
105E    22            6730     	RET			
                      6731     
                      6732     
                      6733     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6734     ;
                      6735     ; Set default parameters
                      6736     ;
                      6737     ; No assumptions
                      6738     ;
                      6739     ; Sets default programming parameters
                      6740     ;
                      6741     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6742     SET_DEFAULT_PARAMETERS: 
                      6743     IF MODE == 0	; Main
105F    7880          6744     MOV R0 , # PGM_GOV_P_GAIN 
1061    7607          6745     MOV @ R0 , # 7 
1063    08            6746     INC R0 
1064    7607          6747     MOV @ R0 , # 7 
1066    08            6748     INC R0 
1067    7601          6749     MOV @ R0 , # 1 
1069    08            6750     INC R0 
106A    7604          6751     MOV @ R0 , # 4 
106C    08            6752     INC R0 
106D    76FF          6753     MOV @ R0 , # 0FFH 
106F    08            6754     INC R0 
1070    76FF          6755     MOV @ R0 , # 0FFH 
1072    08            6756     INC R0 
1073    7609          6757     MOV @ R0 , # 9 
1075    08            6758     INC R0 
1076    7602          6759     MOV @ R0 , # 2 
1078    08            6760     INC R0 
1079    7601          6761     MOV @ R0 , # 1 
107B    08            6762     INC R0 
107C    7601          6763     MOV @ R0 , # 1 
                      6764     
107E    788C          6765     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1080    7601          6766     MOV @ R0 , # 1 
1082    08            6767     INC R0 
1083    7600          6768     MOV @ R0 , # 0 
1085    08            6769     INC R0 
1086    76B4          6770     MOV @ R0 , # 180 
1088    08            6771     INC R0 
1089    76FF          6772     MOV @ R0 , # 0FFH 
108B    08            6773     INC R0 
108C    76FF          6774     MOV @ R0 , # 0FFH 
108E    08            6775     INC R0 
108F    76FF          6776     MOV @ R0 , # 0FFH 
1091    08            6777     INC R0 
1092    7603          6778     MOV @ R0 , # 3 
1094    08            6779     INC R0 
1095    76FF          6780     MOV @ R0 , # 0FFH 
1097    08            6781     INC R0 
1098    7601          6782     MOV @ R0 , # 1 
109A    08            6783     INC R0 
109B    76FF          6784     MOV @ R0 , # 0FFH 
109D    08            6785     INC R0 
109E    7625          6786     MOV @ R0 , # 37 
10A0    08            6787     INC R0 
10A1    76D0          6788     MOV @ R0 , # 208 
10A3    08            6789     INC R0 
10A4    7678          6790     MOV @ R0 , # 120 
10A6    08            6791     INC R0 
10A7    76C8          6792     MOV @ R0 , # 200 
10A9    08            6793     INC R0 
10AA    7604          6794     MOV @ R0 , # 4 
10AC    08            6795     INC R0 
10AD    76FF          6796     MOV @ R0 , # 0FFH 
10AF    08            6797     INC R0 
10B0    7601          6798     MOV @ R0 , # 1 
10B2    08            6799     INC R0 
10B3    7600          6800     MOV @ R0 , # 0 
10B5    08            6801     INC R0 
10B6    767A          6802     MOV @ R0 , # 122 
10B8    08            6803     INC R0 
10B9    760A          6804     MOV @ R0 , # 10 
10BB    08            6805     INC R0 
10BC    7601          6806     MOV @ R0 , # 1 
10BE    08            6807     INC R0 
10BF    7601          6808     MOV @ R0 , # 1 
10C1    08            6809     INC R0 
10C2    7600          6810     MOV @ R0 , # 0 
10C4    08            6811     INC R0 
10C5    76FF          6812     MOV @ R0 , # 0FFH 
                      6813     ENDIF
                      6814     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_DITHER
                               ENDIF
                      6885     IF MODE == 2	; Multi
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_PWM_DITHER
                               ENDIF
10C7    22            6956     	RET
                      6957     
                      6958     
                      6959     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6960     ;
                      6961     ; Decode parameters
                      6962     ;
                      6963     ; No assumptions
                      6964     ;
                      6965     ; Decodes programming parameters
                      6966     ;
                      6967     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6968     DECODE_PARAMETERS: 
                      6969     	; Load programmed pwm frequency
10C8    7887          6970     MOV R0 , # PGM_PWM_FREQ 
10CA    E6            6971     MOV A , @ R0 
10CB    FF            6972     MOV R7 , A 
10CC    C272          6973     CLR FLAGS2 . 2 
                      6974     IF DAMPED_MODE_ENABLE == 1
10CE    BF0302        6975     CJNE R7 , # 3 , ( $+5 ) 
10D1    D272          6976     SETB FLAGS2 . 2 
                      6977     ENDIF
                      6978     	; Load programmed direction
10D3    7888          6979     MOV R0 , # PGM_DIRECTION 
                      6980     IF MODE >= 1	; Tail or multi
                               	MOV	A, @TEMP1				
                               	CLR	C
                               	SUBB	A, #3
                               	JZ	DECODE_PARAMS_DIR_SET
                               ENDIF
                      6986     
10D5    C27D          6987     CLR FLAGS3 . 5 
10D7    E6            6988     MOV A , @ R0 
10D8    30E102        6989     	JNB	ACC.1, ($+5)
10DB    D27D          6990     SETB FLAGS3 . 5 
                      6991     DECODE_PARAMS_DIR_SET: 
10DD    C27E          6992     CLR FLAGS3 . 6 
10DF    7889          6993     MOV R0 , # PGM_INPUT_POL 
10E1    E6            6994     MOV A , @ R0 
10E2    30E102        6995     	JNB	ACC.1, ($+5)
10E5    D27E          6996     SETB FLAGS3 . 6 
10E7    C3            6997     	CLR	C
10E8    EF            6998     MOV A , R7 
10E9    9402          6999     	SUBB	A, #2
10EB    6008          7000     	JZ	DECODE_PWM_FREQ_LOW
                      7001     
10ED    758E01        7002     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
10F0    D273          7003     SETB FLAGS2 . 3 
10F2    0210FA        7004     	JMP	DECODE_PWM_FREQ_END
                      7005     
                      7006     DECODE_PWM_FREQ_LOW: 
10F5    758E00        7007     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
10F8    C273          7008     CLR FLAGS2 . 3 
                      7009     
                      7010     DECODE_PWM_FREQ_END: 
10FA    22            7011     	RET
                      7012     
                      7013     
                      7014     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7015     ;
                      7016     ; Decode settings
                      7017     ;
                      7018     ; No assumptions
                      7019     ;
                      7020     ; Decodes various settings
                      7021     ;
                      7022     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7023     DECODE_SETTINGS: 
                      7024     	; Decode governor gains
10FB    7880          7025     MOV R0 , # PGM_GOV_P_GAIN 
10FD    E6            7026     MOV A , @ R0 
10FE    14            7027     	DEC	A	
10FF    900080        7028     	MOV	DPTR, #GOV_GAIN_TABLE
1102    93            7029     	MOVC A, @A+DPTR	
1103    78A4          7030     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
1105    F6            7031     MOV @ R0 , A 
1106    7881          7032     MOV R0 , # PGM_GOV_I_GAIN 
1108    E6            7033     MOV A , @ R0 
1109    14            7034     	DEC	A	
110A    900080        7035     	MOV	DPTR, #GOV_GAIN_TABLE
110D    93            7036     	MOVC A, @A+DPTR	
110E    78A5          7037     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
1110    F6            7038     MOV @ R0 , A 
                      7039     	; Decode startup power
1111    7886          7040     MOV R0 , # PGM_STARTUP_PWR 
1113    E6            7041     MOV A , @ R0 
1114    14            7042     	DEC	A	
1115    90008D        7043     	MOV	DPTR, #STARTUP_POWER_TABLE
1118    93            7044     	MOVC A, @A+DPTR	
1119    78A6          7045     MOV R0 , # PGM_STARTUP_PWR_DECODED 
111B    F6            7046     MOV @ R0 , A 
                      7047     IF MODE == 0	; Main
                      7048     	; Decode spoolup time
111C    789F          7049     MOV R0 , # PGM_MAIN_SPOOLUP_TIME 
111E    E6            7050     MOV A , @ R0 
111F    F8            7051     MOV R0 , A 
1120    7001          7052     	JNZ	($+3)		; If not zero - branch
                      7053     	
1122    08            7054     INC R0 
                      7055     
1123    C3            7056     	CLR	C
1124    E8            7057     MOV A , R0 
1125    9411          7058     	SUBB	A, #17		; Limit to 17 max
1127    4002          7059     	JC	($+4)
                      7060     
1129    7811          7061     MOV R0 , # 17 
                      7062     
112B    E8            7063     MOV A , R0 
112C    28            7064     ADD A , R0 
112D    28            7065     ADD A , R0 
112E    F56B          7066     	MOV	MAIN_SPOOLUP_TIME_3X, A
1130    256B          7067     	ADD	A, MAIN_SPOOLUP_TIME_3X
1132    256B          7068     	ADD	A, MAIN_SPOOLUP_TIME_3X
1134    28            7069     ADD A , R0 
1135    F56C          7070     	MOV	MAIN_SPOOLUP_TIME_10X, A
1137    256B          7071     	ADD	A, MAIN_SPOOLUP_TIME_3X
1139    28            7072     ADD A , R0 
113A    28            7073     ADD A , R0 
113B    F56D          7074     	MOV	MAIN_SPOOLUP_TIME_15X, A
                      7075     ENDIF
                      7076     	; Decode demag compensation
113D    789C          7077     MOV R0 , # PGM_DEMAG_COMP 
113F    E6            7078     MOV A , @ R0 
1140    7537FF        7079     	MOV	DEMAG_PWR_OFF_THRESH, #255	; Set default
1143    75380C        7080     	MOV	LOW_RPM_PWR_SLOPE, #12		; Set default
                      7081     
1146    B40206        7082     	CJNE	A, #2, DECODE_DEMAG_HIGH
                      7083     
1149    7537A0        7084     	MOV	DEMAG_PWR_OFF_THRESH, #160	; Settings for demag comp low
114C    75380A        7085     	MOV	LOW_RPM_PWR_SLOPE, #10		
                      7086     
                      7087     DECODE_DEMAG_HIGH: 
114F    B40306        7088     	CJNE	A, #3, DECODE_DEMAG_DONE
                      7089     
1152    753782        7090     	MOV	DEMAG_PWR_OFF_THRESH, #130	; Settings for demag comp high
1155    753805        7091     	MOV	LOW_RPM_PWR_SLOPE, #5		
                      7092     
                      7093     DECODE_DEMAG_DONE: 
                      7094     	; Decode pwm dither
1158    78A3          7095     MOV R0 , # PGM_PWM_DITHER 
115A    E6            7096     MOV A , @ R0 
115B    14            7097     	DEC	A	
115C    90009A        7098     	MOV	DPTR, #PWM_DITHER_TABLE
115F    93            7099     	MOVC A, @A+DPTR	
1160    F566          7100     	MOV	PWM_DITHER_DECODED, A
1162    114A          7101     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1164    22            7102     	RET
                      7103     
                      7104     
                      7105     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7106     ;
                      7107     ; Set BEC voltage
                      7108     ;
                      7109     ; No assumptions
                      7110     ;
                      7111     ; Sets the BEC output voltage low or high
                      7112     ;
                      7113     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7114     SET_BEC_VOLTAGE: 
                      7115     	; Set bec voltage
                      7116     IF HIGH_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
                      7126     IF HIGH_BEC_VOLTAGE == 2
                               	SET_BEC_0				; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	CJNE	A, #1, SET_BEC_VOLTAGE_2	
                               
                               	SET_BEC_1				; Set to level 1
                               
                               SET_BEC_VOLTAGE_2:
                               	CJNE	A, #2, SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_2				; Set to level 2
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
1165    22            7141     	RET
                      7142     
                      7143     
                      7144     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7145     ;
                      7146     ; Find throttle gain
                      7147     ;
                      7148     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      7149     ;
                      7150     ; Finds throttle gain from throttle calibration values
                      7151     ;
                      7152     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7153     FIND_THROTTLE_GAIN: 
                      7154     	; Load programmed minimum and maximum throttle
1166    7896          7155     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1168    E6            7156     MOV A , @ R0 
1169    FA            7157     MOV R2 , A 
116A    7897          7158     MOV R0 , # PGM_PPM_MAX_THROTTLE 
116C    E6            7159     MOV A , @ R0 
116D    FB            7160     MOV R3 , A 
116E    7888          7161     MOV R0 , # PGM_DIRECTION 
1170    E6            7162     MOV A , @ R0 
1171    B40305        7163     	CJNE	A, #3, FIND_THROTTLE_GAIN_CHECK_FULL
                      7164     
1174    C3            7165     	CLR	C
1175    EB            7166     MOV A , R3 
1176    940E          7167     	SUBB	A, #14				; Compensate for higher deadband in bidirectional
1178    FB            7168     MOV R3 , A 
                      7169     
                      7170     FIND_THROTTLE_GAIN_CHECK_FULL: 
                      7171     	; Check if full range is chosen
1179    307F04        7172     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      7173     
117C    7A00          7174     MOV R2 , # 0 
117E    7BFF          7175     MOV R3 , # 255 
                      7176     
                      7177     FIND_THROTTLE_GAIN_CALCULATE: 
                      7178     	; Calculate difference
1180    C3            7179     	CLR	C
1181    EB            7180     MOV A , R3 
1182    9A            7181     SUBB A , R2 
1183    FC            7182     MOV R4 , A 
                      7183     	; Check that difference is minimum 130
1184    C3            7184     	CLR	C
1185    9482          7185     	SUBB	A, #130
1187    5002          7186     	JNC	($+4)
                      7187     
1189    7C82          7188     MOV R4 , # 130 
                      7189     
                      7190     	; Find gain
118B    757200        7191     	MOV	PPM_THROTTLE_GAIN, #0
                      7192     TEST_THROTTLE_GAIN: 
118E    0572          7193     	INC	PPM_THROTTLE_GAIN
1190    EC            7194     MOV A , R4 
1191    8572F0        7195     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
1194    A4            7196     	MUL	AB
1195    C3            7197     	CLR	C
1196    E5F0          7198     	MOV	A, B
1198    947D          7199     	SUBB	A, #125
119A    40F2          7200     	JC	TEST_THROTTLE_GAIN
119C    22            7201     	RET
                      7202     
                      7203     
                      7204     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7205     ;
                      7206     ; Average throttle 
                      7207     ;
                      7208     ; Outputs result in Temp3
                      7209     ;
                      7210     ; Averages throttle calibration readings
                      7211     ;
                      7212     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7213     AVERAGE_THROTTLE: 
119D    D27F          7214     SETB FLAGS3 . 7 
119F    3166          7215     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
11A1    1205D3        7216     	CALL WAIT30MS		
11A4    7A00          7217     MOV R2 , # 0 
11A6    7B00          7218     MOV R3 , # 0 
11A8    7C10          7219     MOV R4 , # 16 
                      7220     AVERAGE_THROTTLE_MEAS: 
11AA    1205C9        7221     	CALL	WAIT3MS			; Wait for new RC pulse value
11AD    E55C          7222     	MOV	A, NEW_RCP		; Get new RC pulse value
11AF    2A            7223     ADD A , R2 
11B0    FA            7224     MOV R2 , A 
11B1    7400          7225     	MOV	A, #0
11B3    3B            7226     ADDC A , R3 
11B4    FB            7227     MOV R3 , A 
11B5    DCF3          7228     DJNZ R4 , AVERAGE_THROTTLE_MEAS 
                      7229     
11B7    7C04          7230     MOV R4 , # 4 
                      7231     AVERAGE_THROTTLE_DIV: 
11B9    C3            7232     	CLR	C
11BA    EB            7233     MOV A , R3 
11BB    13            7234     	RRC	A      
11BC    FB            7235     MOV R3 , A 
11BD    EA            7236     MOV A , R2 
11BE    13            7237     	RRC	A      
11BF    FA            7238     MOV R2 , A 
11C0    DCF7          7239     DJNZ R4 , AVERAGE_THROTTLE_DIV 
                      7240     
11C2    FE            7241     MOV R6 , A 
11C3    C27F          7242     CLR FLAGS3 . 7 
11C5    3166          7243     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
11C7    22            7244     	RET
                      7245     
                      7246     
                      7247     
                      7248     
                      7249     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7250     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7251     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7252     ;
                      7253     ; Main program start
                      7254     ;
                      7255     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7256     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7257     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7258     PGM_START: 
                      7259     	; Check flash lock byte
11C8    E5EF          7260     	MOV	A, RSTSRC			
11CA    20E603        7261     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      7262     
11CD    752000        7263     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      7264     
11D0    0520          7265     	INC	BIT_ACCESS
11D2    903FFF        7266     MOV DPTR , # 16383 
11D5    E520          7267     	MOV	A, BIT_ACCESS
11D7    14            7268     	DEC	A
11D8    6006          7269     	JZ	LOCK_BYTE_TEST
                      7270     
11DA    901FFF        7271     MOV DPTR , # 8191 
11DD    14            7272     	DEC	A
11DE    6000          7273     	JZ	LOCK_BYTE_TEST
                      7274     
                      7275     LOCK_BYTE_TEST: 
11E0    93            7276     	MOVC A, @A+DPTR		; Read lock byte
11E1    04            7277     	INC	A				
11E2    6003          7278     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      7279     
                      7280     IF ONE_S_CAPABLE == 0		
11E4    75EF12        7281     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      7282     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      7285     
                      7286     LOCK_BYTE_OK: 
                      7287     	; Disable the WDT.
                      7288     IF SIGNATURE_001 == 0F3H		
11E7    53D9BF        7289     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      7290     ENDIF
                      7291     IF SIGNATURE_001 == 0F8H		
                               	MOV	WDTCN, #0DEH		; Disable watchdog
                               	MOV	WDTCN, #0ADH		
                               ENDIF
                      7295     	; Initialize stack
11EA    7581C0        7296     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      7297     	; Initialize VDD monitor
11ED    43FF80        7298     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
11F0    1205C4        7299     	CALL	WAIT1MS			; Wait at least 100us
                      7300     IF ONE_S_CAPABLE == 0		
11F3    75EF02        7301     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      7302     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      7305     	; Set clock frequency
                      7306     IF SIGNATURE_001 == 0F3H		
11F6    43B203        7307     	ORL	OSCICN, #03H		; Set clock divider to 1 (not supported on 'f850)
                      7308     ENDIF
                      7309     IF SIGNATURE_001 == 0F8H		
                               	MOV	CLKSEL, #00H		; Set clock divider to 1 (not supported on 'f3xx)
                               ENDIF
11F9    E5B3          7312     	MOV	A, OSCICL				
11FB    2404          7313     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
11FD    20E70D        7314     	JB	ACC.7, RESET_CAL_DONE	; Is carry (7bit) set? - branch
                      7315     
1200    F521          7316     	MOV	BIT_ACCESS_INT, A
                      7317     IF SIGNATURE_002 <> 010H		
1202    E5E3          7318     	MOV	A, OSCLCN
                      7319     ELSE
                               	MOV	A, OSCXCN
                               ENDIF
1204    20E006        7322     	JB	ACC.0, RESET_CAL_DONE	; Set if cal aleady done
                      7323     
1207    8521B3        7324     	MOV	OSCICL, BIT_ACCESS_INT
                      7325     IF SIGNATURE_002 <> 010H		
120A    43E301        7326     	ORL	OSCLCN, #01H			; Tag that cal is done
                      7327     ELSE
                               	ORL	OSCXCN, #01H			; Tag that cal is done
                               ENDIF
                      7330     
                      7331     RESET_CAL_DONE: 
                      7332     	; Switch power off
120D    114A          7333     	CALL	SWITCH_POWER_OFF
                      7334     	; Ports initialization
120F    7580FF        7335     MOV P0 , # 255 
1212    75A400        7336     MOV P0MDOUT , # 0 
1215    75F1F0        7337     MOV P0MDIN , # -16 
1218    75D4DF        7338     MOV P0SKIP , # -33 
121B    759002        7339     MOV P1 , # 2 
121E    75A5FC        7340     MOV P1MDOUT , # 252 
1221    75F2FD        7341     MOV P1MDIN , # -3 
1224    75D502        7342     MOV P1SKIP , # 2 
                      7343     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
1227    75A610        7346     MOV P2MDOUT , # 16 
                      7347     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      7354     	; Initialize the XBAR and related functionality
                      7355     	INITIALIZE_XBAR
122A    75A0FF        7355+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
122D    75F3F1        7355+1   MOV P2MDIN , # -15 
1230    75E241        7355+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      7356     	; Clear RAM
1233    E4            7357     	CLR	A				; Clear accumulator
1234    F8            7358     MOV R0 , A 
                      7359     CLEAR_RAM: 	
1235    F6            7360     MOV @ R0 , A 
1236    D8FD          7361     DJNZ R0 , CLEAR_RAM 
                      7362     	; Initialize LFSR
1238    756801        7363     	MOV	RANDOM, #1
                      7364     	; Set default programmed parameters
123B    115F          7365     	CALL	SET_DEFAULT_PARAMETERS
                      7366     	; Read all programmed parameters
123D    12173F        7367     	CALL READ_ALL_EEPROM_PARAMETERS
                      7368     	; Set beep strength
1240    7898          7369     MOV R0 , # PGM_BEEP_STRENGTH 
1242    8673          7370     MOV BEEP_STRENGTH , @ R0 
                      7371     	; Set initial arm variable
1244    753001        7372     	MOV	INITIAL_ARM, #1
                      7373     	; Initializing beep
1247    C2AF          7374     	CLR	EA				; Disable interrupts explicitly
1249    1205DD        7375     	CALL WAIT200MS	
124C    1205ED        7376     	CALL BEEP_F1
124F    1205D3        7377     	CALL WAIT30MS
1252    1205F4        7378     	CALL BEEP_F2
1255    1205D3        7379     	CALL WAIT30MS
1258    1205FB        7380     	CALL BEEP_F3
125B    1205D3        7381     	CALL WAIT30MS
                      7382     IF MODE <= 1	; Main or tail
                      7383     	; Wait for receiver to initialize
125E    121864        7384     	CALL	WAIT1S
1261    1205DD        7385     	CALL	WAIT200MS
1264    1205DD        7386     	CALL	WAIT200MS
1267    1205D8        7387     	CALL	WAIT100MS
                      7388     ENDIF
                      7389     
                      7390     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7391     ;
                      7392     ; No signal entry point
                      7393     ;
                      7394     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7395     INIT_NO_SIGNAL: 
                      7396     	; Disable interrupts explicitly
126A    C2AF          7397     	CLR	EA				
                      7398     	; Check if input signal is high for more than 15ms
126C    78FA          7399     MOV R0 , # 250 
                      7400     INPUT_HIGH_CHECK_1: 
126E    79FA          7401     MOV R1 , # 250 
                      7402     INPUT_HIGH_CHECK_2: 
1270    308507        7403     JNB 128 . 5 , BOOTLOADER_DONE 
1273    D9FB          7404     DJNZ R1 , INPUT_HIGH_CHECK_2 
1275    D8F7          7405     DJNZ R0 , INPUT_HIGH_CHECK_1 
                      7406     
1277    021C00        7407     	LJMP	1C00H			; Jump to bootloader
                      7408     
                      7409     BOOTLOADER_DONE: 
                      7410     	; Decode parameters
127A    11C8          7411     	CALL	DECODE_PARAMETERS
                      7412     	; Decode settings
127C    11FB          7413     	CALL	DECODE_SETTINGS
                      7414     	; Set BEC voltage
127E    3165          7415     	CALL	SET_BEC_VOLTAGE
                      7416     	; Find throttle gain from stored min and max settings
1280    3166          7417     	CALL	FIND_THROTTLE_GAIN
                      7418     	; Set beep strength
1282    7898          7419     MOV R0 , # PGM_BEEP_STRENGTH 
1284    8673          7420     MOV BEEP_STRENGTH , @ R0 
                      7421     	; Switch power off
1286    114A          7422     	CALL	SWITCH_POWER_OFF
                      7423     	; Set clock frequency
                      7424     IF MCU_48MHZ == 1
                      7425     	SET_MCU_CLK_24MHZ
1288    75B680        7425+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
128B    75A900        7425+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
128E    757A00        7425+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      7426     ENDIF
                      7427     	; Timer control
1291    758850        7428     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      7429     	; Timer mode
1294    758912        7430     	MOV	TMOD, #12H		; Timer0 as 8bit, timer1 as 16bit
                      7431     	; Timer2: clk/12 for 128us and 32ms interrupts
1297    75C824        7432     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      7433     	; Timer3: clk/12 for commutation timing
129A    759104        7434     	MOV	TMR3CN, #04H		; Timer3 enabled
                      7435     	; PCA
129D    75D840        7436     	MOV	PCA0CN, #40H		; PCA enabled
                      7437     	; Enable interrupts
12A0    75A822        7438     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
12A3    75B802        7439     	MOV	IP, #02H			; High priority to timer0 interrupts
12A6    75E690        7440     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      7441     	; Initialize comparator
12A9    759B80        7442     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
12AC    759D00        7443     	MOV	CPT0MD, #00H		; Comparator response time 100ns
                      7444     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #00H		; Comparator response time 100ns
                               ENDIF
                      7448     	; Initialize ADC
                      7449     	INITIALIZE_ADC			; Initialize ADC operation
12AF    75D10E        7449+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
                      7449+1   IF MCU_50MHZ ==0 
12B2    75BC58        7449+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
                      7449+1   ELSE 
                               MOV ADC0CF , # 0C0H  ; ADC CLOCK 2MHZ
                               ENDIF 
12B5    75BB09        7449+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
12B8    75BA11        7449+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
12BB    75E880        7449+1   MOV ADC0CN , # 80H  ; ADC ENABLED
12BE    1205C4        7450     	CALL	WAIT1MS
12C1    D2AF          7451     	SETB	EA				; Enable all interrupts
                      7452     	; Measure number of lipo cells
12C3    12091E        7453     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      7454     	; Initialize RC pulse
                      7455     	RCP_INT_FIRST 					; Enable interrupt and set to first edge
12C6    53DACF        7455+1   ANL PCA0CPM0 , # 0CFH 
12C9    207E03        7455+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
12CC    43DA20        7455+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
12CF    307E03        7455+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
12D2    43DA10        7455+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7456     	RCP_INT_ENABLE		 			; Enable interrupt
12D5    43DA01        7456+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      7457     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
12D8    C2D8          7457+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
12DA    C271          7458     CLR FLAGS2 . 1 
12DC    1205DD        7459     	CALL WAIT200MS
                      7460     
                      7461     	; Measure PWM frequency
                      7462     MEASURE_PWM_FREQ_INIT: 	
12DF    D261          7463     SETB FLAGS0 . 1 
12E1    7B03          7464     MOV R3 , # 3 
                      7465     MEASURE_PWM_FREQ_START: 	
12E3    7A0C          7466     MOV R2 , # 12 
                      7467     MEASURE_PWM_FREQ_LOOP: 	
                      7468     	; Check if period diff was accepted
12E5    E55B          7469     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
12E7    7007          7470     	JNZ	MEASURE_PWM_FREQ_WAIT
                      7471     
12E9    7A0C          7472     MOV R2 , # 12 
12EB    DB03          7473     DJNZ R3 , ( $+5 ) 
12ED    02126A        7474     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      7475     
                      7476     MEASURE_PWM_FREQ_WAIT: 
12F0    1205D3        7477     	CALL	WAIT30MS						; Wait 30ms for new pulse
12F3    207003        7478     JB FLAGS2 . 0 , ( $+6 ) 
12F6    02126A        7479     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      7480     
12F9    C270          7481     CLR FLAGS2 . 0 
12FB    E55C          7482     	MOV	A, NEW_RCP					; Load value
12FD    C3            7483     	CLR	C
12FE    9402          7484     SUBB A , # 2 
1300    40E1          7485     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      7486     
1302    E52F          7487     	MOV	A, FLAGS3						; Check pwm frequency flags
1304    541F          7488     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1306    855E5D        7489     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
1309    F55E          7490     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
130B    B55DD5        7491     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      7492     
130E    DAD5          7493     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      7494     
                      7495     	; Clear measure pwm frequency flag
1310    C261          7496     CLR FLAGS0 . 1 
                      7497     	; Set up RC pulse interrupts after pwm frequency measurement
                      7498     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
1312    53DACF        7498+1   ANL PCA0CPM0 , # 0CFH 
1315    207E03        7498+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1318    43DA20        7498+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
131B    307E03        7498+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
131E    43DA10        7498+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7499     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
1321    C2D8          7499+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1323    C271          7500     CLR FLAGS2 . 1 
1325    78A2          7501     MOV R0 , # PGM_ENABLE_PWM_INPUT 
1327    E6            7502     MOV A , @ R0 
1328    7008          7503     	JNZ	TEST_FOR_ONESHOT				; If it is - proceed
                      7504     
132A    D274          7505     SETB FLAGS2 . 4 
132C    E52F          7506     	MOV	A, FLAGS3						; Clear pwm frequency flags
132E    54E0          7507     	ANL	A, #NOT((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1330    F52F          7508     	MOV	FLAGS3, A
                      7509     
                      7510     TEST_FOR_ONESHOT: 	
                      7511     	; Test whether signal is OneShot125
1332    C275          7512     CLR FLAGS2 . 5 
1334    752900        7513     	MOV	RCP_OUTSIDE_RANGE_CNT, #0		; Reset out of range counter
1337    1205D8        7514     	CALL WAIT100MS						; Wait for new RC pulse
133A    307409        7515     JNB FLAGS2 . 4 , VALIDATE_RCP_START 
                      7516     
133D    C3            7517     	CLR	C
133E    E529          7518     	MOV	A, RCP_OUTSIDE_RANGE_CNT			; Check how many pulses were outside normal PPM range (800-2160us)
1340    940A          7519     	SUBB	A, #10						
1342    4002          7520     	JC	VALIDATE_RCP_START
                      7521     
1344    D275          7522     SETB FLAGS2 . 5 
                      7523     
                      7524     	; Validate RC pulse
                      7525     VALIDATE_RCP_START: 	
1346    1205C9        7526     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1349    7802          7527     MOV R0 , # 2 
134B    307402        7528     JNB FLAGS2 . 4 , ( $+5 ) 
                      7529     
134E    7800          7530     MOV R0 , # 0 
                      7531     
1350    C3            7532     	CLR	C
1351    E55C          7533     	MOV	A, NEW_RCP					; Load value
1353    98            7534     SUBB A , R0 
1354    40F0          7535     	JC	VALIDATE_RCP_START				; No - start over
                      7536     
                      7537     	; Beep arm sequence start signal
1356    C2AF          7538     	CLR 	EA							; Disable all interrupts
1358    1205ED        7539     	CALL BEEP_F1						; Signal that RC pulse is ready
135B    1205ED        7540     	CALL BEEP_F1
135E    1205ED        7541     	CALL BEEP_F1
1361    D2AF          7542     	SETB	EA							; Enable all interrupts
1363    1205DD        7543     	CALL WAIT200MS	
                      7544     
                      7545     	; Arming sequence start
1366    754A00        7546     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      7547     ARMING_START: 
                      7548     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION	; Check if bidirectional operation
                               	MOV	A, @TEMP1				
                               	CJNE	A, #3, ($+5)
                               
                               	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                               ENDIF
                      7555     
1369    1205C9        7556     	CALL WAIT3MS
136C    788C          7557     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
136E    E6            7558     MOV A , @ R0 
136F    C3            7559     	CLR	C
1370    9401          7560     	SUBB	A, #1				; Is TX programming enabled?
1372    5003          7561     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      7562     
1374    02143D        7563     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7564     
                      7565     ARMING_INITIAL_ARM_CHECK: 
1377    E530          7566     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
1379    C3            7567     	CLR	C
137A    9401          7568     	SUBB	A, #1				; Is it the initial arm sequence?
137C    5003          7569     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      7570     
137E    02143D        7571     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      7572     
                      7573     ARMING_PPM_CHECK: 
1381    207435        7574     JB FLAGS2 . 4 , THROTTLE_HIGH_CAL_START 
                      7575     
                      7576     	; PWM tx program entry
1384    C3            7577     	CLR	C
1385    E55C          7578     	MOV	A, NEW_RCP			; Load new RC pulse value
1387    94FF          7579     SUBB A , # 255 
1389    5003          7580     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      7581     
138B    02143D        7582     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7583     
                      7584     PROGRAM_BY_TX_ENTRY_PWM: 	
138E    C2AF          7585     	CLR	EA					; Disable all interrupts
1390    120602        7586     	CALL BEEP_F4
1393    D2AF          7587     	SETB	EA					; Enable all interrupts
1395    1205D8        7588     	CALL WAIT100MS
1398    C3            7589     	CLR	C
1399    E55C          7590     	MOV	A, NEW_RCP			; Load new RC pulse value
139B    9401          7591     SUBB A , # 1 
139D    50EF          7592     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      7593     
                      7594     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
139F    C2AF          7595     	CLR	EA					; Disable all interrupts
13A1    1205ED        7596     	CALL BEEP_F1
13A4    1205CE        7597     	CALL WAIT10MS
13A7    1205ED        7598     	CALL BEEP_F1
13AA    D2AF          7599     	SETB	EA					; Enable all interrupts
13AC    1205D8        7600     	CALL WAIT100MS
13AF    C3            7601     	CLR	C
13B0    E55C          7602     	MOV	A, NEW_RCP			; Load new RC pulse value
13B2    94FF          7603     SUBB A , # 255 
13B4    40E9          7604     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      7605     
13B6    0218E9        7606     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7607     
                      7608     	; PPM throttle calibration and tx program entry
                      7609     THROTTLE_HIGH_CAL_START: 
                      7610     IF MODE <= 1	; Main or tail
13B9    7F05          7611     MOV R7 , # 5 
                      7612     ELSE
                               	MOV	TEMP8, #2				; Set 1 seconds wait time
                               ENDIF
                      7615     THROTTLE_HIGH_CAL: 			
13BB    D27F          7616     SETB FLAGS3 . 7 
13BD    3166          7617     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13BF    1205D8        7618     	CALL WAIT100MS				; Wait for new throttle value
13C2    C2AF          7619     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
13C4    C27F          7620     CLR FLAGS3 . 7 
13C6    3166          7621     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13C8    AE5C          7622     MOV R6 , NEW_RCP 
13CA    C3            7623     	CLR	C
13CB    E55C          7624     	MOV	A, NEW_RCP			; Load new RC pulse value
13CD    947F          7625     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
13CF    D2AF          7626     	SETB	EA					; Enable interrupts
13D1    4074          7627     	JC	ARM_TARGET_UPDATED		; No - branch
                      7628     
13D3    1205C4        7629     	CALL WAIT1MS		
13D6    C2AF          7630     	CLR	EA					; Disable all interrupts
13D8    120602        7631     	CALL BEEP_F4
13DB    D2AF          7632     	SETB	EA					; Enable all interrupts
13DD    DFDC          7633     DJNZ R7 , THROTTLE_HIGH_CAL 
                      7634     
13DF    319D          7635     	CALL	AVERAGE_THROTTLE
13E1    C3            7636     	CLR	C
13E2    EE            7637     MOV A , R6 
13E3    9405          7638     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
13E5    7897          7639     MOV R0 , # PGM_PPM_MAX_THROTTLE 
13E7    F6            7640     MOV @ R0 , A 
13E8    1205DD        7641     	CALL WAIT200MS				
13EB    121780        7642     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
13EE    12186C        7643     	CALL	SUCCESS_BEEP
                      7644     
                      7645     THROTTLE_LOW_CAL_START: 
13F1    7F0A          7646     MOV R7 , # 10 
                      7647     THROTTLE_LOW_CAL: 			
13F3    D27F          7648     SETB FLAGS3 . 7 
13F5    3166          7649     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13F7    1205D8        7650     	CALL WAIT100MS
13FA    C2AF          7651     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
13FC    C27F          7652     CLR FLAGS3 . 7 
13FE    3166          7653     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1400    AE5C          7654     MOV R6 , NEW_RCP 
1402    C3            7655     	CLR	C
1403    E55C          7656     	MOV	A, NEW_RCP			; Load new RC pulse value
1405    947F          7657     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
1407    D2AF          7658     	SETB	EA					; Enable interrupts
1409    50E6          7659     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      7660     
140B    1205C4        7661     	CALL WAIT1MS		
140E    C2AF          7662     	CLR	EA					; Disable all interrupts
1410    1205ED        7663     	CALL BEEP_F1
1413    1205CE        7664     	CALL WAIT10MS
1416    1205ED        7665     	CALL BEEP_F1
1419    D2AF          7666     	SETB	EA					; Enable all interrupts
141B    DFD6          7667     DJNZ R7 , THROTTLE_LOW_CAL 
                      7668     
141D    319D          7669     	CALL	AVERAGE_THROTTLE
141F    EE            7670     MOV A , R6 
1420    2405          7671     	ADD	A, #5				; Add about 2%
1422    7896          7672     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1424    F6            7673     MOV @ R0 , A 
1425    1205DD        7674     	CALL WAIT200MS				
1428    121780        7675     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
142B    12189B        7676     	CALL	SUCCESS_BEEP_INVERTED
                      7677     
                      7678     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
142E    1205D8        7679     	CALL WAIT100MS
1431    3166          7680     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1433    C3            7681     	CLR	C
1434    E55C          7682     	MOV	A, NEW_RCP			; Load new RC pulse value
1436    94FF          7683     SUBB A , # 255 
1438    40F4          7684     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      7685     
143A    0218E9        7686     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7687     
                      7688     PROGRAM_BY_TX_CHECKED: 
143D    C3            7689     	CLR	C
143E    E55C          7690     	MOV	A, NEW_RCP			; Load new RC pulse value
1440    954A          7691     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
1442    4003          7692     	JC	ARM_TARGET_UPDATED		; No - do not update
                      7693     
1444    855C4A        7694     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      7695     
                      7696     ARM_TARGET_UPDATED: 
1447    1205D8        7697     	CALL WAIT100MS				; Wait for new throttle value
144A    7801          7698     MOV R0 , # 1 
144C    7988          7699     MOV R1 , # PGM_DIRECTION 
144E    E7            7700     MOV A , @ R1 
144F    B40302        7701     	CJNE	A, #3, ($+5)			; No - branch
                      7702     
1452    7805          7703     MOV R0 , # ( RCP_STOP+4 ) 
                      7704     
1454    C3            7705     	CLR	C
1455    E55C          7706     	MOV	A, NEW_RCP			; Load new RC pulse value
1457    98            7707     SUBB A , R0 
1458    4002          7708     	JC	ARM_END_BEEP			; Yes - proceed
                      7709     
145A    6169          7710     	JMP	ARMING_START			; No - start over
                      7711     
                      7712     ARM_END_BEEP: 
                      7713     	; Beep arm sequence end signal
145C    C2AF          7714     	CLR 	EA					; Disable all interrupts
145E    120602        7715     	CALL BEEP_F4				; Signal that rcpulse is ready
1461    120602        7716     	CALL BEEP_F4
1464    120602        7717     	CALL BEEP_F4
1467    D2AF          7718     	SETB	EA					; Enable all interrupts
1469    1205DD        7719     	CALL WAIT200MS
                      7720     
                      7721     	; Clear initial arm variable
146C    753000        7722     	MOV	INITIAL_ARM, #0
                      7723     
                      7724     	; Armed and waiting for power on
                      7725     WAIT_FOR_POWER_ON: 
146F    E4            7726     	CLR	A
1470    F531          7727     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
1472    F532          7728     	MOV	POWER_ON_WAIT_CNT_H, A	
                      7729     WAIT_FOR_POWER_ON_LOOP: 
1474    0531          7730     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
1476    E531          7731     	MOV	A, POWER_ON_WAIT_CNT_L
1478    F4            7732     	CPL	A
1479    7039          7733     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      7734     
147B    0532          7735     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
147D    789A          7736     MOV R0 , # PGM_BEACON_DELAY 
147F    E6            7737     MOV A , @ R0 
1480    7819          7738     MOV R0 , # 25 
1482    14            7739     	DEC	A
1483    6012          7740     	JZ	BEEP_DELAY_SET
                      7741     
1485    7832          7742     MOV R0 , # 50 
1487    14            7743     	DEC	A
1488    600D          7744     	JZ	BEEP_DELAY_SET
                      7745     
148A    787D          7746     MOV R0 , # 125 
148C    14            7747     	DEC	A
148D    6008          7748     	JZ	BEEP_DELAY_SET
                      7749     
148F    78FA          7750     MOV R0 , # 250 
1491    14            7751     	DEC	A
1492    6003          7752     	JZ	BEEP_DELAY_SET
                      7753     
1494    753200        7754     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      7755     
                      7756     BEEP_DELAY_SET: 
1497    C3            7757     	CLR	C
1498    E532          7758     	MOV	A, POWER_ON_WAIT_CNT_H
149A    98            7759     SUBB A , R0 
149B    4017          7760     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      7761     
149D    1532          7762     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
149F    7531B4        7763     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
14A2    7899          7764     MOV R0 , # PGM_BEACON_STRENGTH 
14A4    8673          7765     MOV BEEP_STRENGTH , @ R0 
14A6    C2AF          7766     	CLR 	EA					; Disable all interrupts
14A8    120602        7767     	CALL BEEP_F4				; Signal that there is no signal
14AB    D2AF          7768     	SETB	EA					; Enable all interrupts
14AD    7898          7769     MOV R0 , # PGM_BEEP_STRENGTH 
14AF    8673          7770     MOV BEEP_STRENGTH , @ R0 
14B1    1205D8        7771     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      7772     
                      7773     WAIT_FOR_POWER_ON_NO_BEEP: 
14B4    1205CE        7774     	CALL WAIT10MS
14B7    E52A          7775     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
14B9    7005          7776     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      7777     
14BB    307402        7778     JNB FLAGS2 . 4 , WAIT_FOR_POWER_ON_PPM_NOT_MISSING 
                      7779     
14BE    416A          7780     	JMP	INIT_NO_SIGNAL					; If ppm and pulses missing - go back to detect input signal
                      7781     
                      7782     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
14C0    7801          7783     MOV R0 , # 1 
14C2    207402        7784     JB FLAGS2 . 4 , ( $+5 ) 
                      7785     
14C5    7806          7786     MOV R0 , # ( RCP_STOP+5 ) 
                      7787     
14C7    C3            7788     	CLR	C
14C8    E55C          7789     	MOV	A, NEW_RCP			; Load new RC pulse value
14CA    98            7790     SUBB A , R0 
14CB    40A7          7791     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      7792     
                      7793     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION	; Check if bidirectional operation
                               	MOV	A, @TEMP1				
                               	CLR	C
                               	SUBB	A, #3
                               	JZ 	WAIT_FOR_POWER_ON_CHECK_TIMEOUT	; Do not wait if bidirectional operation
                               ENDIF
                      7800     
14CD    1205D8        7801     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      7802     
                      7803     WAIT_FOR_POWER_ON_CHECK_TIMEOUT: 
14D0    E52A          7804     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
14D2    7003          7805     	JNZ	($+5)				; If it is not zero - proceed
                      7806     
14D4    02126A        7807     	LJMP	INIT_NO_SIGNAL			; If it is zero (pulses missing) - go back to detect input signal
                      7808     
                      7809     
                      7810     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7811     ;
                      7812     ; Start entry point
                      7813     ;
                      7814     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7815     INIT_START: 
14D7    C2AF          7816     	CLR	EA
14D9    114A          7817     	CALL SWITCH_POWER_OFF
14DB    E4            7818     	CLR	A
14DC    F522          7819     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
14DE    F523          7820     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
14E0    F524          7821     	MOV	CURRENT_PWM, A			; Set current pwm to zero
14E2    F525          7822     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
14E4    F526          7823     	MOV	CURRENT_PWM_LIM_DITH, A
14E6    F567          7824     	MOV	PWM_DITHER_EXCESS_POWER, A
14E8    D2AF          7825     	SETB	EA
14EA    7885          7826     MOV R0 , # PGM_MOTOR_IDLE 
14EC    E6            7827     MOV A , @ R0 
14ED    C3            7828     	CLR	C
14EE    33            7829     	RLC	A
14EF    F565          7830     	MOV	PWM_MOTOR_IDLE, A
14F1    E4            7831     	CLR	A
14F2    F542          7832     	MOV	GOV_TARGET_L, A		; Set target to zero
14F4    F543          7833     	MOV	GOV_TARGET_H, A
14F6    F544          7834     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
14F8    F545          7835     	MOV	GOV_INTEGRAL_H, A
14FA    F546          7836     	MOV	GOV_INTEGRAL_X, A
14FC    F570          7837     	MOV	ADC_CONVERSION_CNT, A
14FE    F52C          7838     	MOV	FLAGS0, A				; Clear flags0
1500    F52D          7839     	MOV	FLAGS1, A				; Clear flags1
1502    F536          7840     	MOV	DEMAG_DETECTED_METRIC, A	; Clear demag metric
                      7841     	;**** **** **** **** ****
                      7842     	; Motor start beginning
                      7843     	;**** **** **** **** **** 
1504    757008        7844     MOV ADC_CONVERSION_CNT , # 8 
                      7845     	SET_ADC_IP_TEMP
1507    75BB10        7845+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
150A    1205C4        7846     	CALL WAIT1MS
150D    1209B1        7847     	CALL START_ADC_CONVERSION
                      7848     READ_INITIAL_TEMP: 
                      7849     	GET_ADC_STATUS 
1510    E5E8          7849+1   MOV A , ADC0CN 
1512    20ECFB        7850     	JB	AD0BUSY, READ_INITIAL_TEMP
                      7851     	READ_ADC_RESULT						; Read initial temperature
1515    A8BD          7851+1   MOV R0 , ADC0L 
1517    A9BE          7851+1   MOV R1 , ADC0H 
1519    E9            7852     MOV A , R1 
151A    7001          7853     	JNZ	($+3)							; Is reading below 256?
                      7854     
151C    F8            7855     MOV R0 , A 
                      7856     
151D    8871          7857     MOV CURRENT_AVERAGE_TEMP , R0 
151F    1209B5        7858     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1522    757008        7859     MOV ADC_CONVERSION_CNT , # 8 
                      7860     	SET_ADC_IP_TEMP
1525    75BB10        7860+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      7861     	; Set up start operating conditions
1528    7887          7862     MOV R0 , # PGM_PWM_FREQ 
152A    E6            7863     MOV A , @ R0 
152B    FE            7864     MOV R6 , A 
152C    7602          7865     MOV @ R0 , # 2 
152E    11C8          7866     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1530    7887          7867     MOV R0 , # PGM_PWM_FREQ 
1532    EE            7868     MOV A , R6 
1533    F6            7869     MOV @ R0 , A 
                      7870     	; Set max allowed power
1534    C2AF          7871     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
1536    7561FF        7872     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1539    120A70        7873     	CALL SET_STARTUP_PWM
153C    852261        7874     	MOV	PWM_LIMIT, REQUESTED_PWM
153F    852262        7875     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
1542    852263        7876     	MOV	PWM_LIMIT_BY_RPM, REQUESTED_PWM
1545    D2AF          7877     	SETB	EA
1547    752201        7878     	MOV	REQUESTED_PWM, #1			; Set low pwm again after calling set_startup_pwm
154A    752401        7879     	MOV	CURRENT_PWM, #1
154D    752501        7880     	MOV	CURRENT_PWM_LIMITED, #1	
1550    752601        7881     	MOV	CURRENT_PWM_LIM_DITH, #1
1553    856069        7882     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1556    756A01        7883     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      7884     	; Begin startup sequence
                      7885     IF MCU_48MHZ == 1
                      7886     	SET_MCU_CLK_48MHZ
1559    75B690        7886+1   MOV FLSCL , # 90H  ; SET FLASH TIMING FOR 48MHZ
155C    75A903        7886+1   MOV CLKSEL , # 3  ; SET CLOCK TO 48MHZ
155F    757A01        7886+1   MOV CLOCK_SET_AT_48MHZ , # 1 
                      7887     ENDIF
1562    7888          7888     MOV R0 , # PGM_DIRECTION 
1564    E6            7889     MOV A , @ R0 
1565    B40307        7890     	CJNE	A, #3, INIT_START_BIDIR_DONE
                      7891     
1568    C27D          7892     CLR FLAGS3 . 5 
156A    307602        7893     JNB FLAGS2 . 6 , ( $+5 ) 
156D    D27D          7894     SETB FLAGS3 . 5 
                      7895     
                      7896     INIT_START_BIDIR_DONE: 
156F    D268          7897     SETB FLAGS1 . 0 
1571    D269          7898     SETB FLAGS1 . 1 
1573    753300        7899     	MOV	STARTUP_CNT, #0			; Reset counter
1576    120FB0        7900     	CALL COMM5COMM6				; Initialize commutation
1579    120FD5        7901     	CALL COMM6COMM1				
157C    120A97        7902     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
157F    120A97        7903     	CALL	CALC_NEXT_COMM_TIMING		
1582    120A90        7904     	CALL INITIALIZE_TIMING			; Initialize timing
1585    120A97        7905     	CALL	CALC_NEXT_COMM_TIMING		
1588    120BF4        7906     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
158B    120A90        7907     	CALL	INITIALIZE_TIMING			; Initialize timing
158E    120CB7        7908     	CALL	WAIT_BEFORE_ZC_SCAN			; Set up comparator timeout
1591    0215A0        7909     	JMP	RUN1
                      7910     
                      7911     
                      7912     
                      7913     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7914     ;
                      7915     ; Run entry point
                      7916     ;
                      7917     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7918     DAMPED_TRANSITION: 
                      7919     	; Transition from nondamped to damped if applicable
1594    C2AF          7920     	CLR	EA
1596    11C8          7921     	CALL	DECODE_PARAMETERS		; Set programmed parameters
1598    D2AF          7922     	SETB	EA
159A    757000        7923     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      7924     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
159D    75BB09        7924+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      7925     
                      7926     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      7927     ; Out_cA changes from low to high
                      7928     RUN1: 
15A0    120D0C        7929     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
15A3    120E11        7930     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
15A6    120DF2        7931     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
15A9    1206CD        7932     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
15AC    120E2E        7933     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
15AF    120E78        7934     	CALL COMM1COMM2			; Commutate
15B2    120A97        7935     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
15B5    120BE3        7936     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
15B8    120BF4        7937     	CALL CALC_NEW_WAIT_TIMES
15BB    120CB7        7938     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      7939     
                      7940     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      7941     ; Out_cB changes from high to low
                      7942     RUN2: 
15BE    120CFB        7943     	CALL WAIT_FOR_COMP_OUT_LOW
15C1    120E11        7944     	CALL SETUP_COMM_WAIT	
15C4    120DF2        7945     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
15C7    306D03        7946     JNB FLAGS1 . 5 , ( $+6 ) 
15CA    12076D        7947     	LCALL CALC_GOVERNOR_PROP_ERROR
15CD    206703        7948     JB FLAGS0 . 7 , ( $+6 ) 
15D0    1208C1        7949     	LCALL SET_PWM_LIMIT_LOW_RPM
15D3    306703        7950     JNB FLAGS0 . 7 , ( $+6 ) 
15D6    120908        7951     	LCALL SET_PWM_LIMIT_HIGH_RPM
15D9    120E2E        7952     	CALL WAIT_FOR_COMM
15DC    120E9D        7953     	CALL COMM2COMM3
15DF    120A97        7954     	CALL CALC_NEXT_COMM_TIMING
15E2    120BE3        7955     	CALL WAIT_ADVANCE_TIMING
15E5    120BF4        7956     	CALL CALC_NEW_WAIT_TIMES
15E8    120CB7        7957     	CALL WAIT_BEFORE_ZC_SCAN	
                      7958     
                      7959     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      7960     ; Out_cC changes from low to high
                      7961     RUN3: 
15EB    120D0C        7962     	CALL WAIT_FOR_COMP_OUT_HIGH
15EE    120E11        7963     	CALL SETUP_COMM_WAIT	
15F1    120DF2        7964     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
15F4    306D03        7965     JNB FLAGS1 . 5 , ( $+6 ) 
15F7    1207A9        7966     	LCALL CALC_GOVERNOR_INT_ERROR
15FA    120E2E        7967     	CALL WAIT_FOR_COMM
15FD    120F14        7968     	CALL COMM3COMM4
1600    120A97        7969     	CALL CALC_NEXT_COMM_TIMING
1603    120BE3        7970     	CALL WAIT_ADVANCE_TIMING
1606    120BF4        7971     	CALL CALC_NEW_WAIT_TIMES
1609    120CB7        7972     	CALL WAIT_BEFORE_ZC_SCAN	
                      7973     
                      7974     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      7975     ; Out_cA changes from high to low
                      7976     RUN4: 
160C    120CFB        7977     	CALL WAIT_FOR_COMP_OUT_LOW
160F    120E11        7978     	CALL SETUP_COMM_WAIT	
1612    120DF2        7979     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
1615    306D03        7980     JNB FLAGS1 . 5 , ( $+6 ) 
1618    120807        7981     	LCALL CALC_GOVERNOR_PROP_CORRECTION
161B    120E2E        7982     	CALL WAIT_FOR_COMM
161E    120F39        7983     	CALL COMM4COMM5
1621    120A97        7984     	CALL CALC_NEXT_COMM_TIMING
1624    120BE3        7985     	CALL WAIT_ADVANCE_TIMING
1627    120BF4        7986     	CALL CALC_NEW_WAIT_TIMES
162A    120CB7        7987     	CALL WAIT_BEFORE_ZC_SCAN	
                      7988     
                      7989     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      7990     ; Out_cB changes from low to high
                      7991     RUN5: 
162D    120D0C        7992     	CALL WAIT_FOR_COMP_OUT_HIGH
1630    120E11        7993     	CALL SETUP_COMM_WAIT	
1633    120DF2        7994     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
1636    306D03        7995     JNB FLAGS1 . 5 , ( $+6 ) 
1639    120865        7996     	LCALL CALC_GOVERNOR_INT_CORRECTION
163C    120E2E        7997     	CALL WAIT_FOR_COMM
163F    120FB0        7998     	CALL COMM5COMM6
1642    120A97        7999     	CALL CALC_NEXT_COMM_TIMING
1645    120BE3        8000     	CALL WAIT_ADVANCE_TIMING
1648    120BF4        8001     	CALL CALC_NEW_WAIT_TIMES
164B    120CB7        8002     	CALL WAIT_BEFORE_ZC_SCAN	
                      8003     
                      8004     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      8005     ; Out_cC changes from high to low
                      8006     RUN6: 
164E    1209B1        8007     	CALL START_ADC_CONVERSION
1651    120CFB        8008     	CALL WAIT_FOR_COMP_OUT_LOW
1654    120E11        8009     	CALL SETUP_COMM_WAIT	
1657    120DF2        8010     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
165A    120E2E        8011     	CALL WAIT_FOR_COMM
165D    120FD5        8012     	CALL COMM6COMM1
1660    1209B5        8013     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1663    120A97        8014     	CALL CALC_NEXT_COMM_TIMING
1666    120BE3        8015     	CALL WAIT_ADVANCE_TIMING
1669    120BF4        8016     	CALL CALC_NEW_WAIT_TIMES
166C    120CB7        8017     	CALL WAIT_BEFORE_ZC_SCAN	
                      8018     
                      8019     	; Check if it is direct startup
166F    30692F        8020     JNB FLAGS1 . 1 , NORMAL_RUN_CHECKS 
1672    206B2C        8021     JB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      8022     
                      8023     	; Set spoolup power variables
1675    856461        8024     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
1678    856462        8025     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
167B    856069        8026     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
167E    756A01        8027     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8028     	; Check startup counter
1681    7918          8029     MOV R1 , # 24 
1683    7A0C          8030     MOV R2 , # 12 
1685    C3            8031     	CLR	C
1686    E533          8032     	MOV	A, STARTUP_CNT				; Load counter
1688    99            8033     SUBB A , R1 
1689    4009          8034     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      8035     
168B    C269          8036     CLR FLAGS1 . 1 
168D    D26A          8037     SETB FLAGS1 . 2 
168F    8A34          8038     MOV INITIAL_RUN_ROT_CNT , R2 
                      8039     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               ENDIF
                      8042     IF MODE == 2	; Multi
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG
                               	MOV	PWM_LIMIT_BY_RPM, PWM_SPOOLUP_BEG
                               ENDIF
1691    0216A1        8046     	JMP	NORMAL_RUN_CHECKS
                      8047     
                      8048     DIRECT_START_CHECK_RCP: 
1694    C3            8049     	CLR	C
1695    E55C          8050     	MOV	A, NEW_RCP				; Load new pulse value
1697    9401          8051     SUBB A , # 1 
1699    4003          8052     	JC	($+5)
                      8053     
169B    0215A0        8054     	LJMP	RUN1						; Continue to run 
                      8055     
169E    0216F8        8056     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8057     
                      8058     
                      8059     NORMAL_RUN_CHECKS: 
                      8060     	; Check if it is initial run phase
16A1    306A1B        8061     JNB FLAGS1 . 2 , INITIAL_RUN_PHASE_DONE 
16A4    206B18        8062     JB FLAGS1 . 3 , INITIAL_RUN_PHASE_DONE 
                      8063     
                      8064     	; Decrement startup rotaton count
16A7    E534          8065     	MOV	A, INITIAL_RUN_ROT_CNT
16A9    14            8066     	DEC	A
                      8067     	; Check number of nondamped rotations
16AA    7004          8068     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      8069     
16AC    C26A          8070     CLR FLAGS1 . 2 
16AE    A194          8071     	JMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      8072     
                      8073     NORMAL_RUN_CHECK_STARTUP_ROT: 
16B0    F534          8074     	MOV	INITIAL_RUN_ROT_CNT, A		; Not zero - store counter
                      8075     
16B2    C3            8076     	CLR	C
16B3    E55C          8077     	MOV	A, NEW_RCP				; Load new pulse value
16B5    9401          8078     SUBB A , # 1 
16B7    4003          8079     	JC	($+5)
                      8080     
16B9    0215A0        8081     	LJMP	RUN1						; Continue to run 
                      8082     
16BC    0216F8        8083     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8084     
                      8085     INITIAL_RUN_PHASE_DONE: 
                      8086     IF MODE == 0	; Main
                      8087     	; Check if throttle is zeroed
16BF    C3            8088     	CLR	C
16C0    E55F          8089     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
16C2    9401          8090     	SUBB	A, #1					; Is number of stop RC pulses above limit?
16C4    4009          8091     	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                      8092     
16C6    856462        8093     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
16C9    856069        8094     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
16CC    756A01        8095     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8096     
                      8097     RUN6_CHECK_RCP_STOP_COUNT: 
                      8098     ENDIF
                      8099     	; Exit run loop after a given time
16CF    C3            8100     	CLR	C
16D0    E55F          8101     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
16D2    78FA          8102     MOV R0 , # 250 
16D4    98            8103     SUBB A , R0 
16D5    5021          8104     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      8105     
16D7    307404        8106     JNB FLAGS2 . 4 , RUN6_CHECK_DIR 
                      8107     
16DA    E52A          8108     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
16DC    601A          8109     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      8110     
                      8111     RUN6_CHECK_DIR: 
                      8112     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION		; Check if bidirectional operation
                               	MOV	A, @TEMP1				
                               	CJNE	A, #3, RUN6_CHECK_SPEED
                               
                               	JB	FLAGS3.PGM_DIR_REV, RUN6_CHECK_DIR_REV		; Check if actual rotation direction
                               	JB	FLAGS2.RCP_DIR_REV, RUN6_CHECK_DIR_CHANGE	; Matches force direction
                               	AJMP	RUN6_CHECK_SPEED
                               
                               RUN6_CHECK_DIR_REV:
                               	JNB	FLAGS2.RCP_DIR_REV, RUN6_CHECK_DIR_CHANGE
                               	AJMP	RUN6_CHECK_SPEED
                               
                               RUN6_CHECK_DIR_CHANGE:
                               	JB	FLAGS1.DIR_CHANGE_BRAKE, RUN6_CHECK_SPEED
                               
                               	SETB	FLAGS1.DIR_CHANGE_BRAKE		; Set brake flag
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set max power while braking
                               	JMP	RUN4						; Go back to run 4, thereby changing force direction
                               
                               RUN6_CHECK_SPEED:
                               ENDIF
16DE    78F0          8134     MOV R0 , # 0F0H 
16E0    306B05        8135     JNB FLAGS1 . 3 , RUN6_BRAKE_DONE 
                      8136     
16E3    856461        8137     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG 	; Set max power while braking
16E6    7820          8138     MOV R0 , # 20H 
                      8139     
                      8140     RUN6_BRAKE_DONE: 
16E8    C3            8141     	CLR	C
16E9    E53E          8142     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
16EB    98            8143     SUBB A , R0 
16EC    5002          8144     	JNC	($+4)					; Yes - stop or turn direction 
16EE    A1A0          8145     	AJMP	RUN1						; No - go back to run 1
                      8146     
                      8147     IF MODE >= 1	; Tail or multi
                               	JNB	FLAGS1.DIR_CHANGE_BRAKE, RUN_TO_WAIT_FOR_POWER_ON	; If it is not a direction change - stop
                               
                               	CLR	FLAGS1.DIR_CHANGE_BRAKE		; Clear brake flag
                               	CLR	FLAGS3.PGM_DIR_REV			; Set spinning direction. Default fwd
                               	JNB	FLAGS2.RCP_DIR_REV, ($+5)	; Check force direction
                               	SETB	FLAGS3.PGM_DIR_REV			; Set spinning direction
                               	SETB	FLAGS1.INITIAL_RUN_PHASE		
                               	MOV	INITIAL_RUN_ROT_CNT, #18
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set initial max power
                               	AJMP	RUN1						; Go back to run 1 
                               ENDIF
                      8159     
                      8160     RUN_TO_WAIT_FOR_POWER_ON_FAIL: 	
16F0    0535          8161     	INC	STALL_CNT					; Increment stall count
16F2    E55C          8162     	MOV	A, NEW_RCP				; Check if RCP is zero, then it is a normal stop			
16F4    6002          8163     	JZ	RUN_TO_WAIT_FOR_POWER_ON
16F6    C1FB          8164     	AJMP	RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE
                      8165     
                      8166     RUN_TO_WAIT_FOR_POWER_ON: 	
16F8    753500        8167     	MOV	STALL_CNT, #0
                      8168     
                      8169     RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE: 
16FB    C2AF          8170     	CLR	EA
16FD    114A          8171     	CALL SWITCH_POWER_OFF
16FF    7887          8172     MOV R0 , # PGM_PWM_FREQ 
1701    E6            8173     MOV A , @ R0 
1702    FE            8174     MOV R6 , A 
1703    7602          8175     MOV @ R0 , # 2 
1705    11C8          8176     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1707    7887          8177     MOV R0 , # PGM_PWM_FREQ 
1709    EE            8178     MOV A , R6 
170A    F6            8179     MOV @ R0 , A 
170B    E4            8180     	CLR	A
170C    F522          8181     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
170E    F523          8182     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
1710    F524          8183     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1712    F525          8184     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1714    F526          8185     	MOV	CURRENT_PWM_LIM_DITH, A	
1716    F565          8186     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1718    C268          8187     CLR FLAGS1 . 0 
                      8188     IF MCU_48MHZ == 1
                      8189     	SET_MCU_CLK_24MHZ
171A    75B680        8189+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
171D    75A900        8189+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
1720    757A00        8189+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      8190     ENDIF
1723    D2AF          8191     	SETB	EA
1725    1205C4        8192     	CALL	WAIT1MS					; Wait for pwm to be stopped
1728    114A          8193     	CALL SWITCH_POWER_OFF
                      8194     IF MODE == 0	; Main
172A    307406        8195     JNB FLAGS2 . 4 , RUN_TO_NEXT_STATE_MAIN 
                      8196     
172D    E52A          8197     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
172F    7002          8198     	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                      8199     
1731    416A          8200     	JMP	INIT_NO_SIGNAL				; If it is zero (pulses missing) - go back to detect input signal
                      8201     
                      8202     RUN_TO_NEXT_STATE_MAIN: 
1733    788D          8203     MOV R0 , # PGM_MAIN_REARM_START 
1735    E6            8204     MOV A , @ R0 
1736    C3            8205     	CLR	C
1737    9401          8206     	SUBB	A, #1					; Is re-armed start enabled?
1739    4002          8207     	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                      8208     
173B    6146          8209     	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                      8210     
                      8211     JMP_WAIT_FOR_POWER_ON: 
173D    816F          8212     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      8213     ENDIF
                      8214     IF MODE >= 1	; Tail or multi
                               	JNB	FLAGS2.RCP_PPM, JMP_WAIT_FOR_POWER_ON	; If flag is not set (PWM) - branch
                               
                               	CLR	C
                               	MOV	A, STALL_CNT
                               	SUBB	A, #5
                               	JC	JMP_WAIT_FOR_POWER_ON
                               	JMP	INIT_NO_SIGNAL
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      8226     
                      8227     
                      8228     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8229     
                      8230     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      8890     $INCLUDE (BLHELIBOOTLOAD.INC)			; Include source code for bootloader
                      9283     
                      9284     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      9285     
                      9286     
------                9287     CSEG AT 19FDH
                      9288     RESET: 
19FD    0211C8        9289     LJMP	PGM_START
                      9290     
                      9291     
                      9292     
                      9293     
                      9294     END
MACRO ASSEMBLER BLHELI                                      12/30/15 18:06:58 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

SET4 . . . . . . .  C ADDR   1CC5H   A 
ID3. . . . . . . .  C ADDR   1C52H   A 
BYTE_CNTH. . . . .  D ADDR   0028H   A 
CRCH . . . . . . .  D ADDR   0023H   A 
CMDL . . . . . . .    REG    R4             
XH . . . . . . . .    REG    R1             
NORMAL_RUN_CHECK_~  C ADDR   16B0H   A 
DECODE_DEMAG_HIGH.  C ADDR   114FH   A 
COMM61_DAMP_REV. .  C ADDR   0FFBH   A 
COMP_WAIT_ON_COMP~  C ADDR   0D43H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CFAH   A 
CHECK_TEMP_VOLTAG~  C ADDR   09B5H   A 
MEASURE_LIPO_WAIT~  C ADDR   092FH   A 
GOVERNOR_LIMIT_IN~  C ADDR   088CH   A 
GOVERNOR_CORR_NEG~  C ADDR   0854H   A 
PCA_INT_PPM_BELOW~  C ADDR   04FCH   A 
EEP_PGM_MAIN_SPOO~  C ADDR   1A22H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
TIMER0_OVERFLOW_V~  D ADDR   0079H   A 
PPM_THROTTLE_GAIN.  D ADDR   0072H   A 
LIPO_ADC_LIMIT_H .  D ADDR   006FH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005EH   A 
RCP_EDGE_H . . . .  D ADDR   0058H   A 
FLAGS3 . . . . . .  D ADDR   002FH   A 
RCP_PREV_EDGE_L. .  D ADDR   0027H   A 
ADC_IP . . . . . .  N NUMB   0001h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
POLARIS_THUNDER_4~  N NUMB   008Fh            
POLARIS_THUNDER_3~  N NUMB   008Dh            
POLARIS_THUNDER_1~  N NUMB   0087h            
SET5 . . . . . . .  C ADDR   1CCBH   A 
ID4. . . . . . . .  C ADDR   1C5DH   A 
BOOT_START . . . .  N NUMB   1C00h            
FUNCTION_BEEP. . .  C ADDR   18D0H   A 
INIT_START . . . .  C ADDR   14D7H   A 
PROGRAM_BY_TX_ENT~  C ADDR   138EH   A 
FIND_THROTTLE_GAI~  C ADDR   1180H   A 
COMM45_NONDAMP . .  C ADDR   0F7FH   A 
COMM4COMM5 . . . .  C ADDR   0F39H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B3EH   A 
CHECK_VOLTAGE_SPO~  C ADDR   0A53H   A 
SET_PWM_LIMIT_HIG~  C ADDR   0918H   A 
SET_PWM_DEMAG_DONE  C ADDR   08DDH   A 
CALC_GOVERNOR_SUB~  C ADDR   0760H   A 
PCA_INT_RESTORE_E~  C ADDR   0479H   A 
T2H_INT_RCP_STOP .  C ADDR   0288H   A 
T0_INT_PWM_OFF_DA~  C ADDR   013FH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
EEP_MAIN_REARM_ST~  C ADDR   1A10H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006DH   A 
RANDOM . . . . . .  D ADDR   0068H   A 
PWM_MOTOR_IDLE . .  D ADDR   0065H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005DH   A 
NEXT_WT_START_L. .  D ADDR   0053H   A 
COMM_PERIOD4X_H. .  D ADDR   003EH   A 
PWM_START. . . . .  N NUMB   0032h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D6h            
EMAX_NANO_20A_TAIL  N NUMB   00B3h            
PLATINUM_50AV3_TA~  N NUMB   00A1h            
PLATINUM_PRO_30A_~  N NUMB   009Ah            
POLARIS_THUNDER_4~  N NUMB   0090h            
H_KING_35A_TAIL. .  N NUMB   0080h            
SET6 . . . . . . .  C ADDR   1CD3H   A 
ID5. . . . . . . .  C ADDR   1C6AH   A 
ERRORPROG. . . . .  N NUMB   00C5h            
ERRORCRC . . . . .  N NUMB   00C2h            
BOOT_DELAY . . . .  N NUMB   5F5E10h            
PARAVAL_BEEP . . .  C ADDR   18DEH   A 
COMM45_DAMP_REV. .  C ADDR   0F5FH   A 
COMM23_NFET_DONE .  C ADDR   0EF5H   A 
GOVERNOR_CHECK_PWM  C ADDR   07E2H   A 
GOVERNOR_ACTIVATE.  C ADDR   0719H   A 
PWM_AFET_DAMPED_D~  C ADDR   0187H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
DEMAG_DETECTED_ME~  D ADDR   0036H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
SIGNATURE_001. . .  N NUMB   00F3h            
RTX_PORT . . . . .  N NUMB   0080h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
EMAX_NANO_20A_MUL~  N NUMB   00B4h            
PLATINUM_50AV3_MU~  N NUMB   00A2h            
POLARIS_THUNDER_6~  N NUMB   0092h            
H_KING_35A_MULTI .  N NUMB   0081h            
TURNIGY_AE_25A_MA~  N NUMB   0043h            
TURNIGY_AE_20A_TA~  N NUMB   0041h            
TURNIGY_PLUSH_10A~  N NUMB   001Fh            
XP_35A_SW_TAIL . .  N NUMB   0014h            
GETC . . . . . . .  C ADDR   1D7FH   A 
BIT_CNT. . . . . .  D ADDR   0026H   A 
BOOT_PAGES . . . .  N NUMB   0001h            
WRITE_EEPROM_SIGN~  C ADDR   17F2H   A 
WAIT_FOR_POWER_ON.  C ADDR   146FH   A 
THROTTLE_LOW_CAL_~  C ADDR   13F1H   A 
ERASE_AND_STORE_A~  C ADDR   1780H   A 
PROGRAM_BY_TX_CHE~  C ADDR   143DH   A 
ARMING_INITIAL_AR~  C ADDR   1377H   A 
FIND_THROTTLE_GAI~  C ADDR   1179H   A 
SET_DEFAULT_PARAM~  C ADDR   105FH   A 
COMM56_REV . . . .  C ADDR   0FC4H   A 
COMM23_NFET_OFF_R~  C ADDR   0ED9H   A 
COMP_READ_OK . . .  C ADDR   0DDBH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0BDEH   A 
CALC_NEXT_COMM_TI~  C ADDR   0A97H   A 
COMM5COMM6 . . . .  C ADDR   0FB0H   A 
CALC_GOVERNOR_TAR~  C ADDR   076CH   A 
PCA_INT_STORE_DATA  C ADDR   049EH   A 
T2_INT_RCP_UPDATE~  C ADDR   022EH   A 
PWM_BFET_DAMPED_D~  C ADDR   0198H   A 
RESET. . . . . . .  C ADDR   19FDH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   00A4H   A 
PGM_ENABLE_TEMP_P~  I ADDR   00A0H   A 
_PGM_THROTTLE_RATE  I ADDR   009BH   A 
_PGM_STARTUP_RPM .  I ADDR   008FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   0062H   A 
RCP_PREPREV_EDGE_H  D ADDR   0056H   A 
WT_ZC_SCAN_START_L  D ADDR   004DH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0003h            
STARTUP_PHASE. . .  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
SIGNATURE_002. . .  N NUMB   0090h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C5h            
POLARIS_THUNDER_6~  N NUMB   0093h            
SKYWALKER_20A_MAIN  N NUMB   0058h            
TURNIGY_AE_30A_TA~  N NUMB   0047h            
TURNIGY_AE_20A_MU~  N NUMB   0042h            
XP_35A_SW_MULTI. .  N NUMB   0015h            
XP_7A_MAIN . . . .  N NUMB   0004h            
PRO3 . . . . . . .  C ADDR   1D01H   A 
BOOT_SIGN. . . . .  C ADDR   1DD6H   A 
BYTE_CNTL. . . . .  D ADDR   0027H   A 
BAUDH. . . . . . .  D ADDR   0025H   A 
CRCL . . . . . . .  D ADDR   0022H   A 
XL . . . . . . . .    REG    R0             
FUNCTION_NEXT. . .  C ADDR   1948H   A 
THROTTLE_HIGH_CAL.  C ADDR   13BBH   A 
COMM61_NFET_DONE .  C ADDR   102CH   A 
STORE_TIMES_INCRE~  C ADDR   0CA9H   A 
STARTUP_PWM_SET_P~  C ADDR   0A85H   A 
PWM_CFET_DAMPED_D~  C ADDR   01A9H   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006EH   A 
RCP_EDGE_L . . . .  D ADDR   0057H   A 
COMM_DIFF. . . . .  D ADDR   003FH   A 
STALL_CNT. . . . .  D ADDR   0035H   A 
GOV_SPOOLRATE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
RTX_PIN. . . . . .  N NUMB   0005h            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C6h            
POLARIS_THUNDER_8~  N NUMB   0095h            
TURNIGY_KFORCE_12~  N NUMB   0053h            
TURNIGY_AE_45A_MA~  N NUMB   0049h            
TURNIGY_AE_30A_MU~  N NUMB   0048h            
TURNIGY_PLUSH_30A~  N NUMB   002Bh            
TURNIGY_PLUSH_12A~  N NUMB   0022h            
XP_3A_TAIL . . . .  N NUMB   0002h            
PRO4 . . . . . . .  C ADDR   1D0DH   A 
MAIN . . . . . . .  C ADDR   1C7CH   A 
PARAVAL_NEXT . . .  C ADDR   1933H   A 
WRITE_EEPROM_BYTE.  C ADDR   17C6H   A 
TEST_FOR_ONESHOT .  C ADDR   1332H   A 
MEASURE_PWM_FREQ_~  C ADDR   12DFH   A 
COMM61_NFET_OFF_R~  C ADDR   1011H   A 
COMM_EXIT. . . . .  C ADDR   1047H   A 
CALC_GOVERNOR_INT~  C ADDR   0865H   A 
PCA_INT_PPM_CHECK~  C ADDR   0517H   A 
PCA_INT_FALL_CHEC~  C ADDR   04EEH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0563H   A 
PCA_INT_LIMITED. .  C ADDR   0586H   A 
T2H_INT_RCP_SET_L~  C ADDR   0301H   A 
T2H_INT_START. . .  C ADDR   026CH   A 
T2_INT_PWM_UPDATE.  C ADDR   023FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   012DH   A 
EEP_DUMMY. . . . .  C ADDR   1A27H   A 
EEP_PGM_ENABLE_PW~  C ADDR   1A25H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A13H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
CLOCK_SET_AT_48MHZ  D ADDR   007AH   A 
COMM_PERIOD4X_L. .  D ADDR   003DH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
RTX_MDIN . . . . .  N NUMB   00F1h            
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0000h            
POLARIS_THUNDER_8~  N NUMB   0096h            
SKYWALKER_40A_MAIN  N NUMB   005Bh            
TURNIGY_KFORCE_12~  N NUMB   0054h            
TURNIGY_PLUSH_40A~  N NUMB   002Eh            
SUPERMICRO_3P5A_M~  N NUMB   0019h            
XP_3A_MULTI. . . .  N NUMB   0003h            
WAIT1. . . . . . .  C ADDR   1DCFH   A 
PRO5 . . . . . . .  C ADDR   1D13H   A 
FUNC_PARAVAL_WAIT.  C ADDR   18FCH   A 
WRITE_TAG. . . . .  C ADDR   181DH   A 
READ_EEPROM_STORE~  C ADDR   1758H   A 
RUN6_CHECK_DIR . .  C ADDR   16DEH   A 
RUN1 . . . . . . .  C ADDR   15A0H   A 
WAIT_FOR_POWER_ON~  C ADDR   14D0H   A 
MEASURE_PWM_FREQ_~  C ADDR   12F0H   A 
CLEAR_RAM. . . . .  C ADDR   1235H   A 
SET_BEC_VOLTAGE. .  C ADDR   1165H   A 
DECODE_DEMAG_DONE.  C ADDR   1158H   A 
COMM45_NFET_DONE .  C ADDR   0F91H   A 
WAIT_FOR_COMM. . .  C ADDR   0E2EH   A 
ADJUST_TIMING_TWO~  C ADDR   0C9CH   A 
MEASURE_LIPO_ADD_~  C ADDR   09A4H   A 
CALC_GOVERNOR_PRO~  C ADDR   07A8H   A 
DIV_U16_BY_U16_DI~  C ADDR   0646H   A 
WAIT100MS. . . . .  C ADDR   05D8H   A 
WAIT1MS. . . . . .  C ADDR   05C4H   A 
T0_INT_PWM_OFF_TI~  C ADDR   010DH   A 
T0_INT_PWM_OFF_SE~  C ADDR   010BH   A 
STARTUP_POWER_TAB~  C ADDR   008DH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
SKIP_T2_INT. . . .  D ADDR   0077H   A 
TX_PGM_BEEP_NO . .  D ADDR   0076H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   006AH   A 
WT_ZC_TOUT_START_H  D ADDR   0050H   A 
RCP_SKIP_RATE. . .  N NUMB   0020h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
RTX_MDOUT. . . . .  N NUMB   00A4h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D7h            
PLATINUM_PRO_30A_~  N NUMB   009Bh            
TURNIGY_KFORCE_12~  N NUMB   0055h            
RD1. . . . . . . .  C ADDR   1D2AH   A 
PRO6 . . . . . . .  C ADDR   1D20H   A 
ABD. . . . . . . .  C ADDR   1C2BH   A 
FUNCTION_PARAVAL_~  C ADDR   18CAH   A 
STORE_NEW_VALUE_I~  C ADDR   1826H   A 
RUN2 . . . . . . .  C ADDR   15BEH   A 
ARMING_PPM_CHECK .  C ADDR   1381H   A 
COMM45_NFET_OFF_R~  C ADDR   0F75H   A 
COMM23_FETS_DONE .  C ADDR   0EBBH   A 
COMP_READ_WRONG_T~  C ADDR   0DBBH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CB7H   A 
STORE_TIMES_EXIT .  C ADDR   0C82H   A 
MEASURE_LIPO_UPDA~  C ADDR   09ACH   A 
GOVERNOR_CORR_INT~  C ADDR   08ABH   A 
GOVERNOR_STORE_PR~  C ADDR   07A4H   A 
DIV_U16_BY_U16_DI~  C ADDR   0650H   A 
WAIT200MS. . . . .  C ADDR   05DDH   A 
T2_INT_CURRENT_PW~  C ADDR   0241H   A 
T2_INT_PULSES_ABS~  C ADDR   01D9H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_MAIN_SPOOLUP_~  I ADDR   009FH   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0055H   A 
GOV_ACTIVE . . . .  N NUMB   0005h            
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D8h            
PLATINUM_PRO_30A_~  N NUMB   009Ch            
TURNIGY_AE_25A_TA~  N NUMB   0044h            
TURNIGY_PLUSH_60A~  N NUMB   0031h            
TURNIGY_PLUSH_10A~  N NUMB   0020h            
MAI1 . . . . . . .  C ADDR   1C7EH   A 
IN1. . . . . . . .  C ADDR   1C74H   A 
BAUDL. . . . . . .  D ADDR   0024H   A 
RUN3 . . . . . . .  C ADDR   15EBH   A 
CHECK_VOLTAGE_EXIT  C ADDR   0A63H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0893H   A 
GOVERNOR_CHECK_IN~  C ADDR   07CAH   A 
DIV_U16_BY_U16_DI~  C ADDR   0667H   A 
WAIT3MS. . . . . .  C ADDR   05C9H   A 
T2_INT_PULSES_ABS~  C ADDR   020EH   A 
T0_INT_PWM_ON_TIM~  C ADDR   00EDH   A 
T0_INT_PWM_ON_SET~  C ADDR   00EBH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0045H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
RCP_PPM_ONESHOT125  N NUMB   0005h            
DIR_CHANGE_BRAKE .  N NUMB   0003h            
DEMAG_ENABLED. . .  N NUMB   0004h            
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
POLARIS_THUNDER_1~  N NUMB   0097h            
SKYWALKER_20A_TAIL  N NUMB   0059h            
TURNIGY_AE_25A_MU~  N NUMB   0045h            
TURNIGY_PLUSH_25A~  N NUMB   0028h            
TURNIGY_PLUSH_10A~  N NUMB   0021h            
XP_7A_TAIL . . . .  N NUMB   0005h            
PUTP . . . . . . .  C ADDR   1D40H   A 
SETBUF . . . . . .  C ADDR   1CBFH   A 
MAI2 . . . . . . .  C ADDR   1CA0H   A 
ERRORCOMMAND . . .  N NUMB   00C1h            
BEEP_NO_ENTRY. . .  C ADDR   18F5H   A 
JMP_WAIT_FOR_POWE~  C ADDR   173DH   A 
DIRECT_START_CHEC~  C ADDR   1694H   A 
RUN4 . . . . . . .  C ADDR   160CH   A 
COMM61_FETS_DONE .  C ADDR   0FF3H   A 
COMM23_NONDAMP_REV  C ADDR   0EFDH   A 
COMP_READ_OK_JMP .  C ADDR   0DEDH   A 
STORE_TIMES_UP_OR~  C ADDR   0C40H   A 
STORE_TIMES_DECRE~  C ADDR   0C53H   A 
CALC_NEXT_COMM_NE~  C ADDR   0B23H   A 
TEMP_AVERAGE_INC .  C ADDR   09EFH   A 
GOVERNOR_CORR_INT~  C ADDR   08BCH   A 
MULT_S16_BY_U8_DI~  C ADDR   0676H   A 
PCA_INT_PPM_NEG_C~  C ADDR   053BH   A 
T2_INT_EXIT. . . .  C ADDR   0252H   A 
_EEP_PGM_DAMPING_~  C ADDR   1A16H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PWM_DITHER_EXCESS~  D ADDR   0067H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   005Ah            
TURNIGY_AE_45A_TA~  N NUMB   004Ah            
TURNIGY_PLUSH_80A~  N NUMB   0034h            
TURNIGY_PLUSH_30A~  N NUMB   002Ch            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
XP_7A_MULTI. . . .  N NUMB   0006h            
PUT1 . . . . . . .  C ADDR   1D46H   A 
READ_TAGS. . . . .  C ADDR   1802H   A 
RUN5 . . . . . . .  C ADDR   162DH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B95H   A 
SET_PWM_LIMIT_HIG~  C ADDR   0908H   A 
GOVERNOR_CORR_NEG~  C ADDR   08B0H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0799H   A 
GOVERNOR_TARGET_C~  C ADDR   071BH   A 
CALC_GOVERNOR_TAR~  C ADDR   06CDH   A 
PCA_INT_PWM_DIVID~  C ADDR   056AH   A 
PCA_INT_CHECK_12K~  C ADDR   041DH   A 
T2H_INT_RCP_BAILO~  C ADDR   0332H   A 
_EEP_PGM_MOTOR_GA~  C ADDR   1A07H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
CURRENT_PWM_LIMIT~  D ADDR   007CH   A 
BEEP_STRENGTH. . .  D ADDR   0073H   A 
RCP_PREV_PERIOD_H.  D ADDR   005AH   A 
WT_COMM_START_H. .  D ADDR   0052H   A 
WT_ZC_TOUT_START_L  D ADDR   004FH   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
F85_3A_MAIN. . . .  N NUMB   00D3h            
SKYWALKER_40A_TAIL  N NUMB   005Ch            
TURNIGY_AE_45A_MU~  N NUMB   004Bh            
TURNIGY_PLUSH_40A~  N NUMB   002Fh            
TURNIGY_PLUSH_30A~  N NUMB   002Dh            
TURNIGY_PLUSH_18A~  N NUMB   0025h            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
SUPERMICRO_3P5A_T~  N NUMB   001Ah            
PUT2 . . . . . . .  C ADDR   1D59H   A 
MAI4 . . . . . . .  C ADDR   1CD6H   A 
BAUDTIME . . . . .  N NUMB   0198h            
RUN6 . . . . . . .  C ADDR   164EH   A 
ARMING_START . . .  C ADDR   1369H   A 
MEASURE_PWM_FREQ_~  C ADDR   12E5H   A 
COMM61_NONDAMP_REV  C ADDR   1033H   A 
COMM45_FETS_DONE .  C ADDR   0F57H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CBFH   A 
GOVERNOR_DEACTIVA~  C ADDR   06FAH   A 
PCA_INT_CHECK_LEG~  C ADDR   057BH   A 
PCA_INT_FALL_NOT_~  C ADDR   04CFH   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
PREV_PREV_COMM_H .  D ADDR   003CH   A 
RCP_UPDATED. . . .  N NUMB   0000h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0040h            
MUX_A1 . . . . . .  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Ah            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
FLYCOLOR_FAIRY_30~  N NUMB   00C7h            
ROTORGEEKS_20A_MA~  N NUMB   00C1h            
ALIGN_RCE_BL15P_M~  N NUMB   006Dh            
SKYWALKER_40A_MUL~  N NUMB   005Dh            
TURNIGY_KFORCE_12~  N NUMB   0056h            
TURNIGY_PLUSH_40A~  N NUMB   0030h            
SUPERMICRO_3P5A_M~  N NUMB   001Bh            
DP_3A_MAIN . . . .  N NUMB   0016h            
PUT3 . . . . . . .  C ADDR   1D65H   A 
MAI5 . . . . . . .  C ADDR   1D25H   A 
WAIT_FOR_LOW . . .  C ADDR   1C42H   A 
PARAH. . . . . . .    REG    R3             
STORE_MAIN_FUNC_1.  C ADDR   182AH   A 
ARM_TARGET_UPDATED  C ADDR   1447H   A 
EVALUATE_COMPARAT~  C ADDR   0DF2H   A 
COMP_WAIT_READ_CO~  C ADDR   0D82H   A 
TEMP_CHECK_EXIT. .  C ADDR   0A19H   A 
GOVERNOR_APPLY_PR~  C ADDR   083BH   A 
T2H_INT_RCP_GOV_B~  C ADDR   02BEH   A 
PWM_AFET_EXIT. . .  C ADDR   0164H   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_PWM_IN~  I ADDR   00A2H   A 
_PGM_STARTUP_ACCEL  I ADDR   0090H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
CURRENT_PWM_LIM_D~  D ADDR   007DH   A 
GOV_INTEGRAL_L . .  D ADDR   0044H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0025h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
TURNIGY_KFORCE_12~  N NUMB   0057h            
TURNIGY_PLUSH_60A~  N NUMB   0032h            
PUT4 . . . . . . .  C ADDR   1D77H   A 
MAI6 . . . . . . .  C ADDR   1D36H   A 
CNTH . . . . . . .    REG    R7             
STORE_MAIN_FUNC_2.  C ADDR   182FH   A 
WRITE_EEPROM_BLOC~  C ADDR   17A3H   A 
NORMAL_RUN_CHECKS.  C ADDR   16A1H   A 
INIT_NO_SIGNAL . .  C ADDR   126AH   A 
COMM45_NONDAMP_REV  C ADDR   0F99H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D1AH   A 
WAIT_ADVANCE_TIMI~  C ADDR   0BE3H   A 
CALC_NEW_WAIT_PER~  C ADDR   0B4DH   A 
CALC_GOVERNOR_PRO~  C ADDR   076DH   A 
T2_INT_PPM_TIMEOU~  C ADDR   021AH   A 
PWM_BFET_EXIT. . .  C ADDR   016EH   A 
T0_INT_PWM_OFF_EX~  C ADDR   011AH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
POLARIS_THUNDER_1~  N NUMB   0098h            
ALIGN_RCE_BL35P_M~  N NUMB   0073h            
TURNIGY_PLUSH_60A~  N NUMB   0033h            
TURNIGY_PLUSH_25A~  N NUMB   0029h            
POLYNOM. . . . . .  N NUMB   A001h            
STORE_MAIN_FUNC_3.  C ADDR   1834H   A 
WRITE_EEPROM_BLOC~  C ADDR   17B1H   A 
PROGRAM_BY_TX_ENT~  C ADDR   142EH   A 
READ_ALL_EEPROM_P~  C ADDR   173FH   A 
COMM23_NFET_DONE_~  C ADDR   0F0CH   A 
CALC_NEXT_COMM_NE~  C ADDR   0B2CH   A 
PWM_CFET_EXIT. . .  C ADDR   0178H   A 
T0_INT . . . . . .  C ADDR   00B5H   A 
_EEP_PGM_PWM_DITH~  C ADDR   1A26H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A18H   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
SKIP_T2H_INT . . .  D ADDR   0078H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006BH   A 
RCP_STOP_CNT . . .  D ADDR   005FH   A 
NEW_RCP. . . . . .  D ADDR   005CH   A 
RCP_PREV_PERIOD_L.  D ADDR   0059H   A 
WT_COMM_START_L. .  D ADDR   0051H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
INITIAL_RUN_PHASE.  N NUMB   0002h            
HIGH_RPM . . . . .  N NUMB   0007h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00D0h            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0003h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
POLARIS_THUNDER_1~  N NUMB   0099h            
TURNIGY_PLUSH_80A~  N NUMB   0035h            
TURNIGY_PLUSH_25A~  N NUMB   002Ah            
STORE_MAIN_FUNC_4.  C ADDR   1839H   A 
INIT_START_BIDIR_~  C ADDR   156FH   A 
EVAL_COMP_EXIT . .  C ADDR   0E10H   A 
MEASURE_LIPO_ADJU~  C ADDR   0973H   A 
PCA_INT_SET_TIMEO~  C ADDR   059EH   A 
PWM_NOFET. . . . .  C ADDR   015AH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00D9H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
PREV_PREV_COMM_L .  D ADDR   003BH   A 
PREV_COMM_H. . . .  D ADDR   003AH   A 
RCP_DIR_REV. . . .  N NUMB   0006h            
RCP_TIMEOUT_CNT. .  D ADDR   002AH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0004h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
F85_3A_TAIL. . . .  N NUMB   00D4h            
FVT_LITTLEBEE_20A~  N NUMB   00CAh            
MDRX62H_MAIN . . .  N NUMB   00BEh            
TURNIGY_PLUSH_80A~  N NUMB   0036h            
TURNIGY_PLUSH_18A~  N NUMB   0026h            
XP_12A_MAIN. . . .  N NUMB   000Ah            
PUTW . . . . . . .  C ADDR   1D38H   A 
PARAL. . . . . . .    REG    R2             
STORE_MAIN_FUNC_5.  C ADDR   183EH   A 
BOOTLOADER_DONE. .  C ADDR   127AH   A 
AVERAGE_THROTTLE .  C ADDR   119DH   A 
DECODE_PARAMS_DIR~  C ADDR   10DDH   A 
COMM61_NFET_DONE_~  C ADDR   1042H   A 
SETUP_COMM_WAIT. .  C ADDR   0E11H   A 
CALC_NEXT_COMM_TI~  C ADDR   0B96H   A 
CHECK_VOLTAGE_LIM.  C ADDR   0A49H   A 
CALC_GOVERNOR_INT~  C ADDR   0806H   A 
T2_INT . . . . . .  C ADDR   01ADH   A 
_PGM_DAMPING_FORCE  I ADDR   0093H   A 
AUTO_BAILOUT_ARMED  D ADDR   0060H   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
MOTOR_PPM_LOW_SLO~  N NUMB   002Bh            
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0002h            
CNFET. . . . . . .  N NUMB   0007h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
F85_3A_MULTI . . .  N NUMB   00D5h            
FVT_LITTLEBEE_30A~  N NUMB   00CDh            
FLYCOLOR_FAIRY_30~  N NUMB   00C8h            
ROTORGEEKS_20A_TA~  N NUMB   00C2h            
ALIGN_RCE_BL15P_T~  N NUMB   006Eh            
RCTIMER_6A_MAIN. .  N NUMB   0067h            
TURNIGY_PLUSH_NFE~  N NUMB   003Dh            
TURNIGY_PLUSH_18A~  N NUMB   0027h            
DP_3A_TAIL . . . .  N NUMB   0017h            
XP_7A_FAST_MAIN. .  N NUMB   0007h            
GET1 . . . . . . .  C ADDR   1D84H   A 
BYTE_REG . . . . .  D ADDR   0021H   A 
CNTL . . . . . . .    REG    R6             
STORE_MAIN_FUNC_6.  C ADDR   1843H   A 
ARM_END_BEEP . . .  C ADDR   145CH   A 
THROTTLE_HIGH_CAL~  C ADDR   13B9H   A 
PGM_START. . . . .  C ADDR   11C8H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0CFBH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0BF4H   A 
LOAD_MIN_TIME. . .  C ADDR   0B91H   A 
SET_STARTUP_PWM. .  C ADDR   0A70H   A 
GOVERNOR_STORE_IN~  C ADDR   0800H   A 
T2H_INT_RCP_GOV_B~  C ADDR   02ABH   A 
T2H_INT_EXIT . . .  C ADDR   033DH   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   0347H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0075H   A 
ADC_CONVERSION_CNT  D ADDR   0070H   A 
GOV_ARM_TARGET . .  D ADDR   004AH   A 
RCP_PPM. . . . . .  N NUMB   0004h            
RCP_OUTSIDE_RANGE~  D ADDR   0029H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0005h            
ADC_LIMIT_L. . . .  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
GRAUPNER_ULTRA_20~  N NUMB   00D0h            
FLYCOLOR_FAIRY_30~  N NUMB   00C9h            
ROTORGEEKS_20A_MU~  N NUMB   00C3h            
EMAX_20A_MAIN. . .  N NUMB   00ACh            
TAROT_30A_MAIN . .  N NUMB   00A6h            
ALIGN_RCE_BL15P_M~  N NUMB   006Fh            
DP_3A_MULTI. . . .  N NUMB   0018h            
GET2 . . . . . . .  C ADDR   1D99H   A 
FUNC_PARAVAL . . .  C ADDR   18F8H   A 
WAIT1S_LOOP. . . .  C ADDR   1866H   A 
STORE_MAIN_FUNC_7.  C ADDR   1848H   A 
AVERAGE_THROTTLE_~  C ADDR   11B9H   A 
MEASURE_LIPO_DIVI~  C ADDR   0989H   A 
CALC_GOVERNOR_PRO~  C ADDR   0864H   A 
GOVERNOR_INT_MIN_~  C ADDR   07FBH   A 
GOVERNOR_LIMIT_PR~  C ADDR   07A0H   A 
BEEP_F1. . . . . .  C ADDR   05EDH   A 
PCA_INT_PPM_OUTSI~  C ADDR   0505H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   0071H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0064H   A 
PWM_LIMIT. . . . .  D ADDR   0061H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0006h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
ALIGN_RCE_BL35P_T~  N NUMB   0074h            
GET3 . . . . . . .  C ADDR   1DBDH   A 
STORE_MAIN_FUNC_8.  C ADDR   184DH   A 
INITIAL_RUN_PHASE~  C ADDR   16BFH   A 
TEST_THROTTLE_GAIN  C ADDR   118EH   A 
COMM23_FETS_DONE_~  C ADDR   0EDBH   A 
CALC_NEXT_COMM_ST~  C ADDR   0AF4H   A 
GOVERNOR_STORE_PR~  C ADDR   0862H   A 
GOVERNOR_CHECK_PR~  C ADDR   0826H   A 
MULT_S16_BY_U8_PO~  C ADDR   0690H   A 
DIV_U16_BY_U16 . .  C ADDR   063EH   A 
BEEP_ONOFF . . . .  C ADDR   060BH   A 
BEEP_F2. . . . . .  C ADDR   05F4H   A 
PCA_INT_CHECK_DIFF  C ADDR   0491H   A 
T2H_INT_RCP_INC_L~  C ADDR   0326H   A 
T2H_INT_RCP_GOV_P~  C ADDR   02CBH   A 
T2_INT_SKIP_START.  C ADDR   021EH   A 
PWM_AFET . . . . .  C ADDR   015CH   A 
T0_INT_PWM_OFF_FU~  C ADDR   014CH   A 
EEP_PGM_ENABLE_PO~  C ADDR   1A24H   A 
EEPROM_LAYOUT_REV~  N NUMB   0014h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
PREV_COMM_L. . . .  D ADDR   0039H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
XROTOR_10A_MAIN. .  N NUMB   00B5h            
EMAX_40A_MAIN. . .  N NUMB   00AFh            
ALIGN_RCE_BL35P_M~  N NUMB   0075h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ah            
TURNIGY_KFORCE_70~  N NUMB   004Fh            
TURNIGY_KFORCE_40~  N NUMB   004Ch            
XP_25A_MAIN. . . .  N NUMB   0010h            
INIT . . . . . . .  C ADDR   1C00H   A 
PARAVAL_NO_ENTRY .  C ADDR   18F2H   A 
STORE_MAIN_FUNC_9.  C ADDR   1852H   A 
RUN6_BRAKE_DONE. .  C ADDR   16E8H   A 
SUCCESS_BEEP_INVE~  C ADDR   189BH   A 
SUCCESS_BEEP . . .  C ADDR   186CH   A 
FIND_THROTTLE_GAIN  C ADDR   1166H   A 
DECODE_SETTINGS. .  C ADDR   10FBH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   16F0H   A 
TEMP_AVERAGE_INC_~  C ADDR   09DFH   A 
GOVERNOR_INT_MAX_~  C ADDR   07F3H   A 
GOVERNOR_LIMIT_IN~  C ADDR   07D3H   A 
BEEP_F3. . . . . .  C ADDR   05FBH   A 
PCA_INT_FAIL_MINI~  C ADDR   03AAH   A 
PWM_BFET . . . . .  C ADDR   0166H   A 
T0_INT_PWM_OFF_EX~  C ADDR   013FH   A 
EEP_PGM_GOV_RANGE.  C ADDR   1A17H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0069H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
SKIP_DAMP_ON . . .  N NUMB   0006h            
P1_INIT. . . . . .  N NUMB   0002h            
RTX_SKIP . . . . .  N NUMB   00D4h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
FVT_LITTLEBEE_20A~  N NUMB   00CBh            
MDRX62H_TAIL . . .  N NUMB   00BFh            
XROTOR_20A_MAIN. .  N NUMB   00B8h            
PLATINUM_PRO_150A~  N NUMB   009Dh            
TURNIGY_PLUSH_NFE~  N NUMB   003Ah            
XP_12A_TAIL. . . .  N NUMB   000Bh            
UART_LOOP. . . . .  N NUMB   001Ah            
DAMPED_TRANSITION.  C ADDR   1594H   A 
BEEP_DELAY_SET . .  C ADDR   1497H   A 
PROGRAM_BY_TX_ENT~  C ADDR   139FH   A 
LOCK_BYTE_OK . . .  C ADDR   11E7H   A 
AVERAGE_THROTTLE_~  C ADDR   11AAH   A 
DECODE_PWM_FREQ_L~  C ADDR   10F5H   A 
COMM61_FETS_DONE_~  C ADDR   1013H   A 
COMP_READ_WRONG_L~  C ADDR   0DC5H   A 
SET_PWM_LIMIT_LOW~  C ADDR   0905H   A 
GOVERNOR_ACT_LIM_~  C ADDR   06F4H   A 
BEEP_F4. . . . . .  C ADDR   0602H   A 
PCA_INT_PPM_MAX_C~  C ADDR   054AH   A 
PCA_INT_RESTORE_E~  C ADDR   047BH   A 
PWM_CFET . . . . .  C ADDR   0170H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A6H   A 
_PGM_STARTUP_METH~  I ADDR   0095H   A 
_PGM_VOLT_COMP . .  I ADDR   0091H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0006h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
FVT_LITTLEBEE_30A~  N NUMB   00CEh            
FVT_LITTLEBEE_20A~  N NUMB   00CCh            
MDRX62H_MULTI. . .  N NUMB   00C0h            
H_KING_10A_MAIN. .  N NUMB   0079h            
ALIGN_RCE_BL35X_M~  N NUMB   0070h            
RCTIMER_6A_TAIL. .  N NUMB   0068h            
TURNIGY_PLUSH_NFE~  N NUMB   003Eh            
XP_18A_MAIN. . . .  N NUMB   000Dh            
XP_12A_MULTI . . .  N NUMB   000Ch            
XP_7A_FAST_TAIL. .  N NUMB   0008h            
PROGRAM_BY_TX_EXIT  C ADDR   1957H   A 
READ_EEPROM_BYTE .  C ADDR   17C2H   A 
THROTTLE_LOW_CAL .  C ADDR   13F3H   A 
COMP_READ_WRONG. .  C ADDR   0D8EH   A 
STORE_TIMES_UP_OR~  C ADDR   0CA3H   A 
STORE_TIMES_DECRE~  C ADDR   0CB0H   A 
TEMP_AVERAGE_UPDA~  C ADDR   09F7H   A 
SET_PWM_LIMIT_HIG~  C ADDR   0919H   A 
GOVERNOR_APPLY_IN~  C ADDR   0897H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0831H   A 
CALC_GOVERNOR_STO~  C ADDR   0768H   A 
BEEP_OFF . . . . .  C ADDR   0634H   A 
WAIT10MS . . . . .  C ADDR   05CEH   A 
T2H_INT_RCP_NO_LI~  C ADDR   0330H   A 
PWM_AFET_DAMPED_E~  C ADDR   0189H   A 
T0_INT_PWM_ON_EXIT  C ADDR   00DBH   A 
TX_PGM_PARAMS_MAIN  C ADDR   009FH   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Eh            
PGM_PWM_DITHER . .  I ADDR   00A3H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0074H   A 
INITIAL_RUN_ROT_C~  D ADDR   0034H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
GRAUPNER_ULTRA_20~  N NUMB   00D1h            
FVT_LITTLEBEE_30A~  N NUMB   00CFh            
XROTOR_40A_MAIN. .  N NUMB   00BBh            
EMAX_20A_TAIL. . .  N NUMB   00ADh            
TAROT_30A_TAIL . .  N NUMB   00A7h            
H_KING_20A_MAIN. .  N NUMB   007Ch            
RCTIMER_6A_MULTI .  N NUMB   0069h            
HIMODEL_COOL_22A_~  N NUMB   005Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0037h            
XP_7A_FAST_MULTI .  N NUMB   0009h            
GETW . . . . . . .  C ADDR   1D7BH   A 
READ_TAG . . . . .  C ADDR   180BH   A 
RESET_CAL_DONE . .  C ADDR   120DH   A 
DECODE_PARAMETERS.  C ADDR   10C8H   A 
COMM45_FETS_DONE_~  C ADDR   0F77H   A 
COMM23_NFET_OFF. .  C ADDR   0EB9H   A 
STORE_TIMES_INCRE~  C ADDR   0C46H   A 
CHECK_VOLTAGE_GOOD  C ADDR   0A42H   A 
MEASURE_LIPO_CELLS  C ADDR   091EH   A 
CALC_GOVERNOR_INT~  C ADDR   07A9H   A 
GOVERNOR_FIRST_DE~  C ADDR   0706H   A 
PCA_INT_PPM_CALCU~  C ADDR   0525H   A 
PCA_INT_EXIT . . .  C ADDR   05B2H   A 
T2H_INT_RCP_LIMIT~  C ADDR   02F5H   A 
PWM_BFET_DAMPED_E~  C ADDR   019AH   A 
RCP_PERIOD_DIFF_A~  D ADDR   005BH   A 
COMPARATOR_READ_C~  D ADDR   0041H   A 
STARTUP_CNT. . . .  D ADDR   0033H   A 
PWM_TIMER0_OVERFL~  N NUMB   0003h            
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
GRAUPNER_ULTRA_20~  N NUMB   00D2h            
EMAX_20A_MULTI . .  N NUMB   00AEh            
TAROT_30A_MULTI. .  N NUMB   00A8h            
HIMODEL_COOL_41A_~  N NUMB   0064h            
TURNIGY_PLUSH_6A_~  N NUMB   001Ch            
GETX . . . . . . .  C ADDR   1D89H   A 
WAIT_FOR_POWER_ON~  C ADDR   14C0H   A 
COMP_READ_WRONG_N~  C ADDR   0DA5H   A 
CALC_NEW_WAIT_PER~  C ADDR   0B69H   A 
SWITCH_POWER_OFF .  C ADDR   104AH   A 
CALC_GOVERNOR_TAR~  C ADDR   0734H   A 
WAIT30MS . . . . .  C ADDR   05D3H   A 
PCA_INT_CHECK_1KHZ  C ADDR   046AH   A 
T2H_INT. . . . . .  C ADDR   025FH   A 
PWM_CFET_DAMPED_E~  C ADDR   01ABH   A 
MOTOR_PWM_REMAP. .  C ADDR   00AAH   A 
GOV_INTEGRAL_X . .  D ADDR   0046H   A 
COMP_TIMED_OUT . .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   000Ch            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
XROTOR_10A_TAIL. .  N NUMB   00B6h            
EMAX_40A_TAIL. . .  N NUMB   00B0h            
EAZY_3AV2_MAIN . .  N NUMB   00A3h            
ALIGN_RCE_BL15X_T~  N NUMB   006Bh            
HIMODEL_COOL_33A_~  N NUMB   0061h            
TURNIGY_KFORCE_70~  N NUMB   0050h            
TURNIGY_KFORCE_40~  N NUMB   004Dh            
XP_25A_TAIL. . . .  N NUMB   0011h            
RST. . . . . . . .  C ADDR   1CBDH   A 
SUCCESS. . . . . .  N NUMB   0030h            
BOOT_VERSION . . .  N NUMB   0006h            
XTAL . . . . . . .  N NUMB   17D7840h            
FUNC_PARAVAL_CONT~  C ADDR   1926H   A 
WRITE_TAGS . . . .  C ADDR   1816H   A 
RUN_TO_NEXT_STATE~  C ADDR   1733H   A 
RUN6_CHECK_RCP_ST~  C ADDR   16CFH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   16F8H   A 
WAIT1S . . . . . .  C ADDR   1864H   A 
COMM61_NFET_OFF. .  C ADDR   0FF1H   A 
EVAL_COMP_CHECK_T~  C ADDR   0E00H   A 
COMP_WAIT_ON_COMP~  C ADDR   0D4FH   A 
ADJUST_TIMING_TWO~  C ADDR   0C2DH   A 
INITIALIZE_TIMING.  C ADDR   0A90H   A 
CHECK_VOLTAGE_RET.  C ADDR   0A6FH   A 
WAITXMS_M. . . . .  C ADDR   05E4H   A 
PCA_INT_CHECK_2KHZ  C ADDR   0459H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
WT_ADV_START_H . .  D ADDR   004CH   A 
GOV_TARGET_H . . .  D ADDR   0043H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
XROTOR_20A_TAIL. .  N NUMB   00B9h            
XROTOR_10A_MULTI .  N NUMB   00B7h            
EMAX_40A_MULTI . .  N NUMB   00B1h            
SKYIII_30A_MAIN. .  N NUMB   00A9h            
PLATINUM_PRO_150A~  N NUMB   009Eh            
POLARIS_THUNDER_2~  N NUMB   0088h            
H_KING_50A_MAIN. .  N NUMB   0082h            
GAUI_GE_183_18A_M~  N NUMB   0076h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ch            
TURNIGY_KFORCE_70~  N NUMB   0051h            
TURNIGY_KFORCE_40~  N NUMB   004Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Bh            
XP_25A_MULTI . . .  N NUMB   0012h            
EXIT . . . . . . .  C ADDR   1CB4H   A 
BOOT_MSG . . . . .  C ADDR   1DDCH   A 
READ_INITIAL_TEMP.  C ADDR   1510H   A 
WAIT_FOR_POWER_ON~  C ADDR   14B4H   A 
DECODE_PWM_FREQ_E~  C ADDR   10FAH   A 
WAIT_FOR_COMM_WAIT  C ADDR   0E67H   A 
START_ADC_CONVERS~  C ADDR   09B1H   A 
MULT_S16_BY_U8_EX~  C ADDR   06C4H   A 
PCA_INT_PPM_LIMIT~  C ADDR   055CH   A 
GET_RCP_END. . . .  C ADDR   0381H   A 
T2H_INT_RCP_GOV_P~  C ADDR   0299H   A 
T2_INT_PWM_MIN_RUN  C ADDR   023FH   A 
PWM_DITHER_TABLE .  C ADDR   009AH   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
PGM_ENABLE_POWER_~  I ADDR   00A1H   A 
PWM_DITHER_DECODED  D ADDR   0066H   A 
PWM_LIMIT_BY_RPM .  D ADDR   0063H   A 
LOW_RPM_PWR_SLOPE.  D ADDR   0038H   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   000Ch            
HIGH_BEC_VOLTAGE .  N NUMB   0000h            
PSW. . . . . . . .  D ADDR   00D0H   A 
XROTOR_20A_MULTI .  N NUMB   00BAh            
PLATINUM_PRO_150A~  N NUMB   009Fh            
POLARIS_THUNDER_3~  N NUMB   008Bh            
POLARIS_THUNDER_1~  N NUMB   0085h            
H_KING_10A_TAIL. .  N NUMB   007Ah            
ALIGN_RCE_BL35X_T~  N NUMB   0071h            
TURNIGY_PLUSH_NFE~  N NUMB   003Ch            
XP_18A_TAIL. . . .  N NUMB   000Eh            
WAITF. . . . . . .  C ADDR   1DC9H   A 
BOOT_BAUDRATE. . .  N NUMB   4B00h            
STORE_IN_RAM_EXIT.  C ADDR   1861H   A 
VALIDATE_RCP_START  C ADDR   1346H   A 
LOCK_BYTE_TEST . .  C ADDR   11E0H   A 
COMM45_NFET_OFF. .  C ADDR   0F55H   A 
COMM12_REV . . . .  C ADDR   0E8CH   A 
COMM1COMM2 . . . .  C ADDR   0E78H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CC1H   A 
TEMP_AVERAGE_UPDA~  C ADDR   09F5H   A 
TEMP_AVERAGE_DEC .  C ADDR   09EBH   A 
CALC_GOVERNOR_PRO~  C ADDR   0807H   A 
CALC_GOVERNOR_TAR~  C ADDR   074DH   A 
WAITXMS_O. . . . .  C ADDR   05E2H   A 
PCA_INT_PPM_TIMEO~  C ADDR   05A7H   A 
PCA_INT_CHECK_4KHZ  C ADDR   0448H   A 
T0_INT_PWM_OFF . .  C ADDR   00FCH   A 
T0_INT_START . . .  C ADDR   00C2H   A 
EEPROM_FW_SUB_REV~  N NUMB   0003h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0048H   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
XROTOR_40A_TAIL. .  N NUMB   00BCh            
POLARIS_THUNDER_4~  N NUMB   008Eh            
H_KING_20A_TAIL. .  N NUMB   007Dh            
H_KING_10A_MULTI .  N NUMB   007Bh            
ALIGN_RCE_BL35X_M~  N NUMB   0072h            
HIMODEL_COOL_22A_~  N NUMB   005Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0038h            
XP_18A_MULTI . . .  N NUMB   000Fh            
PUTC . . . . . . .  C ADDR   1D5CH   A 
BIT_REG. . . . . .  D ADDR   0020H   A 
CMDH . . . . . . .    REG    R5             
STORE_MAIN_FUNC_10  C ADDR   1857H   A 
READ_EEPROM_EXIT .  C ADDR   177FH   A 
WAIT_FOR_POWER_ON~  C ADDR   1474H   A 
INPUT_HIGH_CHECK_1  C ADDR   126EH   A 
CHECK_VOLTAGE_STA~  C ADDR   0A1DH   A 
SET_PWM_LIMIT_LOW~  C ADDR   08C1H   A 
CALC_GOVERNOR_INT~  C ADDR   08C0H   A 
GOVERNOR_LIMIT_IN~  C ADDR   07DCH   A 
MULT_S16_BY_U8_DI~  C ADDR   06A9H   A 
BEEP . . . . . . .  C ADDR   0609H   A 
PCA_INT_FALL . . .  C ADDR   04ACH   A 
T2_INT_PWM_EXIT. .  C ADDR   0249H   A 
T2_INT_SKIP_END. .  C ADDR   0229H   A 
EEP_PGM_TEMP_PROT~  C ADDR   1A23H   A 
_EEP_PGM_THROTTLE~  C ADDR   1A1EH   A 
_EEP_PGM_STARTUP_~  C ADDR   1A12H   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A5H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006CH   A 
COMM_PHASE . . . .  D ADDR   0040H   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
XROTOR_40A_MULTI .  N NUMB   00BDh            
EMAX_NANO_20A_MAIN  N NUMB   00B2h            
PLATINUM_50AV3_MA~  N NUMB   00A0h            
H_KING_35A_MAIN. .  N NUMB   007Fh            
H_KING_20A_MULTI .  N NUMB   007Eh            
HIMODEL_COOL_41A_~  N NUMB   0065h            
HIMODEL_COOL_22A_~  N NUMB   0060h            
TURNIGY_PLUSH_NFE~  N NUMB   0039h            
TURNIGY_PLUSH_6A_~  N NUMB   001Dh            
WAITH. . . . . . .  C ADDR   1DCDH   A 
STORE_MAIN_FUNC_11  C ADDR   185CH   A 
ERASE_FLASH. . . .  C ADDR   17DBH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   16FBH   A 
PROGRAM_BY_TX. . .  C ADDR   18E9H   A 
INPUT_HIGH_CHECK_2  C ADDR   1270H   A 
COMM23_NONDAMP . .  C ADDR   0EE3H   A 
COMM2COMM3 . . . .  C ADDR   0E9DH   A 
CALC_NEXT_COMM_AV~  C ADDR   0B10H   A 
MEASURE_LIPO_CELL~  C ADDR   0958H   A 
GOVERNOR_STORE_IN~  C ADDR   08BEH   A 
GOVERNOR_CHECK_IN~  C ADDR   0880H   A 
GOVERNOR_CORR_PRO~  C ADDR   084FH   A 
T2_INT_START . . .  C ADDR   01C9H   A 
PWM_AFET_DAMPED. .  C ADDR   017AH   A 
_EEP_PGM_PPM_CENT~  C ADDR   1A21H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
NEXT_WT_START_H. .  D ADDR   0054H   A 
WT_ADV_START_L . .  D ADDR   004BH   A 
GOV_TARGET_L . . .  D ADDR   0042H   A 
DEMAG_PWR_OFF_THR~  D ADDR   0037H   A 
FLAGS0 . . . . . .  D ADDR   002CH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
EAZY_3AV2_TAIL . .  N NUMB   00A4h            
POLARIS_THUNDER_6~  N NUMB   0091h            
HIMODEL_COOL_41A_~  N NUMB   0066h            
HIMODEL_COOL_33A_~  N NUMB   0062h            
TURNIGY_AE_20A_MA~  N NUMB   0040h            
TURNIGY_PLUSH_6A_~  N NUMB   001Eh            
XP_35A_SW_MAIN . .  N NUMB   0013h            
ID1. . . . . . . .  C ADDR   1C47H   A 
FUNC_PARAVAL_STORE  C ADDR   1918H   A 
WRITE_EEPROM_BYTE~  C ADDR   17C7H   A 
READ_EEPROM_BLOCK1  C ADDR   1767H   A 
READ_EEPROM_READ .  C ADDR   1760H   A 
COMM23_DAMP_REV. .  C ADDR   0EC3H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0C83H   A 
LOAD_MIN_TIME_FAST  C ADDR   0BDCH   A 
MEASURE_LIPO_EXIT.  C ADDR   09B0H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0837H   A 
GOVERNOR_CHECK_PR~  C ADDR   078DH   A 
PCA_INT_SECOND_ME~  C ADDR   03D3H   A 
T2H_INT_RCP_STOP_~  C ADDR   027CH   A 
PWM_BFET_DAMPED. .  C ADDR   018BH   A 
PCA_INT. . . . . .  C ADDR   0361H   A 
EEP_PGM_GOV_SETUP~  C ADDR   1A11H   A 
FLAGS1 . . . . . .  D ADDR   002DH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C4h            
SKYIII_30A_TAIL. .  N NUMB   00AAh            
EAZY_3AV2_MULTI. .  N NUMB   00A5h            
POLARIS_THUNDER_2~  N NUMB   0089h            
H_KING_50A_TAIL. .  N NUMB   0083h            
GAUI_GE_183_18A_T~  N NUMB   0077h            
HIMODEL_COOL_33A_~  N NUMB   0063h            
TURNIGY_AE_30A_MA~  N NUMB   0046h            
BOOT_INFO. . . . .  C ADDR   1DE0H   A 
ERRORVERIFY. . . .  N NUMB   00C0h            
READ_EEPROM_BLOCK2  C ADDR   1775H   A 
MEASURE_PWM_FREQ_~  C ADDR   12E3H   A 
COMM61_NONDAMP . .  C ADDR   101AH   A 
COMM6COMM1 . . . .  C ADDR   0FD5H   A 
COMM34_REV . . . .  C ADDR   0F28H   A 
COMM3COMM4 . . . .  C ADDR   0F14H   A 
COMP_WAIT_NO_OF_R~  C ADDR   0D3EH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D0CH   A 
MEASURE_LIPO_LIMI~  C ADDR   09A0H   A 
GOVERNOR_CORR_PRO~  C ADDR   0860H   A 
GOVERNOR_SPEED_CH~  C ADDR   06D5H   A 
PCA_INT_CHECK_8KHZ  C ADDR   0437H   A 
T2H_INT_RCP_GOV_P~  C ADDR   02CDH   A 
PWM_CFET_DAMPED. .  C ADDR   019CH   A 
DAMPINGFET . . . .  D ADDR   007BH   A 
WT_ZC_SCAN_START_H  D ADDR   004EH   A 
GOV_PROP_PWM . . .  D ADDR   0049H   A 
GOV_PROPORTIONAL_L  D ADDR   0047H   A 
FLAGS2 . . . . . .  D ADDR   002EH   A 
DEMAG_DETECTED . .  N NUMB   0005h            
RCP_SKIP_CNT . . .  D ADDR   002BH   A 
CURRENT_PWM_LIM_D~  D ADDR   0026H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
MCU_48MHZ. . . . .  N NUMB   0001h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
SKYIII_30A_MULTI .  N NUMB   00ABh            
POLARIS_THUNDER_8~  N NUMB   0094h            
POLARIS_THUNDER_3~  N NUMB   008Ch            
POLARIS_THUNDER_2~  N NUMB   008Ah            
POLARIS_THUNDER_1~  N NUMB   0086h            
H_KING_50A_MULTI .  N NUMB   0084h            
GAUI_GE_183_18A_M~  N NUMB   0078h            
TURNIGY_KFORCE_12~  N NUMB   0052h            
XP_3A_MAIN . . . .  N NUMB   0001h            



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6962    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =    103    ----
   IDATA SIZE       =     87    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
