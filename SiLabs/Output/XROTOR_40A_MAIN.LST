MACRO ASSEMBLER BLHELI                                      12/28/15 18:35:59 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\XROTOR_40A_REV14_3.OBJ
ASSEMBLER INVOKED BY: PRINT SET(BESCNO=187) OBJECT(OUTPUT\XROTOR_40A_REV14_3.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ;
                         4     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                         5     ;
                         6     ; Copyright 2011, 2012 Steffen Skaug
                         7     ; This program is distributed under the terms of the GNU General Public License
                         8     ;
                         9     ; This file is part of BLHeli.
                        10     ;
                        11     ; BLHeli is free software: you can redistribute it and/or modify
                        12     ; it under the terms of the GNU General Public License as published by
                        13     ; the Free Software Foundation, either version 3 of the License, or
                        14     ; (at your option) any later version.
                        15     ;
                        16     ; BLHeli is distributed in the hope that it will be useful,
                        17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        19     ; GNU General Public License for more details.
                        20     ;
                        21     ; You should have received a copy of the GNU General Public License
                        22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                        23     ;
                        24     ;**** **** **** **** ****
                        25     ;
                        26     ; The software was initially designed for use with Eflite mCP X, but is now adapted to copters/planes in general
                        27     ;
                        28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.versanet.de/~bkonze/blc_6a/blc_6a.htm
                        29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                        30     ;
                        31     ; This file is best viewed with tab width set to 5
                        32     ;
                        33     ; The input signal can be positive 1kHz, 2kHz, 4kHz, 8kHz or 12kHz PWM (e.g. taken from the "resistor tap" on mCPx)
                        34     ; And the input signal can be PPM (1-2ms) or OneShot125 (125-250us) at rates up to several hundred Hz.
                        35     ; The code autodetects the various input modes/frequencies
                        36     ; The code can also be programmed to accept inverted input signal.
                        37     ;
                        38     ; The first lines of the software must be modified according to the chosen environment:
                        39     ; Uncomment the selected ESC and main/tail/multi mode
                        40     ; BESCNO EQU "ESC"_"mode" 						
                        41     ; 
                        42     ;**** **** **** **** ****
                        43     ; Revision history:
                        44     ; - Rev1.0: Initial revision based upon BLHeli for AVR controllers
                        45     ; - Rev2.0: Changed "Eeprom" initialization, layout and defaults
                        46     ;           Various changes and improvements to comparator reading. Now using timer1 for time from pwm on/off
                        47     ;           Beeps are made louder
                        48     ;           Added programmable low voltage limit
                        49     ;           Added programmable damped tail mode (only for 1S ESCs)
                        50     ;           Added programmable motor rotation direction
                        51     ; - Rev2.1: (minor changes by 4712)
                        52     ;		  Added Disable TX Programming by PC Setup Application 
                        53     ;		  therfore changed EEPROM_LAYOUT_REVISION = 8					
                        54     ;		  Added Vdd Monitor as reset source when writing to "EEProm"
                        55     ;		  Changed for use of batch file to assemble, link and make hex files	
                        56     ; - Rev2.2: (minor changes by 4712)
                        57     ;           Added Disable Throttle Re-Arming every motor start by PC Setup Application 
                        58     ; - Rev2.3: (minor changes by 4712)
                        59     ;           Added bugfixed (2x CLR C before j(n)c operations)thx Steffen!			
                        60     ; - Rev2.4: Revisions 2.1 to 2.3 integrated
                        61     ; - Rev3.0: Added PPM (1050us-1866us) as accepted input signal
                        62     ;           Added startup rpm as a programming parameter
                        63     ;           Added startup acceleration as a programming parameter
                        64     ;           Added option for using voltage measurements to compensate motor power
                        65     ;           Added governor target by setup as a governor mode option
                        66     ;           Governor is kept active regardless of rpm
                        67     ;           Smooth governor spoolup/down in arm and setup modes
                        68     ;           Increased governor P and I gain programming ranges
                        69     ;           Increased and changed low voltage limit programming range
                        70     ;           Disabled tx programming entry for all but the first arming sequence after power on
                        71     ;           Made it possible to skip parameters in tx programming by setting throttle midstick
                        72     ;           Made it default not to rearm for every restart
                        73     ; - Rev3.1: Fixed bug that prevented chosen parameter to be set in tx programming
                        74     ; - Rev3.2: ...also updated the EEPROM revision parameter
                        75     ; - Rev3.3: Fixed negative number bug in voltage compensation
                        76     ;           Fixed bug in startup power calculation for non-default power
                        77     ;           Prevented possibility for voltage compensation fighting low voltage limiting
                        78     ;           Applied overall spoolup control to ensure soft spoolup in any mode
                        79     ;           Added a delay of 3 seconds from initiation of main motor stop until new startup is allowed
                        80     ;           Reduced beep power to reduce power consumption for very strong motors/ESCs
                        81     ; - Rev3.4: Fixed bug that prevented full power in governor arm and setup modes
                        82     ;           Increased NFETON_DELAY for XP_7A and XP_12A to allow for more powerful fets
                        83     ;           Increased initial spoolup power, and linked to startup power
                        84     ; - Rev4.0: Fixed bug that made tail tx program beeps very weak
                        85     ;           Added thermal protection feature
                        86     ;           Governor P and I gain ranges are extended up to 8.0x gain
                        87     ;           Startup sequence is aborted upon zero throttle
                        88     ;           Avoided voltage compensation function induced latency for tail when voltage compensation is not enabled
                        89     ;           Improved input signal frequency detection robustness
                        90     ; - Rev4.1: Increased thermal protection temperature limits
                        91     ; - Rev5.0: Added multi(copter) operating mode. TAIL define changed to MODE with three modes: MAIN, TAIL and MULTI
                        92     ;           Added programmable commutation timing
                        93     ;           Added a damped light mode that has less damping, but that can be used with all escs
                        94     ;           Added programmable damping force
                        95     ;           Added thermal protection for startup too
                        96     ;           Added wait beeps when waiting more than 30 sec for throttle above zero (after having been armed)
                        97     ;           Modified tail idling to provide option for very low speeds
                        98     ;           Changed PPM range to 1150-1830us
                        99     ;           Arming sequence is dropped for PPM input, unless it is governor arm mode
                       100     ;           Loss of input signal will immediately stop the motor for PPM input
                       101     ;           Bug corrected in Turnigy Plush 6A voltage measurement setup
                       102     ;           FET switching delays are set for original fets. Stronger/doubled/tripled etc fets may require faster pfet off switching
                       103     ;           Miscellaneous other changes
                       104     ; - Rev6.0: Reverted comparator reading routine to rev5.0 equivalent, in order to avoid tail motor stops
                       105     ;           Added governor range programmability
                       106     ;           Implemented startup retry sequence with varying startup power for multi mode
                       107     ;           In damped light mode, damping is now applied to the active nfet phase for fully damped capable ESCs
                       108     ; - Rev6.1: Added input signal qualification criteria for PPM, to avoid triggering on noise spikes (fix for plush hardware)
                       109     ;           Changed main and multi mode stop criteria. Will now be in run mode, even if RC pulse input is zero
                       110     ;           Fixed bug in commutation that caused rough running in damped light mode
                       111     ;           Miscellaneous other changes
                       112     ; - Rev7.0  Added direct startup mode programmability
                       113     ;           Added throttle calibration. Min>=1000us and Max<=2000us. Difference must be >520us, otherwise max is shifted so that difference=520us
                       114     ;           Added programmable throttle change rate
                       115     ;           Added programmable beep strength, beacon strength and beacon delay
                       116     ;           Reduced power step to full power significantly
                       117     ;           Miscellaneous other changes
                       118     ; - Rev8.0  Added a 2 second delay after power up, to wait for receiver initialization
                       119     ;           Added a programming option for disabling low voltage limit, and made it default for MULTI
                       120     ;           Added programable demag compensation, using the concept of SimonK
                       121     ;           Improved robustness against noisy input signal
                       122     ;           Refined direct startup
                       123     ;           Removed voltage compensation
                       124     ;           Miscellaneous other changes
                       125     ; - Rev9.0  Increased programming range for startup power, and made its default ESC dependent
                       126     ;           Made default startup method ESC dependent
                       127     ;           Even more smooth and gentle spoolup for MAIN, to suit larger helis
                       128     ;           Improved transition from stepped startup to run
                       129     ;           Refined direct startup
                       130     ; - Rev9.1  Fixed bug that changed FW revision after throttle calibration or TX programming
                       131     ; - Rev9.2  Altered timing of throttle calibration in order to work with MultiWii calibration firmware
                       132     ;           Reduced main spoolup time to around 5 seconds
                       133     ;           Changed default beacon delay to 3 minutes
                       134     ; - Rev9.3  Fixed bug in Plush 60/80A temperature reading, that caused failure in operation above 4S
                       135     ;           Corrected temperature limit for HiModel cool 22/33/41A, RCTimer 6A, Skywalker 20/40A, Turnigy AE45A, Plush 40/60/80A. Limit was previously set too high
                       136     ; - Rev9.4  Improved timing for increased maximum rpm limit
                       137     ; - Rev10.0 Added closed loop mode for multi
                       138     ;           Added high/low BEC voltage option (for the ESCs where HW supports it)
                       139     ;           Added method of resetting all programmed parameter values to defaults by TX programming
                       140     ;           Added Turnigy K-force 40A and Turnigy K-force 120A HV ESCs
                       141     ;           Enabled fully damped mode for several ESCs
                       142     ;           Extended startup power range downwards to enable very smooth start for large heli main motors
                       143     ;           Extended damping force with a highest setting
                       144     ;           Corrected temperature limits for F310 chips (Plush 40A and AE 45A)
                       145     ;           Implemented temperature reading average in order to avoid problems with ADC noise on Skywalkers
                       146     ;           Increased switching delays for XP 7A fast, in order to avoid cross conduction of N and P fets
                       147     ;           Miscellaneous other changes
                       148     ; - Rev10.1 Relaxed RC signal jitter requirement during frequency measurement
                       149     ;           Corrected bug that prevented using governor low
                       150     ;           Enabled vdd monitor always, in order to reduce likelihood of accidental overwriting of adjustments
                       151     ;           Fixed bug that caused stop for PPM input above 2048us, and moved upper accepted limit to 2160us
                       152     ; - Rev10.2 Corrected temperature limit for AE20-30/XP7-25, where limit was too high
                       153     ;           Corrected temperature limit for 120HV, where limit was too low
                       154     ;           Fixed bug that caused AE20/25/30A not to run in reverse
                       155     ; - Rev10.3 Removed vdd monitor for 1S capable ESCs, in order to avoid brownouts/resets
                       156     ;           Made auto bailout spoolup for main more smooth
                       157     ; - Rev10.4 Ensured that main spoolup and governor activation will always be smooth, regardless of throttle input
                       158     ;           Added capability to operate on 12kHz input signal too
                       159     ; - Rev11.0 Fixed bug of programming default values for governor in MULTI mode
                       160     ;           Disabled interrupts explicitly some places, to avoid possibilities for unintentional fet switching
                       161     ;           Changed interrupt disable strategy, to always allow pwm interrupts, to avoid noise when running at low rpms
                       162     ;           Added governor middle range for MAIN mode
                       163     ;           Added bidirectional mode for TAIL and MULTI mode with PPM input
                       164     ;           Changed and improved demag compensation
                       165     ;           Miscellaneous other changes
                       166     ; - Rev11.1 Fixed bug of slow acceleration response for MAIN mode running without governor
                       167     ;           Fixed bug with PWM input, where throttle remains high even when zeroing throttle (seen on V922 tail)
                       168     ;           Fixed bug in bidirectional operation, where direction change could cause reset
                       169     ;           Improved autorotation bailout for MAIN
                       170     ;           Reduced min speed back to 1220 erpm
                       171     ;           Misc code cleanups
                       172     ; - Rev11.2 Fixed throttle calibration bug
                       173     ;           Added high side driver precharge for all-nfet ESCs
                       174     ;           Optimized timing in general and for demag compensation in particular
                       175     ;           Auto bailout functionality modified
                       176     ;           Governor is deactivated for throttle inputs below 10%
                       177     ;           Increased beacon delay times
                       178     ; - Rev12.0 Added programmable main spoolup time
                       179     ;           Added programmable temperature protection enable
                       180     ;           Bidirectional mode stop/start improved. Motor is now stopped before starting
                       181     ;           Power is limited for very low rpms (when BEMF is low), in order to avoid sync loss 
                       182     ;           Damped light mode is made more smooth and quiet, particularly at low and high rpms
                       183     ;           Comparator signal qualification scheme is changed
                       184     ;           Demag compensation scheme is significantly changed
                       185     ;           Increased jitter tolerance for PPM frequency measurement
                       186     ;           Fully damped mode removed, and damped light only supported on damped capable ESCs
                       187     ;           Default tail mode changed to damped light
                       188     ;           Miscellaneous other changes
                       189     ; - Rev12.1 Fixed bug in tail code
                       190     ;           Improved startup for Atmel
                       191     ;           Added support for multiple high BEC voltages
                       192     ;           Added support for RPM output
                       193     ; - Rev12.2 Improved running smoothness, particularly for damped light
                       194     ;           Avoiding lockup at full throttle when input signal is noisy
                       195     ;           Avoiding detection of 1-wire programming signal as valid throttle signal
                       196     ; - Rev13.0 Removed stepped start
                       197     ;           Removed throttle change rate and damping force parameters
                       198     ;           Added support for OneShot125
                       199     ;           Improved commutation timing accuracy
                       200     ; - Rev13.1 Removed startup ramp for MULTI
                       201     ;           Improved startup for some odd ESCs
                       202     ; - Rev13.2 Still tweaking startup to make it more reliable and faster for all ESC/motor combos
                       203     ;           Increased deadband for bidirectional operation
                       204     ;           Relaxed signal detection criteria
                       205     ;           Added support for running 48MHz capable SiLabs MCUs at 48MHz
                       206     ;           Added bootlader to SiLabs code
                       207     ;           Miscellaneous other changes
                       208     ; - Rev14.0 Improved running at high timing
                       209     ;           Improved running at high RPMs and increased max RPM limit
                       210     ;           Avoid being locked in bootloader (implemented in Suite 13202)
                       211     ;           Improved reliability of 3D (bidirectional) mode and startup
                       212     ;           Smoother running and greatly reduced step to full power in damped light mode
                       213     ;           Removed low voltage limiting for MULTI
                       214     ;           Added pwm dither parameter
                       215     ;           Added setting for enable/disable of low RPM power protection
                       216     ;           Added setting for enable/disable of PWM input
                       217     ;           Better AFW and damping for some ESCs (that have a slow high side driver)
                       218     ;           Miscellaneous other changes
                       219     ; - Rev14.1 Fixed max throttle calibration bug (for non-oneshot)
                       220     ;           Fixed some closed loop mode bugs
                       221     ;           Relaxed signal jitter requirement for looptimes below 1000
                       222     ;           Added skipping of damping fet switching near max power, for improved high end throttle linearity, using the concept of SimonK
                       223     ;           Improved sync hold at high rpms
                       224     ; - Rev14.2 Added stalled motor shutoff after about 10 seconds (for tail and multi code with PPM input)
                       225     ;           Greatly increased maximum rpm limit, and added rpm limiting at 250k erpm (48MHz MCUs at 400k erpm)
                       226     ;           Improved bidirectional operation
                       227     ; - Rev14.3 Moved reset vector to be just before the settings segment, in order to better recover from partially failed flashing operation
                       228     ;           Added 100ms intialization delay for the Graupner Ultra 20A ESC
                       229     ;           Shortened stall detect time to about 5sec, and prevented going into tx programming after a stall
                       230     ;           Optimizations of software timing and running reliability
                       231     ;
                       232     ;           
                       233     ;
                       234     ;**** **** **** **** ****
                       235     ; Up to 8K Bytes of In-System Self-Programmable Flash
                       236     ; 768 Bytes Internal SRAM
                       237     ;
                       238     ;**** **** **** **** ****
                       239     ; Master clock is internal 24MHz oscillator
                       240     ; Timer 0 (167/500ns counts) always counts up and is used for
                       241     ; - PWM generation
                       242     ; Timer 1 (167/500ns counts) always counts up and is used for
                       243     ; - Time from pwm on/off event
                       244     ; Timer 2 (500ns counts) always counts up and is used for
                       245     ; - RC pulse timeout/skip counts and commutation times
                       246     ; Timer 3 (500ns counts) always counts up and is used for
                       247     ; - Commutation timeouts
                       248     ; PCA0 (500ns counts) always counts up and is used for
                       249     ; - RC pulse measurement
                       250     ;
                       251     ;**** **** **** **** ****
                       252     ; Interrupt handling
                       253     ; The F330 does not disable interrupts when entering an interrupt routine.
                       254     ; Also some interrupt flags need to be cleared by software
                       255     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                       256     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                       257     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                       258     ;
                       259     ;**** **** **** **** ****
                       260     ; Motor control:
                       261     ; - Brushless motor control with 6 states for each electrical 360 degrees
                       262     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                       263     ; - Timing advance in this implementation is set to 15deg nominally
                       264     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                       265     ; Motor sequence starting from zero crossing:
                       266     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                       267     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                       268     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                       269     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                       270     ;
                       271     ; Motor startup:
                       272     ; Startup is the only phase, before normal bemf commutation run begins.
                       273     ;
                       274     ;**** **** **** **** ****
                       275     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0001                 276     XP_3A_MAIN 					EQU 1
  0002                 277     XP_3A_TAIL 					EQU 2
  0003                 278     XP_3A_MULTI 					EQU 3
  0004                 279     XP_7A_MAIN 					EQU 4
  0005                 280     XP_7A_TAIL 					EQU 5
  0006                 281     XP_7A_MULTI 					EQU 6
  0007                 282     XP_7A_FAST_MAIN 				EQU 7
  0008                 283     XP_7A_FAST_TAIL 				EQU 8
  0009                 284     XP_7A_FAST_MULTI 				EQU 9
  000A                 285     XP_12A_MAIN 					EQU 10
  000B                 286     XP_12A_TAIL 					EQU 11
  000C                 287     XP_12A_MULTI 					EQU 12
  000D                 288     XP_18A_MAIN 					EQU 13
  000E                 289     XP_18A_TAIL 					EQU 14
  000F                 290     XP_18A_MULTI 					EQU 15
  0010                 291     XP_25A_MAIN 					EQU 16
  0011                 292     XP_25A_TAIL 					EQU 17
  0012                 293     XP_25A_MULTI 					EQU 18
  0013                 294     XP_35A_SW_MAIN 				EQU 19
  0014                 295     XP_35A_SW_TAIL 				EQU 20
  0015                 296     XP_35A_SW_MULTI 				EQU 21
  0016                 297     DP_3A_MAIN 					EQU 22
  0017                 298     DP_3A_TAIL  					EQU 23
  0018                 299     DP_3A_MULTI  					EQU 24
  0019                 300     SUPERMICRO_3P5A_MAIN 			EQU 25
  001A                 301     SUPERMICRO_3P5A_TAIL 			EQU 26   
  001B                 302     SUPERMICRO_3P5A_MULTI 			EQU 27   
  001C                 303     TURNIGY_PLUSH_6A_MAIN 			EQU 28
  001D                 304     TURNIGY_PLUSH_6A_TAIL 			EQU 29   
  001E                 305     TURNIGY_PLUSH_6A_MULTI 			EQU 30   
  001F                 306     TURNIGY_PLUSH_10A_MAIN 			EQU 31
  0020                 307     TURNIGY_PLUSH_10A_TAIL 			EQU 32   
  0021                 308     TURNIGY_PLUSH_10A_MULTI 			EQU 33   
  0022                 309     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                 310     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                 311     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  0025                 312     TURNIGY_PLUSH_18A_MAIN 			EQU 37
  0026                 313     TURNIGY_PLUSH_18A_TAIL 			EQU 38   
  0027                 314     TURNIGY_PLUSH_18A_MULTI 			EQU 39   
  0028                 315     TURNIGY_PLUSH_25A_MAIN 			EQU 40
  0029                 316     TURNIGY_PLUSH_25A_TAIL 			EQU 41   
  002A                 317     TURNIGY_PLUSH_25A_MULTI 			EQU 42   
  002B                 318     TURNIGY_PLUSH_30A_MAIN 			EQU 43
  002C                 319     TURNIGY_PLUSH_30A_TAIL 			EQU 44   
  002D                 320     TURNIGY_PLUSH_30A_MULTI 			EQU 45   
  002E                 321     TURNIGY_PLUSH_40A_MAIN 			EQU 46
  002F                 322     TURNIGY_PLUSH_40A_TAIL 			EQU 47   
  0030                 323     TURNIGY_PLUSH_40A_MULTI 			EQU 48   
  0031                 324     TURNIGY_PLUSH_60A_MAIN 			EQU 49
  0032                 325     TURNIGY_PLUSH_60A_TAIL 			EQU 50   
  0033                 326     TURNIGY_PLUSH_60A_MULTI 			EQU 51   
  0034                 327     TURNIGY_PLUSH_80A_MAIN 			EQU 52
  0035                 328     TURNIGY_PLUSH_80A_TAIL 			EQU 53   
  0036                 329     TURNIGY_PLUSH_80A_MULTI 			EQU 54   
  0037                 330     TURNIGY_PLUSH_NFET_18A_MAIN 		EQU 55
  0038                 331     TURNIGY_PLUSH_NFET_18A_TAIL 		EQU 56   
  0039                 332     TURNIGY_PLUSH_NFET_18A_MULTI 		EQU 57   
  003A                 333     TURNIGY_PLUSH_NFET_25A_MAIN 		EQU 58
  003B                 334     TURNIGY_PLUSH_NFET_25A_TAIL 		EQU 59   
  003C                 335     TURNIGY_PLUSH_NFET_25A_MULTI 		EQU 60   
  003D                 336     TURNIGY_PLUSH_NFET_30A_MAIN 		EQU 61
  003E                 337     TURNIGY_PLUSH_NFET_30A_TAIL 		EQU 62   
  003F                 338     TURNIGY_PLUSH_NFET_30A_MULTI 		EQU 63   
  0040                 339     TURNIGY_AE_20A_MAIN 			EQU 64
  0041                 340     TURNIGY_AE_20A_TAIL 			EQU 65   
  0042                 341     TURNIGY_AE_20A_MULTI 			EQU 66   
  0043                 342     TURNIGY_AE_25A_MAIN 			EQU 67
  0044                 343     TURNIGY_AE_25A_TAIL 			EQU 68   
  0045                 344     TURNIGY_AE_25A_MULTI 			EQU 69   
  0046                 345     TURNIGY_AE_30A_MAIN 			EQU 70
  0047                 346     TURNIGY_AE_30A_TAIL 			EQU 71   
  0048                 347     TURNIGY_AE_30A_MULTI 			EQU 72   
  0049                 348     TURNIGY_AE_45A_MAIN 			EQU 73
  004A                 349     TURNIGY_AE_45A_TAIL 			EQU 74   
  004B                 350     TURNIGY_AE_45A_MULTI 			EQU 75   
  004C                 351     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                 352     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                 353     TURNIGY_KFORCE_40A_MULTI 		EQU 78   
  004F                 354     TURNIGY_KFORCE_70A_HV_MAIN 		EQU 79   
  0050                 355     TURNIGY_KFORCE_70A_HV_TAIL 		EQU 80   
  0051                 356     TURNIGY_KFORCE_70A_HV_MULTI 		EQU 81   
  0052                 357     TURNIGY_KFORCE_120A_HV_MAIN 		EQU 82   
  0053                 358     TURNIGY_KFORCE_120A_HV_TAIL 		EQU 83   
  0054                 359     TURNIGY_KFORCE_120A_HV_MULTI 		EQU 84   
  0055                 360     TURNIGY_KFORCE_120A_HV_V2_MAIN	EQU 85   
  0056                 361     TURNIGY_KFORCE_120A_HV_V2_TAIL 	EQU 86   
  0057                 362     TURNIGY_KFORCE_120A_HV_V2_MULTI 	EQU 87   
  0058                 363     SKYWALKER_20A_MAIN 				EQU 88
  0059                 364     SKYWALKER_20A_TAIL 				EQU 89   
  005A                 365     SKYWALKER_20A_MULTI 			EQU 90   
  005B                 366     SKYWALKER_40A_MAIN 				EQU 91
  005C                 367     SKYWALKER_40A_TAIL 				EQU 92   
  005D                 368     SKYWALKER_40A_MULTI 			EQU 93   
  005E                 369     HIMODEL_COOL_22A_MAIN 			EQU 94
  005F                 370     HIMODEL_COOL_22A_TAIL 			EQU 95   
  0060                 371     HIMODEL_COOL_22A_MULTI 			EQU 96   
  0061                 372     HIMODEL_COOL_33A_MAIN 			EQU 97
  0062                 373     HIMODEL_COOL_33A_TAIL 			EQU 98   
  0063                 374     HIMODEL_COOL_33A_MULTI 			EQU 99  
  0064                 375     HIMODEL_COOL_41A_MAIN 			EQU 100
  0065                 376     HIMODEL_COOL_41A_TAIL 			EQU 101  
  0066                 377     HIMODEL_COOL_41A_MULTI 			EQU 102  
  0067                 378     RCTIMER_6A_MAIN 				EQU 103   
  0068                 379     RCTIMER_6A_TAIL 				EQU 104  
  0069                 380     RCTIMER_6A_MULTI 				EQU 105  
  006A                 381     ALIGN_RCE_BL15X_MAIN			EQU 106   
  006B                 382     ALIGN_RCE_BL15X_TAIL 			EQU 107  
  006C                 383     ALIGN_RCE_BL15X_MULTI 			EQU 108  
  006D                 384     ALIGN_RCE_BL15P_MAIN			EQU 109  
  006E                 385     ALIGN_RCE_BL15P_TAIL 			EQU 110  
  006F                 386     ALIGN_RCE_BL15P_MULTI 			EQU 111  
  0070                 387     ALIGN_RCE_BL35X_MAIN			EQU 112  
  0071                 388     ALIGN_RCE_BL35X_TAIL 			EQU 113  
  0072                 389     ALIGN_RCE_BL35X_MULTI 			EQU 114  
  0073                 390     ALIGN_RCE_BL35P_MAIN			EQU 115   
  0074                 391     ALIGN_RCE_BL35P_TAIL 			EQU 116  
  0075                 392     ALIGN_RCE_BL35P_MULTI 			EQU 117  
  0076                 393     GAUI_GE_183_18A_MAIN			EQU 118   
  0077                 394     GAUI_GE_183_18A_TAIL 			EQU 119  
  0078                 395     GAUI_GE_183_18A_MULTI 			EQU 120  
  0079                 396     H_KING_10A_MAIN				EQU 121   
  007A                 397     H_KING_10A_TAIL 				EQU 122  
  007B                 398     H_KING_10A_MULTI 				EQU 123  
  007C                 399     H_KING_20A_MAIN				EQU 124   
  007D                 400     H_KING_20A_TAIL 				EQU 125  
  007E                 401     H_KING_20A_MULTI 				EQU 126  
  007F                 402     H_KING_35A_MAIN				EQU 127   
  0080                 403     H_KING_35A_TAIL 				EQU 128 
  0081                 404     H_KING_35A_MULTI 				EQU 129  
  0082                 405     H_KING_50A_MAIN				EQU 130   
  0083                 406     H_KING_50A_TAIL 				EQU 131  
  0084                 407     H_KING_50A_MULTI 				EQU 132  
  0085                 408     POLARIS_THUNDER_12A_MAIN			EQU 133   
  0086                 409     POLARIS_THUNDER_12A_TAIL 		EQU 134  
  0087                 410     POLARIS_THUNDER_12A_MULTI 		EQU 135  
  0088                 411     POLARIS_THUNDER_20A_MAIN			EQU 136   
  0089                 412     POLARIS_THUNDER_20A_TAIL 		EQU 137  
  008A                 413     POLARIS_THUNDER_20A_MULTI 		EQU 138  
  008B                 414     POLARIS_THUNDER_30A_MAIN			EQU 139   
  008C                 415     POLARIS_THUNDER_30A_TAIL 		EQU 140  
  008D                 416     POLARIS_THUNDER_30A_MULTI 		EQU 141  
  008E                 417     POLARIS_THUNDER_40A_MAIN			EQU 142   
  008F                 418     POLARIS_THUNDER_40A_TAIL 		EQU 143  
  0090                 419     POLARIS_THUNDER_40A_MULTI 		EQU 144  
  0091                 420     POLARIS_THUNDER_60A_MAIN			EQU 145   
  0092                 421     POLARIS_THUNDER_60A_TAIL 		EQU 146  
  0093                 422     POLARIS_THUNDER_60A_MULTI 		EQU 147  
  0094                 423     POLARIS_THUNDER_80A_MAIN			EQU 148   
  0095                 424     POLARIS_THUNDER_80A_TAIL 		EQU 149  
  0096                 425     POLARIS_THUNDER_80A_MULTI 		EQU 150  
  0097                 426     POLARIS_THUNDER_100A_MAIN		EQU 151   
  0098                 427     POLARIS_THUNDER_100A_TAIL 		EQU 152  
  0099                 428     POLARIS_THUNDER_100A_MULTI 		EQU 153  
  009A                 429     PLATINUM_PRO_30A_MAIN			EQU 154   
  009B                 430     PLATINUM_PRO_30A_TAIL 			EQU 155  
  009C                 431     PLATINUM_PRO_30A_MULTI 			EQU 156  
  009D                 432     PLATINUM_PRO_150A_MAIN			EQU 157   
  009E                 433     PLATINUM_PRO_150A_TAIL 			EQU 158  
  009F                 434     PLATINUM_PRO_150A_MULTI 			EQU 159  
  00A0                 435     PLATINUM_50AV3_MAIN				EQU 160   
  00A1                 436     PLATINUM_50AV3_TAIL 			EQU 161  
  00A2                 437     PLATINUM_50AV3_MULTI 			EQU 162  
  00A3                 438     EAZY_3AV2_MAIN					EQU 163   
  00A4                 439     EAZY_3AV2_TAIL 				EQU 164  
  00A5                 440     EAZY_3AV2_MULTI 				EQU 165  
  00A6                 441     TAROT_30A_MAIN					EQU 166   
  00A7                 442     TAROT_30A_TAIL 				EQU 167  
  00A8                 443     TAROT_30A_MULTI 				EQU 168  
  00A9                 444     SKYIII_30A_MAIN				EQU 169   
  00AA                 445     SKYIII_30A_TAIL 				EQU 170  
  00AB                 446     SKYIII_30A_MULTI 				EQU 171  
  00AC                 447     EMAX_20A_MAIN					EQU 172   
  00AD                 448     EMAX_20A_TAIL 					EQU 173  
  00AE                 449     EMAX_20A_MULTI 				EQU 174  
  00AF                 450     EMAX_40A_MAIN					EQU 175   
  00B0                 451     EMAX_40A_TAIL 					EQU 176  
  00B1                 452     EMAX_40A_MULTI 				EQU 177  
  00B2                 453     EMAX_NANO_20A_MAIN				EQU 178   
  00B3                 454     EMAX_NANO_20A_TAIL 				EQU 179  
  00B4                 455     EMAX_NANO_20A_MULTI 			EQU 180  
  00B5                 456     XROTOR_10A_MAIN				EQU 181   
  00B6                 457     XROTOR_10A_TAIL 				EQU 182  
  00B7                 458     XROTOR_10A_MULTI 				EQU 183  
  00B8                 459     XROTOR_20A_MAIN				EQU 184   
  00B9                 460     XROTOR_20A_TAIL 				EQU 185  
  00BA                 461     XROTOR_20A_MULTI 				EQU 186  
  00BB                 462     XROTOR_40A_MAIN				EQU 187   
  00BC                 463     XROTOR_40A_TAIL 				EQU 188  
  00BD                 464     XROTOR_40A_MULTI 				EQU 189  
  00BE                 465     MDRX62H_MAIN					EQU 190   
  00BF                 466     MDRX62H_TAIL 					EQU 191  
  00C0                 467     MDRX62H_MULTI 					EQU 192  
  00C1                 468     ROTORGEEKS_20A_MAIN				EQU 193   
  00C2                 469     ROTORGEEKS_20A_TAIL 			EQU 194  
  00C3                 470     ROTORGEEKS_20A_MULTI 			EQU 195  
  00C4                 471     FLYCOLOR_FAIRY_6A_MAIN			EQU 196   
  00C5                 472     FLYCOLOR_FAIRY_6A_TAIL 			EQU 197  
  00C6                 473     FLYCOLOR_FAIRY_6A_MULTI 			EQU 198  
  00C7                 474     FLYCOLOR_FAIRY_30A_MAIN			EQU 199   
  00C8                 475     FLYCOLOR_FAIRY_30A_TAIL 			EQU 200  
  00C9                 476     FLYCOLOR_FAIRY_30A_MULTI 		EQU 201  
  00CA                 477     FVT_LITTLEBEE_20A_MAIN			EQU 202  
  00CB                 478     FVT_LITTLEBEE_20A_TAIL			EQU 203  
  00CC                 479     FVT_LITTLEBEE_20A_MULTI			EQU 204  
  00CD                 480     FVT_LITTLEBEE_30A_MAIN			EQU 205  
  00CE                 481     FVT_LITTLEBEE_30A_TAIL			EQU 206  
  00CF                 482     FVT_LITTLEBEE_30A_MULTI			EQU 207  
  00D0                 483     GRAUPNER_ULTRA_20A_MAIN			EQU 208  
  00D1                 484     GRAUPNER_ULTRA_20A_TAIL			EQU 209  
  00D2                 485     GRAUPNER_ULTRA_20A_MULTI			EQU 210  
  00D3                 486     F85_3A_MAIN					EQU 211  
  00D4                 487     F85_3A_TAIL					EQU 212  
  00D5                 488     F85_3A_MULTI					EQU 213  
  00D6                 489     ZTW_SPIDER_PRO_20A_MAIN			EQU 214  
  00D7                 490     ZTW_SPIDER_PRO_20A_TAIL			EQU 215  
  00D8                 491     ZTW_SPIDER_PRO_20A_MULTI			EQU 216  
                       492     
                       493     
                       494     ;**** **** **** **** ****
                       495     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                       496     ;BESCNO EQU XP_3A_Main 
                       497     ;BESCNO EQU XP_3A_Tail
                       498     ;BESCNO EQU XP_3A_Multi
                       499     ;BESCNO EQU XP_7A_Main
                       500     ;BESCNO EQU XP_7A_Tail
                       501     ;BESCNO EQU XP_7A_Multi
                       502     ;BESCNO EQU XP_7A_Fast_Main
                       503     ;BESCNO EQU XP_7A_Fast_Tail
                       504     ;BESCNO EQU XP_7A_Fast_Multi
                       505     ;BESCNO EQU XP_12A_Main
                       506     ;BESCNO EQU XP_12A_Tail 
                       507     ;BESCNO EQU XP_12A_Multi
                       508     ;BESCNO EQU XP_18A_Main 
                       509     ;BESCNO EQU XP_18A_Tail 
                       510     ;BESCNO EQU XP_18A_Multi
                       511     ;BESCNO EQU XP_25A_Main 
                       512     ;BESCNO EQU XP_25A_Tail 
                       513     ;BESCNO EQU XP_25A_Multi
                       514     ;BESCNO EQU XP_35A_SW_Main
                       515     ;BESCNO EQU XP_35A_SW_Tail 
                       516     ;BESCNO EQU XP_35A_SW_Multi
                       517     ;BESCNO EQU DP_3A_Main 						
                       518     ;BESCNO EQU DP_3A_Tail 
                       519     ;BESCNO EQU DP_3A_Multi 
                       520     ;BESCNO EQU Supermicro_3p5A_Main
                       521     ;BESCNO EQU Supermicro_3p5A_Tail 
                       522     ;BESCNO EQU Supermicro_3p5A_Multi
                       523     ;BESCNO EQU Turnigy_Plush_6A_Main 
                       524     ;BESCNO EQU Turnigy_Plush_6A_Tail 
                       525     ;BESCNO EQU Turnigy_Plush_6A_Multi
                       526     ;BESCNO EQU Turnigy_Plush_10A_Main 
                       527     ;BESCNO EQU Turnigy_Plush_10A_Tail 
                       528     ;BESCNO EQU Turnigy_Plush_10A_Multi
                       529     ;BESCNO EQU Turnigy_Plush_12A_Main 
                       530     ;BESCNO EQU Turnigy_Plush_12A_Tail 
                       531     ;BESCNO EQU Turnigy_Plush_12A_Multi 
                       532     ;BESCNO EQU Turnigy_Plush_18A_Main 
                       533     ;BESCNO EQU Turnigy_Plush_18A_Tail 
                       534     ;BESCNO EQU Turnigy_Plush_18A_Multi
                       535     ;BESCNO EQU Turnigy_Plush_25A_Main 
                       536     ;BESCNO EQU Turnigy_Plush_25A_Tail
                       537     ;BESCNO EQU Turnigy_Plush_25A_Multi
                       538     ;BESCNO EQU Turnigy_Plush_30A_Main 
                       539     ;BESCNO EQU Turnigy_Plush_30A_Tail 
                       540     ;BESCNO EQU Turnigy_Plush_30A_Multi
                       541     ;BESCNO EQU Turnigy_Plush_40A_Main 
                       542     ;BESCNO EQU Turnigy_Plush_40A_Tail 
                       543     ;BESCNO EQU Turnigy_Plush_40A_Multi 
                       544     ;BESCNO EQU Turnigy_Plush_60A_Main
                       545     ;BESCNO EQU Turnigy_Plush_60A_Tail 
                       546     ;BESCNO EQU Turnigy_Plush_60A_Multi
                       547     ;BESCNO EQU Turnigy_Plush_80A_Main
                       548     ;BESCNO EQU Turnigy_Plush_80A_Tail 
                       549     ;BESCNO EQU Turnigy_Plush_80A_Multi
                       550     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Main
                       551     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Tail 
                       552     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Multi 
                       553     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Main 
                       554     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Tail
                       555     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Multi
                       556     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Main  
                       557     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Tail 
                       558     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Multi
                       559     ;BESCNO EQU Turnigy_AE_20A_Main 
                       560     ;BESCNO EQU Turnigy_AE_20A_Tail 
                       561     ;BESCNO EQU Turnigy_AE_20A_Multi
                       562     ;BESCNO EQU Turnigy_AE_25A_Main 
                       563     ;BESCNO EQU Turnigy_AE_25A_Tail 
                       564     ;BESCNO EQU Turnigy_AE_25A_Multi
                       565     ;BESCNO EQU Turnigy_AE_30A_Main 
                       566     ;BESCNO EQU Turnigy_AE_30A_Tail 
                       567     ;BESCNO EQU Turnigy_AE_30A_Multi
                       568     ;BESCNO EQU Turnigy_AE_45A_Main
                       569     ;BESCNO EQU Turnigy_AE_45A_Tail 
                       570     ;BESCNO EQU Turnigy_AE_45A_Multi
                       571     ;BESCNO EQU Turnigy_KForce_40A_Main
                       572     ;BESCNO EQU Turnigy_KForce_40A_Tail 
                       573     ;BESCNO EQU Turnigy_KForce_40A_Multi 
                       574     ;BESCNO EQU Turnigy_KForce_70A_HV_Main
                       575     ;BESCNO EQU Turnigy_KForce_70A_HV_Tail 
                       576     ;BESCNO EQU Turnigy_KForce_70A_HV_Multi
                       577     ;BESCNO EQU Turnigy_KForce_120A_HV_Main
                       578     ;BESCNO EQU Turnigy_KForce_120A_HV_Tail 
                       579     ;BESCNO EQU Turnigy_KForce_120A_HV_Multi
                       580     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Main
                       581     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Tail 
                       582     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Multi
                       583     ;BESCNO EQU Skywalker_20A_Main
                       584     ;BESCNO EQU Skywalker_20A_Tail
                       585     ;BESCNO EQU Skywalker_20A_Multi 
                       586     ;BESCNO EQU Skywalker_40A_Main 
                       587     ;BESCNO EQU Skywalker_40A_Tail 
                       588     ;BESCNO EQU Skywalker_40A_Multi
                       589     ;BESCNO EQU HiModel_Cool_22A_Main
                       590     ;BESCNO EQU HiModel_Cool_22A_Tail
                       591     ;BESCNO EQU HiModel_Cool_22A_Multi
                       592     ;BESCNO EQU HiModel_Cool_33A_Main
                       593     ;BESCNO EQU HiModel_Cool_33A_Tail
                       594     ;BESCNO EQU HiModel_Cool_33A_Multi
                       595     ;BESCNO EQU HiModel_Cool_41A_Main
                       596     ;BESCNO EQU HiModel_Cool_41A_Tail
                       597     ;BESCNO EQU HiModel_Cool_41A_Multi
                       598     ;BESCNO EQU RCTimer_6A_Main
                       599     ;BESCNO EQU RCTimer_6A_Tail
                       600     ;BESCNO EQU RCTimer_6A_Multi
                       601     ;BESCNO EQU Align_RCE_BL15X_Main
                       602     ;BESCNO EQU Align_RCE_BL15X_Tail
                       603     ;BESCNO EQU Align_RCE_BL15X_Multi
                       604     ;BESCNO EQU Align_RCE_BL15P_Main
                       605     ;BESCNO EQU Align_RCE_BL15P_Tail
                       606     ;BESCNO EQU Align_RCE_BL15P_Multi 
                       607     ;BESCNO EQU Align_RCE_BL35X_Main 
                       608     ;BESCNO EQU Align_RCE_BL35X_Tail
                       609     ;BESCNO EQU Align_RCE_BL35X_Multi
                       610     ;BESCNO EQU Align_RCE_BL35P_Main
                       611     ;BESCNO EQU Align_RCE_BL35P_Tail
                       612     ;BESCNO EQU Align_RCE_BL35P_Multi
                       613     ;BESCNO EQU Gaui_GE_183_18A_Main
                       614     ;BESCNO EQU Gaui_GE_183_18A_Tail
                       615     ;BESCNO EQU Gaui_GE_183_18A_Multi
                       616     ;BESCNO EQU H_King_10A_Main 
                       617     ;BESCNO EQU H_King_10A_Tail 
                       618     ;BESCNO EQU H_King_10A_Multi
                       619     ;BESCNO EQU H_King_20A_Main
                       620     ;BESCNO EQU H_King_20A_Tail
                       621     ;BESCNO EQU H_King_20A_Multi
                       622     ;BESCNO EQU H_King_35A_Main
                       623     ;BESCNO EQU H_King_35A_Tail
                       624     ;BESCNO EQU H_King_35A_Multi
                       625     ;BESCNO EQU H_King_50A_Main
                       626     ;BESCNO EQU H_King_50A_Tail
                       627     ;BESCNO EQU H_King_50A_Multi
                       628     ;BESCNO EQU Polaris_Thunder_12A_Main
                       629     ;BESCNO EQU Polaris_Thunder_12A_Tail
                       630     ;BESCNO EQU Polaris_Thunder_12A_Multi
                       631     ;BESCNO EQU Polaris_Thunder_20A_Main
                       632     ;BESCNO EQU Polaris_Thunder_20A_Tail
                       633     ;BESCNO EQU Polaris_Thunder_20A_Multi
                       634     ;BESCNO EQU Polaris_Thunder_30A_Main
                       635     ;BESCNO EQU Polaris_Thunder_30A_Tail
                       636     ;BESCNO EQU Polaris_Thunder_30A_Multi
                       637     ;BESCNO EQU Polaris_Thunder_40A_Main
                       638     ;BESCNO EQU Polaris_Thunder_40A_Tail
                       639     ;BESCNO EQU Polaris_Thunder_40A_Multi
                       640     ;BESCNO EQU Polaris_Thunder_60A_Main
                       641     ;BESCNO EQU Polaris_Thunder_60A_Tail
                       642     ;BESCNO EQU Polaris_Thunder_60A_Multi
                       643     ;BESCNO EQU Polaris_Thunder_80A_Main
                       644     ;BESCNO EQU Polaris_Thunder_80A_Tail
                       645     ;BESCNO EQU Polaris_Thunder_80A_Multi
                       646     ;BESCNO EQU Polaris_Thunder_100A_Main
                       647     ;BESCNO EQU Polaris_Thunder_100A_Tail
                       648     ;BESCNO EQU Polaris_Thunder_100A_Multi
                       649     ;BESCNO EQU Platinum_Pro_30A_Main
                       650     ;BESCNO EQU Platinum_Pro_30A_Tail
                       651     ;BESCNO EQU Platinum_Pro_30A_Multi 
                       652     ;BESCNO EQU Platinum_Pro_150A_Main
                       653     ;BESCNO EQU Platinum_Pro_150A_Tail
                       654     ;BESCNO EQU Platinum_Pro_150A_Multi
                       655     ;BESCNO EQU Platinum_50Av3_Main
                       656     ;BESCNO EQU Platinum_50Av3_Tail
                       657     ;BESCNO EQU Platinum_50Av3_Multi 
                       658     ;BESCNO EQU EAZY_3Av2_Main
                       659     ;BESCNO EQU EAZY_3Av2_Tail
                       660     ;BESCNO EQU EAZY_3Av2_Multi
                       661     ;BESCNO EQU Tarot_30A_Main
                       662     ;BESCNO EQU Tarot_30A_Tail
                       663     ;BESCNO EQU Tarot_30A_Multi
                       664     ;BESCNO EQU SkyIII_30A_Main
                       665     ;BESCNO EQU SkyIII_30A_Tail
                       666     ;BESCNO EQU SkyIII_30A_Multi
                       667     ;BESCNO EQU EMAX_20A_Main
                       668     ;BESCNO EQU EMAX_20A_Tail
                       669     ;BESCNO EQU EMAX_20A_Multi 
                       670     ;BESCNO EQU EMAX_40A_Main
                       671     ;BESCNO EQU EMAX_40A_Tail
                       672     ;BESCNO EQU EMAX_40A_Multi 
                       673     ;BESCNO EQU EMAX_Nano_20A_Main
                       674     ;BESCNO EQU EMAX_Nano_20A_Tail
                       675     ;BESCNO EQU EMAX_Nano_20A_Multi 
                       676     ;BESCNO EQU XRotor_10A_Main 
                       677     ;BESCNO EQU XRotor_10A_Tail
                       678     ;BESCNO EQU XRotor_10A_Multi 
                       679     ;BESCNO EQU XRotor_20A_Main
                       680     ;BESCNO EQU XRotor_20A_Tail
                       681     ;BESCNO EQU XRotor_20A_Multi 
                       682     ;BESCNO EQU XRotor_40A_Main
                       683     ;BESCNO EQU XRotor_40A_Tail
                       684     ;BESCNO EQU XRotor_40A_Multi 
                       685     ;BESCNO EQU MDRX62H_Main
                       686     ;BESCNO EQU MDRX62H_Tail
                       687     ;BESCNO EQU MDRX62H_Multi 
                       688     ;BESCNO EQU RotorGeeks_20A_Main
                       689     ;BESCNO EQU RotorGeeks_20A_Tail
                       690     ;BESCNO EQU RotorGeeks_20A_Multi
                       691     ;BESCNO EQU Flycolor_Fairy_6A_Main
                       692     ;BESCNO EQU Flycolor_Fairy_6A_Tail
                       693     ;BESCNO EQU Flycolor_Fairy_6A_Multi
                       694     ;BESCNO EQU Flycolor_Fairy_30A_Main
                       695     ;BESCNO EQU Flycolor_Fairy_30A_Tail
                       696     ;BESCNO EQU Flycolor_Fairy_30A_Multi
                       697     ;BESCNO EQU FVT_Littlebee_20A_Main
                       698     ;BESCNO EQU FVT_Littlebee_20A_Tail
                       699     ;BESCNO EQU FVT_Littlebee_20A_Multi 
                       700     ;BESCNO EQU FVT_Littlebee_30A_Main
                       701     ;BESCNO EQU FVT_Littlebee_30A_Tail
                       702     ;BESCNO EQU FVT_Littlebee_30A_Multi 
                       703     ;BESCNO EQU Graupner_Ultra_20A_Main
                       704     ;BESCNO EQU Graupner_Ultra_20A_Tail
                       705     ;BESCNO EQU Graupner_Ultra_20A_Multi 
                       706     ;BESCNO EQU F85_3A_Main
                       707     ;BESCNO EQU F85_3A_Tail
                       708     ;BESCNO EQU F85_3A_Multi
                       709     ;BESCNO EQU ZTW_Spider_Pro_20A_Main
                       710     ;BESCNO EQU ZTW_Spider_Pro_20A_Tail
                       711     ;BESCNO EQU ZTW_Spider_Pro_20A_Multi
                       712     
                       713     
                       714     ;**** **** **** **** ****
                       715     ; ESC selection statements
                       716     IF BESCNO == XP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       720     
                       721     IF BESCNO == XP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       725     
                       726     IF BESCNO == XP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       730     
                       731     IF BESCNO == XP_7A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       735     
                       736     IF BESCNO == XP_7A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       740     
                       741     IF BESCNO == XP_7A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       745     
                       746     IF BESCNO == XP_7A_FAST_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       750     
                       751     IF BESCNO == XP_7A_FAST_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       755     
                       756     IF BESCNO == XP_7A_FAST_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       760     
                       761     IF BESCNO == XP_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       765     
                       766     IF BESCNO == XP_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       770     
                       771     IF BESCNO == XP_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       775     
                       776     IF BESCNO == XP_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       780     
                       781     IF BESCNO == XP_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       785     
                       786     IF BESCNO == XP_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       790     
                       791     IF BESCNO == XP_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       795     
                       796     IF BESCNO == XP_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       800     
                       801     IF BESCNO == XP_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       805     
                       806     IF BESCNO == XP_35A_SW_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       810     
                       811     IF BESCNO == XP_35A_SW_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       815     
                       816     IF BESCNO == XP_35A_SW_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       820     
                       821     IF BESCNO == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       825     
                       826     IF BESCNO == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       830     
                       831     IF BESCNO == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       835     
                       836     IF BESCNO == SUPERMICRO_3P5A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       840     
                       841     IF BESCNO == SUPERMICRO_3P5A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       845     
                       846     IF BESCNO == SUPERMICRO_3P5A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       850     
                       851     IF BESCNO == TURNIGY_PLUSH_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       855     
                       856     IF BESCNO == TURNIGY_PLUSH_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       860     
                       861     IF BESCNO == TURNIGY_PLUSH_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       865     
                       866     IF BESCNO == TURNIGY_PLUSH_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       870     
                       871     IF BESCNO == TURNIGY_PLUSH_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       875     
                       876     IF BESCNO == TURNIGY_PLUSH_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       880     
                       881     IF BESCNO == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       885     
                       886     IF BESCNO == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       890     
                       891     IF BESCNO == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       895     
                       896     IF BESCNO == TURNIGY_PLUSH_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       900     
                       901     IF BESCNO == TURNIGY_PLUSH_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       905     
                       906     IF BESCNO == TURNIGY_PLUSH_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       910     
                       911     IF BESCNO == TURNIGY_PLUSH_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       915     
                       916     IF BESCNO == TURNIGY_PLUSH_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       920     
                       921     IF BESCNO == TURNIGY_PLUSH_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       925     
                       926     IF BESCNO == TURNIGY_PLUSH_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       930     
                       931     IF BESCNO == TURNIGY_PLUSH_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       935     
                       936     IF BESCNO == TURNIGY_PLUSH_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       940     
                       941     IF BESCNO == TURNIGY_PLUSH_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       945     
                       946     IF BESCNO == TURNIGY_PLUSH_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       950     
                       951     IF BESCNO == TURNIGY_PLUSH_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       955     
                       956     IF BESCNO == TURNIGY_PLUSH_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       960     
                       961     IF BESCNO == TURNIGY_PLUSH_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       965     
                       966     IF BESCNO == TURNIGY_PLUSH_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       970     
                       971     IF BESCNO == TURNIGY_PLUSH_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       975     
                       976     IF BESCNO == TURNIGY_PLUSH_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       980     
                       981     IF BESCNO == TURNIGY_PLUSH_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       985     
                       986     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       990     
                       991     IF BESCNO == TURNIGY_PLUSH_NFET_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       995     
                       996     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1000     
                      1001     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1005     
                      1006     IF BESCNO == TURNIGY_PLUSH_NFET_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1010     
                      1011     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1015     
                      1016     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1020     
                      1021     IF BESCNO == TURNIGY_PLUSH_NFET_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1025     
                      1026     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1030     
                      1031     IF BESCNO == TURNIGY_AE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1035     
                      1036     IF BESCNO == TURNIGY_AE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1040     
                      1041     IF BESCNO == TURNIGY_AE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1045     
                      1046     IF BESCNO == TURNIGY_AE_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1050     
                      1051     IF BESCNO == TURNIGY_AE_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1055     
                      1056     IF BESCNO == TURNIGY_AE_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1060     
                      1061     IF BESCNO == TURNIGY_AE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1065     
                      1066     IF BESCNO == TURNIGY_AE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1070     
                      1071     IF BESCNO == TURNIGY_AE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1075     
                      1076     IF BESCNO == TURNIGY_AE_45A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1080     
                      1081     IF BESCNO == TURNIGY_AE_45A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1085     
                      1086     IF BESCNO == TURNIGY_AE_45A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1090     
                      1091     IF BESCNO == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1095     
                      1096     IF BESCNO == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1100     
                      1101     IF BESCNO == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1105     
                      1106     IF BESCNO == TURNIGY_KFORCE_70A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1110     
                      1111     IF BESCNO == TURNIGY_KFORCE_70A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1115     
                      1116     IF BESCNO == TURNIGY_KFORCE_70A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1120     
                      1121     IF BESCNO == TURNIGY_KFORCE_120A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1125     
                      1126     IF BESCNO == TURNIGY_KFORCE_120A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1130     
                      1131     IF BESCNO == TURNIGY_KFORCE_120A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1135     
                      1136     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1140     
                      1141     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1145     
                      1146     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1150     
                      1151     IF BESCNO == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1155     
                      1156     IF BESCNO == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1160     
                      1161     IF BESCNO == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1165     
                      1166     IF BESCNO == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1170     
                      1171     IF BESCNO == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1175     
                      1176     IF BESCNO == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1180     
                      1181     IF BESCNO == HIMODEL_COOL_22A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1185     
                      1186     IF BESCNO == HIMODEL_COOL_22A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1190     
                      1191     IF BESCNO == HIMODEL_COOL_22A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1195     
                      1196     IF BESCNO == HIMODEL_COOL_33A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1200     
                      1201     IF BESCNO == HIMODEL_COOL_33A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1205     
                      1206     IF BESCNO == HIMODEL_COOL_33A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1210     
                      1211     IF BESCNO == HIMODEL_COOL_41A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1215     
                      1216     IF BESCNO == HIMODEL_COOL_41A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1220     
                      1221     IF BESCNO == HIMODEL_COOL_41A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1225     
                      1226     IF BESCNO == RCTIMER_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1230     
                      1231     IF BESCNO == RCTIMER_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1235     
                      1236     IF BESCNO == RCTIMER_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1240     
                      1241     IF BESCNO == ALIGN_RCE_BL15X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1245     
                      1246     IF BESCNO == ALIGN_RCE_BL15X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1250     
                      1251     IF BESCNO == ALIGN_RCE_BL15X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1255     
                      1256     IF BESCNO == ALIGN_RCE_BL15P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1260     
                      1261     IF BESCNO == ALIGN_RCE_BL15P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1265     
                      1266     IF BESCNO == ALIGN_RCE_BL15P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1270     
                      1271     IF BESCNO == ALIGN_RCE_BL35X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1275     
                      1276     IF BESCNO == ALIGN_RCE_BL35X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1280     
                      1281     IF BESCNO == ALIGN_RCE_BL35X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1285     
                      1286     IF BESCNO == ALIGN_RCE_BL35P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1290     
                      1291     IF BESCNO == ALIGN_RCE_BL35P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1295     
                      1296     IF BESCNO == ALIGN_RCE_BL35P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1300     
                      1301     IF BESCNO == GAUI_GE_183_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1305     
                      1306     IF BESCNO == GAUI_GE_183_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1310     
                      1311     IF BESCNO == GAUI_GE_183_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1315     
                      1316     IF BESCNO == H_KING_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1320     
                      1321     IF BESCNO == H_KING_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1325     
                      1326     IF BESCNO == H_KING_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1330     
                      1331     IF BESCNO == H_KING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1335     
                      1336     IF BESCNO == H_KING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1340     
                      1341     IF BESCNO == H_KING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1345     
                      1346     IF BESCNO == H_KING_35A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1350     
                      1351     IF BESCNO == H_KING_35A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1355     
                      1356     IF BESCNO == H_KING_35A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1360     
                      1361     IF BESCNO == H_KING_50A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1365     
                      1366     IF BESCNO == H_KING_50A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1370     
                      1371     IF BESCNO == H_KING_50A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1375     
                      1376     IF BESCNO == POLARIS_THUNDER_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1380     
                      1381     IF BESCNO == POLARIS_THUNDER_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1385     
                      1386     IF BESCNO == POLARIS_THUNDER_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1390     
                      1391     IF BESCNO == POLARIS_THUNDER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1395     
                      1396     IF BESCNO == POLARIS_THUNDER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1400     
                      1401     IF BESCNO == POLARIS_THUNDER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1405     
                      1406     IF BESCNO == POLARIS_THUNDER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1410     
                      1411     IF BESCNO == POLARIS_THUNDER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1415     
                      1416     IF BESCNO == POLARIS_THUNDER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1420     
                      1421     IF BESCNO == POLARIS_THUNDER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1425     
                      1426     IF BESCNO == POLARIS_THUNDER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1430     
                      1431     IF BESCNO == POLARIS_THUNDER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1435     
                      1436     IF BESCNO == POLARIS_THUNDER_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1440     
                      1441     IF BESCNO == POLARIS_THUNDER_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1445     
                      1446     IF BESCNO == POLARIS_THUNDER_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1450     
                      1451     IF BESCNO == POLARIS_THUNDER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1455     
                      1456     IF BESCNO == POLARIS_THUNDER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1460     
                      1461     IF BESCNO == POLARIS_THUNDER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1465     
                      1466     IF BESCNO == POLARIS_THUNDER_100A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1470     
                      1471     IF BESCNO == POLARIS_THUNDER_100A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1475     
                      1476     IF BESCNO == POLARIS_THUNDER_100A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1480     
                      1481     IF BESCNO == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1485     
                      1486     IF BESCNO == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1490     
                      1491     IF BESCNO == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1495     
                      1496     IF BESCNO == PLATINUM_PRO_150A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1500     
                      1501     IF BESCNO == PLATINUM_PRO_150A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1505     
                      1506     IF BESCNO == PLATINUM_PRO_150A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1510     
                      1511     IF BESCNO == PLATINUM_50AV3_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1515     
                      1516     IF BESCNO == PLATINUM_50AV3_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1520     
                      1521     IF BESCNO == PLATINUM_50AV3_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1525     
                      1526     IF BESCNO == EAZY_3AV2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1530     
                      1531     IF BESCNO == EAZY_3AV2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1535     
                      1536     IF BESCNO == EAZY_3AV2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1540     
                      1541     IF BESCNO == TAROT_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1545     
                      1546     IF BESCNO == TAROT_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1550     
                      1551     IF BESCNO == TAROT_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1555     
                      1556     IF BESCNO == SKYIII_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1560     
                      1561     IF BESCNO == SKYIII_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1565     
                      1566     IF BESCNO == SKYIII_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1570     
                      1571     IF BESCNO == EMAX_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1575     
                      1576     IF BESCNO == EMAX_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1580     
                      1581     IF BESCNO == EMAX_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1585     
                      1586     IF BESCNO == EMAX_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1590     
                      1591     IF BESCNO == EMAX_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1595     
                      1596     IF BESCNO == EMAX_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1600     
                      1601     IF BESCNO == EMAX_NANO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1605     
                      1606     IF BESCNO == EMAX_NANO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1610     
                      1611     IF BESCNO == EMAX_NANO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1615     
                      1616     IF BESCNO == XROTOR_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1620     
                      1621     IF BESCNO == XROTOR_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1625     
                      1626     IF BESCNO == XROTOR_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1630     
                      1631     IF BESCNO == XROTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1635     
                      1636     IF BESCNO == XROTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1640     
                      1641     IF BESCNO == XROTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1645     
                      1646     IF BESCNO == XROTOR_40A_MAIN
  0000                1647     MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                      1648     $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                      2262     ENDIF
                      2263     
                      2264     IF BESCNO == XROTOR_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      2268     
                      2269     IF BESCNO == XROTOR_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      2273     
                      2274     IF BESCNO == MDRX62H_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2278     
                      2279     IF BESCNO == MDRX62H_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2283     
                      2284     IF BESCNO == MDRX62H_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2288     
                      2289     IF BESCNO == ROTORGEEKS_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2293     
                      2294     IF BESCNO == ROTORGEEKS_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2298     
                      2299     IF BESCNO == ROTORGEEKS_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2303     
                      2304     IF BESCNO == FLYCOLOR_FAIRY_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2308     
                      2309     IF BESCNO == FLYCOLOR_FAIRY_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2313     
                      2314     IF BESCNO == FLYCOLOR_FAIRY_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2318     
                      2319     IF BESCNO == FLYCOLOR_FAIRY_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2323     
                      2324     IF BESCNO == FLYCOLOR_FAIRY_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2328     
                      2329     IF BESCNO == FLYCOLOR_FAIRY_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2333     
                      2334     IF BESCNO == FVT_LITTLEBEE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2338     
                      2339     IF BESCNO == FVT_LITTLEBEE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2343     
                      2344     IF BESCNO == FVT_LITTLEBEE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2348     
                      2349     IF BESCNO == FVT_LITTLEBEE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2353     
                      2354     IF BESCNO == FVT_LITTLEBEE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2358     
                      2359     IF BESCNO == FVT_LITTLEBEE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2363     
                      2364     IF BESCNO == GRAUPNER_ULTRA_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2368     
                      2369     IF BESCNO == GRAUPNER_ULTRA_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2373     
                      2374     IF BESCNO == GRAUPNER_ULTRA_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2378     
                      2379     IF BESCNO == F85_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2383     
                      2384     IF BESCNO == F85_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2388     
                      2389     IF BESCNO == F85_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2393     
                      2394     IF BESCNO == ZTW_SPIDER_PRO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2398     
                      2399     IF BESCNO == ZTW_SPIDER_PRO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2403     
                      2404     IF BESCNO == ZTW_SPIDER_PRO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2408     
                      2409     
                      2410     ;**** **** **** **** ****
                      2411     ; TX programming defaults
                      2412     ;
                      2413     ; Parameter dependencies:
                      2414     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                      2415     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                      2416     ;
                      2417     ; MAIN
  0007                2418     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                2419     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                2420     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                2421     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                2422     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                2423     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2424     IF DAMPED_MODE_ENABLE == 1
  0002                2425     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
                      2426     ELSE
                               DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low	
                               ENDIF
  0001                2429     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2430     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                2431     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                2432     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                2433     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                2434     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                2435     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                2436     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                      2437     
                      2438     ; TAIL
  0003                2439     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                2440     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                2441     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2442     IF DAMPED_MODE_ENABLE == 1
  0003                2443     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                      2444     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		
                               ENDIF
  0001                2447     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2448     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2449     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                2450     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                2451     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                2452     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2453     DEFAULT_PGM_TAIL_PWM_DITHER		EQU 3 	; 1=Off		2=7			3=15			4=31			5=63
                      2454     
                      2455     ; MULTI
  0009                2456     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                2457     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                2458     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                2459     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0003                2460     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2461     IF DAMPED_MODE_ENABLE == 1
  0001                2462     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight 
                      2463     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low
                               ENDIF
  0002                2466     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                2467     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2468     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0028                2469     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0050                2470     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0004                2471     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2472     DEFAULT_PGM_MULTI_PWM_DITHER		EQU 3 	; 1=Off		2=7			3=15			4=31			5=63
                      2473     
                      2474     ; COMMON
  0001                2475     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 1 	; 1=Enabled 	0=Disabled
  0025                2476     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 37	; 4*37+1000=1148
  00D0                2477     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 208	; 4*208+1000=1832
  007A                2478     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 122	; 4*122+1000=1488 (used in bidirectional mode)
  0000                2479     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0=Low		1+= High or higher	
  0001                2480     DEFAULT_PGM_ENABLE_TEMP_PROT	 	EQU 1 	; 1=Enabled 	0=Disabled
  0001                2481     DEFAULT_PGM_ENABLE_POWER_PROT 	EQU 1 	; 1=Enabled 	0=Disabled
  0000                2482     DEFAULT_PGM_ENABLE_PWM_INPUT	 	EQU 0 	; 1=Enabled 	0=Disabled
                      2483     
                      2484     ; PATRICK'S CHANGES
  002B                2485     MOTOR_PPM_LOW_SLOPE				EQU 43   ;256/6 = 43 -Patrick
                      2486     
                      2487     ;**** **** **** **** ****
                      2488     ; Constant definitions for main
                      2489     IF MODE == 0
                      2490     
  0002                2491     GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
  000A                2492     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0040                2493     RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0020                2494     RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                2495     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                2496     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                2497     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                2498     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                2499     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                      2500     
  0032                2501     PWM_START			EQU	50 	; PWM used as max power during start
                      2502     
  0001                2503     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                      2504     
  0008                2505     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                      2506     
                      2507     ENDIF
                      2508     ; Constant definitions for tail
                      2509     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2528     ; Constant definitions for multi
                      2529     IF MODE == 2
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2548     
                      2549     ;**** **** **** **** ****
                      2550     ; Temporary register definitions
  REG                 2551     TEMP1		EQU	R0
  REG                 2552     TEMP2		EQU	R1
  REG                 2553     TEMP3		EQU	R2
  REG                 2554     TEMP4		EQU	R3
  REG                 2555     TEMP5		EQU	R4
  REG                 2556     TEMP6		EQU	R5
  REG                 2557     TEMP7		EQU	R6
  REG                 2558     TEMP8		EQU	R7
                      2559     
                      2560     ;**** **** **** **** ****
                      2561     ; Register definitions
------                2562     DSEG AT 20H					; Variables segment 
                      2563     
0020                  2564     BIT_ACCESS: 				DS	1		; MUST BE AT THIS ADDRESS. Variable at bit accessible address (for non interrupt routines)
0021                  2565     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                      2566     
0022                  2567     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                  2568     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                  2569     CURRENT_PWM: 				DS	1		; Current pwm
0025                  2570     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited
0026                  2571     CURRENT_PWM_LIM_DITH: 		DS	1		; Current pwm that is limited and dithered (applied to the motor output)
0027                  2572     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0028                  2573     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0029                  2574     RCP_OUTSIDE_RANGE_CNT: 		DS	1		; RC pulse outside range counter (incrementing) 
002A                  2575     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
002B                  2576     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
                      2577     
002C                  2578     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                2579     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                2580     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                2581     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                2582     PWM_TIMER0_OVERFLOW			EQU	3		; Set for 48MHz MCUs when PWM timer 0 overflows
  0004                2583     DEMAG_ENABLED				EQU 	4		; Set when demag compensation is enabled (above a min speed and throttle)
  0005                2584     DEMAG_DETECTED				EQU 	5		; Set when excessive demag time is detected
  0006                2585     DEMAG_CUT_POWER			EQU 	6		; Set when demag compensation cuts power
  0007                2586     HIGH_RPM					EQU 	7		; Set when motor rpm is high (Comm_Period4x_H less than 2)
                      2587     
002D                  2588     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                2589     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                2590     STARTUP_PHASE				EQU 	1		; Set when in startup phase
  0002                2591     INITIAL_RUN_PHASE			EQU	2		; Set when in initial run phase, before synchronized run is achieved
  0003                2592     DIR_CHANGE_BRAKE			EQU 	3		; Set when braking before direction change
  0004                2593     COMP_TIMED_OUT				EQU 	4		; Set when comparator reading timed out
  0005                2594     GOV_ACTIVE				EQU 	5		; Set when governor is active (enabled when speed is above minimum)
  0006                2595     SKIP_DAMP_ON				EQU 	6 		; Set when turning damping fet on is skipped
                      2596     ;						EQU 	7 		
                      2597     
002E                  2598     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                2599     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                2600     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                2601     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode
  0003                2602     PGM_PWM_HIGH_FREQ			EQU	3		; Progremmed pwm high frequency
  0004                2603     RCP_PPM					EQU 	4		; RC pulse ppm type input (set also when oneshot is set)
  0005                2604     RCP_PPM_ONESHOT125			EQU 	5		; RC pulse ppm type input is OneShot125
  0006                2605     RCP_DIR_REV				EQU 	6		; RC pulse direction in bidirectional mode
                      2606     ;						EQU 	7	
                      2607     
002F                  2608     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                2609     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                2610     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                2611     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                2612     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                2613     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                2614     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                2615     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                2616     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                      2617     
                      2618     
                      2619     ;**** **** **** **** ****
                      2620     ; RAM definitions
------                2621     DSEG AT 30H						; Ram data segment, direct addressing
                      2622     
0030                  2623     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                      2624     
0031                  2625     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                  2626     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                      2627     
0033                  2628     STARTUP_CNT: 				DS	1		; Startup phase commutations counter (incrementing)
0034                  2629     INITIAL_RUN_ROT_CNT: 		DS	1		; Initial run rotations counter (incrementing)
0035                  2630     STALL_CNT: 				DS	1		; Counts start/run attempts that resulted in stall. Reset upon a proper stop
0036                  2631     DEMAG_DETECTED_METRIC: 		DS	1		; Metric used to gauge demag event frequency
0037                  2632     DEMAG_PWR_OFF_THRESH: 		DS	1		; Metric threshold above which power is cut
0038                  2633     LOW_RPM_PWR_SLOPE: 			DS	1		; Sets the slope of power increase for low rpms
                      2634     
0039                  2635     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003A                  2636     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003B                  2637     PREV_PREV_COMM_L: 			DS	1		; Pre-previous commutation timer3 timestamp (lo byte)
003C                  2638     PREV_PREV_COMM_H: 			DS	1		; Pre-previous commutation timer3 timestamp (hi byte)
003D                  2639     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003E                  2640     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003F                  2641     COMM_DIFF: 				DS	1		; Timer3 count difference between the last two commutations
0040                  2642     COMM_PHASE: 				DS	1		; Current commutation phase
0041                  2643     COMPARATOR_READ_CNT:  		DS	1		; Number of comparator reads done
                      2644     
0042                  2645     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0043                  2646     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0044                  2647     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0045                  2648     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0046                  2649     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0047                  2650     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0048                  2651     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0049                  2652     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
004A                  2653     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
                      2654     
004B                  2655     WT_ADV_START_L: 			DS	1		; Timer3 start point for commutation advance timing (lo byte)
004C                  2656     WT_ADV_START_H: 			DS	1		; Timer3 start point for commutation advance timing (hi byte)
004D                  2657     WT_ZC_SCAN_START_L: 			DS	1		; Timer3 start point from commutation to zero cross scan (lo byte)
004E                  2658     WT_ZC_SCAN_START_H: 			DS	1		; Timer3 start point from commutation to zero cross scan (hi byte)
004F                  2659     WT_ZC_TOUT_START_L: 			DS	1		; Timer3 start point for zero cross scan timeout (lo byte)
0050                  2660     WT_ZC_TOUT_START_H: 			DS	1		; Timer3 start point for zero cross scan timeout (hi byte)
0051                  2661     WT_COMM_START_L: 			DS	1		; Timer3 start point from zero cross to commutation (lo byte)
0052                  2662     WT_COMM_START_H: 			DS	1		; Timer3 start point from zero cross to commutation (hi byte)
0053                  2663     NEXT_WT_START_L: 			DS	1		; Timer3 start point for next wait period (lo byte)
0054                  2664     NEXT_WT_START_H: 			DS	1		; Timer3 start point for next wait period (hi byte)
                      2665     
0055                  2666     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0056                  2667     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0057                  2668     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0058                  2669     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0059                  2670     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
005A                  2671     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
005B                  2672     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
005C                  2673     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005D                  2674     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005E                  2675     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005F                  2676     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
0060                  2677     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      2678     
0061                  2679     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
0062                  2680     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup
0063                  2681     PWM_LIMIT_BY_RPM: 			DS	1		; Maximum allowed pwm for low or high rpms
0064                  2682     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0065                  2683     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0066                  2684     PWM_DITHER_DECODED: 			DS	1		; Decoded pwm dither value
0067                  2685     PWM_DITHER_EXCESS_POWER: 		DS	1		; Excess power (above max) from pwm dither
0068                  2686     RANDOM: 					DS	1		; Random number from LFSR 
                      2687     
0069                  2688     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
006A                  2689     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
006B                  2690     MAIN_SPOOLUP_TIME_3X: 		DS	1		; Main spoolup time x3
006C                  2691     MAIN_SPOOLUP_TIME_10X: 		DS	1		; Main spoolup time x10
006D                  2692     MAIN_SPOOLUP_TIME_15X: 		DS	1		; Main spoolup time x15
                      2693     
006E                  2694     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006F                  2695     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
0070                  2696     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      2697     
0071                  2698     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      2699     
0072                  2700     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
0073                  2701     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      2702     
0074                  2703     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0075                  2704     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0076                  2705     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      2706     
0077                  2707     SKIP_T2_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 interrupt shall be ignored 
0078                  2708     SKIP_T2H_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 high interrupt shall be ignored 
0079                  2709     TIMER0_OVERFLOW_VALUE: 		DS	1		; Remaining timer 0 wait time used with 48MHz MCUs
007A                  2710     CLOCK_SET_AT_48MHZ: 			DS	1		; Variable set if 48MHz MCUs run at 48MHz
007B                  2711     DAMPINGFET: 				DS	1		; Port position of fet used for damping
007C                  2712     CURRENT_PWM_LIMITED_REMAPPED: 	DS	1
007D                  2713     CURRENT_PWM_LIM_DITH_REMAPPED:  DS	1
                      2714     
                      2715     ; Indirect addressing data segment. The variables below must be in this sequence
------                2716     ISEG AT 080H					
0080                  2717     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  2718     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  2719     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  2720     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  2721     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  2722     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  2723     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  2724     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  2725     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  2726     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  2727     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  2728     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  2729     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  2730     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  2731     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  2732     _PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm (unused - place holder)
0090                  2733     _PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration (unused - place holder)
0091                  2734     _PGM_VOLT_COMP: 			DS	1		; Place holder
0092                  2735     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  2736     _PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force (unused - place holder)
0094                  2737     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  2738     _PGM_STARTUP_METHOD: 		DS	1		; Programmed startup method (unused - place holder)
0096                  2739     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  2740     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  2741     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  2742     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  2743     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  2744     _PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate (unused - place holder)
009C                  2745     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  2746     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  2747     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
009F                  2748     PGM_MAIN_SPOOLUP_TIME: 		DS	1		; Programmed main spoolup time
00A0                  2749     PGM_ENABLE_TEMP_PROT: 		DS	1		; Programmed temperature protection enable
00A1                  2750     PGM_ENABLE_POWER_PROT: 		DS	1		; Programmed low rpm power protection enable
00A2                  2751     PGM_ENABLE_PWM_INPUT: 		DS	1		; Programmed PWM input signal enable
00A3                  2752     PGM_PWM_DITHER: 			DS	1		; Programmed output PWM dither
                      2753     
                      2754     ; The sequence of the variables below is no longer of importance
00A4                  2755     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A5                  2756     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A6                  2757     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
                      2758     
                      2759     
                      2760     ; Indirect addressing data segment
------                2761     ISEG AT 0D0H					
00D0                  2762     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      2763     
                      2764     
                      2765     ;**** **** **** **** ****
------                2766     CSEG AT 1A00H            ; "Eeprom" segment
  000E                2767     EEPROM_FW_MAIN_REVISION		EQU	14		; Main revision of the firmware
  0003                2768     EEPROM_FW_SUB_REVISION		EQU	3		; Sub revision of the firmware
  0014                2769     EEPROM_LAYOUT_REVISION		EQU	20		; Revision of the EEPROM layout
                      2770     
1A00    0E            2771     EEP_FW_MAIN_REVISION:  DB 14 
1A01    03            2772     EEP_FW_SUB_REVISION:  DB 3 
1A02    14            2773     EEP_LAYOUT_REVISION:  DB 20 
                      2774     
                      2775     IF MODE == 0
1A03    07            2776     EEP_PGM_GOV_P_GAIN:  DB 7 
1A04    07            2777     EEP_PGM_GOV_I_GAIN:  DB 7 
1A05    01            2778     EEP_PGM_GOV_MODE:  DB 1 
1A06    04            2779     EEP_PGM_LOW_VOLTAGE_LIM:  DB 4 
1A07    FF            2780     _EEP_PGM_MOTOR_GAIN: 		DB	0FFH							
1A08    FF            2781     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							
1A09    09            2782     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    02            2783     EEP_PGM_PWM_FREQ:  DB 2 
1A0B    01            2784     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            2785     EEP_PGM_INPUT_POL:  DB 1 
1A0D    A5            2786     EEP_INITIALIZED_L: 			DB	0A5H							; EEPROM initialized signature low byte
1A0E    5A            2787     EEP_INITIALIZED_H: 			DB	05AH							; EEPROM initialized signature high byte
1A0F    01            2788     EEP_ENABLE_TX_PROGRAM:  DB 1 
1A10    00            2789     EEP_MAIN_REARM_START:  DB 0 
1A11    B4            2790     EEP_PGM_GOV_SETUP_TARGET:  DB 180 
1A12    FF            2791     _EEP_PGM_STARTUP_RPM: 		DB	0FFH	
1A13    FF            2792     _EEP_PGM_STARTUP_ACCEL: 		DB	0FFH	
1A14    FF            2793     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            2794     EEP_PGM_COMM_TIMING:  DB 3 
1A16    FF            2795     _EEP_PGM_DAMPING_FORCE: 		DB	0FFH						
1A17    01            2796     EEP_PGM_GOV_RANGE:  DB 1 
1A18    FF            2797     _EEP_PGM_STARTUP_METHOD: 		DB	0FFH	
1A19    25            2798     EEP_PGM_PPM_MIN_THROTTLE:  DB 37 
1A1A    D0            2799     EEP_PGM_PPM_MAX_THROTTLE:  DB 208 
1A1B    78            2800     EEP_PGM_BEEP_STRENGTH:  DB 120 
1A1C    C8            2801     EEP_PGM_BEACON_STRENGTH:  DB 200 
1A1D    04            2802     EEP_PGM_BEACON_DELAY:  DB 4 
1A1E    FF            2803     _EEP_PGM_THROTTLE_RATE: 		DB	0FFH	
1A1F    01            2804     EEP_PGM_DEMAG_COMP:  DB 1 
1A20    00            2805     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    FF            2806     _EEP_PGM_PPM_CENTER_THROTTLE: 	DB	0FFH							
1A22    0A            2807     EEP_PGM_MAIN_SPOOLUP_TIME:  DB 10 
1A23    01            2808     EEP_PGM_TEMP_PROT_ENABLE:  DB 1 
1A24    01            2809     EEP_PGM_ENABLE_POWER_PROT:  DB 1 
1A25    00            2810     EEP_PGM_ENABLE_PWM_INPUT:  DB 0 
1A26    FF            2811     _EEP_PGM_PWM_DITHER: 		DB	0FFH	
                      2812     ENDIF 
                      2813     
                      2814     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               EEP_PGM_PWM_DITHER:			DB	DEFAULT_PGM_TAIL_PWM_DITHER		; EEPROM copy of programmed output PWM dither
                               ENDIF
                      2852     
                      2853     IF MODE == 2
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MULTI_P_GAIN			; EEPROM copy of programmed closed loop P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MULTI_I_GAIN			; EEPROM copy of programmed closed loop I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MULTI_GOVERNOR_MODE	; EEPROM copy of programmed closed loop mode
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_MULTI_GAIN			; EEPROM copy of programmed tail gain
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MULTI_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MULTI_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MULTI_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MULTI_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	055H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0AAH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MULTI_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MULTI_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MULTI_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MULTI_BEACON_DELAY	; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MULTI_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               EEP_PGM_PWM_DITHER:			DB	DEFAULT_PGM_MULTI_PWM_DITHER		; EEPROM copy of programmed output PWM dither
                               ENDIF
                      2891     
1A27    FF            2892     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      2893     
------                2894     CSEG AT 1A60H
1A60    20202020      2895     EEP_NAME: 					DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      2896     
                      2897     ;**** **** **** **** ****
                      2898     INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                2898+1   CSEG AT 0  ; CODE SEGMENT START
0000    0219FD        2898+1   JMP RESET 
------                2898+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200AA        2898+1   JMP T0_INT 
------                2898+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0201B0        2898+1   JMP T2_INT 
------                2898+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020364        2898+1   JMP PCA_INT 
------                2898+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02034A        2898+1   JMP T3_INT 
------                2899     CSEG AT 80H			; Code segment after interrupt vectors 
                      2900     
                      2901     ;**** **** **** **** ****
                      2902     
                      2903     ; Table definitions
0080    02030406      2904     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    0406080C      2905     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
0091    10182030
0095    406080A0
0099    C0
009A    00070F1F      2906     PWM_DITHER_TABLE:   		DB 	00H, 07H, 0FH, 1FH, 3FH
009E    3F
                      2907     IF MODE == 0
                      2908       IF DAMPED_MODE_ENABLE == 1
009F    0D0D0403      2909     	TX_PGM_PARAMS_MAIN:   	DB 	13, 13, 4, 3, 6, 13, 5, 3, 3, 2, 2
00A3    060D0503
00A7    030202
                      2910       ENDIF
                      2911       IF DAMPED_MODE_ENABLE == 0
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 2, 3, 2, 2
                                 ENDIF
                      2914     ENDIF
                      2915     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF
                               ENDIF
                      2923     IF MODE == 2
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF 
                               ENDIF
                      2931     
                      2932     
                      2933     
                      2934     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2935     ;
                      2936     ; Timer0 interrupt routine
                      2937     ;
                      2938     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      2939     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      2940     ;
                      2941     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2942     T0_INT: 	; Used for pwm control
00AA    C2AF          2943     	CLR 	EA			; Disable all interrupts
                      2944     IF MCU_48MHZ == 1
                      2945     	; Check overflow flag
00AC    306308        2946     JNB FLAGS0 . 3 , T0_INT_START 
                      2947     
00AF    C263          2948     CLR FLAGS0 . 3 
00B1    85798A        2949     	MOV	TL0, TIMER0_OVERFLOW_VALUE	; Set timer 
00B4    D2AF          2950     	SETB	EA			; Enable all interrupts
00B6    32            2951     	RETI
                      2952     
                      2953     T0_INT_START: 
                      2954     ENDIF
00B7    C0D0          2955     	PUSH	PSW			; Preserve registers through interrupt
00B9    C0E0          2956     	PUSH	ACC
00BB    C0F0          2957     	PUSH	B			; Preserve B through interrupt -Patrick		
                      2958     	
                      2959     	; Scale Current_Pwm_Limited and Current_Pwm_Lim_Dith by MOTOR_PPM_LOW_SLOPE -Patrick
                      2960     
                      2961     	; Scale Current_Pwm_Limited -Patrick
00BD    75F02B        2962     MOV B , # 43 
00C0    E525          2963     	MOV	A, CURRENT_PWM_LIMITED
00C2    A4            2964     	MUL  AB
00C3    85F07C        2965     	MOV  CURRENT_PWM_LIMITED_REMAPPED, B
                      2966     
                      2967     	; Scale Current_Pwm_Lim_Dith -Patrick
00C6    75F02B        2968     MOV B , # 43 
00C9    E526          2969     	MOV	A, CURRENT_PWM_LIM_DITH
00CB    A4            2970     	MUL  AB
00CC    85F07D        2971     	MOV  CURRENT_PWM_LIM_DITH_REMAPPED, B
                      2972     
                      2973     	; Check if pwm is on
00CF    206229        2974     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      2975     
                      2976     	; Pwm on cycle
00D2    E57C          2977     	MOV	A, CURRENT_PWM_LIMITED_REMAPPED ; Replace with remapped value -Patrick
00D4    6002          2978     	JZ	T0_INT_PWM_ON_EXIT
                      2979     
                      2980     T0_INT_PWM_ON_EXECUTE: 
00D6    E4            2981     	CLR	A					
00D7    73            2982     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      2983     
                      2984     T0_INT_PWM_ON_EXIT: 
                      2985     	; Set timer for coming on cycle length
00D8    E57C          2986     	MOV 	A, CURRENT_PWM_LIMITED_REMAPPED		; Load current pwm and replace with remapped value -Patrick
00DA    F4            2987     	CPL	A						; cpl is 255-x
                      2988     IF MCU_48MHZ == 0
                               	MOV	TL0, A					; Write start point for timer
                               ELSE
00DB    C3            2991     	CLR	C
00DC    33            2992     	RLC	A
00DD    4009          2993     	JC	T0_INT_PWM_ON_SET_TIMER
                      2994     
00DF    758A00        2995     	MOV	TL0, #0
00E2    D263          2996     SETB FLAGS0 . 3 
00E4    F579          2997     	MOV	TIMER0_OVERFLOW_VALUE, A
00E6    01EA          2998     	AJMP	T0_INT_PWM_ON_TIMER_SET
                      2999     
                      3000     T0_INT_PWM_ON_SET_TIMER: 
00E8    F58A          3001     	MOV	TL0, A
                      3002     T0_INT_PWM_ON_TIMER_SET: 
                      3003     ENDIF
                      3004     	; Set other variables
00EA    758B00        3005     	MOV	TL1, #0					; Reset timer1	
                      3006     IF MCU_48MHZ == 1
00ED    758D00        3007     	MOV	TH1, #0		
                      3008     ENDIF
00F0    D262          3009     SETB FLAGS0 . 2 
                      3010     	; Exit interrupt
00F2    D0F0          3011     	POP	  B			; Restore B register -Patrick
00F4    D0E0          3012     	POP	ACC			; Restore preserved registers
00F6    D0D0          3013     	POP	PSW
00F8    D2AF          3014     	SETB	EA			; Enable all interrupts
00FA    32            3015     	RETI
                      3016     
                      3017     
                      3018     	; Pwm off cycle
                      3019     T0_INT_PWM_OFF: 
                      3020     IF MCU_48MHZ == 0
                               	MOV	TL0, CURRENT_PWM_LIM_DITH_REMAPPED	; Load new timer setting and replace with remapped value -Patrick
                               ELSE
00FB    C3            3023     	CLR	C
00FC    E57D          3024     	MOV	A, CURRENT_PWM_LIM_DITH_REMAPPED ; Replace with remapped value -Patrick
00FE    33            3025     	RLC	A
00FF    4009          3026     	JC	T0_INT_PWM_OFF_SET_TIMER 
                      3027     
0101    758A00        3028     	MOV	TL0, #0
0104    D263          3029     SETB FLAGS0 . 3 
0106    F579          3030     	MOV	TIMER0_OVERFLOW_VALUE, A
0108    210C          3031     	AJMP	T0_INT_PWM_OFF_TIMER_SET
                      3032     
                      3033     T0_INT_PWM_OFF_SET_TIMER: 
010A    F58A          3034     	MOV	TL0, A
                      3035     T0_INT_PWM_OFF_TIMER_SET: 
                      3036     ENDIF
                      3037     	; Clear pwm on flag
010C    C262          3038     CLR FLAGS0 . 2 
                      3039     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
010E    E57D          3040     	MOV	A, CURRENT_PWM_LIM_DITH_REMAPPED		; Load current pwm and replace with remapped value -Patrick
0110    F4            3041     	CPL	A						; Full pwm?
0111    603C          3042     	JZ	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      3043     
                      3044     IF DAMPED_MODE_ENABLE == 1
                      3045     	; Do not execute damped pwm when stopped
0113    306803        3046     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_EXIT_NFETS_OFF 
                      3047     
                      3048     	; If damped operation, set pFETs on in pwm_off
0116    207215        3049     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      3050     ENDIF
                      3051     
                      3052     T0_INT_PWM_OFF_EXIT_NFETS_OFF: 	
                      3053     	; Separate exit commands here for minimum delay
0119    758B00        3054     	MOV	TL1, #0		; Reset timer1	
                      3055     IF MCU_48MHZ == 1
011C    758D00        3056     	MOV	TH1, #0		
                      3057     ENDIF
011F    D0F0          3058     	POP	  B			; Restore B register -Patrick
0121    D0E0          3059     	POP	ACC			; Restore preserved registers
0123    D0D0          3060     	POP	PSW
                      3061     	ALL_NFETS_OFF 		; Switch off all nfets
0125    C293          3061+1   CLR P1 . 3 
0127    C297          3061+1   CLR P1 . 7 
0129    C294          3061+1   CLR P1 . 4 
012B    D2AF          3062     	SETB	EA			; Enable all interrupts
012D    32            3063     	RETI
                      3064     
                      3065     T0_INT_PWM_OFF_DAMPED: 
                      3066     IF PFETON_DELAY < 128
                      3067     	ALL_NFETS_OFF 				; Switch off all nfets
012E    C293          3067+1   CLR P1 . 3 
0130    C297          3067+1   CLR P1 . 7 
0132    C294          3067+1   CLR P1 . 4 
0134    206E09        3068     JB FLAGS1 . 6 , T0_INT_PWM_OFF_DAMP_DONE 
                      3069     IF PFETON_DELAY NE 0
0137    740C          3070     MOV A , # 12 
0139    D5E0FD        3071     	DJNZ	ACC, $	
                      3072     ENDIF
                      3073     	DAMPING_FET_ON
013C    E57B          3073+1   MOV A , DAMPINGFET 
013E    4290          3073+1   ORL P1 , A 
                      3074     T0_INT_PWM_OFF_DAMP_DONE: 
                      3075     ENDIF
                      3076     IF PFETON_DELAY >= 128			; "Negative", 1's complement
                               	JB	FLAGS1.SKIP_DAMP_ON, T0_INT_PWM_OFF_DAMP_DONE
                               	DAMPING_FET_ON				; Damping fet on
                               	MOV	A, #PFETON_DELAY
                               	CPL	A
                               T0_INT_PWM_OFF_DAMP_DONE:
                               	ALL_NFETS_OFF 				; Switch off all nfets
                               ENDIF
                      3084     T0_INT_PWM_OFF_EXIT: 	
0140    758B00        3085     	MOV	TL1, #0		; Reset timer1	
                      3086     IF MCU_48MHZ == 1
0143    758D00        3087     	MOV	TH1, #0		
                      3088     ENDIF
0146    D0F0          3089     	POP	  B			; Restore B register -Patrick
0148    D0E0          3090     	POP	ACC			; Restore preserved registers
014A    D0D0          3091     	POP	PSW
014C    D2AF          3092     	SETB	EA			; Enable all interrupts
014E    32            3093     	RETI
                      3094     
                      3095     T0_INT_PWM_OFF_FULLPOWER_EXIT: 
014F    758A00        3096     	MOV	TL0, #0		; Set long time till next interrupt
                      3097     IF MCU_48MHZ == 1
0152    D263          3098     SETB FLAGS0 . 3 
0154    757900        3099     	MOV	TIMER0_OVERFLOW_VALUE, #0
                      3100     ENDIF
0157    C28D          3101     	CLR	TF0			; Clear interrupt flag
0159    D262          3102     SETB FLAGS0 . 2 
015B    2140          3103     	AJMP	T0_INT_PWM_OFF_EXIT
                      3104     
                      3105     
                      3106     PWM_NOFET: 	; Dummy pwm on cycle
015D    01D8          3107     	AJMP	T0_INT_PWM_ON_EXIT
                      3108     
                      3109     PWM_AFET: 		; Pwm on cycle afet on
015F    306805        3110     JNB FLAGS1 . 0 , PWM_AFET_EXIT 
0162    206602        3111     JB FLAGS0 . 6 , PWM_AFET_EXIT 
                      3112     	ANFET_ON	
0165    D293          3112+1   SETB P1 . 3 
                      3113     PWM_AFET_EXIT: 
0167    01D8          3114     	AJMP	T0_INT_PWM_ON_EXIT
                      3115     
                      3116     PWM_BFET: 		; Pwm on cycle bfet on
0169    306805        3117     JNB FLAGS1 . 0 , PWM_BFET_EXIT 
016C    206602        3118     JB FLAGS0 . 6 , PWM_BFET_EXIT 
                      3119     	BNFET_ON
016F    D294          3119+1   SETB P1 . 4 
                      3120     PWM_BFET_EXIT: 
0171    01D8          3121     	AJMP	T0_INT_PWM_ON_EXIT
                      3122     
                      3123     PWM_CFET: 		; Pwm on cycle cfet on
0173    306805        3124     JNB FLAGS1 . 0 , PWM_CFET_EXIT 
0176    206602        3125     JB FLAGS0 . 6 , PWM_CFET_EXIT 
                      3126     	CNFET_ON
0179    D297          3126+1   SETB P1 . 7 
                      3127     PWM_CFET_EXIT: 
017B    01D8          3128     	AJMP	T0_INT_PWM_ON_EXIT
                      3129     
                      3130     PWM_AFET_DAMPED: 	
                      3131     	APFET_OFF
017D    C292          3131+1   CLR P1 . 2 
017F    30680A        3132     JNB FLAGS1 . 0 , PWM_AFET_DAMPED_EXIT 
0182    206607        3133     JB FLAGS0 . 6 , PWM_AFET_DAMPED_EXIT 
                      3134     IF NFETON_DELAY NE 0
0185    740C          3135     MOV A , # 12 
0187    D5E0FD        3136     	DJNZ ACC,	$
                      3137     ENDIF
                      3138     PWM_AFET_DAMPED_DONE: 
                      3139     	ANFET_ON								; Switch nFET
018A    D293          3139+1   SETB P1 . 3 
                      3140     PWM_AFET_DAMPED_EXIT: 
018C    01D8          3141     	AJMP	T0_INT_PWM_ON_EXIT
                      3142     
                      3143     PWM_BFET_DAMPED: 
                      3144     	BPFET_OFF
018E    C295          3144+1   CLR P1 . 5 
0190    30680A        3145     JNB FLAGS1 . 0 , PWM_BFET_DAMPED_EXIT 
0193    206607        3146     JB FLAGS0 . 6 , PWM_BFET_DAMPED_EXIT 
                      3147     IF NFETON_DELAY NE 0
0196    740C          3148     MOV A , # 12 
0198    D5E0FD        3149     	DJNZ ACC,	$
                      3150     ENDIF
                      3151     PWM_BFET_DAMPED_DONE: 
                      3152     	BNFET_ON								; Switch nFET
019B    D294          3152+1   SETB P1 . 4 
                      3153     PWM_BFET_DAMPED_EXIT: 
019D    01D8          3154     	AJMP	T0_INT_PWM_ON_EXIT
                      3155     
                      3156     PWM_CFET_DAMPED: 	
                      3157     	CPFET_OFF
019F    C296          3157+1   CLR P1 . 6 
01A1    30680A        3158     JNB FLAGS1 . 0 , PWM_CFET_DAMPED_EXIT 
01A4    206607        3159     JB FLAGS0 . 6 , PWM_CFET_DAMPED_EXIT 
                      3160     IF NFETON_DELAY NE 0
01A7    740C          3161     MOV A , # 12 
01A9    D5E0FD        3162     	DJNZ ACC,	$
                      3163     ENDIF
                      3164     PWM_CFET_DAMPED_DONE: 
                      3165     	CNFET_ON								; Switch nFET
01AC    D297          3165+1   SETB P1 . 7 
                      3166     PWM_CFET_DAMPED_EXIT:  
01AE    01D8          3167     	AJMP	T0_INT_PWM_ON_EXIT
                      3168     
                      3169     
                      3170     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3171     ;
                      3172     ; Timer2 interrupt routine
                      3173     ;
                      3174     ; No assumptions
                      3175     ;
                      3176     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3177     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
01B0    C2AF          3178     	CLR	EA
01B2    C2AD          3179     	CLR	ET2			; Disable timer2 interrupts
01B4    53E6EF        3180     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
01B7    C0D0          3181     	PUSH	PSW			; Preserve registers through interrupt
01B9    C0E0          3182     	PUSH	ACC
01BB    D2D3          3183     	SETB	PSW.3		; Select register bank 1 for interrupt routines
01BD    D2AF          3184     	SETB	EA
                      3185     IF MCU_48MHZ == 1
01BF    E57A          3186     	MOV	A, CLOCK_SET_AT_48MHZ
01C1    6009          3187     	JZ 	T2_INT_START
                      3188     
                      3189     	; Check skip variable
01C3    E577          3190     	MOV	A, SKIP_T2_INT
01C5    6005          3191     	JZ	T2_INT_START				; Execute this interrupt
                      3192     
01C7    757700        3193     	MOV	SKIP_T2_INT, #0
01CA    4155          3194     	AJMP	T2_INT_EXIT
                      3195     
                      3196     T2_INT_START: 
01CC    757701        3197     	MOV	SKIP_T2_INT, #1			; Skip next interrupt
                      3198     ENDIF
                      3199     	; Clear low byte interrupt flag
01CF    C2CE          3200     	CLR	TF2L						; Clear interrupt flag
                      3201     	; Check RC pulse timeout counter
01D1    E52A          3202     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
01D3    6007          3203     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      3204     
                      3205     	; Decrement timeout counter (if PWM)
01D5    207449        3206     JB FLAGS2 . 4 , T2_INT_SKIP_START 
                      3207     
01D8    152A          3208     	DEC	RCP_TIMEOUT_CNT			; No - decrement
01DA    4121          3209     	AJMP	T2_INT_SKIP_START
                      3210     
                      3211     T2_INT_PULSES_ABSENT: 
                      3212     	; Timeout counter has reached zero, pulses are absent
01DC    7800          3213     MOV R0 , # 0 
01DE    7900          3214     MOV R1 , # 0 
01E0    20742E        3215     JB FLAGS2 . 4 , T2_INT_PULSES_ABSENT_NO_MAX 
                      3216     
                      3217     	READ_RCP_INT 					; Look at value of Rcp_In
01E3    E580          3217+1   MOV A , P0 
01E5    307E01        3217+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
01E8    F4            3217+1   CPL A  ; YES - INVERT
01E9    30E502        3218     JNB ACC . 5 , ( $+5 ) 
01EC    78FF          3219     MOV R0 , # 255 
                      3220     	RCP_INT_FIRST 					; Set interrupt trig to first again
01EE    53DACF        3220+1   ANL PCA0CPM0 , # 0CFH 
01F1    207E03        3220+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
01F4    43DA20        3220+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
01F7    307E03        3220+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
01FA    43DA10        3220+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3221     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
01FD    C2D8          3221+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
01FF    C271          3222     CLR FLAGS2 . 1 
                      3223     	READ_RCP_INT 					; Look once more at value of Rcp_In
0201    E580          3223+1   MOV A , P0 
0203    307E01        3223+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0206    F4            3223+1   CPL A  ; YES - INVERT
0207    30E502        3224     JNB ACC . 5 , ( $+5 ) 
020A    79FF          3225     MOV R1 , # 255 
020C    C3            3226     	CLR	C
020D    E8            3227     MOV A , R0 
020E    99            3228     SUBB A , R1 
020F    70CB          3229     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      3230     
                      3231     T2_INT_PULSES_ABSENT_NO_MAX: 
0211    306103        3232     JNB FLAGS0 . 1 , ( $+6 ) 
                      3233     
0214    752A40        3234     MOV RCP_TIMEOUT_CNT , # 64 
                      3235     
0217    207403        3236     JB FLAGS2 . 4 , T2_INT_PPM_TIMEOUT_SET 
                      3237     
021A    752A40        3238     MOV RCP_TIMEOUT_CNT , # 64 
                      3239     
                      3240     T2_INT_PPM_TIMEOUT_SET: 
021D    885C          3241     MOV NEW_RCP , R0 
021F    D270          3242     SETB FLAGS2 . 0 
                      3243     
                      3244     T2_INT_SKIP_START: 
0221    20740D        3245     JB FLAGS2 . 4 , T2_INT_RCP_UPDATE_START 
                      3246     
                      3247     	; Check RC pulse skip counter
0224    E52B          3248     	MOV	A, RCP_SKIP_CNT			
0226    6004          3249     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      3250     	
                      3251     	; Decrement skip counter (only if edge counter is zero)
0228    152B          3252     	DEC	RCP_SKIP_CNT				; Decrement
022A    4131          3253     	AJMP	T2_INT_RCP_UPDATE_START
                      3254     
                      3255     T2_INT_SKIP_END: 
                      3256     	; Skip counter has reached zero, start looking for RC pulses again
                      3257     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
022C    43DA01        3257+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      3258     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
022F    C2D8          3258+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3259     	
                      3260     T2_INT_RCP_UPDATE_START: 
                      3261     	; Process updated RC pulse
0231    207002        3262     JB FLAGS2 . 0 , ( $+5 ) 
0234    4144          3263     	AJMP	T2_INT_CURRENT_PWM_UPDATE	; No - update pwm limits and exit
                      3264     
0236    A85C          3265     MOV R0 , NEW_RCP 
0238    206102        3266     JB FLAGS0 . 1 , ( $+5 ) 
                      3267     
023B    C270          3268     CLR FLAGS2 . 0 
                      3269     
                      3270     	; Use a gain of 1.0625x for pwm input if not governor mode
023D    207402        3271     JB FLAGS2 . 4 , T2_INT_PWM_MIN_RUN 
                      3272     
                      3273     IF MODE == 0	; Main - do not adjust gain
0240    4142          3274     	AJMP	T2_INT_PWM_MIN_RUN
                      3275     ELSE
                               
                               IF MODE == 2	; Multi 
                               	MOV	TEMP2, #PGM_GOV_MODE		; Closed loop mode?
                               	CJNE	@TEMP2, #4, T2_INT_PWM_MIN_RUN; Yes - branch
                               ENDIF
                               
                               	; Limit the maximum value to avoid wrap when scaled to pwm range
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
                               	JC	T2_INT_RCP_UPDATE_MULT
                               
                               	MOV	A, #240			; Set requested pwm to max
                               	MOV	TEMP1, A		
                               
                               T2_INT_RCP_UPDATE_MULT:	
                               	; Multiply by 1.0625 (optional adjustment gyro gain)
                               	MOV	A, TEMP1
                               	SWAP	A			; After this "0.0625"
                               	ANL	A, #0FH
                               	ADD	A, TEMP1
                               	MOV	TEMP1, A		
                               	; Adjust tail gain
                               	MOV	TEMP2, #PGM_MOTOR_GAIN
                               	CJNE	@TEMP2, #3, ($+5)			; Is gain 1?
                               	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                               
                               	CLR	C
                               	RRC	A			; After this "0.5"
                               	CLR	C
                               	RRC	A			; After this "0.25"
                               	MOV	BIT_ACCESS_INT, @TEMP2				; (Temp2 has #Pgm_Motor_Gain)
                               	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                               
                               	CLR	C
                               	RRC	A			; After this "0.125"
                               
                               T2_INT_RCP_GAIN_CORR:
                               	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                               
                               	CLR	C
                               	XCH	A, TEMP1
                               	SUBB	A, TEMP1					; Apply negative correction
                               	MOV	TEMP1, A
                               	AJMP	T2_INT_PWM_MIN_RUN
                               
                               T2_INT_RCP_GAIN_POS:
                               	ADD	A, TEMP1					; Apply positive correction
                               	MOV	TEMP1, A
                               	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                               
                               	MOV	A, #0FFH					; Yes - limit
                               	MOV	TEMP1, A
                               ENDIF
                      3330     
                      3331     T2_INT_PWM_MIN_RUN:  
                      3332     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      3342     
                      3343     T2_INT_PWM_UPDATE:  
                      3344     	; Update requested_pwm
0242    8822          3345     MOV REQUESTED_PWM , R0 
                      3346     IF MODE >= 1	; Tail or multi
                               	; Boost pwm during direct start
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JZ	T2_INT_CURRENT_PWM_UPDATE
                               
                               	MOV	A, STARTUP_CNT				; Add an extra power boost during start
                               	CLR	C
                               	RRC	A
                               	CLR	C
                               	RRC	A
                               	ADD	A, REQUESTED_PWM			
                               	MOV	REQUESTED_PWM, A
                               	JNC	($+5)
                               
                               	MOV	REQUESTED_PWM, #0FFH
                               
                               ENDIF
                      3364     T2_INT_CURRENT_PWM_UPDATE:  
                      3365     IF MODE == 0 OR MODE == 2	; Main or multi
0244    7882          3366     MOV R0 , # PGM_GOV_MODE 
0246    B60403        3367     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      3368     ENDIF
                      3369     
0249    852224        3370     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      3371     IF MODE >= 1	; Tail or multi
                               	; Set current_pwm_limited
                               	MOV	TEMP1, CURRENT_PWM			; Default not limited
                               	CLR	C
                               	MOV	A, CURRENT_PWM				; Check against limit
                               	SUBB	A, PWM_LIMIT
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT			; Limit pwm
                               
                               IF MODE == 2	; Multi
                               	; Limit pwm for low rpms
                               	CLR	C
                               	MOV	A, TEMP1					; Check against limit
                               	SUBB	A, PWM_LIMIT_BY_RPM
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT_BY_RPM		; Limit pwm
                               
                               ENDIF
                               	MOV	CURRENT_PWM_LIMITED, TEMP1
                               	; Dither
                               	MOV	A, PWM_DITHER_DECODED		; Load pwm dither
                               	JNZ	($+4)					; If active - branch
                               	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                               
                               	CLR	C
                               	MOV	A, TEMP1
                               	MOV	TEMP3, PWM_DITHER_DECODED				
                               	SUBB	A, TEMP3					; Calculate pwm minus dither value
                               	JNC	T2_INT_CURRENT_PWM_FULL_DITHER; If pwm more than dither value, then do full dither
                               
                               	MOV	A, TEMP1					; Set dither level to current pwm
                               	MOV	TEMP3, A				
                               	CLR	A						; Set pwm minus dither
                               
                               T2_INT_CURRENT_PWM_FULL_DITHER:
                               	MOV	TEMP2, A					; Load pwm minus dither value
                               	MOV	A, TEMP3					; Load dither	
                               	CLR	C
                               	RLC	A						; Shift left once
                               	MOV	TEMP4, A
                               	MOV	A, RANDOM					; Load random number
                               	CPL	A						; Invert to create proper DC bias in random code
                               	ANL	A, TEMP4					; And with double dither value
                               	ADD	A, TEMP2					; Add pwm minus dither
                               	JC	T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER	; If dither cause power above max - branch and increase excess 
                               
                               	ADD	A, PWM_DITHER_EXCESS_POWER	; Add excess power from previous cycles
                               	MOV	TEMP1, A
                               	MOV	A, PWM_DITHER_EXCESS_POWER	; Decrement excess power
                               	JZ	($+4)
                               	DEC	PWM_DITHER_EXCESS_POWER
                               	JC	T2_INT_CURRENT_PWM_DITHER_MAX_POWER; If dither cause power above max - branch
                               
                               	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                               
                               T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER:
                               	INC	TEMP3					; Add one to dither in order to always reach max power
                               	CLR	C
                               	MOV	A, PWM_DITHER_EXCESS_POWER
                               	SUBB	A, TEMP3					; Limit excess power 
                               	JNC	($+4)
                               	INC	PWM_DITHER_EXCESS_POWER
                               
                               T2_INT_CURRENT_PWM_DITHER_MAX_POWER:
                               	MOV	TEMP1, #255				; Set power to max
                               
                               T2_INT_CURRENT_PWM_NO_DITHER:
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               IF DAMPED_MODE_ENABLE == 1
                               	; Skip damping fet switching for high throttle
                               	CLR	FLAGS1.SKIP_DAMP_ON
                               	CLR	C
                               	MOV	A, CURRENT_PWM_LIM_DITH
                               	SUBB	A, #248
                               	JC	T2_INT_PWM_EXIT
                               	SETB	FLAGS1.SKIP_DAMP_ON
                               ENDIF
                               ENDIF
                      3451     T2_INT_PWM_EXIT: 	
                      3452     	; Set demag enabled if pwm is above limit
024C    C3            3453     	CLR	C
024D    E525          3454     	MOV	A, CURRENT_PWM_LIMITED	
024F    9440          3455     	SUBB	A, #40H					; Set if above 25%
0251    4002          3456     	JC	($+4)
                      3457     
0253    D264          3458     SETB FLAGS0 . 4 
                      3459     
                      3460     T2_INT_EXIT: 	
                      3461     	; Check if high byte flag is set
0255    20CF0A        3462     	JB	TF2H, T2H_INT		
0258    D0E0          3463     	POP	ACC			; Restore preserved registers
025A    D0D0          3464     	POP	PSW
025C    43E610        3465     	ORL	EIE1, #10H	; Enable PCA0 interrupts
025F    D2AD          3466     	SETB	ET2			; Enable timer2 interrupts
0261    32            3467     	RETI
                      3468     
                      3469     T2H_INT: 
                      3470     IF MCU_48MHZ == 1
0262    E57A          3471     	MOV	A, CLOCK_SET_AT_48MHZ
0264    6009          3472     	JZ 	T2H_INT_START
                      3473     
                      3474     	; Check skip variable
0266    E578          3475     	MOV	A, SKIP_T2H_INT
0268    6005          3476     	JZ	T2H_INT_START				; Execute this interrupt
                      3477     
026A    757800        3478     	MOV	SKIP_T2H_INT, #0
026D    6140          3479     	AJMP	T2H_INT_EXIT
                      3480     
                      3481     T2H_INT_START: 
026F    757801        3482     	MOV	SKIP_T2H_INT, #1			; Skip next interrupt
                      3483     ENDIF
                      3484     	; High byte interrupt (happens every 32ms)
0272    C2CF          3485     	CLR	TF2H					; Clear interrupt flag
0274    7802          3486     MOV R0 , # 2 
                      3487     	; Check RC pulse timeout counter (used here for PPM only)
0276    E52A          3488     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
0278    6005          3489     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      3490     
                      3491     	; Decrement timeout counter (if PPM)
027A    307402        3492     JNB FLAGS2 . 4 , T2H_INT_RCP_STOP_CHECK 
                      3493     
027D    152A          3494     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      3495     
                      3496     T2H_INT_RCP_STOP_CHECK: 
                      3497     	; Check RC pulse against stop value
027F    C3            3498     	CLR	C
0280    E55C          3499     	MOV	A, NEW_RCP				; Load new pulse value
0282    9401          3500     SUBB A , # 1 
0284    4005          3501     	JC	T2H_INT_RCP_STOP
                      3502     
                      3503     	; RC pulse higher than stop value, reset stop counter
0286    755F00        3504     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0289    419C          3505     	AJMP	T2H_INT_RCP_GOV_PWM
                      3506     
                      3507     T2H_INT_RCP_STOP: 	
                      3508     	; RC pulse less than stop value
028B    756000        3509     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
028E    756900        3510     	MOV	SPOOLUP_LIMIT_CNT, #0
0291    E55F          3511     	MOV	A, RCP_STOP_CNT			; Increment stop counter
0293    2401          3512     	ADD	A, #1
0295    F55F          3513     	MOV	RCP_STOP_CNT, A
0297    5003          3514     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      3515     
0299    755FFF        3516     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      3517     
                      3518     T2H_INT_RCP_GOV_PWM: 
                      3519     IF MODE == 0	; Main
                      3520     	; Update governor variables
029C    7982          3521     MOV R1 , # PGM_GOV_MODE 
029E    B7020D        3522     CJNE @ R1 , # 2 , T2H_INT_RCP_GOV_BY_SETUP 
                      3523     
02A1    306D1D        3524     JNB FLAGS1 . 5 , T2H_INT_RCP_GOV_BY_TX 
                      3525     
02A4    C3            3526     	CLR	C
02A5    E522          3527     	MOV	A, REQUESTED_PWM
02A7    9432          3528     	SUBB	A, #50						; Is requested pwm below 20%?
02A9    4016          3529     	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                      3530     
02AB    854A22        3531     	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                      3532     
                      3533     T2H_INT_RCP_GOV_BY_SETUP: 
02AE    7982          3534     MOV R1 , # PGM_GOV_MODE 
02B0    B7030E        3535     CJNE @ R1 , # 3 , T2H_INT_RCP_GOV_BY_TX 
                      3536     
02B3    306D0B        3537     JNB FLAGS1 . 5 , T2H_INT_RCP_GOV_BY_TX 
                      3538     
02B6    C3            3539     	CLR	C
02B7    E522          3540     	MOV	A, REQUESTED_PWM
02B9    9432          3541     	SUBB	A, #50						; Is requested pwm below 20%?
02BB    4004          3542     	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                      3543     
02BD    798E          3544     MOV R1 , # PGM_GOV_SETUP_TARGET 
02BF    8722          3545     MOV REQUESTED_PWM , @ R1 
                      3546     
                      3547     T2H_INT_RCP_GOV_BY_TX: 
02C1    C3            3548     	CLR	C
02C2    E523          3549     	MOV	A, GOVERNOR_REQ_PWM
02C4    9522          3550     	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
02C6    6008          3551     	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                      3552     
02C8    4004          3553     	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                      3554     
02CA    1523          3555     	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
02CC    41D0          3556     	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                      3557     
                      3558     T2H_INT_RCP_GOV_PWM_INC: 
02CE    0523          3559     	INC	GOVERNOR_REQ_PWM				; Increment
                      3560     
                      3561     T2H_INT_RCP_GOV_PWM_DONE: 
02D0    D8CA          3562     DJNZ R0 , T2H_INT_RCP_GOV_PWM 
                      3563     
02D2    0569          3564     	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
02D4    E569          3565     	MOV	A, SPOOLUP_LIMIT_CNT
02D6    7002          3566     	JNZ	($+4)						; Wrapped?
                      3567     
02D8    1569          3568     	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                      3569     
02DA    D56A63        3570     	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_EXIT	; Jump if skip count is not reached
                      3571     
02DD    756A01        3572     	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
02E0    7805          3573     MOV R0 , # 5 
02E2    C3            3574     	CLR	C
02E3    E569          3575     	MOV	A, SPOOLUP_LIMIT_CNT
02E5    956B          3576     	SUBB	A, MAIN_SPOOLUP_TIME_3X			; No spoolup until 3*N*32ms
                      3577     
02E7    4057          3578     	JC	T2H_INT_EXIT
                      3579     
02E9    C3            3580     	CLR	C
02EA    E569          3581     	MOV	A, SPOOLUP_LIMIT_CNT
02EC    956C          3582     	SUBB	A, MAIN_SPOOLUP_TIME_10X			; Slow spoolup until "100"*N*32ms
02EE    5008          3583     	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                      3584     
02F0    7801          3585     MOV R0 , # 1 
02F2    756A03        3586     	MOV	SPOOLUP_LIMIT_SKIP, #3			
02F5    020304        3587     	JMP	T2H_INT_RCP_SET_LIMIT
                      3588     
                      3589     T2H_INT_RCP_LIMIT_MIDDLE_RAMP: 
02F8    C3            3590     	CLR	C
02F9    E569          3591     	MOV	A, SPOOLUP_LIMIT_CNT
02FB    956D          3592     	SUBB	A, MAIN_SPOOLUP_TIME_15X			; Faster spoolup until "150"*N*32ms
02FD    5005          3593     	JNC	T2H_INT_RCP_SET_LIMIT
                      3594     
02FF    7801          3595     MOV R0 , # 1 
0301    756A01        3596     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      3597     
                      3598     T2H_INT_RCP_SET_LIMIT: 
                      3599     	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
0304    C3            3600     	CLR	C
0305    E562          3601     	MOV	A, PWM_LIMIT_SPOOLUP
0307    9524          3602     	SUBB	A, CURRENT_PWM
0309    401E          3603     	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                      3604     
030B    7982          3605     MOV R1 , # PGM_GOV_MODE 
030D    B70402        3606     CJNE @ R1 , # 4 , ( $+5 ) 
0310    6135          3607     	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                      3608     
0312    206D14        3609     JB FLAGS1 . 5 , T2H_INT_RCP_INC_LIMIT 
                      3610     
0315    852462        3611     	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
0318    E569          3612     	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
031A    04            3613     	INC	A
031B    6003          3614     	JZ	($+5)
                      3615     
031D    856B69        3616     	MOV	SPOOLUP_LIMIT_CNT, MAIN_SPOOLUP_TIME_3X	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                      3617     
0320    756A01        3618     	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
0323    75233C        3619     	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                      3620     									; 20=Fail on jerk when governor activates
                      3621     									; 30=Ok
                      3622     									; 100=Fail on small governor settling overshoot on low headspeeds
                      3623     									; 200=Fail on governor settling overshoot
0326    020340        3624     	JMP	T2H_INT_EXIT					; Exit
                      3625     
                      3626     T2H_INT_RCP_INC_LIMIT: 
0329    E562          3627     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
032B    28            3628     ADD A , R0 
032C    5005          3629     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      3630     
032E    7562FF        3631     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
0331    6135          3632     	AJMP	T2H_INT_RCP_BAILOUT_ARM
                      3633     
                      3634     T2H_INT_RCP_NO_LIMIT: 
0333    F562          3635     	MOV	PWM_LIMIT_SPOOLUP, A
                      3636     T2H_INT_RCP_BAILOUT_ARM: 
0335    E562          3637     	MOV	A, PWM_LIMIT_SPOOLUP
0337    04            3638     	INC	A
0338    7006          3639     	JNZ	T2H_INT_EXIT
                      3640     
033A    7560FF        3641     	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
033D    7569FF        3642     	MOV	SPOOLUP_LIMIT_CNT, #255			
                      3643     
                      3644     ENDIF
                      3645     T2H_INT_EXIT: 
0340    D0E0          3646     	POP	ACC			; Restore preserved registers
0342    D0D0          3647     	POP	PSW
0344    43E610        3648     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0347    D2AD          3649     	SETB	ET2			; Enable timer2 interrupts
0349    32            3650     	RETI
                      3651     
                      3652     
                      3653     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3654     ;
                      3655     ; Timer3 interrupt routine
                      3656     ;
                      3657     ; No assumptions
                      3658     ;
                      3659     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3660     T3_INT: 	; Used for commutation timing
034A    C2AF          3661     	CLR 	EA				; Disable all interrupts
034C    C0D0          3662     	PUSH	PSW				; Preserve registers through interrupt
034E    53E67F        3663     	ANL	EIE1, #7FH		; Disable timer3 interrupts
0351    C260          3664     CLR FLAGS0 . 0 
                      3665     	; Set up next wait
0353    759100        3666     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
0356    855394        3667     	MOV	TMR3L, NEXT_WT_START_L	; Set wait value	
0359    855495        3668     	MOV	TMR3H, NEXT_WT_START_H
035C    759104        3669     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
035F    D0D0          3670     	POP	PSW
0361    D2AF          3671     	SETB	EA				; Enable all interrupts
0363    32            3672     	RETI
                      3673     
                      3674     
                      3675     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3676     ;
                      3677     ; PCA interrupt routine
                      3678     ;
                      3679     ; No assumptions
                      3680     ;
                      3681     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3682     PCA_INT: 	; Used for RC pulse timing
0364    C2AF          3683     	CLR	EA
0366    53E6EF        3684     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
0369    C2AD          3685     	CLR	ET2			; Disable timer2 interrupts
036B    C0D0          3686     	PUSH	PSW			; Preserve registers through interrupt
036D    C0E0          3687     	PUSH	ACC
036F    C0F0          3688     	PUSH	B
0371    D2D3          3689     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0373    D2AF          3690     	SETB	EA
                      3691     	; Get the PCA counter values
                      3692     	GET_RCP_CAPTURE_VALUES
0375    A8FB          3692+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0377    A9FC          3692+1   MOV R1 , PCA0CPH0 
                      3692+1   IF 1 ==1 
0379    E57A          3692+1   MOV A , CLOCK_SET_AT_48MHZ 
037B    6007          3692+1   JZ GET_RCP_END 
037D    C3            3692+1   CLR C 
037E    E9            3692+1   MOV A , R1 
037F    13            3692+1   RRC A 
0380    F9            3692+1   MOV R1 , A 
0381    E8            3692+1   MOV A , R0 
0382    13            3692+1   RRC A 
0383    F8            3692+1   MOV R0 , A 
                      3692+1   GET_RCP_END:  
                      3692+1   ENDIF 
                      3693     	; Clear interrupt flag
                      3694     	RCP_CLEAR_INT_FLAG 				
0384    C2D8          3694+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3695     	; Check which edge it is
0386    307102        3696     JNB FLAGS2 . 1 , ( $+5 ) 
0389    61D6          3697     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      3698     
                      3699     	RCP_INT_SECOND					; Yes - set second edge trig
038B    53DACF        3699+1   ANL PCA0CPM0 , # 0CFH 
038E    207E03        3699+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0391    43DA10        3699+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
0394    307E03        3699+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0397    43DA20        3699+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
039A    D271          3700     SETB FLAGS2 . 1 
                      3701     	; Read RC signal level
                      3702     	READ_RCP_INT			
039C    E580          3702+1   MOV A , P0 
039E    307E01        3702+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
03A1    F4            3702+1   CPL A  ; YES - INVERT
                      3703     	; Test RC signal level
03A2    20E502        3704     JB ACC . 5 , ( $+5 ) 
03A5    61AD          3705     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      3706     
                      3707     	; RC pulse was high, store RC pulse start timestamp
03A7    8827          3708     MOV RCP_PREV_EDGE_L , R0 
03A9    8928          3709     MOV RCP_PREV_EDGE_H , R1 
03AB    A1B5          3710     	AJMP	PCA_INT_EXIT				; Exit
                      3711     
                      3712     PCA_INT_FAIL_MINIMUM: 
                      3713     	; Prepare for next interrupt
                      3714     	RCP_INT_FIRST					; Set interrupt trig to first again
03AD    53DACF        3714+1   ANL PCA0CPM0 , # 0CFH 
03B0    207E03        3714+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03B3    43DA20        3714+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03B6    307E03        3714+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03B9    43DA10        3714+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3715     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03BC    C2D8          3715+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03BE    C271          3716     CLR FLAGS2 . 1 
03C0    307402        3717     JNB FLAGS2 . 4 , ( $+5 ) 
                      3718     
03C3    A1A1          3719     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      3720     
03C5    7800          3721     MOV R0 , # 0 
                      3722     	READ_RCP_INT 					; Test RC signal level again
03C7    E580          3722+1   MOV A , P0 
03C9    307E01        3722+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
03CC    F4            3722+1   CPL A  ; YES - INVERT
03CD    30E502        3723     JNB ACC . 5 , ( $+5 ) 
                      3724     
03D0    A1A1          3725     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      3726     
03D2    885C          3727     MOV NEW_RCP , R0 
03D4    A189          3728     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      3729     
                      3730     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      3731     	; Prepare for next interrupt
                      3732     	RCP_INT_FIRST 					; Set first edge trig
03D6    53DACF        3732+1   ANL PCA0CPM0 , # 0CFH 
03D9    207E03        3732+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03DC    43DA20        3732+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03DF    307E03        3732+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03E2    43DA10        3732+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03E5    C271          3733     CLR FLAGS2 . 1 
                      3734     	; Check if pwm frequency shall be measured
03E7    206102        3735     JB FLAGS0 . 1 , ( $+5 ) 
03EA    81AF          3736     	AJMP	PCA_INT_FALL				; No - skip measurements
                      3737     
                      3738     	; Set second edge trig only during pwm frequency measurement
                      3739     	RCP_INT_SECOND 				; Set second edge trig
03EC    53DACF        3739+1   ANL PCA0CPM0 , # 0CFH 
03EF    207E03        3739+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03F2    43DA10        3739+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03F5    307E03        3739+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03F8    43DA20        3739+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      3740     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03FB    C2D8          3740+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03FD    D271          3741     SETB FLAGS2 . 1 
                      3742     	; Store edge data to RAM
03FF    8857          3743     MOV RCP_EDGE_L , R0 
0401    8958          3744     MOV RCP_EDGE_H , R1 
                      3745     	; Calculate pwm frequency
0403    C3            3746     	CLR	C
0404    E8            3747     MOV A , R0 
0405    9555          3748     	SUBB	A, RCP_PREPREV_EDGE_L	
0407    F8            3749     MOV R0 , A 
0408    E9            3750     MOV A , R1 
0409    9556          3751     	SUBB	A, RCP_PREPREV_EDGE_H
040B    F9            3752     MOV R1 , A 
040C    7B00          3753     MOV R3 , # 0 
040E    7E08          3754     MOV R6 , # 8 
0410    7A00          3755     MOV R2 , # 0 
                      3756     	; Check if pulse is too short
0412    C3            3757     	CLR	C
0413    E8            3758     MOV A , R0 
0414    948C          3759     	SUBB	A, #LOW(140)				; If pulse below 70us, not accepted
0416    E9            3760     MOV A , R1 
0417    9400          3761     	SUBB	A, #HIGH(140)
0419    5005          3762     	JNC	PCA_INT_CHECK_12KHZ
                      3763     
041B    755B00        3764     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0	; Set not accepted 
041E    81A1          3765     	AJMP	PCA_INT_STORE_DATA
                      3766     
                      3767     PCA_INT_CHECK_12KHZ: 
0420    8821          3768     MOV BIT_ACCESS_INT , R0 
0422    78A2          3769     MOV R0 , # PGM_ENABLE_PWM_INPUT 
0424    E6            3770     MOV A , @ R0 
0425    A821          3771     MOV R0 , BIT_ACCESS_INT 
0427    6055          3772     	JZ	PCA_INT_RESTORE_EDGE		; If it is not - branch
                      3773     
                      3774     	; Check if pwm frequency is 12kHz
0429    C3            3775     	CLR	C
042A    E8            3776     MOV A , R0 
042B    94C8          3777     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
042D    E9            3778     MOV A , R1 
042E    9400          3779     	SUBB	A, #HIGH(200)
0430    5008          3780     	JNC	PCA_INT_CHECK_8KHZ
                      3781     
0432    E4            3782     	CLR	A
0433    D2E4          3783     SETB ACC . 4 
0435    FB            3784     MOV R3 , A 
0436    7A0A          3785     MOV R2 , # 10 
0438    817C          3786     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3787     
                      3788     PCA_INT_CHECK_8KHZ: 
                      3789     	; Check if pwm frequency is 8kHz
043A    C3            3790     	CLR	C
043B    E8            3791     MOV A , R0 
043C    9468          3792     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
043E    E9            3793     MOV A , R1 
043F    9401          3794     	SUBB	A, #HIGH(360)
0441    5008          3795     	JNC	PCA_INT_CHECK_4KHZ
                      3796     
0443    E4            3797     	CLR	A
0444    D2E3          3798     SETB ACC . 3 
0446    FB            3799     MOV R3 , A 
0447    7A0F          3800     MOV R2 , # 15 
0449    817C          3801     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3802     
                      3803     PCA_INT_CHECK_4KHZ: 
                      3804     	; Check if pwm frequency is 4kHz
044B    C3            3805     	CLR	C
044C    E8            3806     MOV A , R0 
044D    94D0          3807     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
044F    E9            3808     MOV A , R1 
0450    9402          3809     	SUBB	A, #HIGH(720)
0452    5008          3810     	JNC	PCA_INT_CHECK_2KHZ
                      3811     
0454    E4            3812     	CLR	A
0455    D2E2          3813     SETB ACC . 2 
0457    FB            3814     MOV R3 , A 
0458    7A1E          3815     MOV R2 , # 30 
045A    817C          3816     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3817     
                      3818     PCA_INT_CHECK_2KHZ: 
                      3819     	; Check if pwm frequency is 2kHz
045C    C3            3820     	CLR	C
045D    E8            3821     MOV A , R0 
045E    94A0          3822     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0460    E9            3823     MOV A , R1 
0461    9405          3824     	SUBB	A, #HIGH(1440)
0463    5008          3825     	JNC	PCA_INT_CHECK_1KHZ
                      3826     
0465    E4            3827     	CLR	A
0466    D2E1          3828     SETB ACC . 1 
0468    FB            3829     MOV R3 , A 
0469    7A3C          3830     MOV R2 , # 60 
046B    817C          3831     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3832     
                      3833     PCA_INT_CHECK_1KHZ: 
                      3834     	; Check if pwm frequency is 1kHz
046D    C3            3835     	CLR	C
046E    E8            3836     MOV A , R0 
046F    9498          3837     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0471    E9            3838     MOV A , R1 
0472    9408          3839     	SUBB	A, #HIGH(2200)
0474    5008          3840     	JNC	PCA_INT_RESTORE_EDGE
                      3841     
0476    E4            3842     	CLR	A
0477    D2E0          3843     SETB ACC . 0 
0479    FB            3844     MOV R3 , A 
047A    7A78          3845     MOV R2 , # 120 
                      3846     
                      3847     PCA_INT_RESTORE_EDGE_SET_MSB: 
047C    7E00          3848     MOV R6 , # 0 
                      3849     PCA_INT_RESTORE_EDGE: 
                      3850     	; Calculate difference between this period and previous period
047E    C3            3851     	CLR	C
047F    E8            3852     MOV A , R0 
0480    9559          3853     	SUBB	A, RCP_PREV_PERIOD_L
0482    FC            3854     MOV R4 , A 
0483    E9            3855     MOV A , R1 
0484    955A          3856     	SUBB	A, RCP_PREV_PERIOD_H
0486    FD            3857     MOV R5 , A 
                      3858     	; Make positive
0487    30E70A        3859     	JNB	ACC.7, PCA_INT_CHECK_DIFF
048A    EC            3860     MOV A , R4 
048B    F4            3861     	CPL	A
048C    2401          3862     	ADD	A, #1
048E    FC            3863     MOV R4 , A 
048F    ED            3864     MOV A , R5 
0490    F4            3865     	CPL	A
0491    3400          3866     	ADDC	A, #0
0493    FD            3867     MOV R5 , A 
                      3868     
                      3869     PCA_INT_CHECK_DIFF: 
                      3870     	; Check difference
0494    755B00        3871     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0497    C3            3872     	CLR	C
0498    EC            3873     MOV A , R4 
0499    9A            3874     SUBB A , R2 
049A    ED            3875     MOV A , R5 
049B    9E            3876     SUBB A , R6 
049C    5003          3877     	JNC	PCA_INT_STORE_DATA
                      3878     
049E    755B01        3879     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      3880     
                      3881     PCA_INT_STORE_DATA: 
                      3882     	; Store previous period
04A1    8859          3883     MOV RCP_PREV_PERIOD_L , R0 
04A3    895A          3884     MOV RCP_PREV_PERIOD_H , R1 
                      3885     	; Store pre previous edge
04A5    855755        3886     	MOV	RCP_PREPREV_EDGE_L, RCP_EDGE_L
04A8    855856        3887     	MOV	RCP_PREPREV_EDGE_H, RCP_EDGE_H
04AB    7802          3888     MOV R0 , # 2 
04AD    A189          3889     	AJMP	PCA_INT_LIMITED
                      3890     
                      3891     PCA_INT_FALL: 
                      3892     	; RC pulse edge was second, calculate new pulse length
04AF    C3            3893     	CLR	C
04B0    E8            3894     MOV A , R0 
04B1    9527          3895     	SUBB	A, RCP_PREV_EDGE_L	
04B3    F8            3896     MOV R0 , A 
04B4    E9            3897     MOV A , R1 
04B5    9528          3898     	SUBB	A, RCP_PREV_EDGE_H
04B7    F9            3899     MOV R1 , A 
04B8    307C02        3900     JNB FLAGS3 . 4 , ( $+5 ) 
04BB    A16D          3901     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3902     
04BD    307B02        3903     JNB FLAGS3 . 3 , ( $+5 ) 
04C0    A16D          3904     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3905     
04C2    307A02        3906     JNB FLAGS3 . 2 , ( $+5 ) 
04C5    A166          3907     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3908     
04C7    207502        3909     JB FLAGS2 . 5 , ( $+5 ) 
04CA    81D2          3910     	AJMP	PCA_INT_FALL_NOT_ONESHOT
                      3911     
04CC    E9            3912     MOV A , R1 
04CD    FD            3913     MOV R5 , A 
04CE    E8            3914     MOV A , R0 
04CF    FC            3915     MOV R4 , A 
04D0    81F1          3916     	AJMP	PCA_INT_FALL_CHECK_RANGE
                      3917     
                      3918     PCA_INT_FALL_NOT_ONESHOT: 
04D2    E9            3919     MOV A , R1 
04D3    C3            3920     	CLR	C
04D4    13            3921     	RRC	A
04D5    F9            3922     MOV R1 , A 
04D6    E8            3923     MOV A , R0 
04D7    13            3924     	RRC	A
04D8    F8            3925     MOV R0 , A 
                      3926     
04D9    307902        3927     JNB FLAGS3 . 1 , ( $+5 ) 
04DC    A166          3928     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3929     
04DE    E9            3930     MOV A , R1 
04DF    C3            3931     	CLR	C
04E0    13            3932     	RRC	A
04E1    F9            3933     MOV R1 , A 
04E2    E8            3934     MOV A , R0 
04E3    13            3935     	RRC	A
04E4    F8            3936     MOV R0 , A 
                      3937     
04E5    307802        3938     JNB FLAGS3 . 0 , ( $+5 ) 
04E8    A166          3939     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3940     
04EA    E9            3941     MOV A , R1 
04EB    C3            3942     	CLR	C
04EC    13            3943     	RRC	A
04ED    FD            3944     MOV R5 , A 
04EE    E8            3945     MOV A , R0 
04EF    13            3946     	RRC	A
04F0    FC            3947     MOV R4 , A 
                      3948     PCA_INT_FALL_CHECK_RANGE: 
                      3949     	; Skip range limitation if pwm frequency measurement
04F1    206126        3950     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      3951     
                      3952     	; Check if 2160us or above (in order to ignore false pulses)
04F4    C3            3953     	CLR	C
04F5    EC            3954     MOV A , R4 
04F6    941C          3955     	SUBB	A, #28
04F8    ED            3956     MOV A , R5 
04F9    9402          3957     	SUBB A, #2
04FB    4002          3958     	JC	($+4)						; No - proceed
                      3959     
04FD    A108          3960     	AJMP	PCA_INT_PPM_OUTSIDE_RANGE		; Yes - ignore pulse
                      3961     
                      3962     PCA_INT_PPM_BELOW_FULL_RANGE: 
                      3963     	; Check if below 800us (in order to ignore false pulses)
04FF    ED            3964     MOV A , R5 
0500    7018          3965     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      3966     
0502    C3            3967     	CLR	C
0503    EC            3968     MOV A , R4 
0504    94C8          3969     	SUBB	A, #200
0506    5012          3970     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      3971     
                      3972     PCA_INT_PPM_OUTSIDE_RANGE: 
0508    0529          3973     	INC	RCP_OUTSIDE_RANGE_CNT
050A    C3            3974     	CLR	C
050B    E529          3975     	MOV	A, RCP_OUTSIDE_RANGE_CNT
050D    940A          3976     	SUBB	A, #10						; Allow a given number of outside pulses
050F    5002          3977     	JNC	($+4)			
0511    A1A1          3978     	AJMP	PCA_INT_SET_TIMEOUT				; If below limit - ignore pulse
                      3979     
0513    755C00        3980     	MOV	NEW_RCP, #0					; Set pulse length to zero
0516    D270          3981     SETB FLAGS2 . 0 
0518    A1A1          3982     	AJMP	PCA_INT_SET_TIMEOUT			
                      3983     
                      3984     PCA_INT_PPM_CHECK_FULL_RANGE: 
051A    E529          3985     	MOV	A, RCP_OUTSIDE_RANGE_CNT
051C    6002          3986     	JZ	($+4)
                      3987     
051E    1529          3988     	DEC	RCP_OUTSIDE_RANGE_CNT
                      3989     
                      3990     	; Calculate "1000us" plus throttle minimum
                      3991     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION			; Check if bidirectional operation (store in Temp2)
                               	MOV	A, @TEMP1				
                               	MOV	TEMP2, A				
                               ENDIF
0520    7400          3996     	MOV	A, #0						; Set 1000us as default minimum
0522    207F03        3997     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      3998     
0525    7896          3999     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      4000     IF MODE >= 1	; Tail or multi
                               	CJNE	TEMP2, #3, ($+5)
                               
                               	MOV	TEMP1, #PGM_PPM_CENTER_THROTTLE	; Center throttle value is in 4us units
                               ENDIF
0527    E6            4005     MOV A , @ R0 
                      4006     
                      4007     PCA_INT_PPM_CALCULATE: 
0528    24FA          4008     	ADD	A, #250						; Add 1000us to minimum
052A    FE            4009     MOV R6 , A 
052B    E4            4010     	CLR	A
052C    3400          4011     	ADDC	A, #0
052E    FF            4012     MOV R7 , A 
                      4013     
052F    C3            4014     	CLR	C
0530    EC            4015     MOV A , R4 
0531    9E            4016     SUBB A , R6 
0532    FC            4017     MOV R4 , A 
0533    ED            4018     MOV A , R5 
0534    9F            4019     SUBB A , R7 
0535    FD            4020     MOV R5 , A 
                      4021     IF MODE >= 1	; Tail or multi
                               	MOV	BIT_ACCESS_INT.0, C
                               	CJNE	TEMP2, #3, PCA_INT_PPM_BIDIR_DIR_SET; If not bidirectional operation - branch
                               
                               	MOV	C, BIT_ACCESS_INT.0
                               	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                               
                               PCA_INT_PPM_BIDIR_REV:
                               	JB	FLAGS2.RCP_DIR_REV, PCA_INT_PPM_BIDIR_DIR_SET	; If same direction - branch
                               
                               	SETB	FLAGS2.RCP_DIR_REV
                               	AJMP	PCA_INT_PPM_BIDIR_DIR_SET
                               
                               PCA_INT_PPM_BIDIR_FWD:
                               	JNB	FLAGS2.RCP_DIR_REV, PCA_INT_PPM_BIDIR_DIR_SET	; If same direction - branch
                               
                               	CLR	FLAGS2.RCP_DIR_REV
                               
                               PCA_INT_PPM_BIDIR_DIR_SET:
                               	MOV	C, BIT_ACCESS_INT.0
                               ENDIF
0536    5006          4042     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      4043     
                      4044     IF MODE >= 1	; Tail or multi
                               	CJNE	TEMP2, #3, PCA_INT_PPM_UNIDIR_NEG 	; If not bidirectional operation - branch
                               
                               	MOV	A, TEMP5						; Change sign		
                               	CPL	A
                               	ADD	A, #1
                               	MOV	TEMP5, A
                               	MOV	A, TEMP6							
                               	CPL	A
                               	ADDC	A, #0
                               	MOV	TEMP6, A
                               	JMP	PCA_INT_PPM_NEG_CHECKED
                               
                               PCA_INT_PPM_UNIDIR_NEG:
                               ENDIF
0538    7800          4059     MOV R0 , # 0 
053A    7900          4060     MOV R1 , # 0 
053C    A16D          4061     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4062     
                      4063     PCA_INT_PPM_NEG_CHECKED: 
                      4064     IF MODE >= 1	; Tail or multi
                               	CJNE	TEMP2, #3, PCA_INT_PPM_BIDIR_DONE	; If not bidirectional operation - branch
                               
                               	MOV	A, TEMP5						; Multiply value by 2
                               	RLC	A
                               	MOV	TEMP5 A
                               	MOV	A, TEMP6
                               	RLC	A
                               	MOV	TEMP6 A
                               	CLR	C							; Subtract deadband
                               	MOV	A, TEMP5
                               	SUBB	A, #10		
                               	MOV	TEMP5, A
                               	MOV	A, TEMP6
                               	SUBB	A, #0
                               	MOV	TEMP6, A
                               	JNC	PCA_INT_PPM_BIDIR_DONE
                               
                               	MOV	TEMP5, #RCP_MIN
                               	MOV	TEMP6, #0
                               
                               PCA_INT_PPM_BIDIR_DONE:
                               ENDIF
053E    C3            4087     	CLR	C							; Check that RC pulse is within legal range (max 255)
053F    EC            4088     MOV A , R4 
0540    94FF          4089     SUBB A , # 255 
0542    ED            4090     MOV A , R5 
0543    9400          4091     	SUBB	A, #0
0545    4006          4092     	JC	PCA_INT_PPM_MAX_CHECKED
                      4093     
0547    78FF          4094     MOV R0 , # 255 
0549    7900          4095     MOV R1 , # 0 
054B    A16D          4096     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4097     
                      4098     PCA_INT_PPM_MAX_CHECKED: 
054D    EC            4099     MOV A , R4 
054E    8572F0        4100     	MOV	B, PPM_THROTTLE_GAIN
0551    A4            4101     	MUL	AB
0552    C5F0          4102     	XCH	A, B
0554    A2F7          4103     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0556    33            4104     	RLC	A
0557    F8            4105     MOV R0 , A 
0558    7900          4106     MOV R1 , # 0 
055A    4003          4107     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      4108     	
055C    020589        4109     	JMP	PCA_INT_LIMITED			
                      4110     
                      4111     PCA_INT_PPM_LIMIT_AFTER_MULT: 
055F    78FF          4112     MOV R0 , # 255 
0561    7900          4113     MOV R1 , # 0 
0563    020589        4114     	JMP	PCA_INT_LIMITED			
                      4115     
                      4116     PCA_INT_PWM_DIVIDE: 
0566    E9            4117     MOV A , R1 
0567    C3            4118     	CLR	C
0568    13            4119     	RRC	A
0569    F9            4120     MOV R1 , A 
056A    E8            4121     MOV A , R0 
056B    13            4122     	RRC	A
056C    F8            4123     MOV R0 , A 
                      4124     
                      4125     PCA_INT_PWM_DIVIDE_DONE: 
056D    307C0E        4126     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
0570    E9            4127     MOV A , R1 
0571    6002          4128     	JZ	($+4)
                      4129     
0573    78FF          4130     MOV R0 , # 255 
                      4131     
0575    C3            4132     	CLR	C
0576    E8            4133     MOV A , R0 
0577    13            4134     	RRC	A
0578    38            4135     ADDC A , R0 
0579    F8            4136     MOV R0 , A 
057A    E4            4137     	CLR	A
057B    3400          4138     	ADDC	A, #0
057D    F9            4139     MOV R1 , A 
                      4140     
                      4141     PCA_INT_CHECK_LEGAL_RANGE: 
                      4142     	; Check that RC pulse is within legal range
057E    C3            4143     	CLR	C
057F    E8            4144     MOV A , R0 
0580    94FF          4145     SUBB A , # 255 
0582    E9            4146     MOV A , R1 
0583    9400          4147     	SUBB	A, #0
0585    4002          4148     	JC	PCA_INT_LIMITED
                      4149     
0587    78FF          4150     MOV R0 , # 255 
                      4151     
                      4152     PCA_INT_LIMITED: 
                      4153     	; RC pulse value accepted
0589    885C          4154     MOV NEW_RCP , R0 
058B    D270          4155     SETB FLAGS2 . 0 
058D    206102        4156     JB FLAGS0 . 1 , ( $+5 ) 
                      4157     
0590    A1A1          4158     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      4159     
0592    741F          4160     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0594    F4            4161     	CPL	A
0595    552F          4162     	ANL	A, FLAGS3					; Clear all pwm frequency flags
0597    4B            4163     ORL A , R3 
0598    F52F          4164     	MOV	FLAGS3, A
059A    C274          4165     CLR FLAGS2 . 4 
059C    EB            4166     MOV A , R3 
059D    7002          4167     	JNZ	PCA_INT_SET_TIMEOUT
                      4168     
059F    D274          4169     SETB FLAGS2 . 4 
                      4170     
                      4171     PCA_INT_SET_TIMEOUT: 
05A1    752A40        4172     MOV RCP_TIMEOUT_CNT , # 64 
05A4    307403        4173     JNB FLAGS2 . 4 , PCA_INT_PPM_TIMEOUT_SET 
                      4174     
05A7    752A0A        4175     MOV RCP_TIMEOUT_CNT , # 10 
                      4176     
                      4177     PCA_INT_PPM_TIMEOUT_SET: 
05AA    306102        4178     JNB FLAGS0 . 1 , ( $+5 ) 
                      4179     
05AD    A1B5          4180     	AJMP PCA_INT_EXIT				; Yes - exit
                      4181     
05AF    207403        4182     JB FLAGS2 . 4 , PCA_INT_EXIT 
                      4183     
                      4184     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
05B2    53DAFE        4184+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      4185     
                      4186     PCA_INT_EXIT: 	; Exit interrupt routine	
05B5    207403        4187     JB FLAGS2 . 4 , ( $+6 ) 
                      4188     
05B8    752B20        4189     MOV RCP_SKIP_CNT , # 32 
                      4190     
05BB    D0F0          4191     	POP	B			; Restore preserved registers
05BD    D0E0          4192     	POP	ACC			
05BF    D0D0          4193     	POP	PSW
05C1    D2AD          4194     	SETB	ET2			; Enable timer2 interrupts
05C3    43E610        4195     	ORL	EIE1, #10H	; Enable PCA0 interrupts
05C6    32            4196     	RETI
                      4197     
                      4198     
                      4199     
                      4200     
                      4201     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4202     ;
                      4203     ; Wait xms ~(x*4*250)  (Different entry points)	
                      4204     ;
                      4205     ; No assumptions
                      4206     ;
                      4207     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4208     WAIT1MS: 	
05C7    7901          4209     MOV R1 , # 1 
05C9    0205E5        4210     	JMP	WAITXMS_O
                      4211     
                      4212     WAIT3MS: 	
05CC    7903          4213     MOV R1 , # 3 
05CE    0205E5        4214     	JMP	WAITXMS_O
                      4215     
                      4216     WAIT10MS: 	
05D1    790A          4217     MOV R1 , # 10 
05D3    0205E5        4218     	JMP	WAITXMS_O
                      4219     
                      4220     WAIT30MS: 	
05D6    791E          4221     MOV R1 , # 30 
05D8    0205E5        4222     	JMP	WAITXMS_O
                      4223     
                      4224     WAIT100MS: 	
05DB    7964          4225     MOV R1 , # 100 
05DD    0205E5        4226     	JMP	WAITXMS_O
                      4227     
                      4228     WAIT200MS: 	
05E0    79C8          4229     MOV R1 , # 200 
05E2    0205E5        4230     	JMP	WAITXMS_O
                      4231     
                      4232     WAITXMS_O: 	; Outer loop
05E5    7817          4233     MOV R0 , # 23 
                      4234     WAITXMS_M: 	; Middle loop
05E7    E4            4235     	CLR	A
05E8    D5E0FD        4236      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
05EB    D8FA          4237     DJNZ R0 , WAITXMS_M 
05ED    D9F6          4238     DJNZ R1 , WAITXMS_O 
05EF    22            4239     	RET
                      4240     
                      4241     
                      4242     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4243     ;
                      4244     ; Beeper routines (4 different entry points) 
                      4245     ;
                      4246     ; No assumptions
                      4247     ;
                      4248     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4249     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
05F0    7A14          4250     MOV R2 , # 20 
05F2    7B78          4251     MOV R3 , # 120 
05F4    02060C        4252     	JMP	BEEP
                      4253     
                      4254     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
05F7    7A10          4255     MOV R2 , # 16 
05F9    7B8C          4256     MOV R3 , # 140 
05FB    02060C        4257     	JMP	BEEP
                      4258     
                      4259     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
05FE    7A0D          4260     MOV R2 , # 13 
0600    7BB4          4261     MOV R3 , # 180 
0602    02060C        4262     	JMP	BEEP
                      4263     
                      4264     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0605    7A0B          4265     MOV R2 , # 11 
0607    7BC8          4266     MOV R3 , # 200 
0609    02060C        4267     	JMP	BEEP
                      4268     
                      4269     BEEP: 	; Beep loop start
060C    7902          4270     MOV R1 , # 2 
                      4271     BEEP_ONOFF: 
060E    B27D          4272     CPL FLAGS3 . 5 
0610    E4            4273     	CLR	A
                      4274     	BPFET_OFF			; BpFET off
0611    C295          4274+1   CLR P1 . 5 
0613    D5E0FD        4275     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      4276     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
0616    D294          4276+1   SETB P1 . 4 
0618    D5E0FD        4277     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      4278     	BNFET_OFF			; BnFET off again
061B    C294          4278+1   CLR P1 . 4 
061D    D5E0FD        4279     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      4280     	BPFET_ON			; BpFET on
0620    D295          4280+1   SETB P1 . 5 
0622    D5E0FD        4281     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      4282     	; Turn on nfet
                      4283     	ANFET_ON			; AnFET on
0625    D293          4283+1   SETB P1 . 3 
0627    E573          4284     	MOV	A, BEEP_STRENGTH
0629    D5E0FD        4285     	DJNZ	ACC, $		
                      4286     	; Turn off nfet
                      4287     	ANFET_OFF			; AnFET off
062C    C293          4287+1   CLR P1 . 3 
062E    7496          4288     	MOV	A, #150		; 25s off
0630    D5E0FD        4289     	DJNZ	ACC, $		
0633    D9D9          4290     DJNZ R1 , BEEP_ONOFF 
                      4291     	; Copy variable
0635    EA            4292     MOV A , R2 
0636    F8            4293     MOV R0 , A 
                      4294     BEEP_OFF: 		; Fets off loop
0637    D5E0FD        4295     	DJNZ	ACC, $
063A    D8FB          4296     DJNZ R0 , BEEP_OFF 
063C    DBCE          4297     DJNZ R3 , BEEP 
                      4298     	BPFET_OFF			; BpFET off
063E    C295          4298+1   CLR P1 . 5 
0640    22            4299     	RET
                      4300     
                      4301     
                      4302     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4303     ;
                      4304     ; Division 16bit unsigned by 16bit unsigned
                      4305     ;
                      4306     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      4307     ; Result will be in Temp2/Temp1
                      4308     ;
                      4309     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4310     DIV_U16_BY_U16: 	
0641    C3            4311     	CLR	C       
0642    7C00          4312     MOV R4 , # 0 
0644    7D00          4313     MOV R5 , # 0 
0646    75F000        4314     	MOV	B, #0
                      4315     DIV_U16_BY_U16_DIV1: 
0649    05F0          4316     	INC	B      			; Increment counter for each left shift
064B    EA            4317     MOV A , R2 
064C    33            4318     	RLC	A      		
064D    FA            4319     MOV R2 , A 
064E    EB            4320     MOV A , R3 
064F    33            4321     	RLC	A      	  	
0650    FB            4322     MOV R3 , A 
0651    50F6          4323     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      4324     DIV_U16_BY_U16_DIV2:         
0653    EB            4325     MOV A , R3 
0654    13            4326     	RRC	A      
0655    FB            4327     MOV R3 , A 
0656    EA            4328     MOV A , R2 
0657    13            4329     	RRC	A      
0658    FA            4330     MOV R2 , A 
0659    C3            4331     	CLR	C      
065A    E9            4332     MOV A , R1 
065B    FF            4333     MOV R7 , A 
065C    E8            4334     MOV A , R0 
065D    FE            4335     MOV R6 , A 
065E    E8            4336     MOV A , R0 
065F    9A            4337     SUBB A , R2 
0660    F8            4338     MOV R0 , A 
0661    E9            4339     MOV A , R1 
0662    9B            4340     SUBB A , R3 
0663    F9            4341     MOV R1 , A 
0664    5004          4342     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
0666    EF            4343     MOV A , R7 
0667    F9            4344     MOV R1 , A 
0668    EE            4345     MOV A , R6 
0669    F8            4346     MOV R0 , A 
                      4347     DIV_U16_BY_U16_DIV3: 
066A    B3            4348     	CPL	C      			; Invert carry, so it can be directly copied into result
066B    EC            4349     MOV A , R4 
066C    33            4350     	RLC	A      			; Shift carry flag into temporary result
066D    FC            4351     MOV R4 , A 
066E    ED            4352     MOV A , R5 
066F    33            4353     	RLC	A
0670    FD            4354     MOV R5 , A 
0671    D5F0DF        4355     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
0674    ED            4356     MOV A , R5 
0675    F9            4357     MOV R1 , A 
0676    EC            4358     MOV A , R4 
0677    F8            4359     MOV R0 , A 
0678    22            4360     	RET
                      4361     
                      4362     
                      4363     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4364     ;
                      4365     ; Multiplication 16bit signed by 8bit unsigned
                      4366     ;
                      4367     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      4368     ; Result will be in Temp2/Temp1. Result will divided by 16
                      4369     ;
                      4370     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4371     MULT_S16_BY_U8_DIV_16: 
0679    E8            4372     MOV A , R0 
067A    89F0          4373     MOV B , R1 
067C    8A20          4374     MOV BIT_ACCESS , R2 
067E    D2D4          4375     	SETB	PSW.4		; Select register bank 2 for math routines
0680    F8            4376     MOV R0 , A 
0681    A9F0          4377     MOV R1 , B 
0683    7B00          4378     MOV R3 , # 0 
0685    30F70B        4379     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      4380     
0688    7BFF          4381     MOV R3 , # 0FFH 
068A    F4            4382     	CPL	A
068B    2401          4383     	ADD	A, #1
068D    F8            4384     MOV R0 , A 
068E    E9            4385     MOV A , R1 
068F    F4            4386     	CPL	A
0690    3400          4387     	ADDC	A, #0
0692    F9            4388     MOV R1 , A 
                      4389     MULT_S16_BY_U8_POSITIVE: 
0693    E8            4390     MOV A , R0 
0694    8520F0        4391     	MOV	B, BIT_ACCESS
0697    A4            4392     	MUL	AB
0698    ADF0          4393     MOV R5 , B 
069A    F8            4394     MOV R0 , A 
069B    E9            4395     MOV A , R1 
069C    8520F0        4396     	MOV	B, BIT_ACCESS
069F    A4            4397     	MUL	AB
06A0    AFF0          4398     MOV R7 , B 
06A2    FE            4399     MOV R6 , A 
06A3    ED            4400     MOV A , R5 
06A4    2E            4401     ADD A , R6 
06A5    F9            4402     MOV R1 , A 
06A6    7400          4403     	MOV	A, #0
06A8    3F            4404     ADDC A , R7 
06A9    FA            4405     MOV R2 , A 
06AA    7C04          4406     MOV R4 , # 4 
                      4407     MULT_S16_BY_U8_DIV_LOOP: 
06AC    C3            4408     	CLR	C			; Rotate right 
06AD    EA            4409     MOV A , R2 
06AE    13            4410     	RRC	A
06AF    FA            4411     MOV R2 , A 
06B0    E9            4412     MOV A , R1 
06B1    13            4413     	RRC	A
06B2    F9            4414     MOV R1 , A 
06B3    E8            4415     MOV A , R0 
06B4    13            4416     	RRC	A
06B5    F8            4417     MOV R0 , A 
06B6    DCF4          4418     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      4419     
06B8    8BF0          4420     MOV B , R3 
06BA    30F70A        4421     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      4422     
06BD    E8            4423     MOV A , R0 
06BE    F4            4424     	CPL	A
06BF    2401          4425     	ADD	A, #1
06C1    F8            4426     MOV R0 , A 
06C2    E9            4427     MOV A , R1 
06C3    F4            4428     	CPL	A
06C4    3400          4429     	ADDC	A, #0
06C6    F9            4430     MOV R1 , A 
                      4431     
                      4432     MULT_S16_BY_U8_EXIT: 
06C7    E8            4433     MOV A , R0 
06C8    89F0          4434     MOV B , R1 
06CA    C2D4          4435     	CLR	PSW.4		; Select normal register bank
06CC    F8            4436     MOV R0 , A 
06CD    A9F0          4437     MOV R1 , B 
06CF    22            4438     	RET
                      4439     
                      4440     
                      4441     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4442     ;
                      4443     ; Calculate governor routines
                      4444     ;
                      4445     ; No assumptions
                      4446     ;
                      4447     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      4448     ; The governor task is split into several routines in order to distribute processing time
                      4449     ;
                      4450     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4451     ; First governor routine - calculate governor target
                      4452     IF MODE == 0	; Main
                      4453     CALC_GOVERNOR_TARGET: 
06D0    7882          4454     MOV R0 , # PGM_GOV_MODE 
06D2    B60403        4455     CJNE @ R0 , # 4 , GOVERNOR_SPEED_CHECK 
06D5    02076F        4456     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      4457     
                      4458     GOVERNOR_SPEED_CHECK: 
                      4459     	; Stop governor for stop RC pulse	
06D8    C3            4460     	CLR	C
06D9    E55C          4461     	MOV	A, NEW_RCP				; Check RC pulse against stop value
06DB    9419          4462     	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
06DD    401E          4463     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      4464     
06DF    E52D          4465     	MOV	A, FLAGS1
06E1    5406          4466     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
06E3    7018          4467     	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                      4468     
                      4469     	; Skip speed check if governor is already active
06E5    206D36        4470     JB FLAGS1 . 5 , GOVERNOR_TARGET_CALC 
                      4471     
                      4472     	; Check speed (do not run governor for low speeds)
06E8    7805          4473     MOV R0 , # 05H 
06EA    7994          4474     MOV R1 , # PGM_GOV_RANGE 
06EC    E7            4475     MOV A , @ R1 
06ED    14            4476     	DEC	A
06EE    6007          4477     	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                      4478     
06F0    780A          4479     MOV R0 , # 0AH 
06F2    14            4480     	DEC	A
06F3    6002          4481     	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                      4482     	
06F5    7812          4483     MOV R0 , # 12H 
                      4484     
                      4485     GOVERNOR_ACT_LIM_SET: 
06F7    C3            4486     	CLR	C
06F8    E53E          4487     	MOV	A, COMM_PERIOD4X_H
06FA    98            4488     SUBB A , R0 
06FB    401F          4489     	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                      4490     
                      4491     GOVERNOR_DEACTIVATE: 
06FD    306D09        4492     JNB FLAGS1 . 5 , GOVERNOR_FIRST_DEACTIVATE_DONE 
                      4493      
0700    856462        4494     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
0703    7569FF        4495     	MOV	SPOOLUP_LIMIT_CNT, #255
0706    756A01        4496     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      4497     
                      4498     GOVERNOR_FIRST_DEACTIVATE_DONE: 
0709    852224        4499     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
070C    E4            4500     	CLR	A
070D    F542          4501     	MOV	GOV_TARGET_L, A			; Set target to zero
070F    F543          4502     	MOV	GOV_TARGET_H, A
0711    F544          4503     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
0713    F545          4504     	MOV	GOV_INTEGRAL_H, A
0715    F546          4505     	MOV	GOV_INTEGRAL_X, A
0717    C26D          4506     CLR FLAGS1 . 5 
0719    02076F        4507     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      4508     
                      4509     GOVERNOR_ACTIVATE: 
071C    D26D          4510     SETB FLAGS1 . 5 
                      4511     
                      4512     GOVERNOR_TARGET_CALC: 
                      4513     	; Governor calculations
071E    7994          4514     MOV R1 , # PGM_GOV_RANGE 
0720    E7            4515     MOV A , @ R1 
0721    14            4516     	DEC	A
0722    7013          4517     	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                      4518     
0724    E523          4519     	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
0726    F4            4520     	CPL	A					; Calculate 255-pwm (invert pwm) 
                      4521     	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
0727    33            4522     	RLC	A					; Msb to carry
0728    33            4523     	RLC	A					; To bit0
0729    F9            4524     MOV R1 , A 
072A    13            4525     	RRC	A					
072B    F8            4526     MOV R0 , A 
072C    E9            4527     MOV A , R1 
072D    5401          4528     	ANL	A, #01H				; Calculate H byte
072F    04            4529     	INC	A					; Add 1
0730    F9            4530     MOV R1 , A 
0731    E8            4531     MOV A , R0 
0732    54FE          4532     	ANL	A, #0FEH				; Calculate L byte
0734    020763        4533     	JMP	CALC_GOVERNOR_SUBTRACT_025
                      4534     
                      4535     CALC_GOVERNOR_TARGET_MIDDLE: 
0737    E7            4536     MOV A , @ R1 
0738    14            4537     	DEC	A
0739    14            4538     	DEC	A
073A    7014          4539     	JNZ	CALC_GOVERNOR_TARGET_LOW
                      4540     
073C    E523          4541     	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
073E    F4            4542     	CPL	A					; Calculate 255-pwm (invert pwm) 
                      4543     	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
073F    33            4544     	RLC	A					; Msb to carry
0740    33            4545     	RLC	A					; To bit0
0741    33            4546     	RLC	A					; To bit1
0742    F9            4547     MOV R1 , A 
0743    13            4548     	RRC	A					
0744    F8            4549     MOV R0 , A 
0745    E9            4550     MOV A , R1 
0746    5403          4551     	ANL	A, #03H				; Calculate H byte
0748    04            4552     	INC	A					; Add 1
0749    F9            4553     MOV R1 , A 
074A    E8            4554     MOV A , R0 
074B    54FC          4555     	ANL	A, #0FCH				; Calculate L byte
074D    02076B        4556     	JMP	CALC_GOVERNOR_STORE_TARGET
                      4557     
                      4558     CALC_GOVERNOR_TARGET_LOW: 
0750    E523          4559     	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
0752    F4            4560     	CPL	A					; Calculate 255-pwm (invert pwm) 
                      4561     	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
0753    33            4562     	RLC	A					; Msb to carry
0754    33            4563     	RLC	A					; To bit0
0755    33            4564     	RLC	A					; To bit1
0756    33            4565     	RLC	A					; To bit2
0757    F9            4566     MOV R1 , A 
0758    13            4567     	RRC	A					
0759    F8            4568     MOV R0 , A 
075A    E9            4569     MOV A , R1 
075B    5407          4570     	ANL	A, #07H				; Calculate H byte
075D    04            4571     	INC	A					; Add 1
075E    04            4572     	INC	A					; Add 1 more
075F    F9            4573     MOV R1 , A 
0760    E8            4574     MOV A , R0 
0761    54F8          4575     	ANL	A, #0F8H				; Calculate L byte
                      4576     CALC_GOVERNOR_SUBTRACT_025: 
0763    C3            4577     	CLR	C
0764    9440          4578     	SUBB	A, #40H				; Subtract 0.25
0766    F8            4579     MOV R0 , A 
0767    E9            4580     MOV A , R1 
0768    9400          4581     	SUBB	A, #0
076A    F9            4582     MOV R1 , A 
                      4583     CALC_GOVERNOR_STORE_TARGET: 
                      4584     	; Store governor target
076B    8842          4585     MOV GOV_TARGET_L , R0 
076D    8943          4586     MOV GOV_TARGET_H , R1 
                      4587     CALC_GOVERNOR_TARGET_EXIT: 
076F    22            4588     	RET						
                      4589     ENDIF
                      4590     IF MODE == 1	; Tail
                               CALC_GOVERNOR_TARGET:
                               	RET						
                               ENDIF
                      4594     IF MODE == 2	; Multi
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Closed loop mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_TARGET_CALC	; Yes - branch
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_TARGET_CALC:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #RCP_STOP				; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	JMP	GOVERNOR_ACTIVATE			; No - activate
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	CLR	FLAGS1.GOV_ACTIVE
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	TEMP1, #PGM_GOV_MODE		; Store gov mode
                               	MOV	A, @TEMP1
                               	MOV	TEMP5, A
                               	SETB	FLAGS1.GOV_ACTIVE
                               	MOV	A, REQUESTED_PWM			; Load requested pwm
                               	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                               	; Calculate comm period target 2*(51000/Requested_Pwm)
                               	MOV	TEMP1, #38H				; Load 51000
                               	MOV	TEMP2, #0C7H
                               	MOV	TEMP3, COMM_PERIOD4X_L		; Load comm period
                               	MOV	TEMP4, COMM_PERIOD4X_H		
                               	; Set speed range 
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 200k eRPM range here
                               	; Check range
                               	MOV	A, TEMP5
                               	DEC	A
                               	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                               GOVERNOR_ACTIVATE_100K:
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 100k eRPM range here
                               	MOV	A, TEMP5					; Check range again
                               	DEC	A
                               	DEC	A
                               	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                               GOVERNOR_ACTIVATE_50K:
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 50k eRPM range here
                               GOVERNOR_ACTIVATE_RANGE_SET:
                               	CALL	DIV_U16_BY_U16
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      4672     
                      4673     
                      4674     ; Second governor routine - calculate governor proportional error
                      4675     CALC_GOVERNOR_PROP_ERROR: 
                      4676     IF MODE <= 1	; Main or tail
                      4677     	; Load comm period and divide by 2
0770    C3            4678     	CLR	C
0771    E53E          4679     	MOV	A, COMM_PERIOD4X_H
0773    13            4680     	RRC	A
0774    F9            4681     MOV R1 , A 
0775    E53D          4682     	MOV	A, COMM_PERIOD4X_L
0777    13            4683     	RRC	A
0778    F8            4684     MOV R0 , A 
                      4685     	; Calculate error
0779    C3            4686     	CLR	C
077A    E542          4687     	MOV	A, GOV_TARGET_L
077C    98            4688     SUBB A , R0 
077D    F8            4689     MOV R0 , A 
077E    E543          4690     	MOV	A, GOV_TARGET_H
0780    99            4691     SUBB A , R1 
0781    F9            4692     MOV R1 , A 
                      4693     ENDIF
                      4694     IF MODE == 2	; Multi
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, GOVERNOR_REQ_PWM
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               ENDIF
                      4704     	; Check error and limit
0782    500C          4705     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      4706     
0784    C3            4707     	CLR	C
0785    E8            4708     MOV A , R0 
0786    9480          4709     	SUBB	A, #80H					; Is error too negative?
0788    E9            4710     MOV A , R1 
0789    94FF          4711     	SUBB	A, #0FFH
078B    4016          4712     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
078D    0207A7        4713     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4714     
                      4715     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0790    C3            4716     	CLR	C
0791    E8            4717     MOV A , R0 
0792    947F          4718     	SUBB	A, #7FH					; Is error too positive?
0794    E9            4719     MOV A , R1 
0795    9400          4720     	SUBB	A, #00H
0797    5003          4721     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
0799    0207A7        4722     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4723     
                      4724     GOVERNOR_LIMIT_PROP_ERROR_POS: 
079C    787F          4725     MOV R0 , # 7FH 
079E    7900          4726     MOV R1 , # 00H 
07A0    0207A7        4727     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4728     
                      4729     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
07A3    7880          4730     MOV R0 , # 80H 
07A5    79FF          4731     MOV R1 , # 0FFH 
                      4732     
                      4733     GOVERNOR_STORE_PROP_ERROR: 
                      4734     	; Store proportional
07A7    8847          4735     MOV GOV_PROPORTIONAL_L , R0 
07A9    8948          4736     MOV GOV_PROPORTIONAL_H , R1 
                      4737     CALC_GOVERNOR_PROP_ERROR_EXIT: 
07AB    22            4738     	RET						
                      4739     
                      4740     
                      4741     ; Third governor routine - calculate governor integral error
                      4742     CALC_GOVERNOR_INT_ERROR: 
                      4743     	; Add proportional to integral
07AC    E547          4744     	MOV	A, GOV_PROPORTIONAL_L
07AE    2544          4745     	ADD	A, GOV_INTEGRAL_L
07B0    F8            4746     MOV R0 , A 
07B1    E548          4747     	MOV	A, GOV_PROPORTIONAL_H
07B3    3545          4748     	ADDC	A, GOV_INTEGRAL_H
07B5    F9            4749     MOV R1 , A 
07B6    854820        4750     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
07B9    E4            4751     	CLR	A
07BA    300701        4752     	JNB	BIT_ACCESS.7, ($+4)			
07BD    F4            4753     	CPL	A
07BE    3546          4754     	ADDC	A, GOV_INTEGRAL_X
07C0    FA            4755     MOV R2 , A 
                      4756     	; Check integral and limit
07C1    30E709        4757     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      4758     
07C4    C3            4759     	CLR	C
07C5    EA            4760     MOV A , R2 
07C6    94F0          4761     	SUBB	A, #0F0H					; Is error too negative?
07C8    4015          4762     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
07CA    0207E5        4763     	JMP	GOVERNOR_CHECK_PWM
                      4764     
                      4765     GOVERNOR_CHECK_INT_LIMIT_POS: 
07CD    C3            4766     	CLR	C
07CE    EA            4767     MOV A , R2 
07CF    940F          4768     	SUBB	A, #0FH					; Is error too positive?
07D1    5003          4769     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
07D3    0207E5        4770     	JMP	GOVERNOR_CHECK_PWM
                      4771     
                      4772     GOVERNOR_LIMIT_INT_ERROR_POS: 
07D6    78FF          4773     MOV R0 , # 0FFH 
07D8    79FF          4774     MOV R1 , # 0FFH 
07DA    7A0F          4775     MOV R2 , # 0FH 
07DC    0207E5        4776     	JMP	GOVERNOR_CHECK_PWM
                      4777     
                      4778     GOVERNOR_LIMIT_INT_ERROR_NEG: 
07DF    7800          4779     MOV R0 , # 00H 
07E1    7900          4780     MOV R1 , # 00H 
07E3    7AF0          4781     MOV R2 , # 0F0H 
                      4782     
                      4783     GOVERNOR_CHECK_PWM: 
                      4784     	; Check current pwm
07E5    C3            4785     	CLR	C
07E6    E524          4786     	MOV	A, CURRENT_PWM
07E8    9561          4787     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
07EA    500A          4788     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      4789     
07EC    C3            4790     	CLR	C
07ED    7401          4791     	MOV	A, #1
07EF    9524          4792     	SUBB	A, CURRENT_PWM				; Is current pwm at minimum?
07F1    500B          4793     	JNC	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      4794     
07F3    020803        4795     	JMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      4796     
                      4797     GOVERNOR_INT_MAX_PWM: 
07F6    E548          4798     	MOV	A, GOV_PROPORTIONAL_H
07F8    20E70E        4799     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      4800     
07FB    020803        4801     	JMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      4802     
                      4803     GOVERNOR_INT_MIN_PWM: 
07FE    E548          4804     	MOV	A, GOV_PROPORTIONAL_H
0800    30E706        4805     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      4806     
                      4807     GOVERNOR_STORE_INT_ERROR: 
                      4808     	; Store integral
0803    8844          4809     MOV GOV_INTEGRAL_L , R0 
0805    8945          4810     MOV GOV_INTEGRAL_H , R1 
0807    8A46          4811     MOV GOV_INTEGRAL_X , R2 
                      4812     CALC_GOVERNOR_INT_ERROR_EXIT: 
0809    22            4813     	RET						
                      4814     
                      4815     
                      4816     ; Fourth governor routine - calculate governor proportional correction
                      4817     CALC_GOVERNOR_PROP_CORRECTION: 
                      4818     	; Load proportional gain
080A    78A4          4819     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
080C    E6            4820     MOV A , @ R0 
080D    FA            4821     MOV R2 , A 
                      4822     	; Load proportional
080E    C3            4823     	CLR	C
080F    E547          4824     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0811    33            4825     	RLC	A
0812    F8            4826     MOV R0 , A 
0813    E548          4827     	MOV	A, GOV_PROPORTIONAL_H
0815    33            4828     	RLC	A
0816    F9            4829     MOV R1 , A 
                      4830     	; Apply gain
0817    120679        4831     	CALL	MULT_S16_BY_U8_DIV_16
                      4832     	; Check error and limit (to low byte)
081A    E9            4833     MOV A , R1 
081B    30E70B        4834     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      4835     
081E    C3            4836     	CLR	C
081F    E8            4837     MOV A , R0 
0820    9480          4838     	SUBB	A, #80H					; Is error too negative?
0822    E9            4839     MOV A , R1 
0823    94FF          4840     	SUBB	A, #0FFH
0825    4013          4841     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0827    013E          4842     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4843     
                      4844     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0829    C3            4845     	CLR	C
082A    E8            4846     MOV A , R0 
082B    947F          4847     	SUBB	A, #7FH					; Is error too positive?
082D    E9            4848     MOV A , R1 
082E    9400          4849     	SUBB	A, #00H
0830    5002          4850     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0832    013E          4851     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4852     
                      4853     GOVERNOR_LIMIT_PROP_CORR_POS: 
0834    787F          4854     MOV R0 , # 7FH 
0836    7900          4855     MOV R1 , # 00H 
0838    013E          4856     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4857     
                      4858     GOVERNOR_LIMIT_PROP_CORR_NEG: 
083A    7880          4859     MOV R0 , # 80H 
083C    79FF          4860     MOV R1 , # 0FFH 
                      4861     
                      4862     GOVERNOR_APPLY_PROP_CORR: 
                      4863     	; Test proportional sign
083E    E8            4864     MOV A , R0 
083F    20E715        4865     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      4866     
                      4867     	; Subtract positive proportional
0842    C3            4868     	CLR	C
0843    E523          4869     	MOV	A, GOVERNOR_REQ_PWM
0845    98            4870     SUBB A , R0 
0846    F8            4871     MOV R0 , A 
                      4872     	; Check result
0847    4009          4873     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      4874     
0849    C3            4875     	CLR	C
084A    E8            4876     MOV A , R0 
084B    9401          4877     	SUBB	A, #1
084D    4003          4878     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
084F    020865        4879     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4880     
                      4881     GOVERNOR_CORR_PROP_MIN_PWM: 
0852    7801          4882     MOV R0 , # 1 
0854    020865        4883     	JMP	GOVERNOR_STORE_PROP_CORR
                      4884     
                      4885     GOVERNOR_CORR_NEG_PROP: 
                      4886     	; Add negative proportional
0857    E8            4887     MOV A , R0 
0858    F4            4888     	CPL	A
0859    2401          4889     	ADD	A, #1
085B    2523          4890     	ADD	A, GOVERNOR_REQ_PWM
085D    F8            4891     MOV R0 , A 
                      4892     	; Check result
085E    4003          4893     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0860    020865        4894     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4895     
                      4896     GOVERNOR_CORR_PROP_MAX_PWM: 
0863    78FF          4897     MOV R0 , # 255 
                      4898     GOVERNOR_STORE_PROP_CORR: 
                      4899     	; Store proportional pwm
0865    8849          4900     MOV GOV_PROP_PWM , R0 
                      4901     CALC_GOVERNOR_PROP_CORR_EXIT: 
0867    22            4902     	RET
                      4903     
                      4904     
                      4905     ; Fifth governor routine - calculate governor integral correction
                      4906     CALC_GOVERNOR_INT_CORRECTION: 
                      4907     	; Load integral gain
0868    78A5          4908     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
086A    E6            4909     MOV A , @ R0 
086B    FA            4910     MOV R2 , A 
                      4911     	; Load integral
086C    A845          4912     MOV R0 , GOV_INTEGRAL_H 
086E    A946          4913     MOV R1 , GOV_INTEGRAL_X 
                      4914     	; Apply gain
0870    120679        4915     	CALL	MULT_S16_BY_U8_DIV_16
                      4916     	; Check integral and limit
0873    E9            4917     MOV A , R1 
0874    30E70C        4918     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      4919     
0877    C3            4920     	CLR	C
0878    E8            4921     MOV A , R0 
0879    9401          4922     	SUBB	A, #01H					; Is integral too negative?
087B    E9            4923     MOV A , R1 
087C    94FF          4924     	SUBB	A, #0FFH
087E    4016          4925     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0880    02089A        4926     	JMP	GOVERNOR_APPLY_INT_CORR
                      4927     
                      4928     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0883    C3            4929     	CLR	C
0884    E8            4930     MOV A , R0 
0885    94FF          4931     	SUBB	A, #0FFH					; Is integral too positive?
0887    E9            4932     MOV A , R1 
0888    9400          4933     	SUBB	A, #00H
088A    5003          4934     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
088C    02089A        4935     	JMP	GOVERNOR_APPLY_INT_CORR
                      4936     
                      4937     GOVERNOR_LIMIT_INT_CORR_POS: 
088F    78FF          4938     MOV R0 , # 0FFH 
0891    7900          4939     MOV R1 , # 00H 
0893    02089A        4940     	JMP	GOVERNOR_APPLY_INT_CORR
                      4941     
                      4942     GOVERNOR_LIMIT_INT_CORR_NEG: 
0896    7801          4943     MOV R0 , # 01H 
0898    79FF          4944     MOV R1 , # 0FFH 
                      4945     
                      4946     GOVERNOR_APPLY_INT_CORR: 
                      4947     	; Test integral sign
089A    E9            4948     MOV A , R1 
089B    20E715        4949     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      4950     
                      4951     	; Subtract positive integral
089E    C3            4952     	CLR	C
089F    E549          4953     	MOV	A, GOV_PROP_PWM
08A1    98            4954     SUBB A , R0 
08A2    F8            4955     MOV R0 , A 
                      4956     	; Check result
08A3    4009          4957     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      4958     
08A5    C3            4959     	CLR	C
08A6    E8            4960     MOV A , R0 
08A7    9401          4961     	SUBB	A, #1
08A9    4003          4962     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
08AB    0208C1        4963     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4964     
                      4965     GOVERNOR_CORR_INT_MIN_PWM: 
08AE    7801          4966     MOV R0 , # 1 
08B0    0208C1        4967     	JMP	GOVERNOR_STORE_INT_CORR
                      4968     
                      4969     GOVERNOR_CORR_NEG_INT: 
                      4970     	; Add negative integral
08B3    E8            4971     MOV A , R0 
08B4    F4            4972     	CPL	A
08B5    2401          4973     	ADD	A, #1
08B7    2549          4974     	ADD	A, GOV_PROP_PWM
08B9    F8            4975     MOV R0 , A 
                      4976     	; Check result
08BA    4003          4977     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
08BC    0208C1        4978     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4979     
                      4980     GOVERNOR_CORR_INT_MAX_PWM: 
08BF    78FF          4981     MOV R0 , # 255 
                      4982     GOVERNOR_STORE_INT_CORR: 
                      4983     	; Store current pwm
08C1    8824          4984     MOV CURRENT_PWM , R0 
                      4985     CALC_GOVERNOR_INT_CORR_EXIT: 
08C3    22            4986     	RET
                      4987     
                      4988     
                      4989     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4990     ;
                      4991     ; Set pwm limit low rpm
                      4992     ;
                      4993     ; No assumptions
                      4994     ;
                      4995     ; Sets power limit for low rpms and disables demag for low rpms
                      4996     ;
                      4997     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4998     SET_PWM_LIMIT_LOW_RPM: 
                      4999     	; Set pwm limit and demag disable for low rpms
08C4    78FF          5000     MOV R0 , # 0FFH 
08C6    C264          5001     CLR FLAGS0 . 4 
08C8    20693D        5002     JB FLAGS1 . 1 , SET_PWM_LIMIT_LOW_RPM_EXIT 
08CB    206A12        5003     JB FLAGS1 . 2 , SET_PWM_DEMAG_DONE 
                      5004     
08CE    D264          5005     SETB FLAGS0 . 4 
08D0    C3            5006     	CLR	C
08D1    E53E          5007     	MOV	A, COMM_PERIOD4X_H
08D3    940A          5008     	SUBB	A, #0AH						; ~31250 eRPM
08D5    4009          5009     	JC	SET_PWM_DEMAG_DONE				; If speed above - branch
                      5010     
08D7    C3            5011     	CLR	C
08D8    E525          5012     	MOV	A, CURRENT_PWM_LIMITED	
08DA    9440          5013     	SUBB	A, #40H						; Do not disable if pwm above 25%
08DC    5002          5014     	JNC	SET_PWM_DEMAG_DONE
                      5015     
08DE    C264          5016     CLR FLAGS0 . 4 
                      5017     
                      5018     SET_PWM_DEMAG_DONE: 
08E0    79A1          5019     MOV R1 , # PGM_ENABLE_POWER_PROT 
08E2    E7            5020     MOV A , @ R1 
08E3    6023          5021     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Exit if disabled
                      5022     
08E5    E53E          5023     	MOV	A, COMM_PERIOD4X_H
08E7    601F          5024     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Avoid divide by zero
                      5025     
08E9    74FF          5026     	MOV	A, #255						; Divide 255 by Comm_Period4x_H
08EB    853EF0        5027     	MOV	B, COMM_PERIOD4X_H
08EE    84            5028     	DIV	AB
08EF    8538F0        5029     	MOV	B, LOW_RPM_PWR_SLOPE			; Multiply by slope
08F2    306A03        5030     JNB FLAGS1 . 2 , ( $+6 ) 
08F5    75F005        5031     	MOV	B, #5
08F8    A4            5032     	MUL	AB
08F9    F8            5033     MOV R0 , A 
08FA    C5F0          5034     	XCH	A, B
08FC    6002          5035     	JZ	($+4)						; Limit to max
                      5036     	
08FE    78FF          5037     MOV R0 , # 0FFH 
                      5038     
0900    C3            5039     	CLR	C
0901    E8            5040     MOV A , R0 
0902    9564          5041     	SUBB	A, PWM_SPOOLUP_BEG
0904    5002          5042     	JNC	SET_PWM_LIMIT_LOW_RPM_EXIT
                      5043     
0906    A864          5044     MOV R0 , PWM_SPOOLUP_BEG 
                      5045     
                      5046     SET_PWM_LIMIT_LOW_RPM_EXIT: 
0908    8863          5047     MOV PWM_LIMIT_BY_RPM , R0 
090A    22            5048     	RET
                      5049     	
                      5050     
                      5051     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5052     ;
                      5053     ; Set pwm limit high rpm
                      5054     ;
                      5055     ; No assumptions
                      5056     ;
                      5057     ; Sets power limit for high rpms
                      5058     ;
                      5059     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5060     SET_PWM_LIMIT_HIGH_RPM: 
                      5061     IF MCU_48MHZ == 1
090B    C3            5062     	CLR	C
090C    E53D          5063     	MOV	A, COMM_PERIOD4X_L
090E    94C8          5064     	SUBB	A, #0C8H				; Limit Comm_Period to 200, which is 400k erpm
0910    E53E          5065     	MOV	A, COMM_PERIOD4X_H
0912    9400          5066     	SUBB	A, #00H
                      5067     ELSE
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_L
                               	SUBB	A, #40H				; Limit Comm_Period to 320, which is 250k erpm
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, #01H
                               ENDIF
0914    E563          5074     	MOV	A, PWM_LIMIT_BY_RPM
0916    5003          5075     	JNC	SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT
                      5076     	
0918    14            5077     	DEC	A
0919    211C          5078     	AJMP	SET_PWM_LIMIT_HIGH_RPM_STORE
                      5079     	
                      5080     SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT: 
091B    04            5081     	INC	A
                      5082     SET_PWM_LIMIT_HIGH_RPM_STORE: 
091C    6002          5083     	JZ	($+4)
                      5084     
091E    F563          5085     	MOV	PWM_LIMIT_BY_RPM, A
                      5086     
0920    22            5087     	RET
                      5088     
                      5089     
                      5090     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5091     ;
                      5092     ; Measure lipo cells
                      5093     ;
                      5094     ; No assumptions
                      5095     ;
                      5096     ; Measure voltage and calculate lipo cells
                      5097     ;
                      5098     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5099     MEASURE_LIPO_CELLS: 
                      5100     IF MODE >= 1	; Tail or multi
                               	; If not supported, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      5104     IF MODE == 0	; Main
                      5105     	; Load programmed low voltage limit
0921    7883          5106     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0923    E6            5107     MOV A , @ R0 
0924    F520          5108     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      5109     	; Set commutation to BpFET on
0926    120FB3        5110     	CALL	COMM5COMM6			
                      5111     	; Start adc
                      5112     	START_ADC 
0929    75E890        5112+1   MOV ADC0CN , # 90H  ; ADC START
                      5113     	; Wait for ADC reference to settle, and then start again
092C    1205C7        5114     	CALL	WAIT1MS
                      5115     	START_ADC
092F    75E890        5115+1   MOV ADC0CN , # 90H  ; ADC START
                      5116     	; Wait for ADC conversion to complete
                      5117     MEASURE_LIPO_WAIT_ADC: 
                      5118     	GET_ADC_STATUS 
0932    E5E8          5118+1   MOV A , ADC0CN 
0934    20ECFB        5119     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      5120     	; Read ADC result
                      5121     	READ_ADC_RESULT
0937    A8BD          5121+1   MOV R0 , ADC0L 
0939    A9BE          5121+1   MOV R1 , ADC0H 
                      5122     	; Stop ADC
                      5123     	STOP_ADC
                      5124     	; Switch power off
093B    12104D        5125     	CALL	SWITCH_POWER_OFF		
                      5126     	; Set limit step
093E    756E00        5127     MOV LIPO_ADC_LIMIT_L , # 0 
0941    756F00        5128     MOV LIPO_ADC_LIMIT_H , # 0 
0944    C3            5129     	CLR	C
0945    7400          5130     MOV A , # 0 
0947    13            5131     	RRC	A
0948    FD            5132     MOV R5 , A 
0949    7400          5133     MOV A , # 0 
094B    6066          5134     	JZ	MEASURE_LIPO_EXIT		; Exit if disabled
                      5135     
094D    13            5136     	RRC	A
094E    FC            5137     MOV R4 , A 
094F    7400          5138     MOV A , # 0 
0951    2C            5139     ADD A , R4 
0952    FC            5140     MOV R4 , A 
0953    7400          5141     MOV A , # 0 
0955    3D            5142     ADDC A , R5 
0956    FD            5143     MOV R5 , A 
0957    EC            5144     MOV A , R4 
0958    FA            5145     MOV R2 , A 
0959    ED            5146     MOV A , R5 
095A    FB            5147     MOV R3 , A 
                      5148     MEASURE_LIPO_CELL_LOOP: 
                      5149     	; Check voltage against xS lower limit
095B    C3            5150     	CLR	C
095C    E8            5151     MOV A , R0 
095D    9A            5152     SUBB A , R2 
095E    E9            5153     MOV A , R1 
095F    9B            5154     SUBB A , R3 
0960    4014          5155     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      5156     
                      5157     	; Set xS voltage limit
0962    E56E          5158     	MOV	A, LIPO_ADC_LIMIT_L		
0964    2400          5159     ADD A , # 0 
0966    F56E          5160     	MOV	LIPO_ADC_LIMIT_L, A
0968    E56F          5161     	MOV	A, LIPO_ADC_LIMIT_H		
096A    3400          5162     ADDC A , # 0 
096C    F56F          5163     	MOV	LIPO_ADC_LIMIT_H, A
                      5164     	; Set (x+1)S lower limit
096E    EA            5165     MOV A , R2 
096F    2C            5166     ADD A , R4 
0970    FA            5167     MOV R2 , A 
0971    EB            5168     MOV A , R3 
0972    3D            5169     ADDC A , R5 
0973    FB            5170     MOV R3 , A 
0974    80E5          5171     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      5172     
                      5173     MEASURE_LIPO_ADJUST: 
0976    AE6E          5174     MOV R6 , LIPO_ADC_LIMIT_L 
0978    AF6F          5175     MOV R7 , LIPO_ADC_LIMIT_H 
                      5176     	; Calculate 3.125%
097A    C3            5177     	CLR	C
097B    E56F          5178     	MOV	A, LIPO_ADC_LIMIT_H
097D    13            5179     	RRC	A
097E    F9            5180     MOV R1 , A 
097F    E56E          5181     	MOV	A, LIPO_ADC_LIMIT_L	
0981    13            5182     	RRC	A
0982    F8            5183     MOV R0 , A 
0983    C3            5184     	CLR	C
0984    E9            5185     MOV A , R1 
0985    13            5186     	RRC	A
0986    F9            5187     MOV R1 , A 
0987    E8            5188     MOV A , R0 
0988    13            5189     	RRC	A
0989    F8            5190     MOV R0 , A 
                      5191     	; Divide three times to get to 3.125%
098A    7A03          5192     MOV R2 , # 3 
                      5193     MEASURE_LIPO_DIVIDE_LOOP: 
098C    C3            5194     	CLR	C
098D    E9            5195     MOV A , R1 
098E    13            5196     	RRC	A
098F    F9            5197     MOV R1 , A 
0990    E8            5198     MOV A , R0 
0991    13            5199     	RRC	A
0992    F8            5200     MOV R0 , A 
0993    DAF7          5201     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      5202     
                      5203     	; Add the programmed number of 0.1V (or 3.125% increments)
0995    AA20          5204     MOV R2 , BIT_ACCESS 
0997    1A            5205     DEC R2 
0998    7009          5206     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      5207     
099A    756E00        5208     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
099D    756F00        5209     	MOV	LIPO_ADC_LIMIT_H, #0
09A0    0209B3        5210     	JMP	MEASURE_LIPO_EXIT	
                      5211     
                      5212     MEASURE_LIPO_LIMIT_ON: 
09A3    1A            5213     DEC R2 
09A4    EA            5214     MOV A , R2 
09A5    6008          5215     	JZ	MEASURE_LIPO_UPDATE
                      5216     
                      5217     MEASURE_LIPO_ADD_LOOP: 
09A7    EE            5218     MOV A , R6 
09A8    28            5219     ADD A , R0 
09A9    FE            5220     MOV R6 , A 
09AA    EF            5221     MOV A , R7 
09AB    39            5222     ADDC A , R1 
09AC    FF            5223     MOV R7 , A 
09AD    DAF8          5224     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      5225     
                      5226     MEASURE_LIPO_UPDATE: 
                      5227     	; Set ADC limit
09AF    8E6E          5228     MOV LIPO_ADC_LIMIT_L , R6 
09B1    8F6F          5229     MOV LIPO_ADC_LIMIT_H , R7 
                      5230     ENDIF
                      5231     MEASURE_LIPO_EXIT: 
09B3    22            5232     	RET
                      5233     
                      5234     
                      5235     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5236     ;
                      5237     ; Start ADC conversion
                      5238     ;
                      5239     ; No assumptions
                      5240     ;
                      5241     ; Start conversion used for measuring power supply voltage
                      5242     ;
                      5243     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5244     START_ADC_CONVERSION: 
                      5245     	; Start adc
                      5246     	START_ADC 
09B4    75E890        5246+1   MOV ADC0CN , # 90H  ; ADC START
09B7    22            5247     	RET
                      5248     
                      5249     
                      5250     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5251     ;
                      5252     ; Check temperature, power supply voltage and limit power
                      5253     ;
                      5254     ; No assumptions
                      5255     ;
                      5256     ; Used to limit main motor power in order to maintain the required voltage
                      5257     ;
                      5258     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5259     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      5260     	; Load programmed low voltage limit
09B8    7883          5261     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
09BA    E6            5262     MOV A , @ R0 
09BB    FF            5263     MOV R7 , A 
                      5264     	; Wait for ADC conversion to complete
                      5265     	GET_ADC_STATUS 
09BC    E5E8          5265+1   MOV A , ADC0CN 
09BE    20ECF7        5266     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      5267     	; Read ADC result
                      5268     	READ_ADC_RESULT
09C1    A8BD          5268+1   MOV R0 , ADC0L 
09C3    A9BE          5268+1   MOV R1 , ADC0H 
                      5269     	; Stop ADC
                      5270     	STOP_ADC
                      5271     
09C5    0570          5272     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
09C7    C3            5273     	CLR	C
09C8    E570          5274     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
09CA    9408          5275     SUBB A , # 8 
09CC    4052          5276     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      5277     
09CE    757000        5278     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
09D1    E9            5279     MOV A , R1 
09D2    FA            5280     MOV R2 , A 
09D3    79A0          5281     MOV R1 , # PGM_ENABLE_TEMP_PROT 
09D5    E7            5282     MOV A , @ R1 
09D6    6044          5283     	JZ	TEMP_CHECK_EXIT			; No - branch
                      5284     
09D8    EA            5285     MOV A , R2 
09D9    7007          5286     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      5287     
09DB    E571          5288     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
09DD    601B          5289     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
09DF    0209EE        5290     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      5291     
                      5292     TEMP_AVERAGE_INC_DEC: 
09E2    C3            5293     	CLR	C
09E3    E8            5294     MOV A , R0 
09E4    9571          5295     	SUBB	A, CURRENT_AVERAGE_TEMP
09E6    6010          5296     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      5297     
09E8    E571          5298     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
09EA    5006          5299     	JNC	TEMP_AVERAGE_INC				
                      5300     
09EC    600C          5301     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      5302     TEMP_AVERAGE_DEC: 
09EE    14            5303     	DEC	A						; Decrement average
09EF    0209FA        5304     	JMP	TEMP_AVERAGE_UPDATED
                      5305     
                      5306     TEMP_AVERAGE_INC: 
09F2    04            5307     	INC	A						; Increment average
09F3    60F9          5308     	JZ	TEMP_AVERAGE_DEC
09F5    0209FA        5309     	JMP	TEMP_AVERAGE_UPDATED
                      5310     
                      5311     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
09F8    E571          5312     	MOV	A, CURRENT_AVERAGE_TEMP
                      5313     TEMP_AVERAGE_UPDATED: 
09FA    F571          5314     	MOV	CURRENT_AVERAGE_TEMP, A
09FC    C3            5315     	CLR	C
09FD    9472          5316     SUBB A , # 114 
09FF    401B          5317     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5318     
0A01    7561C0        5319     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      5320     
0A04    C3            5321     	CLR	C
0A05    9404          5322     SUBB A , # 4 
0A07    4013          5323     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5324     
0A09    756180        5325     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      5326     
0A0C    C3            5327     	CLR	C
0A0D    9404          5328     SUBB A , # 4 
0A0F    400B          5329     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5330     
0A11    756140        5331     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      5332     
0A14    C3            5333     	CLR	C
0A15    9404          5334     SUBB A , # 4 
0A17    4003          5335     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5336     
0A19    756100        5337     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      5338     
                      5339     TEMP_CHECK_EXIT: 
                      5340     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0A1C    75BB09        5340+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0A1F    22            5341     	RET
                      5342     
                      5343     CHECK_VOLTAGE_START: 
                      5344     IF MODE == 0	; Main 
                      5345     	; Check if low voltage limiting is enabled
0A20    EF            5346     MOV A , R7 
0A21    C3            5347     	CLR	C
0A22    9401          5348     	SUBB	A, #1					; Is low voltage limit disabled?
0A24    601F          5349     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      5350     
0A26    7400          5351     MOV A , # 0 
0A28    601B          5352     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      5353     
                      5354     	; Check if ADC is saturated
0A2A    C3            5355     	CLR	C
0A2B    E8            5356     MOV A , R0 
0A2C    94FF          5357     	SUBB	A, #0FFH
0A2E    E9            5358     MOV A , R1 
0A2F    9403          5359     	SUBB	A, #03H
0A31    5012          5360     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      5361     
                      5362     	; Check voltage against limit
0A33    C3            5363     	CLR	C
0A34    E8            5364     MOV A , R0 
0A35    956E          5365     	SUBB	A, LIPO_ADC_LIMIT_L
0A37    E9            5366     MOV A , R1 
0A38    956F          5367     	SUBB	A, LIPO_ADC_LIMIT_H
0A3A    5009          5368     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      5369     
                      5370     	; Decrease pwm limit
0A3C    E561          5371     	MOV  A, PWM_LIMIT
0A3E    600C          5372     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      5373     
0A40    1561          5374     	DEC	PWM_LIMIT					; Decrement limit
0A42    020A4C        5375     	JMP	CHECK_VOLTAGE_LIM
                      5376     
                      5377     CHECK_VOLTAGE_GOOD: 
                      5378     	; Increase pwm limit
0A45    E561          5379     	MOV  A, PWM_LIMIT
0A47    F4            5380     	CPL	A			
0A48    6002          5381     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      5382     
0A4A    0561          5383     	INC	PWM_LIMIT					; Increment limit
                      5384     
                      5385     CHECK_VOLTAGE_LIM: 
0A4C    A861          5386     MOV R0 , PWM_LIMIT 
0A4E    C3            5387     	CLR	C
0A4F    E524          5388     	MOV	A, CURRENT_PWM
0A51    98            5389     SUBB A , R0 
0A52    5002          5390     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      5391     
0A54    A824          5392     MOV R0 , CURRENT_PWM 
                      5393     
                      5394     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      5395     	; Slow spoolup
0A56    C3            5396     	CLR	C
0A57    E8            5397     MOV A , R0 
0A58    9562          5398     	SUBB	A, PWM_LIMIT_SPOOLUP
0A5A    400A          5399     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      5400     
0A5C    A862          5401     MOV R0 , PWM_LIMIT_SPOOLUP 
0A5E    E562          5402     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0A60    F4            5403     	CPL	A
0A61    6003          5404     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      5405      
0A63    856261        5406     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      5407     
                      5408     CHECK_VOLTAGE_EXIT: 
0A66    8825          5409     MOV CURRENT_PWM_LIMITED , R0 
0A68    8826          5410     MOV CURRENT_PWM_LIM_DITH , R0 
                      5411     ENDIF
                      5412     IF MODE == 1	; Tail
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               ENDIF
                      5422     IF MODE == 2	; Multi
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	ADD	A, #16			
                               	JNC	($+4)					; If not max - branch
                               
                               	MOV	A, #255
                               
                               	MOV	PWM_LIMIT, A				; Increment limit 
                               	; Set current pwm limited if closed loop mode
                               	MOV	TEMP2, #PGM_GOV_MODE		; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)			
                               	AJMP	CHECK_VOLTAGE_PWM_DONE		; No - branch
                               
                               	CLR	C
                               	MOV	TEMP1, PWM_LIMIT			; Set limit
                               	MOV	A, CURRENT_PWM
                               	SUBB	A, TEMP1
                               	JNC	CHECK_VOLTAGE_LOW_RPM		; If current pwm above limit - branch and limit	
                               
                               	MOV	TEMP1, CURRENT_PWM			; Set current pwm (no limiting)
                               
                               CHECK_VOLTAGE_LOW_RPM:
                               	; Limit pwm for low rpms
                               	CLR	C
                               	MOV	A, TEMP1					; Check against limit
                               	SUBB	A, PWM_LIMIT_BY_RPM
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT_BY_RPM		; Limit pwm
                               
                               	MOV  CURRENT_PWM_LIMITED, TEMP1
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               CHECK_VOLTAGE_PWM_DONE:
                               ENDIF
                      5457     	; Set adc mux for next conversion
0A6A    E570          5458     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0A6C    B40703        5459     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      5460     
                      5461     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0A6F    75BB10        5461+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5462     
                      5463     CHECK_VOLTAGE_RET: 
0A72    22            5464     	RET
                      5465     
                      5466     
                      5467     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5468     ;
                      5469     ; Set startup PWM routine
                      5470     ;
                      5471     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      5472     ;
                      5473     ; Used for pwm control during startup
                      5474     ;
                      5475     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5476     SET_STARTUP_PWM: 	
                      5477     	; Adjust startup power
0A73    7432          5478     MOV A , # 50 
0A75    79A6          5479     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0A77    87F0          5480     MOV B , @ R1 
0A79    A4            5481     	MUL	AB
0A7A    C5F0          5482     	XCH	A, B
0A7C    A2F7          5483     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0A7E    33            5484     	RLC	A
0A7F    F8            5485     MOV R0 , A 
0A80    C3            5486     	CLR	C
0A81    E8            5487     MOV A , R0 
0A82    9561          5488     	SUBB	A, PWM_LIMIT	
0A84    4002          5489     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      5490     
0A86    A861          5491     MOV R0 , PWM_LIMIT 
                      5492     
                      5493     STARTUP_PWM_SET_PWM: 
                      5494     	; Set pwm variables
0A88    8822          5495     MOV REQUESTED_PWM , R0 
0A8A    8824          5496     MOV CURRENT_PWM , R0 
0A8C    8825          5497     MOV CURRENT_PWM_LIMITED , R0 
0A8E    8826          5498     MOV CURRENT_PWM_LIM_DITH , R0 
0A90    8864          5499     MOV PWM_SPOOLUP_BEG , R0 
0A92    22            5500     	RET
                      5501     
                      5502     
                      5503     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5504     ;
                      5505     ; Initialize timing routine
                      5506     ;
                      5507     ; No assumptions
                      5508     ;
                      5509     ; Part of initialization before motor start
                      5510     ;
                      5511     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5512     INITIALIZE_TIMING:  
0A93    753D00        5513     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0A96    753EF0        5514     	MOV	COMM_PERIOD4X_H, #0F0H
0A99    22            5515     	RET
                      5516     
                      5517     
                      5518     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5519     ;
                      5520     ; Calculate next commutation timing routine
                      5521     ;
                      5522     ; No assumptions
                      5523     ;
                      5524     ; Called immediately after each commutation
                      5525     ; Also sets up timer 3 to wait advance timing
                      5526     ; Two entry points are used
                      5527     ;
                      5528     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5529     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
                      5530     	; Read commutation time
0A9A    75C820        5531     	MOV	TMR2CN, #20H		; Timer2 disabled
0A9D    A8CC          5532     MOV R0 , TMR2L 
0A9F    A9CD          5533     MOV R1 , TMR2H 
0AA1    75C824        5534     	MOV	TMR2CN, #24H		; Timer2 enabled
                      5535     IF MCU_48MHZ == 1
0AA4    C3            5536     	CLR	C
0AA5    E9            5537     MOV A , R1 
0AA6    13            5538     	RRC	A
0AA7    F9            5539     MOV R1 , A 
0AA8    E8            5540     MOV A , R0 
0AA9    13            5541     	RRC	A
0AAA    F8            5542     MOV R0 , A 
                      5543     ENDIF
                      5544     	; Calculate this commutation time
0AAB    AA39          5545     MOV R2 , PREV_COMM_L 
0AAD    AB3A          5546     MOV R3 , PREV_COMM_H 
0AAF    8839          5547     MOV PREV_COMM_L , R0 
0AB1    893A          5548     MOV PREV_COMM_H , R1 
0AB3    C3            5549     	CLR	C
0AB4    E8            5550     MOV A , R0 
0AB5    9A            5551     SUBB A , R2 
0AB6    F8            5552     MOV R0 , A 
0AB7    E9            5553     MOV A , R1 
0AB8    9B            5554     SUBB A , R3 
                      5555     IF MCU_48MHZ == 1
0AB9    547F          5556     	ANL	A, #7FH
                      5557     ENDIF
0ABB    F9            5558     MOV R1 , A 
0ABC    306702        5559     JNB FLAGS0 . 7 , ( $+5 ) 
0ABF    6199          5560     	AJMP	CALC_NEXT_COMM_TIMING_FAST
                      5561     
0AC1    306933        5562     JNB FLAGS1 . 1 , CALC_NEXT_COMM_STARTUP_DONE 
                      5563     
0AC4    AC3B          5564     MOV R4 , PREV_PREV_COMM_L 
0AC6    AD3C          5565     MOV R5 , PREV_PREV_COMM_H 
0AC8    8A3B          5566     MOV PREV_PREV_COMM_L , R2 
0ACA    8B3C          5567     MOV PREV_PREV_COMM_H , R3 
0ACC    C3            5568     	CLR	C
0ACD    EB            5569     MOV A , R3 
0ACE    9D            5570     SUBB A , R5 
                      5571     IF MCU_48MHZ == 1
0ACF    547F          5572     	ANL	A, #7FH
                      5573     ENDIF
0AD1    FB            5574     MOV R3 , A 
0AD2    C3            5575     	CLR	C
0AD3    E9            5576     MOV A , R1 
0AD4    9B            5577     SUBB A , R3 
0AD5    F53F          5578     	MOV	COMM_DIFF, A
0AD7    A839          5579     MOV R0 , PREV_COMM_L 
0AD9    A93A          5580     MOV R1 , PREV_COMM_H 
0ADB    C3            5581     	CLR	C
0ADC    E8            5582     MOV A , R0 
0ADD    9C            5583     SUBB A , R4 
0ADE    F8            5584     MOV R0 , A 
0ADF    E9            5585     MOV A , R1 
0AE0    9D            5586     SUBB A , R5 
                      5587     IF MCU_48MHZ == 1
0AE1    547F          5588     	ANL	A, #7FH
                      5589     ENDIF
0AE3    F9            5590     MOV R1 , A 
                      5591     
0AE4    C3            5592     	CLR	C
0AE5    E53E          5593     	MOV	A, COMM_PERIOD4X_H		; Average with previous and save
0AE7    13            5594     	RRC	A
0AE8    FB            5595     MOV R3 , A 
0AE9    E53D          5596     	MOV	A, COMM_PERIOD4X_L
0AEB    13            5597     	RRC	A
0AEC    FA            5598     MOV R2 , A 
0AED    E8            5599     MOV A , R0 
0AEE    2A            5600     ADD A , R2 
0AEF    F53D          5601     	MOV	COMM_PERIOD4X_L, A
0AF1    E9            5602     MOV A , R1 
0AF2    3B            5603     ADDC A , R3 
0AF3    F53E          5604     	MOV	COMM_PERIOD4X_H, A
0AF5    6141          5605     	AJMP	CALC_NEW_WAIT_TIMES_SETUP
                      5606     
                      5607     CALC_NEXT_COMM_STARTUP_DONE: 
                      5608     	; Calculate new commutation time 
0AF7    AA3D          5609     MOV R2 , COMM_PERIOD4X_L 
0AF9    AB3E          5610     MOV R3 , COMM_PERIOD4X_H 
0AFB    AC3D          5611     MOV R4 , COMM_PERIOD4X_L 
0AFD    AD3E          5612     MOV R5 , COMM_PERIOD4X_H 
0AFF    7E04          5613     MOV R6 , # 4 
0B01    7F02          5614     MOV R7 , # 2 
0B03    C3            5615     	CLR	C
0B04    EB            5616     MOV A , R3 
0B05    9404          5617     	SUBB	A, #04H
0B07    4002          5618     	JC	($+4)
                      5619     
0B09    1E            5620     DEC R6 
0B0A    1F            5621     DEC R7 
                      5622     
0B0B    C3            5623     	CLR	C
0B0C    EB            5624     MOV A , R3 
0B0D    9408          5625     	SUBB	A, #08H
0B0F    4002          5626     	JC	($+4)
                      5627     
0B11    1E            5628     DEC R6 
0B12    1F            5629     DEC R7 
                      5630     
                      5631     CALC_NEXT_COMM_AVG_PERIOD_DIV: 
0B13    C3            5632     	CLR	C
0B14    ED            5633     MOV A , R5 
0B15    13            5634     	RRC	A					; Divide by 2
0B16    FD            5635     MOV R5 , A 
0B17    EC            5636     MOV A , R4 
0B18    13            5637     	RRC	A
0B19    FC            5638     MOV R4 , A 
0B1A    DEF7          5639     DJNZ R6 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      5640     
0B1C    C3            5641     	CLR	C
0B1D    EA            5642     MOV A , R2 
0B1E    9C            5643     SUBB A , R4 
0B1F    FA            5644     MOV R2 , A 
0B20    EB            5645     MOV A , R3 
0B21    9D            5646     SUBB A , R5 
0B22    FB            5647     MOV R3 , A 
0B23    EF            5648     MOV A , R7 
0B24    6009          5649     	JZ	CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE
                      5650     
                      5651     CALC_NEXT_COMM_NEW_PERIOD_DIV: 
0B26    C3            5652     	CLR	C
0B27    E9            5653     MOV A , R1 
0B28    13            5654     	RRC	A					; Divide by 2
0B29    F9            5655     MOV R1 , A 
0B2A    E8            5656     MOV A , R0 
0B2B    13            5657     	RRC	A
0B2C    F8            5658     MOV R0 , A 
0B2D    DFF7          5659     DJNZ R7 , CALC_NEXT_COMM_NEW_PERIOD_DIV 
                      5660     
                      5661     CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE: 
0B2F    EA            5662     MOV A , R2 
0B30    28            5663     ADD A , R0 
0B31    FA            5664     MOV R2 , A 
0B32    EB            5665     MOV A , R3 
0B33    39            5666     ADDC A , R1 
0B34    FB            5667     MOV R3 , A 
0B35    8A3D          5668     MOV COMM_PERIOD4X_L , R2 
0B37    8B3E          5669     MOV COMM_PERIOD4X_H , R3 
0B39    5006          5670     	JNC	CALC_NEW_WAIT_TIMES_SETUP; If period larger than 0xffff - go to slow case
                      5671     
0B3B    7BFF          5672     MOV R3 , # 0FFH 
0B3D    8B3D          5673     MOV COMM_PERIOD4X_L , R3 
0B3F    8B3E          5674     MOV COMM_PERIOD4X_H , R3 
                      5675     
                      5676     CALC_NEW_WAIT_TIMES_SETUP: 	
                      5677     	; Set high rpm bit (if above 156k erpm)
0B41    C3            5678     	CLR	C
0B42    EB            5679     MOV A , R3 
0B43    9402          5680     	SUBB	A, #2
0B45    5002          5681     	JNC	($+4)
                      5682     
0B47    D267          5683     SETB FLAGS0 . 7 
                      5684     	
                      5685     	; Load programmed commutation timing
0B49    306904        5686     JNB FLAGS1 . 1 , CALC_NEW_WAIT_PER_STARTUP_DONE 
                      5687     
0B4C    7F03          5688     MOV R7 , # 3 
0B4E    616C          5689     	AJMP	CALC_NEW_WAIT_PER_DEMAG_DONE
                      5690     
                      5691     CALC_NEW_WAIT_PER_STARTUP_DONE: 
0B50    7892          5692     MOV R0 , # PGM_COMM_TIMING 
0B52    E6            5693     MOV A , @ R0 
0B53    FF            5694     MOV R7 , A 
0B54    C3            5695     	CLR	C
0B55    E536          5696     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0B57    9482          5697     	SUBB	A, #130
0B59    4011          5698     	JC	CALC_NEW_WAIT_PER_DEMAG_DONE
                      5699     
0B5B    0F            5700     INC R7 
                      5701     
0B5C    C3            5702     	CLR	C
0B5D    E536          5703     	MOV	A, DEMAG_DETECTED_METRIC
0B5F    94A0          5704     	SUBB	A, #160
0B61    4001          5705     	JC	($+3)
                      5706     
0B63    0F            5707     INC R7 
                      5708     
0B64    C3            5709     	CLR	C
0B65    EF            5710     MOV A , R7 
0B66    9406          5711     	SUBB	A, #6
0B68    4002          5712     	JC	($+4)
                      5713     
0B6A    7F05          5714     MOV R7 , # 5 
                      5715     
                      5716     CALC_NEW_WAIT_PER_DEMAG_DONE: 
                      5717     	; Set timing reduction
                      5718     IF MCU_48MHZ == 0
                               	MOV	TEMP7, #4
                               ELSE
0B6C    7E01          5721     MOV R6 , # 1 
                      5722     ENDIF
                      5723     	; Load current commutation timing
0B6E    E53E          5724     	MOV	A, COMM_PERIOD4X_H		; Divide 4 times
0B70    C4            5725     	SWAP	A
0B71    540F          5726     	ANL	A, #00FH
0B73    F9            5727     MOV R1 , A 
0B74    E53E          5728     	MOV	A, COMM_PERIOD4X_H
0B76    C4            5729     	SWAP	A
0B77    54F0          5730     	ANL	A, #0F0H
0B79    F8            5731     MOV R0 , A 
0B7A    E53D          5732     	MOV	A, COMM_PERIOD4X_L
0B7C    C4            5733     	SWAP	A
0B7D    540F          5734     	ANL	A, #00FH
0B7F    28            5735     ADD A , R0 
0B80    F8            5736     MOV R0 , A 
                      5737     
0B81    C3            5738     	CLR	C
0B82    E8            5739     MOV A , R0 
0B83    9E            5740     SUBB A , R6 
0B84    FA            5741     MOV R2 , A 
0B85    E9            5742     MOV A , R1 
0B86    9400          5743     	SUBB	A, #0
0B88    FB            5744     MOV R3 , A 
0B89    4009          5745     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      5746     
0B8B    C3            5747     	CLR	C
0B8C    EA            5748     MOV A , R2 
0B8D    9402          5749     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0B8F    EB            5750     MOV A , R3 
0B90    9400          5751     	SUBB	A, #0
0B92    5004          5752     	JNC	CALC_NEW_WAIT_TIMES_EXIT	; Check that result is still above minumum
                      5753     
                      5754     LOAD_MIN_TIME: 
0B94    7A02          5755     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0B96    E4            5756     	CLR	A
0B97    FB            5757     MOV R3 , A 
                      5758     
                      5759     CALC_NEW_WAIT_TIMES_EXIT: 	
0B98    22            5760     	RET
                      5761     
                      5762     
                      5763     ; Fast calculation (Comm_Period4x_H less than 2)
                      5764     CALC_NEXT_COMM_TIMING_FAST: 			
                      5765     	; Calculate new commutation time
0B99    AA3D          5766     MOV R2 , COMM_PERIOD4X_L 
0B9B    AB3E          5767     MOV R3 , COMM_PERIOD4X_H 
0B9D    EB            5768     MOV A , R3 
0B9E    C4            5769     	SWAP	A
0B9F    FE            5770     MOV R6 , A 
0BA0    EA            5771     MOV A , R2 
0BA1    C4            5772     	SWAP A
0BA2    540F          5773     	ANL	A, #0FH
0BA4    4E            5774     ORL A , R6 
0BA5    FC            5775     MOV R4 , A 
0BA6    C3            5776     	CLR	C
0BA7    EA            5777     MOV A , R2 
0BA8    9C            5778     SUBB A , R4 
0BA9    FA            5779     MOV R2 , A 
0BAA    EB            5780     MOV A , R3 
0BAB    9400          5781     	SUBB	A, #0
0BAD    FB            5782     MOV R3 , A 
0BAE    C3            5783     	CLR	C
0BAF    E8            5784     MOV A , R0 
0BB0    13            5785     	RRC	A					; Divide by 2 2 times
0BB1    C3            5786     	CLR	C
0BB2    13            5787     	RRC	A
0BB3    F8            5788     MOV R0 , A 
0BB4    EA            5789     MOV A , R2 
0BB5    28            5790     ADD A , R0 
0BB6    FA            5791     MOV R2 , A 
0BB7    EB            5792     MOV A , R3 
0BB8    3400          5793     	ADDC	A, #0
0BBA    FB            5794     MOV R3 , A 
0BBB    8A3D          5795     MOV COMM_PERIOD4X_L , R2 
0BBD    8B3E          5796     MOV COMM_PERIOD4X_H , R3 
0BBF    C3            5797     	CLR	C
0BC0    EB            5798     MOV A , R3 
0BC1    9402          5799     	SUBB	A, #2
0BC3    4002          5800     	JC	($+4)
                      5801     
0BC5    C267          5802     CLR FLAGS0 . 7 
                      5803     	
                      5804     IF MCU_48MHZ == 0
                               	MOV	TEMP1, #4				; Set timing reduction
                               ELSE
0BC7    7801          5807     MOV R0 , # 1 
                      5808     ENDIF
0BC9    EB            5809     MOV A , R3 
0BCA    C4            5810     	SWAP	A
0BCB    FE            5811     MOV R6 , A 
0BCC    7B00          5812     MOV R3 , # 0 
0BCE    EA            5813     MOV A , R2 
0BCF    C4            5814     	SWAP A
0BD0    540F          5815     	ANL	A, #0FH
0BD2    4E            5816     ORL A , R6 
0BD3    FA            5817     MOV R2 , A 
0BD4    C3            5818     	CLR	C
0BD5    EA            5819     MOV A , R2 
0BD6    98            5820     SUBB A , R0 
0BD7    FA            5821     MOV R2 , A 
0BD8    4005          5822     	JC	LOAD_MIN_TIME_FAST		; Check that result is still positive
                      5823     
0BDA    C3            5824     	CLR	C
0BDB    9402          5825     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0BDD    5002          5826     	JNC	CALC_NEW_WAIT_TIMES_FAST_DONE	; Check that result is still above minumum
                      5827     
                      5828     LOAD_MIN_TIME_FAST: 
0BDF    7A02          5829     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
                      5830     
                      5831     CALC_NEW_WAIT_TIMES_FAST_DONE: 	
0BE1    7892          5832     MOV R0 , # PGM_COMM_TIMING 
0BE3    E6            5833     MOV A , @ R0 
0BE4    FF            5834     MOV R7 , A 
0BE5    22            5835     	RET
                      5836     
                      5837     
                      5838     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5839     ;
                      5840     ; Wait advance timing routine
                      5841     ;
                      5842     ; No assumptions
                      5843     ; NOTE: Be VERY careful if using temp registers. They are passed over this routine
                      5844     ;
                      5845     ; Waits for the advance timing to elapse and sets up the next zero cross wait
                      5846     ;
                      5847     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5848     WAIT_ADVANCE_TIMING: 	
0BE6    306002        5849     JNB FLAGS0 . 0 , ( $+5 ) 
0BE9    61E6          5850     	AJMP	WAIT_ADVANCE_TIMING
                      5851     
                      5852     	; Setup next wait time
0BEB    854F53        5853     	MOV	NEXT_WT_START_L, WT_ZC_TOUT_START_L
0BEE    855054        5854     	MOV	NEXT_WT_START_H, WT_ZC_TOUT_START_H
0BF1    D260          5855     SETB FLAGS0 . 0 
0BF3    43E680        5856     	ORL	EIE1, #80H	; Enable timer3 interrupts
0BF6    22            5857     	RET
                      5858     
                      5859     
                      5860     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5861     ;
                      5862     ; Calculate new wait times routine
                      5863     ;
                      5864     ; No assumptions
                      5865     ;
                      5866     ; Calculates new wait times
                      5867     ;
                      5868     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5869     CALC_NEW_WAIT_TIMES: 	
0BF7    C3            5870     	CLR	C
0BF8    E4            5871     	CLR	A
0BF9    9A            5872     SUBB A , R2 
0BFA    F8            5873     MOV R0 , A 
0BFB    E4            5874     	CLR	A
0BFC    9B            5875     SUBB A , R3 
0BFD    F9            5876     MOV R1 , A 
                      5877     IF MCU_48MHZ == 1
0BFE    C3            5878     	CLR	C
0BFF    E8            5879     MOV A , R0 
0C00    33            5880     	RLC	A
0C01    F8            5881     MOV R0 , A 
0C02    E9            5882     MOV A , R1 
0C03    33            5883     	RLC	A
0C04    F9            5884     MOV R1 , A 
                      5885     ENDIF
0C05    306702        5886     JNB FLAGS0 . 7 , ( $+5 ) 
0C08    8186          5887     	AJMP	CALC_NEW_WAIT_TIMES_FAST
                      5888     
0C0A    E8            5889     MOV A , R0 
0C0B    FA            5890     MOV R2 , A 
0C0C    E9            5891     MOV A , R1 
0C0D    FB            5892     MOV R3 , A 
0C0E    D3            5893     	SETB	C					; Negative numbers - set carry
0C0F    E9            5894     MOV A , R1 
0C10    13            5895     	RRC	A					; Divide by 2
0C11    FD            5896     MOV R5 , A 
0C12    E8            5897     MOV A , R0 
0C13    13            5898     	RRC	A
0C14    FC            5899     MOV R4 , A 
0C15    884F          5900     MOV WT_ZC_TOUT_START_L , R0 
0C17    8950          5901     MOV WT_ZC_TOUT_START_H , R1 
0C19    C3            5902     	CLR	C
0C1A    EF            5903     MOV A , R7 
0C1B    9403          5904     	SUBB	A, #3				; Is timing normal?
0C1D    6037          5905     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      5906     
0C1F    EF            5907     MOV A , R7 
0C20    20E00D        5908     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      5909     
0C23    E8            5910     MOV A , R0 
0C24    2C            5911     ADD A , R4 
0C25    F8            5912     MOV R0 , A 
0C26    E9            5913     MOV A , R1 
0C27    3D            5914     ADDC A , R5 
0C28    F9            5915     MOV R1 , A 
0C29    EC            5916     MOV A , R4 
0C2A    FA            5917     MOV R2 , A 
0C2B    ED            5918     MOV A , R5 
0C2C    FB            5919     MOV R3 , A 
0C2D    020C43        5920     	JMP	STORE_TIMES_UP_OR_DOWN
                      5921     
                      5922     ADJUST_TIMING_TWO_STEPS: 
0C30    E8            5923     MOV A , R0 
0C31    28            5924     ADD A , R0 
0C32    F8            5925     MOV R0 , A 
0C33    E9            5926     MOV A , R1 
0C34    39            5927     ADDC A , R1 
0C35    F9            5928     MOV R1 , A 
0C36    C3            5929     	CLR	C
0C37    E8            5930     MOV A , R0 
0C38    2402          5931     	ADD	A, #(COMM_TIME_MIN SHL 1)
0C3A    F8            5932     MOV R0 , A 
0C3B    E9            5933     MOV A , R1 
0C3C    3400          5934     	ADDC	A, #0
0C3E    F9            5935     MOV R1 , A 
0C3F    7AFE          5936     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
0C41    7BFF          5937     MOV R3 , # 0FFH 
                      5938     
                      5939     STORE_TIMES_UP_OR_DOWN: 
0C43    C3            5940     	CLR	C
0C44    EF            5941     MOV A , R7 
0C45    9403          5942     	SUBB	A, #3					; Is timing higher than normal?
0C47    400D          5943     	JC	STORE_TIMES_DECREASE		; No - branch
                      5944     
                      5945     STORE_TIMES_INCREASE: 
0C49    8A51          5946     MOV WT_COMM_START_L , R2 
0C4B    8B52          5947     MOV WT_COMM_START_H , R3 
0C4D    884B          5948     MOV WT_ADV_START_L , R0 
0C4F    894C          5949     MOV WT_ADV_START_H , R1 
0C51    8C4D          5950     MOV WT_ZC_SCAN_START_L , R4 
0C53    8D4E          5951     MOV WT_ZC_SCAN_START_H , R5 
0C55    22            5952     	RET
                      5953     
                      5954     STORE_TIMES_DECREASE: 
0C56    8851          5955     MOV WT_COMM_START_L , R0 
0C58    8952          5956     MOV WT_COMM_START_H , R1 
0C5A    8A4B          5957     MOV WT_ADV_START_L , R2 
0C5C    8B4C          5958     MOV WT_ADV_START_H , R3 
0C5E    8C4D          5959     MOV WT_ZC_SCAN_START_L , R4 
0C60    8D4E          5960     MOV WT_ZC_SCAN_START_H , R5 
0C62    306920        5961     JNB FLAGS1 . 1 , STORE_TIMES_EXIT 
                      5962     
0C65    C3            5963     	CLR	C
0C66    E533          5964     	MOV	A, STARTUP_CNT			
0C68    9403          5965     	SUBB	A, #3
0C6A    4019          5966     	JC	STORE_TIMES_EXIT
                      5967     
0C6C    E53F          5968     	MOV	A, COMM_DIFF			; Compensate commutation wait for comparator offset
0C6E    A2E7          5969     	MOV	C, ACC.7
0C70    13            5970     	RRC	A
0C71    F8            5971     MOV R0 , A 
0C72    E552          5972     	MOV	A, WT_COMM_START_H
0C74    F4            5973     	CPL	A
0C75    2401          5974     	ADD	A, #1
0C77    38            5975     ADDC A , R0 
0C78    400B          5976     	JC	STORE_TIMES_EXIT
0C7A    20E708        5977     	JB	ACC.7, STORE_TIMES_EXIT
                      5978     
0C7D    7551FF        5979     	MOV	WT_COMM_START_L, #0FFH
0C80    F4            5980     	CPL	A
0C81    2401          5981     	ADD	A, #1
0C83    F552          5982     	MOV	WT_COMM_START_H, A 
                      5983     
                      5984     STORE_TIMES_EXIT: 
0C85    22            5985     	RET
                      5986     
                      5987     
                      5988     CALC_NEW_WAIT_TIMES_FAST: 	
0C86    E8            5989     MOV A , R0 
0C87    FA            5990     MOV R2 , A 
0C88    D3            5991     	SETB	C					; Negative numbers - set carry
0C89    E8            5992     MOV A , R0 
0C8A    13            5993     	RRC	A
0C8B    FC            5994     MOV R4 , A 
0C8C    884F          5995     MOV WT_ZC_TOUT_START_L , R0 
0C8E    C3            5996     	CLR	C
0C8F    EF            5997     MOV A , R7 
0C90    9403          5998     	SUBB	A, #3				; Is timing normal?
0C92    601F          5999     	JZ	STORE_TIMES_DECREASE_FAST; Yes - branch
                      6000     
0C94    EF            6001     MOV A , R7 
0C95    20E007        6002     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS_FAST	; If an odd number - branch
                      6003     
0C98    E8            6004     MOV A , R0 
0C99    2C            6005     ADD A , R4 
0C9A    F8            6006     MOV R0 , A 
0C9B    EC            6007     MOV A , R4 
0C9C    FA            6008     MOV R2 , A 
0C9D    81A6          6009     	AJMP	STORE_TIMES_UP_OR_DOWN_FAST
                      6010     
                      6011     ADJUST_TIMING_TWO_STEPS_FAST: 
0C9F    E8            6012     MOV A , R0 
0CA0    28            6013     ADD A , R0 
0CA1    2402          6014     	ADD	A, #(COMM_TIME_MIN SHL 1)
0CA3    F8            6015     MOV R0 , A 
0CA4    7AFE          6016     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
                      6017     
                      6018     STORE_TIMES_UP_OR_DOWN_FAST: 
0CA6    C3            6019     	CLR	C
0CA7    EF            6020     MOV A , R7 
0CA8    9403          6021     	SUBB	A, #3				; Is timing higher than normal?
0CAA    4007          6022     	JC	STORE_TIMES_DECREASE_FAST; No - branch
                      6023     
                      6024     STORE_TIMES_INCREASE_FAST: 
0CAC    8A51          6025     MOV WT_COMM_START_L , R2 
0CAE    884B          6026     MOV WT_ADV_START_L , R0 
0CB0    8C4D          6027     MOV WT_ZC_SCAN_START_L , R4 
0CB2    22            6028     	RET
                      6029     
                      6030     STORE_TIMES_DECREASE_FAST: 
0CB3    8851          6031     MOV WT_COMM_START_L , R0 
0CB5    8A4B          6032     MOV WT_ADV_START_L , R2 
0CB7    8C4D          6033     MOV WT_ZC_SCAN_START_L , R4 
0CB9    22            6034     	RET
                      6035     
                      6036     
                      6037     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6038     ;
                      6039     ; Wait before zero cross scan routine
                      6040     ;
                      6041     ; No assumptions
                      6042     ;
                      6043     ; Waits for the zero cross scan wait time to elapse
                      6044     ; Also sets up timer 3 for the zero cross scan timeout time
                      6045     ;
                      6046     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6047     WAIT_BEFORE_ZC_SCAN: 	
                      6048     	; Calculate random number
0CBA    E568          6049     	MOV	A, RANDOM
0CBC    C3            6050     	CLR	C
0CBD    33            6051     	RLC	A
0CBE    5002          6052     	JNC	WAIT_BEFORE_ZC_SCAN_RAND
                      6053     
0CC0    646B          6054     	XRL	A, #06BH		; Sequence length of 35, when initialized to 1
                      6055     
                      6056     WAIT_BEFORE_ZC_SCAN_RAND:           
0CC2    F568          6057     	MOV	RANDOM, A
                      6058     
                      6059     WAIT_BEFORE_ZC_SCAN_WAIT:           
0CC4    306002        6060     JNB FLAGS0 . 0 , ( $+5 ) 
0CC7    81C4          6061     	AJMP	WAIT_BEFORE_ZC_SCAN_WAIT
                      6062     
0CC9    D260          6063     SETB FLAGS0 . 0 
0CCB    43E680        6064     	ORL	EIE1, #80H			; Enable timer3 interrupts
0CCE    E52D          6065     	MOV	A, FLAGS1
0CD0    5406          6066     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0CD2    6029          6067     	JZ	WAIT_BEFORE_ZC_SCAN_EXIT		
                      6068     
0CD4    A83D          6069     MOV R0 , COMM_PERIOD4X_L 
0CD6    A93E          6070     MOV R1 , COMM_PERIOD4X_H 
0CD8    C3            6071     	CLR	C
0CD9    E9            6072     MOV A , R1 
0CDA    13            6073     	RRC	A
0CDB    F9            6074     MOV R1 , A 
0CDC    E8            6075     MOV A , R0 
0CDD    13            6076     	RRC	A
0CDE    F8            6077     MOV R0 , A 
                      6078     IF MCU_48MHZ == 1
0CDF    C3            6079     	CLR	C
0CE0    E8            6080     MOV A , R0 
0CE1    33            6081     	RLC	A
0CE2    F8            6082     MOV R0 , A 
0CE3    E9            6083     MOV A , R1 
0CE4    33            6084     	RLC	A
0CE5    F9            6085     MOV R1 , A 
                      6086     ENDIF
0CE6    53E67F        6087     	ANL	EIE1, #7FH			; Disable timer3 interrupts
0CE9    759100        6088     	MOV	TMR3CN, #00H			; Timer3 disabled and interrupt flag cleared
0CEC    C3            6089     	CLR	C
0CED    E4            6090     	CLR	A
0CEE    98            6091     SUBB A , R0 
0CEF    F594          6092     	MOV	TMR3L, A
0CF1    E4            6093     	CLR	A
0CF2    99            6094     SUBB A , R1 
0CF3    F595          6095     	MOV	TMR3H, A
0CF5    759104        6096     	MOV	TMR3CN, #04H			; Timer3 enabled and interrupt flag cleared
                      6097     
0CF8    D260          6098     SETB FLAGS0 . 0 
0CFA    43E680        6099     	ORL	EIE1, #80H			; Enable timer3 interrupts
                      6100     
                      6101     WAIT_BEFORE_ZC_SCAN_EXIT:           
0CFD    22            6102     	RET
                      6103     
                      6104     
                      6105     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6106     ;
                      6107     ; Wait for comparator to go low/high routines
                      6108     ;
                      6109     ; No assumptions
                      6110     ;
                      6111     ; Waits for the zero cross scan wait time to elapse
                      6112     ; Then scans for comparator going low/high
                      6113     ;
                      6114     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6115     WAIT_FOR_COMP_OUT_LOW: 
0CFE    D265          6116     SETB FLAGS0 . 5 
0D00    754100        6117     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0D03    752000        6118     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0D06    306B03        6119     JNB FLAGS1 . 3 , ( $+6 ) 
0D09    752040        6120     	MOV	BIT_ACCESS, #40H		
0D0C    020D1D        6121     	JMP	WAIT_FOR_COMP_OUT_START
                      6122     
                      6123     WAIT_FOR_COMP_OUT_HIGH: 
0D0F    D265          6124     SETB FLAGS0 . 5 
0D11    754100        6125     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0D14    752040        6126     	MOV	BIT_ACCESS, #40H			; Desired comparator output
0D17    306B03        6127     JNB FLAGS1 . 3 , ( $+6 ) 
0D1A    752000        6128     	MOV	BIT_ACCESS, #00H		
                      6129     
                      6130     WAIT_FOR_COMP_OUT_START: 
0D1D    D2AF          6131     	SETB	EA						; Enable interrupts
                      6132     	; Set number of comparator readings
0D1F    7801          6133     MOV R0 , # 1 
0D21    206722        6134     JB FLAGS0 . 7 , COMP_WAIT_ON_COMP_ABLE 
                      6135     
0D24    E52D          6136     	MOV	A, FLAGS1					; Clear demag detected flag if start phases
0D26    5406          6137     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0D28    6002          6138     	JZ	($+4)
                      6139     		
0D2A    C265          6140     CLR FLAGS0 . 5 
                      6141     
0D2C    C3            6142     	CLR	C						; Set number of readings higher for lower speeds
0D2D    E53E          6143     	MOV 	A, COMM_PERIOD4X_H			
0D2F    9405          6144     	SUBB	A, #05H
0D31    4013          6145     	JC	COMP_WAIT_ON_COMP_ABLE
                      6146     
0D33    7802          6147     MOV R0 , # 2 
                      6148     
0D35    9405          6149     	SUBB	A, #05H
0D37    4008          6150     	JC	COMP_WAIT_NO_OF_READINGS
                      6151     
0D39    7803          6152     MOV R0 , # 3 
                      6153     
0D3B    9405          6154     	SUBB	A, #05H					; Set number of consecutive readings higher for lower speeds
0D3D    4002          6155     	JC	COMP_WAIT_NO_OF_READINGS
                      6156     
0D3F    7806          6157     MOV R0 , # 6 
                      6158     
                      6159     COMP_WAIT_NO_OF_READINGS: 
0D41    306902        6160     JNB FLAGS1 . 1 , ( $+5 ) 
0D44    780A          6161     MOV R0 , # 10 
                      6162     
                      6163     COMP_WAIT_ON_COMP_ABLE: 
0D46    206009        6164     JB FLAGS0 . 0 , COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT 
                      6165     
0D49    E541          6166     	MOV	A, COMPARATOR_READ_CNT			; Check that comparator has been read
0D4B    6005          6167     	JZ	COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT	; If not read - branch
                      6168     
0D4D    D2AF          6169     	SETB	EA							; Enable interrupts
0D4F    D26C          6170     SETB FLAGS1 . 4 
0D51    22            6171     	RET								; Yes - return
                      6172     
                      6173     
                      6174     COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT: 
0D52    D2AF          6175     	SETB	EA							; Enable interrupts
0D54    00            6176     	NOP								; Allocate only just enough time to capture interrupt
0D55    00            6177     	NOP
0D56    C2AF          6178     	CLR	EA							; Disable interrupts
0D58    20672A        6179     JB FLAGS0 . 7 , COMP_WAIT_READ_COMP 
                      6180     
0D5B    E53E          6181     	MOV	A, COMM_PERIOD4X_H				; Reduce required distance to pwm transition for higher speeds
0D5D    C3            6182     	CLR	C
0D5E    FB            6183     MOV R3 , A 
0D5F    940F          6184     	SUBB	A, #0FH
0D61    4002          6185     	JC	($+4)
                      6186     
0D63    7B0F          6187     MOV R3 , # 0FH 
                      6188     
0D65    EB            6189     MOV A , R3 
0D66    2405          6190     	ADD	A, #5
0D68    307301        6191     JNB FLAGS2 . 3 , ( $+4 ) 
                      6192     
0D6B    23            6193     	RL	A
                      6194     
0D6C    306A02        6195     JNB FLAGS1 . 2 , ( $+5 ) 
0D6F    7428          6196     	MOV	A, #40
                      6197     
0D71    206201        6198     JB FLAGS0 . 2 , ( $+4 ) 
                      6199     
0D74    23            6200     	RL	A
                      6201     
0D75    F9            6202     MOV R1 , A 
0D76    306902        6203     JNB FLAGS1 . 1 , ( $+5 ) 
0D79    7982          6204     MOV R1 , # 130 
                      6205     
                      6206     IF MCU_48MHZ == 0
                               	MOV	A, TL1
                               ELSE
0D7B    E58D          6209     	MOV	A, TH1
0D7D    13            6210     	RRC	A
0D7E    E58B          6211     	MOV	A, TL1
0D80    13            6212     	RRC	A
                      6213     ENDIF
0D81    C3            6214     	CLR	C
0D82    99            6215     SUBB A , R1 
0D83    40C1          6216     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle
                      6217     
                      6218     COMP_WAIT_READ_COMP: 
0D85    0541          6219     	INC	COMPARATOR_READ_CNT			; Increment comparator read count
                      6220     	READ_COMP_OUT					; Read comparator output
0D87    E59B          6220+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0D89    F4            6220+1   CPL A 
0D8A    5440          6221     	ANL	A, #40H
0D8C    B52002        6222     	CJNE	A, BIT_ACCESS, COMP_READ_WRONG
0D8F    A1DE          6223     	AJMP	COMP_READ_OK
                      6224     	
                      6225     COMP_READ_WRONG: 
0D91    306914        6226     JNB FLAGS1 . 1 , COMP_READ_WRONG_NOT_STARTUP 
                      6227     
0D94    08            6228     INC R0 
0D95    C3            6229     	CLR	C
0D96    E8            6230     MOV A , R0 
0D97    940A          6231     	SUBB	A, #10					; If above initial requirement - go back and restart
0D99    4002          6232     	JC	($+4)
0D9B    A11D          6233     	AJMP	WAIT_FOR_COMP_OUT_START
                      6234     
0D9D    C3            6235     	CLR	C
0D9E    E533          6236     	MOV	A, STARTUP_CNT				; For the first commutations - go back and restart
0DA0    9406          6237     	SUBB	A, #6
0DA2    5002          6238     	JNC	($+4)
0DA4    A11D          6239     	AJMP	WAIT_FOR_COMP_OUT_START
                      6240     
0DA6    A146          6241     	AJMP	COMP_WAIT_ON_COMP_ABLE		; If below initial requirement - continue to look for good ones
                      6242     
                      6243     COMP_READ_WRONG_NOT_STARTUP: 
0DA8    206502        6244     JB FLAGS0 . 5 , ( $+5 ) 
0DAB    A11D          6245     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct, and timeout already extended - go back and restart
                      6246     
0DAD    C265          6247     CLR FLAGS0 . 5 
0DAF    53E67F        6248     	ANL	EIE1, #7FH				; Disable timer3 interrupts
0DB2    759100        6249     	MOV	TMR3CN, #00H				; Timer3 disabled and interrupt flag cleared
0DB5    306710        6250     JNB FLAGS0 . 7 , COMP_READ_WRONG_LOW_RPM 
                      6251     
0DB8    759400        6252     	MOV	TMR3L, #00H				; Set timeout to 256us
                      6253     IF MCU_48MHZ == 1
0DBB    7595FC        6254     	MOV	TMR3H, #0FCH
                      6255     ELSE
                               	MOV	TMR3H, #0FEH
                               ENDIF
                      6258     COMP_READ_WRONG_TIMEOUT_SET: 
0DBE    759104        6259     	MOV	TMR3CN, #04H				; Timer3 enabled and interrupt flag cleared
0DC1    D260          6260     SETB FLAGS0 . 0 
0DC3    43E680        6261     	ORL	EIE1, #80H				; Enable timer3 interrupts
0DC6    A11D          6262     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      6263     
                      6264     COMP_READ_WRONG_LOW_RPM: 
0DC8    AE3D          6265     MOV R6 , COMM_PERIOD4X_L 
0DCA    AF3E          6266     MOV R7 , COMM_PERIOD4X_H 
                      6267     IF MCU_48MHZ == 1
0DCC    C3            6268     	CLR	C
0DCD    EE            6269     MOV A , R6 
0DCE    33            6270     	RLC	A
0DCF    FE            6271     MOV R6 , A 
0DD0    EF            6272     MOV A , R7 
0DD1    33            6273     	RLC	A
0DD2    FF            6274     MOV R7 , A 
                      6275     ENDIF
0DD3    C3            6276     	CLR	C
0DD4    E4            6277     	CLR	A
0DD5    9E            6278     SUBB A , R6 
0DD6    F594          6279     	MOV	TMR3L, A
0DD8    E4            6280     	CLR	A
0DD9    9F            6281     SUBB A , R7 
0DDA    F595          6282     	MOV	TMR3H, A
0DDC    A1BE          6283     	AJMP	COMP_READ_WRONG_TIMEOUT_SET
                      6284     
                      6285     COMP_READ_OK: 
0DDE    C3            6286     	CLR	C
0DDF    E533          6287     	MOV	A, STARTUP_CNT				; Force a timeout for the first commutations			
0DE1    9402          6288     	SUBB	A, #2
0DE3    5002          6289     	JNC	($+4)
0DE5    A11D          6290     	AJMP	WAIT_FOR_COMP_OUT_START
                      6291     
0DE7    306502        6292     JNB FLAGS0 . 5 , ( $+5 ) 
0DEA    A11D          6293     	AJMP	WAIT_FOR_COMP_OUT_START
                      6294     
0DEC    D802          6295     DJNZ R0 , COMP_READ_OK_JMP 
0DEE    A1F2          6296     	AJMP	($+4)
                      6297     
                      6298     COMP_READ_OK_JMP: 
0DF0    A146          6299     	AJMP	COMP_WAIT_ON_COMP_ABLE	
                      6300     
0DF2    C26C          6301     CLR FLAGS1 . 4 
0DF4    22            6302     	RET							
                      6303     
                      6304     
                      6305     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6306     ;
                      6307     ; Evaluate comparator integrity
                      6308     ;
                      6309     ; No assumptions
                      6310     ;
                      6311     ; Checks comparator signal behaviour versus expected behaviour
                      6312     ;
                      6313     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6314     EVALUATE_COMPARATOR_INTEGRITY: 
0DF5    E52D          6315     	MOV	A, FLAGS1
0DF7    5406          6316     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0DF9    6008          6317     	JZ	EVAL_COMP_CHECK_TIMEOUT
                      6318     
0DFB    206A02        6319     JB FLAGS1 . 2 , ( $+5 ) 
0DFE    0533          6320     	INC	STARTUP_CNT					; Increment counter
0E00    020E13        6321     	JMP	EVAL_COMP_EXIT
                      6322     
                      6323     EVAL_COMP_CHECK_TIMEOUT: 
0E03    306C0D        6324     JNB FLAGS1 . 4 , EVAL_COMP_EXIT 
0E06    206B0A        6325     JB FLAGS1 . 3 , EVAL_COMP_EXIT 
0E09    206507        6326     JB FLAGS0 . 5 , EVAL_COMP_EXIT 
0E0C    1581          6327     	DEC	SP								; Routine exit without "ret" command
0E0E    1581          6328     	DEC	SP
0E10    0216F3        6329     	LJMP	RUN_TO_WAIT_FOR_POWER_ON_FAIL			; Yes - exit run mode
                      6330     
                      6331     EVAL_COMP_EXIT: 
0E13    22            6332     	RET
                      6333     
                      6334     
                      6335     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6336     ;
                      6337     ; Setup commutation timing routine
                      6338     ;
                      6339     ; No assumptions
                      6340     ;
                      6341     ; Sets up and starts wait from commutation to zero cross
                      6342     ;
                      6343     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6344     SETUP_COMM_WAIT:  
0E14    53E67F        6345     	ANL	EIE1, #7FH		; Disable timer3 interrupts
0E17    759100        6346     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
0E1A    855194        6347     	MOV	TMR3L, WT_COMM_START_L
0E1D    855295        6348     	MOV	TMR3H, WT_COMM_START_H
0E20    759104        6349     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
                      6350     	; Setup next wait time
0E23    854B53        6351     	MOV	NEXT_WT_START_L, WT_ADV_START_L
0E26    854C54        6352     	MOV	NEXT_WT_START_H, WT_ADV_START_H
0E29    D260          6353     SETB FLAGS0 . 0 
0E2B    43E680        6354     	ORL	EIE1, #80H		; Enable timer3 interrupts
0E2E    D2AF          6355     	SETB	EA				; Enable interrupts again
0E30    22            6356     	RET
                      6357     
                      6358     
                      6359     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6360     ;
                      6361     ; Wait for commutation routine
                      6362     ;
                      6363     ; No assumptions
                      6364     ;
                      6365     ; Waits from zero cross to commutation 
                      6366     ;
                      6367     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6368     WAIT_FOR_COMM:  
                      6369     	; Update demag metric
0E31    7800          6370     MOV R0 , # 0 
0E33    306405        6371     JNB FLAGS0 . 4 , ( $+8 ) 
0E36    306502        6372     JNB FLAGS0 . 5 , ( $+5 ) 
                      6373     
0E39    7801          6374     MOV R0 , # 1 
                      6375     
0E3B    E536          6376     	MOV	A, DEMAG_DETECTED_METRIC	; Sliding average of 8, 256 when demag and 0 when not. Limited to minimum 120
0E3D    75F007        6377     	MOV	B, #7
0E40    A4            6378     	MUL	AB					; Multiply by 7
0E41    F9            6379     MOV R1 , A 
0E42    E5F0          6380     	MOV	A, B					; Add new value for current demag status
0E44    28            6381     ADD A , R0 
0E45    F5F0          6382     	MOV	B, A
0E47    E9            6383     MOV A , R1 
0E48    A2F0          6384     	MOV	C, B.0				; Divide by 8
0E4A    13            6385     	RRC	A					
0E4B    A2F1          6386     	MOV	C, B.1
0E4D    13            6387     	RRC	A
0E4E    A2F2          6388     	MOV	C, B.2
0E50    13            6389     	RRC	A
0E51    F536          6390     	MOV	DEMAG_DETECTED_METRIC, A
0E53    C3            6391     	CLR	C
0E54    9478          6392     	SUBB	A, #120				; Limit to minimum 120
0E56    5003          6393     	JNC	($+5)
                      6394     
0E58    753678        6395     	MOV	DEMAG_DETECTED_METRIC, #120
                      6396     
0E5B    C3            6397     	CLR	C
0E5C    E536          6398     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0E5E    9537          6399     	SUBB	A, DEMAG_PWR_OFF_THRESH
0E60    4008          6400     	JC	WAIT_FOR_COMM_WAIT		; Cut power if many consecutive demags. This will help retain sync during hard accelerations
                      6401     
0E62    D266          6402     SETB FLAGS0 . 6 
                      6403     	ALL_NFETS_OFF
0E64    C293          6403+1   CLR P1 . 3 
0E66    C297          6403+1   CLR P1 . 7 
0E68    C294          6403+1   CLR P1 . 4 
                      6404     
                      6405     WAIT_FOR_COMM_WAIT: 
0E6A    306002        6406     JNB FLAGS0 . 0 , ( $+5 ) 
0E6D    C16A          6407     	AJMP	WAIT_FOR_COMM_WAIT					
                      6408     
                      6409     	; Setup next wait time
0E6F    854D53        6410     	MOV	NEXT_WT_START_L, WT_ZC_SCAN_START_L
0E72    854E54        6411     	MOV	NEXT_WT_START_H, WT_ZC_SCAN_START_H
0E75    D260          6412     SETB FLAGS0 . 0 
0E77    43E680        6413     	ORL	EIE1, #80H			; Enable timer3 interrupts
0E7A    22            6414     	RET
                      6415     
                      6416     
                      6417     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6418     ;
                      6419     ; Commutation routines
                      6420     ;
                      6421     ; No assumptions
                      6422     ;
                      6423     ; Performs commutation switching 
                      6424     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      6425     ;
                      6426     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6427     ; Comm phase 1 to comm phase 2
                      6428     COMM1COMM2: 	
                      6429     	SET_RPM_OUT
0E7B    207D11        6430     JB FLAGS3 . 5 , COMM12_REV 
                      6431     
0E7E    C2AF          6432     	CLR 	EA					; Disable all interrupts
0E80    754002        6433     	MOV	COMM_PHASE, #2
                      6434     	BPFET_OFF 				; Turn off pfet
0E83    C295          6434+1   CLR P1 . 5 
                      6435     	APFET_ON					; Turn on pfet
0E85    D292          6435+1   SETB P1 . 2 
0E87    D2AF          6436     	SETB	EA
                      6437     	SET_COMP_PHASE_B 			; Set comparator phase
0E89    759F80        6437+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E8C    02104A        6438     	JMP	COMM_EXIT
                      6439     
                      6440     COMM12_REV: 	
0E8F    C2AF          6441     	CLR 	EA					; Disable all interrupts
0E91    754002        6442     	MOV	COMM_PHASE, #2
                      6443     	BPFET_OFF 				; Turn off pfet
0E94    C295          6443+1   CLR P1 . 5 
                      6444     	CPFET_ON					; Turn on pfet (reverse)
0E96    D296          6444+1   SETB P1 . 6 
0E98    D2AF          6445     	SETB	EA
                      6446     	SET_COMP_PHASE_B 			; Set comparator phase
0E9A    759F80        6446+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E9D    02104A        6447     	JMP	COMM_EXIT
                      6448     
                      6449     
                      6450     ; Comm phase 2 to comm phase 3
                      6451     COMM2COMM3: 	
                      6452     	CLEAR_RPM_OUT
0EA0    307243        6453     JNB FLAGS2 . 2 , COMM23_NONDAMP 
                      6454     
                      6455     	; Comm2Comm3 Damped
0EA3    207D20        6456     JB FLAGS3 . 5 , COMM23_DAMP_REV 
                      6457     
0EA6    C2AF          6458     	CLR 	EA					; Disable all interrupts
0EA8    754003        6459     	MOV	COMM_PHASE, #3
0EAB    90018E        6460     	MOV	DPTR, #PWM_BFET_DAMPED	
0EAE    757B20        6461     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6462     	CNFET_OFF					; Turn off fets
0EB1    C297          6462+1   CLR P1 . 7 
                      6463     	CPFET_OFF						
0EB3    C296          6463+1   CLR P1 . 6 
0EB5    306204        6464     JNB FLAGS0 . 2 , COMM23_NFET_OFF 
                      6465     	BNFET_ON					; Pwm on - turn on nfet
0EB8    D294          6465+1   SETB P1 . 4 
0EBA    C1BE          6466     	AJMP	COMM23_FETS_DONE
                      6467     COMM23_NFET_OFF: 
                      6468     	BPFET_ON					; Pwm off - switch damping fets	
0EBC    D295          6468+1   SETB P1 . 5 
                      6469     COMM23_FETS_DONE: 
0EBE    D2AF          6470     	SETB	EA
                      6471     	SET_COMP_PHASE_C 			; Set comparator phase
0EC0    759F89        6471+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0EC3    02104A        6472     	LJMP	COMM_EXIT
                      6473     
                      6474     	; Comm2Comm3 Damped reverse
                      6475     COMM23_DAMP_REV: 
0EC6    C2AF          6476     	CLR 	EA					; Disable all interrupts
0EC8    754003        6477     	MOV	COMM_PHASE, #3
0ECB    90018E        6478     	MOV	DPTR, #PWM_BFET_DAMPED	
0ECE    757B20        6479     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6480     	ANFET_OFF					; Turn off fets (reverse)
0ED1    C293          6480+1   CLR P1 . 3 
                      6481     	APFET_OFF						
0ED3    C292          6481+1   CLR P1 . 2 
0ED5    306204        6482     JNB FLAGS0 . 2 , COMM23_NFET_OFF_REV 
                      6483     	BNFET_ON					; Pwm on - turn on nfet
0ED8    D294          6483+1   SETB P1 . 4 
0EDA    C1DE          6484     	AJMP	COMM23_FETS_DONE_REV
                      6485     COMM23_NFET_OFF_REV: 
                      6486     	BPFET_ON					; Pwm off - switch damping fets	
0EDC    D295          6486+1   SETB P1 . 5 
                      6487     COMM23_FETS_DONE_REV: 
0EDE    D2AF          6488     	SETB	EA
                      6489     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0EE0    759F81        6489+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0EE3    02104A        6490     	LJMP	COMM_EXIT
                      6491     
                      6492     	; Comm2Comm3 Non-damped
                      6493     COMM23_NONDAMP: 
0EE6    207D17        6494     JB FLAGS3 . 5 , COMM23_NONDAMP_REV 
                      6495     
0EE9    C2AF          6496     	CLR 	EA					; Disable all interrupts
0EEB    754003        6497     	MOV	COMM_PHASE, #3
0EEE    900169        6498     	MOV	DPTR, #PWM_BFET	
                      6499     	CNFET_OFF					; Turn off nfet
0EF1    C297          6499+1   CLR P1 . 7 
0EF3    306202        6500     JNB FLAGS0 . 2 , COMM23_NFET_DONE 
                      6501     	BNFET_ON					; Yes - turn on nfet
0EF6    D294          6501+1   SETB P1 . 4 
                      6502     COMM23_NFET_DONE: 
0EF8    D2AF          6503     	SETB	EA
                      6504     	SET_COMP_PHASE_C 			; Set comparator phase
0EFA    759F89        6504+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0EFD    02104A        6505     	LJMP	COMM_EXIT
                      6506     
                      6507     	; Comm2Comm3 Non-damped reverse
                      6508     COMM23_NONDAMP_REV: 
0F00    C2AF          6509     	CLR 	EA					; Disable all interrupts
0F02    754003        6510     	MOV	COMM_PHASE, #3
0F05    900169        6511     	MOV	DPTR, #PWM_BFET	
                      6512     	ANFET_OFF					; Turn off nfet (reverse)
0F08    C293          6512+1   CLR P1 . 3 
0F0A    306202        6513     JNB FLAGS0 . 2 , COMM23_NFET_DONE_REV 
                      6514     	BNFET_ON					; Yes - turn on nfet
0F0D    D294          6514+1   SETB P1 . 4 
                      6515     COMM23_NFET_DONE_REV: 
0F0F    D2AF          6516     	SETB	EA
                      6517     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0F11    759F81        6517+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F14    02104A        6518     	LJMP	COMM_EXIT
                      6519     
                      6520     
                      6521     ; Comm phase 3 to comm phase 4
                      6522     COMM3COMM4: 	
                      6523     	SET_RPM_OUT
0F17    207D11        6524     JB FLAGS3 . 5 , COMM34_REV 
                      6525     
0F1A    C2AF          6526     	CLR 	EA					; Disable all interrupts
0F1C    754004        6527     	MOV	COMM_PHASE, #4
                      6528     	APFET_OFF 				; Turn off pfet
0F1F    C292          6528+1   CLR P1 . 2 
                      6529     	CPFET_ON					; Turn on pfet
0F21    D296          6529+1   SETB P1 . 6 
0F23    D2AF          6530     	SETB	EA
                      6531     	SET_COMP_PHASE_A 			; Set comparator phase
0F25    759F81        6531+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F28    02104A        6532     	JMP	COMM_EXIT
                      6533     
                      6534     COMM34_REV: 	
0F2B    C2AF          6535     	CLR 	EA					; Disable all interrupts
0F2D    754004        6536     	MOV	COMM_PHASE, #4
                      6537     	CPFET_OFF 				; Turn off pfet (reverse)
0F30    C296          6537+1   CLR P1 . 6 
                      6538     	APFET_ON					; Turn on pfet (reverse)
0F32    D292          6538+1   SETB P1 . 2 
0F34    D2AF          6539     	SETB	EA
                      6540     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0F36    759F89        6540+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F39    02104A        6541     	JMP	COMM_EXIT
                      6542     
                      6543     
                      6544     ; Comm phase 4 to comm phase 5
                      6545     COMM4COMM5: 	
                      6546     	CLEAR_RPM_OUT
0F3C    307243        6547     JNB FLAGS2 . 2 , COMM45_NONDAMP 
                      6548     
                      6549     	; Comm4Comm5 Damped
0F3F    207D20        6550     JB FLAGS3 . 5 , COMM45_DAMP_REV 
                      6551     
0F42    C2AF          6552     	CLR 	EA					; Disable all interrupts
0F44    754005        6553     	MOV	COMM_PHASE, #5
0F47    90017D        6554     	MOV	DPTR, #PWM_AFET_DAMPED	
0F4A    757B04        6555     	MOV	DAMPINGFET, #(1 SHL APFET)
                      6556     	BNFET_OFF					; Turn off fets
0F4D    C294          6556+1   CLR P1 . 4 
                      6557     	BPFET_OFF						
0F4F    C295          6557+1   CLR P1 . 5 
0F51    306204        6558     JNB FLAGS0 . 2 , COMM45_NFET_OFF 
                      6559     	ANFET_ON					; Pwm on - turn on nfet
0F54    D293          6559+1   SETB P1 . 3 
0F56    E15A          6560     	AJMP	COMM45_FETS_DONE
                      6561     COMM45_NFET_OFF: 
                      6562     	APFET_ON					; Pwm off - switch damping fets	
0F58    D292          6562+1   SETB P1 . 2 
                      6563     COMM45_FETS_DONE: 
0F5A    D2AF          6564     	SETB	EA
                      6565     	SET_COMP_PHASE_B 			; Set comparator phase
0F5C    759F80        6565+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F5F    02104A        6566     	LJMP	COMM_EXIT
                      6567     
                      6568     	; Comm4Comm5 Damped reverse
                      6569     COMM45_DAMP_REV: 
0F62    C2AF          6570     	CLR 	EA					; Disable all interrupts
0F64    754005        6571     	MOV	COMM_PHASE, #5
0F67    90019F        6572     	MOV	DPTR, #PWM_CFET_DAMPED	; (reverse)
0F6A    757B40        6573     	MOV	DAMPINGFET, #(1 SHL CPFET)	; (reverse)
                      6574     	BNFET_OFF					; Turn off fets
0F6D    C294          6574+1   CLR P1 . 4 
                      6575     	BPFET_OFF						
0F6F    C295          6575+1   CLR P1 . 5 
0F71    306204        6576     JNB FLAGS0 . 2 , COMM45_NFET_OFF_REV 
                      6577     	CNFET_ON					; Pwm on - turn on nfet (reverse)
0F74    D297          6577+1   SETB P1 . 7 
0F76    E17A          6578     	AJMP	COMM45_FETS_DONE_REV
                      6579     COMM45_NFET_OFF_REV: 
                      6580     	CPFET_ON					; Pwm off - switch damping fets (reverse)	
0F78    D296          6580+1   SETB P1 . 6 
                      6581     COMM45_FETS_DONE_REV: 
0F7A    D2AF          6582     	SETB	EA
                      6583     	SET_COMP_PHASE_B 			; Set comparator phase
0F7C    759F80        6583+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F7F    02104A        6584     	LJMP	COMM_EXIT
                      6585     
                      6586     	; Comm4Comm5 Non-damped
                      6587     COMM45_NONDAMP: 
0F82    207D17        6588     JB FLAGS3 . 5 , COMM45_NONDAMP_REV 
                      6589     
0F85    C2AF          6590     	CLR 	EA					; Disable all interrupts
0F87    754005        6591     	MOV	COMM_PHASE, #5
0F8A    90015F        6592     	MOV	DPTR, #PWM_AFET	
                      6593     	BNFET_OFF					; Turn off nfet
0F8D    C294          6593+1   CLR P1 . 4 
0F8F    306202        6594     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      6595     	ANFET_ON					; Yes - turn on nfet
0F92    D293          6595+1   SETB P1 . 3 
                      6596     COMM45_NFET_DONE: 
0F94    D2AF          6597     	SETB	EA
                      6598     	SET_COMP_PHASE_B 			; Set comparator phase
0F96    759F80        6598+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F99    02104A        6599     	LJMP	COMM_EXIT
                      6600     
                      6601     	; Comm4Comm5 Non-damped reverse
                      6602     COMM45_NONDAMP_REV: 
0F9C    C2AF          6603     	CLR 	EA					; Disable all interrupts
0F9E    754005        6604     	MOV	COMM_PHASE, #5
0FA1    900173        6605     	MOV	DPTR, #PWM_CFET		;  (reverse)
                      6606     	BNFET_OFF					; Turn off nfet
0FA4    C294          6606+1   CLR P1 . 4 
0FA6    3062EB        6607     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      6608     	CNFET_ON					; Yes - turn on nfet (reverse)
0FA9    D297          6608+1   SETB P1 . 7 
0FAB    D2AF          6609     	SETB	EA
                      6610     	SET_COMP_PHASE_B 			; Set comparator phase
0FAD    759F80        6610+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0FB0    02104A        6611     	LJMP	COMM_EXIT
                      6612     
                      6613     
                      6614     ; Comm phase 5 to comm phase 6
                      6615     COMM5COMM6: 	
                      6616     	SET_RPM_OUT
0FB3    207D11        6617     JB FLAGS3 . 5 , COMM56_REV 
                      6618     
0FB6    C2AF          6619     	CLR 	EA					; Disable all interrupts
0FB8    754006        6620     	MOV	COMM_PHASE, #6
                      6621     	CPFET_OFF 				; Turn off pfet
0FBB    C296          6621+1   CLR P1 . 6 
                      6622     	BPFET_ON					; Turn on pfet
0FBD    D295          6622+1   SETB P1 . 5 
0FBF    D2AF          6623     	SETB	EA
                      6624     	SET_COMP_PHASE_C 			; Set comparator phase
0FC1    759F89        6624+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0FC4    02104A        6625     	JMP	COMM_EXIT
                      6626     
                      6627     COMM56_REV: 
0FC7    C2AF          6628     	CLR 	EA					; Disable all interrupts
0FC9    754006        6629     	MOV	COMM_PHASE, #6
                      6630     	APFET_OFF 				; Turn off pfet (reverse)
0FCC    C292          6630+1   CLR P1 . 2 
                      6631     	BPFET_ON					; Turn on pfet
0FCE    D295          6631+1   SETB P1 . 5 
0FD0    D2AF          6632     	SETB	EA
                      6633     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0FD2    759F81        6633+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0FD5    02104A        6634     	JMP	COMM_EXIT
                      6635     
                      6636     
                      6637     ; Comm phase 6 to comm phase 1
                      6638     COMM6COMM1: 	
                      6639     	CLEAR_RPM_OUT
0FD8    307242        6640     JNB FLAGS2 . 2 , COMM61_NONDAMP 
                      6641     
                      6642     	; Comm6Comm1 Damped
0FDB    207D20        6643     JB FLAGS3 . 5 , COMM61_DAMP_REV 
                      6644     
0FDE    C2AF          6645     	CLR 	EA					; Disable all interrupts
0FE0    754001        6646     	MOV	COMM_PHASE, #1
0FE3    90019F        6647     	MOV	DPTR, #PWM_CFET_DAMPED	
0FE6    757B40        6648     	MOV	DAMPINGFET, #(1 SHL CPFET)
                      6649     	ANFET_OFF					; Turn off fets
0FE9    C293          6649+1   CLR P1 . 3 
                      6650     	APFET_OFF						
0FEB    C292          6650+1   CLR P1 . 2 
0FED    306204        6651     JNB FLAGS0 . 2 , COMM61_NFET_OFF 
                      6652     	CNFET_ON					; Pwm on - turn on nfet
0FF0    D297          6652+1   SETB P1 . 7 
0FF2    E1F6          6653     	AJMP	COMM61_FETS_DONE
                      6654     COMM61_NFET_OFF: 
                      6655     	CPFET_ON					; Pwm off - switch damping fets	
0FF4    D296          6655+1   SETB P1 . 6 
                      6656     COMM61_FETS_DONE: 
0FF6    D2AF          6657     	SETB	EA
                      6658     	SET_COMP_PHASE_A 			; Set comparator phase
0FF8    759F81        6658+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0FFB    02104A        6659     	LJMP	COMM_EXIT
                      6660     
                      6661     	; Comm6Comm1 Damped reverse
                      6662     COMM61_DAMP_REV: 
0FFE    C2AF          6663     	CLR 	EA					; Disable all interrupts
1000    754001        6664     	MOV	COMM_PHASE, #1
1003    90017D        6665     	MOV	DPTR, #PWM_AFET_DAMPED	; (reverse)	
1006    757B04        6666     	MOV	DAMPINGFET, #(1 SHL APFET)	; (reverse)
                      6667     	CNFET_OFF					; Turn off fets (reverse)
1009    C297          6667+1   CLR P1 . 7 
                      6668     	CPFET_OFF						
100B    C296          6668+1   CLR P1 . 6 
100D    306204        6669     JNB FLAGS0 . 2 , COMM61_NFET_OFF_REV 
                      6670     	ANFET_ON					; Pwm on - turn on nfet
1010    D293          6670+1   SETB P1 . 3 
1012    0116          6671     	AJMP	COMM61_FETS_DONE_REV
                      6672     COMM61_NFET_OFF_REV: 
                      6673     	APFET_ON					; Pwm off - switch damping fets (reverse)	
1014    D292          6673+1   SETB P1 . 2 
                      6674     COMM61_FETS_DONE_REV: 
1016    D2AF          6675     	SETB	EA
                      6676     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
1018    759F89        6676+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
101B    014A          6677     	AJMP	COMM_EXIT
                      6678     
                      6679     	; Comm6Comm1 Non-damped
                      6680     COMM61_NONDAMP: 
101D    207D16        6681     JB FLAGS3 . 5 , COMM61_NONDAMP_REV 
                      6682     
1020    C2AF          6683     	CLR 	EA					; Disable all interrupts
1022    754001        6684     	MOV	COMM_PHASE, #1
1025    900173        6685     	MOV	DPTR, #PWM_CFET	
                      6686     	ANFET_OFF					; Turn off nfet
1028    C293          6686+1   CLR P1 . 3 
102A    306202        6687     JNB FLAGS0 . 2 , COMM61_NFET_DONE 
                      6688     	CNFET_ON					; Yes - turn on nfet
102D    D297          6688+1   SETB P1 . 7 
                      6689     COMM61_NFET_DONE: 
102F    D2AF          6690     	SETB	EA
                      6691     	SET_COMP_PHASE_A 			; Set comparator phase
1031    759F81        6691+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
1034    014A          6692     	AJMP	COMM_EXIT
                      6693     
                      6694     	; Comm6Comm1 Non-damped reverse
                      6695     COMM61_NONDAMP_REV: 
1036    C2AF          6696     	CLR 	EA					; Disable all interrupts
1038    754001        6697     	MOV	COMM_PHASE, #1
103B    90015F        6698     	MOV	DPTR, #PWM_AFET		; (reverse)
                      6699     	CNFET_OFF					; Turn off nfet (reverse)
103E    C297          6699+1   CLR P1 . 7 
1040    306202        6700     JNB FLAGS0 . 2 , COMM61_NFET_DONE_REV 
                      6701     	ANFET_ON					; Yes - turn on nfet (reverse)
1043    D293          6701+1   SETB P1 . 3 
                      6702     COMM61_NFET_DONE_REV: 
1045    D2AF          6703     	SETB	EA
                      6704     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
1047    759F89        6704+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
                      6705     
                      6706     COMM_EXIT: 
104A    C266          6707     CLR FLAGS0 . 6 
104C    22            6708     	RET
                      6709     
                      6710     
                      6711     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6712     ;
                      6713     ; Switch power off routine
                      6714     ;
                      6715     ; No assumptions
                      6716     ;
                      6717     ; Switches all fets off 
                      6718     ;
                      6719     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6720     SWITCH_POWER_OFF: 
104D    90015D        6721     	MOV	DPTR, #PWM_NOFET	; Set DPTR register to pwm_nofet		
1050    757B00        6722     	MOV	DAMPINGFET, #0
                      6723     	ALL_NFETS_OFF			; Turn off all nfets
1053    C293          6723+1   CLR P1 . 3 
1055    C297          6723+1   CLR P1 . 7 
1057    C294          6723+1   CLR P1 . 4 
                      6724     	ALL_PFETS_OFF			; Turn off all pfets
1059    C292          6724+1   CLR P1 . 2 
105B    C296          6724+1   CLR P1 . 6 
105D    C295          6724+1   CLR P1 . 5 
105F    C262          6725     CLR FLAGS0 . 2 
1061    22            6726     	RET			
                      6727     
                      6728     
                      6729     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6730     ;
                      6731     ; Set default parameters
                      6732     ;
                      6733     ; No assumptions
                      6734     ;
                      6735     ; Sets default programming parameters
                      6736     ;
                      6737     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6738     SET_DEFAULT_PARAMETERS: 
                      6739     IF MODE == 0	; Main
1062    7880          6740     MOV R0 , # PGM_GOV_P_GAIN 
1064    7607          6741     MOV @ R0 , # 7 
1066    08            6742     INC R0 
1067    7607          6743     MOV @ R0 , # 7 
1069    08            6744     INC R0 
106A    7601          6745     MOV @ R0 , # 1 
106C    08            6746     INC R0 
106D    7604          6747     MOV @ R0 , # 4 
106F    08            6748     INC R0 
1070    76FF          6749     MOV @ R0 , # 0FFH 
1072    08            6750     INC R0 
1073    76FF          6751     MOV @ R0 , # 0FFH 
1075    08            6752     INC R0 
1076    7609          6753     MOV @ R0 , # 9 
1078    08            6754     INC R0 
1079    7602          6755     MOV @ R0 , # 2 
107B    08            6756     INC R0 
107C    7601          6757     MOV @ R0 , # 1 
107E    08            6758     INC R0 
107F    7601          6759     MOV @ R0 , # 1 
                      6760     
1081    788C          6761     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1083    7601          6762     MOV @ R0 , # 1 
1085    08            6763     INC R0 
1086    7600          6764     MOV @ R0 , # 0 
1088    08            6765     INC R0 
1089    76B4          6766     MOV @ R0 , # 180 
108B    08            6767     INC R0 
108C    76FF          6768     MOV @ R0 , # 0FFH 
108E    08            6769     INC R0 
108F    76FF          6770     MOV @ R0 , # 0FFH 
1091    08            6771     INC R0 
1092    76FF          6772     MOV @ R0 , # 0FFH 
1094    08            6773     INC R0 
1095    7603          6774     MOV @ R0 , # 3 
1097    08            6775     INC R0 
1098    76FF          6776     MOV @ R0 , # 0FFH 
109A    08            6777     INC R0 
109B    7601          6778     MOV @ R0 , # 1 
109D    08            6779     INC R0 
109E    76FF          6780     MOV @ R0 , # 0FFH 
10A0    08            6781     INC R0 
10A1    7625          6782     MOV @ R0 , # 37 
10A3    08            6783     INC R0 
10A4    76D0          6784     MOV @ R0 , # 208 
10A6    08            6785     INC R0 
10A7    7678          6786     MOV @ R0 , # 120 
10A9    08            6787     INC R0 
10AA    76C8          6788     MOV @ R0 , # 200 
10AC    08            6789     INC R0 
10AD    7604          6790     MOV @ R0 , # 4 
10AF    08            6791     INC R0 
10B0    76FF          6792     MOV @ R0 , # 0FFH 
10B2    08            6793     INC R0 
10B3    7601          6794     MOV @ R0 , # 1 
10B5    08            6795     INC R0 
10B6    7600          6796     MOV @ R0 , # 0 
10B8    08            6797     INC R0 
10B9    767A          6798     MOV @ R0 , # 122 
10BB    08            6799     INC R0 
10BC    760A          6800     MOV @ R0 , # 10 
10BE    08            6801     INC R0 
10BF    7601          6802     MOV @ R0 , # 1 
10C1    08            6803     INC R0 
10C2    7601          6804     MOV @ R0 , # 1 
10C4    08            6805     INC R0 
10C5    7600          6806     MOV @ R0 , # 0 
10C7    08            6807     INC R0 
10C8    76FF          6808     MOV @ R0 , # 0FFH 
                      6809     ENDIF
                      6810     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_DITHER
                               ENDIF
                      6881     IF MODE == 2	; Multi
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_PWM_DITHER
                               ENDIF
10CA    22            6952     	RET
                      6953     
                      6954     
                      6955     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6956     ;
                      6957     ; Decode parameters
                      6958     ;
                      6959     ; No assumptions
                      6960     ;
                      6961     ; Decodes programming parameters
                      6962     ;
                      6963     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6964     DECODE_PARAMETERS: 
                      6965     	; Load programmed pwm frequency
10CB    7887          6966     MOV R0 , # PGM_PWM_FREQ 
10CD    E6            6967     MOV A , @ R0 
10CE    FF            6968     MOV R7 , A 
10CF    C272          6969     CLR FLAGS2 . 2 
                      6970     IF DAMPED_MODE_ENABLE == 1
10D1    BF0302        6971     CJNE R7 , # 3 , ( $+5 ) 
10D4    D272          6972     SETB FLAGS2 . 2 
                      6973     ENDIF
                      6974     	; Load programmed direction
10D6    7888          6975     MOV R0 , # PGM_DIRECTION 
                      6976     IF MODE >= 1	; Tail or multi
                               	MOV	A, @TEMP1				
                               	CLR	C
                               	SUBB	A, #3
                               	JZ	DECODE_PARAMS_DIR_SET
                               ENDIF
                      6982     
10D8    C27D          6983     CLR FLAGS3 . 5 
10DA    E6            6984     MOV A , @ R0 
10DB    30E102        6985     	JNB	ACC.1, ($+5)
10DE    D27D          6986     SETB FLAGS3 . 5 
                      6987     DECODE_PARAMS_DIR_SET: 
10E0    C27E          6988     CLR FLAGS3 . 6 
10E2    7889          6989     MOV R0 , # PGM_INPUT_POL 
10E4    E6            6990     MOV A , @ R0 
10E5    30E102        6991     	JNB	ACC.1, ($+5)
10E8    D27E          6992     SETB FLAGS3 . 6 
10EA    C3            6993     	CLR	C
10EB    EF            6994     MOV A , R7 
10EC    9402          6995     	SUBB	A, #2
10EE    6008          6996     	JZ	DECODE_PWM_FREQ_LOW
                      6997     
10F0    758E01        6998     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
10F3    D273          6999     SETB FLAGS2 . 3 
10F5    0210FD        7000     	JMP	DECODE_PWM_FREQ_END
                      7001     
                      7002     DECODE_PWM_FREQ_LOW: 
10F8    758E00        7003     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
10FB    C273          7004     CLR FLAGS2 . 3 
                      7005     
                      7006     DECODE_PWM_FREQ_END: 
10FD    22            7007     	RET
                      7008     
                      7009     
                      7010     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7011     ;
                      7012     ; Decode settings
                      7013     ;
                      7014     ; No assumptions
                      7015     ;
                      7016     ; Decodes various settings
                      7017     ;
                      7018     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7019     DECODE_SETTINGS: 
                      7020     	; Decode governor gains
10FE    7880          7021     MOV R0 , # PGM_GOV_P_GAIN 
1100    E6            7022     MOV A , @ R0 
1101    14            7023     	DEC	A	
1102    900080        7024     	MOV	DPTR, #GOV_GAIN_TABLE
1105    93            7025     	MOVC A, @A+DPTR	
1106    78A4          7026     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
1108    F6            7027     MOV @ R0 , A 
1109    7881          7028     MOV R0 , # PGM_GOV_I_GAIN 
110B    E6            7029     MOV A , @ R0 
110C    14            7030     	DEC	A	
110D    900080        7031     	MOV	DPTR, #GOV_GAIN_TABLE
1110    93            7032     	MOVC A, @A+DPTR	
1111    78A5          7033     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
1113    F6            7034     MOV @ R0 , A 
                      7035     	; Decode startup power
1114    7886          7036     MOV R0 , # PGM_STARTUP_PWR 
1116    E6            7037     MOV A , @ R0 
1117    14            7038     	DEC	A	
1118    90008D        7039     	MOV	DPTR, #STARTUP_POWER_TABLE
111B    93            7040     	MOVC A, @A+DPTR	
111C    78A6          7041     MOV R0 , # PGM_STARTUP_PWR_DECODED 
111E    F6            7042     MOV @ R0 , A 
                      7043     IF MODE == 0	; Main
                      7044     	; Decode spoolup time
111F    789F          7045     MOV R0 , # PGM_MAIN_SPOOLUP_TIME 
1121    E6            7046     MOV A , @ R0 
1122    F8            7047     MOV R0 , A 
1123    7001          7048     	JNZ	($+3)		; If not zero - branch
                      7049     	
1125    08            7050     INC R0 
                      7051     
1126    C3            7052     	CLR	C
1127    E8            7053     MOV A , R0 
1128    9411          7054     	SUBB	A, #17		; Limit to 17 max
112A    4002          7055     	JC	($+4)
                      7056     
112C    7811          7057     MOV R0 , # 17 
                      7058     
112E    E8            7059     MOV A , R0 
112F    28            7060     ADD A , R0 
1130    28            7061     ADD A , R0 
1131    F56B          7062     	MOV	MAIN_SPOOLUP_TIME_3X, A
1133    256B          7063     	ADD	A, MAIN_SPOOLUP_TIME_3X
1135    256B          7064     	ADD	A, MAIN_SPOOLUP_TIME_3X
1137    28            7065     ADD A , R0 
1138    F56C          7066     	MOV	MAIN_SPOOLUP_TIME_10X, A
113A    256B          7067     	ADD	A, MAIN_SPOOLUP_TIME_3X
113C    28            7068     ADD A , R0 
113D    28            7069     ADD A , R0 
113E    F56D          7070     	MOV	MAIN_SPOOLUP_TIME_15X, A
                      7071     ENDIF
                      7072     	; Decode demag compensation
1140    789C          7073     MOV R0 , # PGM_DEMAG_COMP 
1142    E6            7074     MOV A , @ R0 
1143    7537FF        7075     	MOV	DEMAG_PWR_OFF_THRESH, #255	; Set default
1146    75380C        7076     	MOV	LOW_RPM_PWR_SLOPE, #12		; Set default
                      7077     
1149    B40206        7078     	CJNE	A, #2, DECODE_DEMAG_HIGH
                      7079     
114C    7537A0        7080     	MOV	DEMAG_PWR_OFF_THRESH, #160	; Settings for demag comp low
114F    75380A        7081     	MOV	LOW_RPM_PWR_SLOPE, #10		
                      7082     
                      7083     DECODE_DEMAG_HIGH: 
1152    B40306        7084     	CJNE	A, #3, DECODE_DEMAG_DONE
                      7085     
1155    753782        7086     	MOV	DEMAG_PWR_OFF_THRESH, #130	; Settings for demag comp high
1158    753805        7087     	MOV	LOW_RPM_PWR_SLOPE, #5		
                      7088     
                      7089     DECODE_DEMAG_DONE: 
                      7090     	; Decode pwm dither
115B    78A3          7091     MOV R0 , # PGM_PWM_DITHER 
115D    E6            7092     MOV A , @ R0 
115E    14            7093     	DEC	A	
115F    90009A        7094     	MOV	DPTR, #PWM_DITHER_TABLE
1162    93            7095     	MOVC A, @A+DPTR	
1163    F566          7096     	MOV	PWM_DITHER_DECODED, A
1165    114D          7097     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1167    22            7098     	RET
                      7099     
                      7100     
                      7101     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7102     ;
                      7103     ; Set BEC voltage
                      7104     ;
                      7105     ; No assumptions
                      7106     ;
                      7107     ; Sets the BEC output voltage low or high
                      7108     ;
                      7109     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7110     SET_BEC_VOLTAGE: 
                      7111     	; Set bec voltage
                      7112     IF HIGH_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
                      7122     IF HIGH_BEC_VOLTAGE == 2
                               	SET_BEC_0				; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	CJNE	A, #1, SET_BEC_VOLTAGE_2	
                               
                               	SET_BEC_1				; Set to level 1
                               
                               SET_BEC_VOLTAGE_2:
                               	CJNE	A, #2, SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_2				; Set to level 2
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
1168    22            7137     	RET
                      7138     
                      7139     
                      7140     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7141     ;
                      7142     ; Find throttle gain
                      7143     ;
                      7144     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      7145     ;
                      7146     ; Finds throttle gain from throttle calibration values
                      7147     ;
                      7148     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7149     FIND_THROTTLE_GAIN: 
                      7150     	; Load programmed minimum and maximum throttle
1169    7896          7151     MOV R0 , # PGM_PPM_MIN_THROTTLE 
116B    E6            7152     MOV A , @ R0 
116C    FA            7153     MOV R2 , A 
116D    7897          7154     MOV R0 , # PGM_PPM_MAX_THROTTLE 
116F    E6            7155     MOV A , @ R0 
1170    FB            7156     MOV R3 , A 
1171    7888          7157     MOV R0 , # PGM_DIRECTION 
1173    E6            7158     MOV A , @ R0 
1174    B40305        7159     	CJNE	A, #3, FIND_THROTTLE_GAIN_CHECK_FULL
                      7160     
1177    C3            7161     	CLR	C
1178    EB            7162     MOV A , R3 
1179    940E          7163     	SUBB	A, #14				; Compensate for higher deadband in bidirectional
117B    FB            7164     MOV R3 , A 
                      7165     
                      7166     FIND_THROTTLE_GAIN_CHECK_FULL: 
                      7167     	; Check if full range is chosen
117C    307F04        7168     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      7169     
117F    7A00          7170     MOV R2 , # 0 
1181    7BFF          7171     MOV R3 , # 255 
                      7172     
                      7173     FIND_THROTTLE_GAIN_CALCULATE: 
                      7174     	; Calculate difference
1183    C3            7175     	CLR	C
1184    EB            7176     MOV A , R3 
1185    9A            7177     SUBB A , R2 
1186    FC            7178     MOV R4 , A 
                      7179     	; Check that difference is minimum 130
1187    C3            7180     	CLR	C
1188    9482          7181     	SUBB	A, #130
118A    5002          7182     	JNC	($+4)
                      7183     
118C    7C82          7184     MOV R4 , # 130 
                      7185     
                      7186     	; Find gain
118E    757200        7187     	MOV	PPM_THROTTLE_GAIN, #0
                      7188     TEST_THROTTLE_GAIN: 
1191    0572          7189     	INC	PPM_THROTTLE_GAIN
1193    EC            7190     MOV A , R4 
1194    8572F0        7191     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
1197    A4            7192     	MUL	AB
1198    C3            7193     	CLR	C
1199    E5F0          7194     	MOV	A, B
119B    947D          7195     	SUBB	A, #125
119D    40F2          7196     	JC	TEST_THROTTLE_GAIN
119F    22            7197     	RET
                      7198     
                      7199     
                      7200     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7201     ;
                      7202     ; Average throttle 
                      7203     ;
                      7204     ; Outputs result in Temp3
                      7205     ;
                      7206     ; Averages throttle calibration readings
                      7207     ;
                      7208     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7209     AVERAGE_THROTTLE: 
11A0    D27F          7210     SETB FLAGS3 . 7 
11A2    3169          7211     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
11A4    1205D6        7212     	CALL WAIT30MS		
11A7    7A00          7213     MOV R2 , # 0 
11A9    7B00          7214     MOV R3 , # 0 
11AB    7C10          7215     MOV R4 , # 16 
                      7216     AVERAGE_THROTTLE_MEAS: 
11AD    1205CC        7217     	CALL	WAIT3MS			; Wait for new RC pulse value
11B0    E55C          7218     	MOV	A, NEW_RCP		; Get new RC pulse value
11B2    2A            7219     ADD A , R2 
11B3    FA            7220     MOV R2 , A 
11B4    7400          7221     	MOV	A, #0
11B6    3B            7222     ADDC A , R3 
11B7    FB            7223     MOV R3 , A 
11B8    DCF3          7224     DJNZ R4 , AVERAGE_THROTTLE_MEAS 
                      7225     
11BA    7C04          7226     MOV R4 , # 4 
                      7227     AVERAGE_THROTTLE_DIV: 
11BC    C3            7228     	CLR	C
11BD    EB            7229     MOV A , R3 
11BE    13            7230     	RRC	A      
11BF    FB            7231     MOV R3 , A 
11C0    EA            7232     MOV A , R2 
11C1    13            7233     	RRC	A      
11C2    FA            7234     MOV R2 , A 
11C3    DCF7          7235     DJNZ R4 , AVERAGE_THROTTLE_DIV 
                      7236     
11C5    FE            7237     MOV R6 , A 
11C6    C27F          7238     CLR FLAGS3 . 7 
11C8    3169          7239     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
11CA    22            7240     	RET
                      7241     
                      7242     
                      7243     
                      7244     
                      7245     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7246     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7247     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7248     ;
                      7249     ; Main program start
                      7250     ;
                      7251     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7252     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7253     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7254     PGM_START: 
                      7255     	; Check flash lock byte
11CB    E5EF          7256     	MOV	A, RSTSRC			
11CD    20E603        7257     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      7258     
11D0    752000        7259     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      7260     
11D3    0520          7261     	INC	BIT_ACCESS
11D5    903FFF        7262     MOV DPTR , # 16383 
11D8    E520          7263     	MOV	A, BIT_ACCESS
11DA    14            7264     	DEC	A
11DB    6006          7265     	JZ	LOCK_BYTE_TEST
                      7266     
11DD    901FFF        7267     MOV DPTR , # 8191 
11E0    14            7268     	DEC	A
11E1    6000          7269     	JZ	LOCK_BYTE_TEST
                      7270     
                      7271     LOCK_BYTE_TEST: 
11E3    93            7272     	MOVC A, @A+DPTR		; Read lock byte
11E4    04            7273     	INC	A				
11E5    6003          7274     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      7275     
                      7276     IF ONE_S_CAPABLE == 0		
11E7    75EF12        7277     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      7278     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      7281     
                      7282     LOCK_BYTE_OK: 
                      7283     	; Disable the WDT.
                      7284     IF SIGNATURE_001 == 0F3H		
11EA    53D9BF        7285     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      7286     ENDIF
                      7287     IF SIGNATURE_001 == 0F8H		
                               	MOV	WDTCN, #0DEH		; Disable watchdog
                               	MOV	WDTCN, #0ADH		
                               ENDIF
                      7291     	; Initialize stack
11ED    7581C0        7292     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      7293     	; Initialize VDD monitor
11F0    43FF80        7294     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
11F3    1205C7        7295     	CALL	WAIT1MS			; Wait at least 100us
                      7296     IF ONE_S_CAPABLE == 0		
11F6    75EF02        7297     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      7298     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      7301     	; Set clock frequency
                      7302     IF SIGNATURE_001 == 0F3H		
11F9    43B203        7303     	ORL	OSCICN, #03H		; Set clock divider to 1 (not supported on 'f850)
                      7304     ENDIF
                      7305     IF SIGNATURE_001 == 0F8H		
                               	MOV	CLKSEL, #00H		; Set clock divider to 1 (not supported on 'f3xx)
                               ENDIF
11FC    E5B3          7308     	MOV	A, OSCICL				
11FE    2404          7309     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
1200    20E70D        7310     	JB	ACC.7, RESET_CAL_DONE	; Is carry (7bit) set? - branch
                      7311     
1203    F521          7312     	MOV	BIT_ACCESS_INT, A
                      7313     IF SIGNATURE_002 <> 010H		
1205    E5E3          7314     	MOV	A, OSCLCN
                      7315     ELSE
                               	MOV	A, OSCXCN
                               ENDIF
1207    20E006        7318     	JB	ACC.0, RESET_CAL_DONE	; Set if cal aleady done
                      7319     
120A    8521B3        7320     	MOV	OSCICL, BIT_ACCESS_INT
                      7321     IF SIGNATURE_002 <> 010H		
120D    43E301        7322     	ORL	OSCLCN, #01H			; Tag that cal is done
                      7323     ELSE
                               	ORL	OSCXCN, #01H			; Tag that cal is done
                               ENDIF
                      7326     
                      7327     RESET_CAL_DONE: 
                      7328     	; Switch power off
1210    114D          7329     	CALL	SWITCH_POWER_OFF
                      7330     	; Ports initialization
1212    7580FF        7331     MOV P0 , # 255 
1215    75A400        7332     MOV P0MDOUT , # 0 
1218    75F1F0        7333     MOV P0MDIN , # -16 
121B    75D4DF        7334     MOV P0SKIP , # -33 
121E    759002        7335     MOV P1 , # 2 
1221    75A5FC        7336     MOV P1MDOUT , # 252 
1224    75F2FD        7337     MOV P1MDIN , # -3 
1227    75D502        7338     MOV P1SKIP , # 2 
                      7339     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
122A    75A610        7342     MOV P2MDOUT , # 16 
                      7343     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      7350     	; Initialize the XBAR and related functionality
                      7351     	INITIALIZE_XBAR
122D    75A0FF        7351+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
1230    75F3F1        7351+1   MOV P2MDIN , # -15 
1233    75E241        7351+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      7352     	; Clear RAM
1236    E4            7353     	CLR	A				; Clear accumulator
1237    F8            7354     MOV R0 , A 
                      7355     CLEAR_RAM: 	
1238    F6            7356     MOV @ R0 , A 
1239    D8FD          7357     DJNZ R0 , CLEAR_RAM 
                      7358     	; Initialize LFSR
123B    756801        7359     	MOV	RANDOM, #1
                      7360     	; Set default programmed parameters
123E    1162          7361     	CALL	SET_DEFAULT_PARAMETERS
                      7362     	; Read all programmed parameters
1240    121742        7363     	CALL READ_ALL_EEPROM_PARAMETERS
                      7364     	; Set beep strength
1243    7898          7365     MOV R0 , # PGM_BEEP_STRENGTH 
1245    8673          7366     MOV BEEP_STRENGTH , @ R0 
                      7367     	; Set initial arm variable
1247    753001        7368     	MOV	INITIAL_ARM, #1
                      7369     	; Initializing beep
124A    C2AF          7370     	CLR	EA				; Disable interrupts explicitly
124C    1205E0        7371     	CALL WAIT200MS	
124F    1205F0        7372     	CALL BEEP_F1
1252    1205D6        7373     	CALL WAIT30MS
1255    1205F7        7374     	CALL BEEP_F2
1258    1205D6        7375     	CALL WAIT30MS
125B    1205FE        7376     	CALL BEEP_F3
125E    1205D6        7377     	CALL WAIT30MS
                      7378     IF MODE <= 1	; Main or tail
                      7379     	; Wait for receiver to initialize
1261    121867        7380     	CALL	WAIT1S
1264    1205E0        7381     	CALL	WAIT200MS
1267    1205E0        7382     	CALL	WAIT200MS
126A    1205DB        7383     	CALL	WAIT100MS
                      7384     ENDIF
                      7385     
                      7386     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7387     ;
                      7388     ; No signal entry point
                      7389     ;
                      7390     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7391     INIT_NO_SIGNAL: 
                      7392     	; Disable interrupts explicitly
126D    C2AF          7393     	CLR	EA				
                      7394     	; Check if input signal is high for more than 15ms
126F    78FA          7395     MOV R0 , # 250 
                      7396     INPUT_HIGH_CHECK_1: 
1271    79FA          7397     MOV R1 , # 250 
                      7398     INPUT_HIGH_CHECK_2: 
1273    308507        7399     JNB 128 . 5 , BOOTLOADER_DONE 
1276    D9FB          7400     DJNZ R1 , INPUT_HIGH_CHECK_2 
1278    D8F7          7401     DJNZ R0 , INPUT_HIGH_CHECK_1 
                      7402     
127A    021C00        7403     	LJMP	1C00H			; Jump to bootloader
                      7404     
                      7405     BOOTLOADER_DONE: 
                      7406     	; Decode parameters
127D    11CB          7407     	CALL	DECODE_PARAMETERS
                      7408     	; Decode settings
127F    11FE          7409     	CALL	DECODE_SETTINGS
                      7410     	; Set BEC voltage
1281    3168          7411     	CALL	SET_BEC_VOLTAGE
                      7412     	; Find throttle gain from stored min and max settings
1283    3169          7413     	CALL	FIND_THROTTLE_GAIN
                      7414     	; Set beep strength
1285    7898          7415     MOV R0 , # PGM_BEEP_STRENGTH 
1287    8673          7416     MOV BEEP_STRENGTH , @ R0 
                      7417     	; Switch power off
1289    114D          7418     	CALL	SWITCH_POWER_OFF
                      7419     	; Set clock frequency
                      7420     IF MCU_48MHZ == 1
                      7421     	SET_MCU_CLK_24MHZ
128B    75B680        7421+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
128E    75A900        7421+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
1291    757A00        7421+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      7422     ENDIF
                      7423     	; Timer control
1294    758850        7424     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      7425     	; Timer mode
1297    758912        7426     	MOV	TMOD, #12H		; Timer0 as 8bit, timer1 as 16bit
                      7427     	; Timer2: clk/12 for 128us and 32ms interrupts
129A    75C824        7428     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      7429     	; Timer3: clk/12 for commutation timing
129D    759104        7430     	MOV	TMR3CN, #04H		; Timer3 enabled
                      7431     	; PCA
12A0    75D840        7432     	MOV	PCA0CN, #40H		; PCA enabled
                      7433     	; Enable interrupts
12A3    75A822        7434     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
12A6    75B802        7435     	MOV	IP, #02H			; High priority to timer0 interrupts
12A9    75E690        7436     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      7437     	; Initialize comparator
12AC    759B80        7438     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
12AF    759D00        7439     	MOV	CPT0MD, #00H		; Comparator response time 100ns
                      7440     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #00H		; Comparator response time 100ns
                               ENDIF
                      7444     	; Initialize ADC
                      7445     	INITIALIZE_ADC			; Initialize ADC operation
12B2    75D10E        7445+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
                      7445+1   IF MCU_50MHZ ==0 
12B5    75BC58        7445+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
                      7445+1   ELSE 
                               MOV ADC0CF , # 0C0H  ; ADC CLOCK 2MHZ
                               ENDIF 
12B8    75BB09        7445+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
12BB    75BA11        7445+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
12BE    75E880        7445+1   MOV ADC0CN , # 80H  ; ADC ENABLED
12C1    1205C7        7446     	CALL	WAIT1MS
12C4    D2AF          7447     	SETB	EA				; Enable all interrupts
                      7448     	; Measure number of lipo cells
12C6    120921        7449     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      7450     	; Initialize RC pulse
                      7451     	RCP_INT_FIRST 					; Enable interrupt and set to first edge
12C9    53DACF        7451+1   ANL PCA0CPM0 , # 0CFH 
12CC    207E03        7451+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
12CF    43DA20        7451+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
12D2    307E03        7451+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
12D5    43DA10        7451+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7452     	RCP_INT_ENABLE		 			; Enable interrupt
12D8    43DA01        7452+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      7453     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
12DB    C2D8          7453+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
12DD    C271          7454     CLR FLAGS2 . 1 
12DF    1205E0        7455     	CALL WAIT200MS
                      7456     
                      7457     	; Measure PWM frequency
                      7458     MEASURE_PWM_FREQ_INIT: 	
12E2    D261          7459     SETB FLAGS0 . 1 
12E4    7B03          7460     MOV R3 , # 3 
                      7461     MEASURE_PWM_FREQ_START: 	
12E6    7A0C          7462     MOV R2 , # 12 
                      7463     MEASURE_PWM_FREQ_LOOP: 	
                      7464     	; Check if period diff was accepted
12E8    E55B          7465     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
12EA    7007          7466     	JNZ	MEASURE_PWM_FREQ_WAIT
                      7467     
12EC    7A0C          7468     MOV R2 , # 12 
12EE    DB03          7469     DJNZ R3 , ( $+5 ) 
12F0    02126D        7470     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      7471     
                      7472     MEASURE_PWM_FREQ_WAIT: 
12F3    1205D6        7473     	CALL	WAIT30MS						; Wait 30ms for new pulse
12F6    207003        7474     JB FLAGS2 . 0 , ( $+6 ) 
12F9    02126D        7475     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      7476     
12FC    C270          7477     CLR FLAGS2 . 0 
12FE    E55C          7478     	MOV	A, NEW_RCP					; Load value
1300    C3            7479     	CLR	C
1301    9402          7480     SUBB A , # 2 
1303    40E1          7481     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      7482     
1305    E52F          7483     	MOV	A, FLAGS3						; Check pwm frequency flags
1307    541F          7484     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1309    855E5D        7485     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
130C    F55E          7486     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
130E    B55DD5        7487     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      7488     
1311    DAD5          7489     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      7490     
                      7491     	; Clear measure pwm frequency flag
1313    C261          7492     CLR FLAGS0 . 1 
                      7493     	; Set up RC pulse interrupts after pwm frequency measurement
                      7494     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
1315    53DACF        7494+1   ANL PCA0CPM0 , # 0CFH 
1318    207E03        7494+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
131B    43DA20        7494+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
131E    307E03        7494+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1321    43DA10        7494+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7495     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
1324    C2D8          7495+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1326    C271          7496     CLR FLAGS2 . 1 
1328    78A2          7497     MOV R0 , # PGM_ENABLE_PWM_INPUT 
132A    E6            7498     MOV A , @ R0 
132B    7008          7499     	JNZ	TEST_FOR_ONESHOT				; If it is - proceed
                      7500     
132D    D274          7501     SETB FLAGS2 . 4 
132F    E52F          7502     	MOV	A, FLAGS3						; Clear pwm frequency flags
1331    54E0          7503     	ANL	A, #NOT((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1333    F52F          7504     	MOV	FLAGS3, A
                      7505     
                      7506     TEST_FOR_ONESHOT: 	
                      7507     	; Test whether signal is OneShot125
1335    C275          7508     CLR FLAGS2 . 5 
1337    752900        7509     	MOV	RCP_OUTSIDE_RANGE_CNT, #0		; Reset out of range counter
133A    1205DB        7510     	CALL WAIT100MS						; Wait for new RC pulse
133D    307409        7511     JNB FLAGS2 . 4 , VALIDATE_RCP_START 
                      7512     
1340    C3            7513     	CLR	C
1341    E529          7514     	MOV	A, RCP_OUTSIDE_RANGE_CNT			; Check how many pulses were outside normal PPM range (800-2160us)
1343    940A          7515     	SUBB	A, #10						
1345    4002          7516     	JC	VALIDATE_RCP_START
                      7517     
1347    D275          7518     SETB FLAGS2 . 5 
                      7519     
                      7520     	; Validate RC pulse
                      7521     VALIDATE_RCP_START: 	
1349    1205CC        7522     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
134C    7802          7523     MOV R0 , # 2 
134E    307402        7524     JNB FLAGS2 . 4 , ( $+5 ) 
                      7525     
1351    7800          7526     MOV R0 , # 0 
                      7527     
1353    C3            7528     	CLR	C
1354    E55C          7529     	MOV	A, NEW_RCP					; Load value
1356    98            7530     SUBB A , R0 
1357    40F0          7531     	JC	VALIDATE_RCP_START				; No - start over
                      7532     
                      7533     	; Beep arm sequence start signal
1359    C2AF          7534     	CLR 	EA							; Disable all interrupts
135B    1205F0        7535     	CALL BEEP_F1						; Signal that RC pulse is ready
135E    1205F0        7536     	CALL BEEP_F1
1361    1205F0        7537     	CALL BEEP_F1
1364    D2AF          7538     	SETB	EA							; Enable all interrupts
1366    1205E0        7539     	CALL WAIT200MS	
                      7540     
                      7541     	; Arming sequence start
1369    754A00        7542     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      7543     ARMING_START: 
                      7544     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION	; Check if bidirectional operation
                               	MOV	A, @TEMP1				
                               	CJNE	A, #3, ($+5)
                               
                               	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                               ENDIF
                      7551     
136C    1205CC        7552     	CALL WAIT3MS
136F    788C          7553     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1371    E6            7554     MOV A , @ R0 
1372    C3            7555     	CLR	C
1373    9401          7556     	SUBB	A, #1				; Is TX programming enabled?
1375    5003          7557     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      7558     
1377    021440        7559     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7560     
                      7561     ARMING_INITIAL_ARM_CHECK: 
137A    E530          7562     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
137C    C3            7563     	CLR	C
137D    9401          7564     	SUBB	A, #1				; Is it the initial arm sequence?
137F    5003          7565     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      7566     
1381    021440        7567     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      7568     
                      7569     ARMING_PPM_CHECK: 
1384    207435        7570     JB FLAGS2 . 4 , THROTTLE_HIGH_CAL_START 
                      7571     
                      7572     	; PWM tx program entry
1387    C3            7573     	CLR	C
1388    E55C          7574     	MOV	A, NEW_RCP			; Load new RC pulse value
138A    94FF          7575     SUBB A , # 255 
138C    5003          7576     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      7577     
138E    021440        7578     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7579     
                      7580     PROGRAM_BY_TX_ENTRY_PWM: 	
1391    C2AF          7581     	CLR	EA					; Disable all interrupts
1393    120605        7582     	CALL BEEP_F4
1396    D2AF          7583     	SETB	EA					; Enable all interrupts
1398    1205DB        7584     	CALL WAIT100MS
139B    C3            7585     	CLR	C
139C    E55C          7586     	MOV	A, NEW_RCP			; Load new RC pulse value
139E    9401          7587     SUBB A , # 1 
13A0    50EF          7588     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      7589     
                      7590     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
13A2    C2AF          7591     	CLR	EA					; Disable all interrupts
13A4    1205F0        7592     	CALL BEEP_F1
13A7    1205D1        7593     	CALL WAIT10MS
13AA    1205F0        7594     	CALL BEEP_F1
13AD    D2AF          7595     	SETB	EA					; Enable all interrupts
13AF    1205DB        7596     	CALL WAIT100MS
13B2    C3            7597     	CLR	C
13B3    E55C          7598     	MOV	A, NEW_RCP			; Load new RC pulse value
13B5    94FF          7599     SUBB A , # 255 
13B7    40E9          7600     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      7601     
13B9    0218EC        7602     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7603     
                      7604     	; PPM throttle calibration and tx program entry
                      7605     THROTTLE_HIGH_CAL_START: 
                      7606     IF MODE <= 1	; Main or tail
13BC    7F05          7607     MOV R7 , # 5 
                      7608     ELSE
                               	MOV	TEMP8, #2				; Set 1 seconds wait time
                               ENDIF
                      7611     THROTTLE_HIGH_CAL: 			
13BE    D27F          7612     SETB FLAGS3 . 7 
13C0    3169          7613     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13C2    1205DB        7614     	CALL WAIT100MS				; Wait for new throttle value
13C5    C2AF          7615     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
13C7    C27F          7616     CLR FLAGS3 . 7 
13C9    3169          7617     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13CB    AE5C          7618     MOV R6 , NEW_RCP 
13CD    C3            7619     	CLR	C
13CE    E55C          7620     	MOV	A, NEW_RCP			; Load new RC pulse value
13D0    947F          7621     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
13D2    D2AF          7622     	SETB	EA					; Enable interrupts
13D4    4074          7623     	JC	ARM_TARGET_UPDATED		; No - branch
                      7624     
13D6    1205C7        7625     	CALL WAIT1MS		
13D9    C2AF          7626     	CLR	EA					; Disable all interrupts
13DB    120605        7627     	CALL BEEP_F4
13DE    D2AF          7628     	SETB	EA					; Enable all interrupts
13E0    DFDC          7629     DJNZ R7 , THROTTLE_HIGH_CAL 
                      7630     
13E2    31A0          7631     	CALL	AVERAGE_THROTTLE
13E4    C3            7632     	CLR	C
13E5    EE            7633     MOV A , R6 
13E6    9405          7634     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
13E8    7897          7635     MOV R0 , # PGM_PPM_MAX_THROTTLE 
13EA    F6            7636     MOV @ R0 , A 
13EB    1205E0        7637     	CALL WAIT200MS				
13EE    121783        7638     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
13F1    12186F        7639     	CALL	SUCCESS_BEEP
                      7640     
                      7641     THROTTLE_LOW_CAL_START: 
13F4    7F0A          7642     MOV R7 , # 10 
                      7643     THROTTLE_LOW_CAL: 			
13F6    D27F          7644     SETB FLAGS3 . 7 
13F8    3169          7645     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13FA    1205DB        7646     	CALL WAIT100MS
13FD    C2AF          7647     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
13FF    C27F          7648     CLR FLAGS3 . 7 
1401    3169          7649     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1403    AE5C          7650     MOV R6 , NEW_RCP 
1405    C3            7651     	CLR	C
1406    E55C          7652     	MOV	A, NEW_RCP			; Load new RC pulse value
1408    947F          7653     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
140A    D2AF          7654     	SETB	EA					; Enable interrupts
140C    50E6          7655     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      7656     
140E    1205C7        7657     	CALL WAIT1MS		
1411    C2AF          7658     	CLR	EA					; Disable all interrupts
1413    1205F0        7659     	CALL BEEP_F1
1416    1205D1        7660     	CALL WAIT10MS
1419    1205F0        7661     	CALL BEEP_F1
141C    D2AF          7662     	SETB	EA					; Enable all interrupts
141E    DFD6          7663     DJNZ R7 , THROTTLE_LOW_CAL 
                      7664     
1420    31A0          7665     	CALL	AVERAGE_THROTTLE
1422    EE            7666     MOV A , R6 
1423    2405          7667     	ADD	A, #5				; Add about 2%
1425    7896          7668     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1427    F6            7669     MOV @ R0 , A 
1428    1205E0        7670     	CALL WAIT200MS				
142B    121783        7671     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
142E    12189E        7672     	CALL	SUCCESS_BEEP_INVERTED
                      7673     
                      7674     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
1431    1205DB        7675     	CALL WAIT100MS
1434    3169          7676     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1436    C3            7677     	CLR	C
1437    E55C          7678     	MOV	A, NEW_RCP			; Load new RC pulse value
1439    94FF          7679     SUBB A , # 255 
143B    40F4          7680     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      7681     
143D    0218EC        7682     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7683     
                      7684     PROGRAM_BY_TX_CHECKED: 
1440    C3            7685     	CLR	C
1441    E55C          7686     	MOV	A, NEW_RCP			; Load new RC pulse value
1443    954A          7687     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
1445    4003          7688     	JC	ARM_TARGET_UPDATED		; No - do not update
                      7689     
1447    855C4A        7690     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      7691     
                      7692     ARM_TARGET_UPDATED: 
144A    1205DB        7693     	CALL WAIT100MS				; Wait for new throttle value
144D    7801          7694     MOV R0 , # 1 
144F    7988          7695     MOV R1 , # PGM_DIRECTION 
1451    E7            7696     MOV A , @ R1 
1452    B40302        7697     	CJNE	A, #3, ($+5)			; No - branch
                      7698     
1455    7805          7699     MOV R0 , # ( RCP_STOP+4 ) 
                      7700     
1457    C3            7701     	CLR	C
1458    E55C          7702     	MOV	A, NEW_RCP			; Load new RC pulse value
145A    98            7703     SUBB A , R0 
145B    4002          7704     	JC	ARM_END_BEEP			; Yes - proceed
                      7705     
145D    616C          7706     	JMP	ARMING_START			; No - start over
                      7707     
                      7708     ARM_END_BEEP: 
                      7709     	; Beep arm sequence end signal
145F    C2AF          7710     	CLR 	EA					; Disable all interrupts
1461    120605        7711     	CALL BEEP_F4				; Signal that rcpulse is ready
1464    120605        7712     	CALL BEEP_F4
1467    120605        7713     	CALL BEEP_F4
146A    D2AF          7714     	SETB	EA					; Enable all interrupts
146C    1205E0        7715     	CALL WAIT200MS
                      7716     
                      7717     	; Clear initial arm variable
146F    753000        7718     	MOV	INITIAL_ARM, #0
                      7719     
                      7720     	; Armed and waiting for power on
                      7721     WAIT_FOR_POWER_ON: 
1472    E4            7722     	CLR	A
1473    F531          7723     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
1475    F532          7724     	MOV	POWER_ON_WAIT_CNT_H, A	
                      7725     WAIT_FOR_POWER_ON_LOOP: 
1477    0531          7726     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
1479    E531          7727     	MOV	A, POWER_ON_WAIT_CNT_L
147B    F4            7728     	CPL	A
147C    7039          7729     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      7730     
147E    0532          7731     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
1480    789A          7732     MOV R0 , # PGM_BEACON_DELAY 
1482    E6            7733     MOV A , @ R0 
1483    7819          7734     MOV R0 , # 25 
1485    14            7735     	DEC	A
1486    6012          7736     	JZ	BEEP_DELAY_SET
                      7737     
1488    7832          7738     MOV R0 , # 50 
148A    14            7739     	DEC	A
148B    600D          7740     	JZ	BEEP_DELAY_SET
                      7741     
148D    787D          7742     MOV R0 , # 125 
148F    14            7743     	DEC	A
1490    6008          7744     	JZ	BEEP_DELAY_SET
                      7745     
1492    78FA          7746     MOV R0 , # 250 
1494    14            7747     	DEC	A
1495    6003          7748     	JZ	BEEP_DELAY_SET
                      7749     
1497    753200        7750     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      7751     
                      7752     BEEP_DELAY_SET: 
149A    C3            7753     	CLR	C
149B    E532          7754     	MOV	A, POWER_ON_WAIT_CNT_H
149D    98            7755     SUBB A , R0 
149E    4017          7756     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      7757     
14A0    1532          7758     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
14A2    7531B4        7759     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
14A5    7899          7760     MOV R0 , # PGM_BEACON_STRENGTH 
14A7    8673          7761     MOV BEEP_STRENGTH , @ R0 
14A9    C2AF          7762     	CLR 	EA					; Disable all interrupts
14AB    120605        7763     	CALL BEEP_F4				; Signal that there is no signal
14AE    D2AF          7764     	SETB	EA					; Enable all interrupts
14B0    7898          7765     MOV R0 , # PGM_BEEP_STRENGTH 
14B2    8673          7766     MOV BEEP_STRENGTH , @ R0 
14B4    1205DB        7767     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      7768     
                      7769     WAIT_FOR_POWER_ON_NO_BEEP: 
14B7    1205D1        7770     	CALL WAIT10MS
14BA    E52A          7771     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
14BC    7005          7772     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      7773     
14BE    307402        7774     JNB FLAGS2 . 4 , WAIT_FOR_POWER_ON_PPM_NOT_MISSING 
                      7775     
14C1    416D          7776     	JMP	INIT_NO_SIGNAL					; If ppm and pulses missing - go back to detect input signal
                      7777     
                      7778     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
14C3    7801          7779     MOV R0 , # 1 
14C5    207402        7780     JB FLAGS2 . 4 , ( $+5 ) 
                      7781     
14C8    7806          7782     MOV R0 , # ( RCP_STOP+5 ) 
                      7783     
14CA    C3            7784     	CLR	C
14CB    E55C          7785     	MOV	A, NEW_RCP			; Load new RC pulse value
14CD    98            7786     SUBB A , R0 
14CE    40A7          7787     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      7788     
                      7789     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION	; Check if bidirectional operation
                               	MOV	A, @TEMP1				
                               	CLR	C
                               	SUBB	A, #3
                               	JZ 	WAIT_FOR_POWER_ON_CHECK_TIMEOUT	; Do not wait if bidirectional operation
                               ENDIF
                      7796     
14D0    1205DB        7797     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      7798     
                      7799     WAIT_FOR_POWER_ON_CHECK_TIMEOUT: 
14D3    E52A          7800     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
14D5    7003          7801     	JNZ	($+5)				; If it is not zero - proceed
                      7802     
14D7    02126D        7803     	LJMP	INIT_NO_SIGNAL			; If it is zero (pulses missing) - go back to detect input signal
                      7804     
                      7805     
                      7806     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7807     ;
                      7808     ; Start entry point
                      7809     ;
                      7810     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7811     INIT_START: 
14DA    C2AF          7812     	CLR	EA
14DC    114D          7813     	CALL SWITCH_POWER_OFF
14DE    E4            7814     	CLR	A
14DF    F522          7815     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
14E1    F523          7816     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
14E3    F524          7817     	MOV	CURRENT_PWM, A			; Set current pwm to zero
14E5    F525          7818     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
14E7    F526          7819     	MOV	CURRENT_PWM_LIM_DITH, A
14E9    F567          7820     	MOV	PWM_DITHER_EXCESS_POWER, A
14EB    D2AF          7821     	SETB	EA
14ED    7885          7822     MOV R0 , # PGM_MOTOR_IDLE 
14EF    E6            7823     MOV A , @ R0 
14F0    C3            7824     	CLR	C
14F1    33            7825     	RLC	A
14F2    F565          7826     	MOV	PWM_MOTOR_IDLE, A
14F4    E4            7827     	CLR	A
14F5    F542          7828     	MOV	GOV_TARGET_L, A		; Set target to zero
14F7    F543          7829     	MOV	GOV_TARGET_H, A
14F9    F544          7830     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
14FB    F545          7831     	MOV	GOV_INTEGRAL_H, A
14FD    F546          7832     	MOV	GOV_INTEGRAL_X, A
14FF    F570          7833     	MOV	ADC_CONVERSION_CNT, A
1501    F52C          7834     	MOV	FLAGS0, A				; Clear flags0
1503    F52D          7835     	MOV	FLAGS1, A				; Clear flags1
1505    F536          7836     	MOV	DEMAG_DETECTED_METRIC, A	; Clear demag metric
                      7837     	;**** **** **** **** ****
                      7838     	; Motor start beginning
                      7839     	;**** **** **** **** **** 
1507    757008        7840     MOV ADC_CONVERSION_CNT , # 8 
                      7841     	SET_ADC_IP_TEMP
150A    75BB10        7841+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
150D    1205C7        7842     	CALL WAIT1MS
1510    1209B4        7843     	CALL START_ADC_CONVERSION
                      7844     READ_INITIAL_TEMP: 
                      7845     	GET_ADC_STATUS 
1513    E5E8          7845+1   MOV A , ADC0CN 
1515    20ECFB        7846     	JB	AD0BUSY, READ_INITIAL_TEMP
                      7847     	READ_ADC_RESULT						; Read initial temperature
1518    A8BD          7847+1   MOV R0 , ADC0L 
151A    A9BE          7847+1   MOV R1 , ADC0H 
151C    E9            7848     MOV A , R1 
151D    7001          7849     	JNZ	($+3)							; Is reading below 256?
                      7850     
151F    F8            7851     MOV R0 , A 
                      7852     
1520    8871          7853     MOV CURRENT_AVERAGE_TEMP , R0 
1522    1209B8        7854     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1525    757008        7855     MOV ADC_CONVERSION_CNT , # 8 
                      7856     	SET_ADC_IP_TEMP
1528    75BB10        7856+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      7857     	; Set up start operating conditions
152B    7887          7858     MOV R0 , # PGM_PWM_FREQ 
152D    E6            7859     MOV A , @ R0 
152E    FE            7860     MOV R6 , A 
152F    7602          7861     MOV @ R0 , # 2 
1531    11CB          7862     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1533    7887          7863     MOV R0 , # PGM_PWM_FREQ 
1535    EE            7864     MOV A , R6 
1536    F6            7865     MOV @ R0 , A 
                      7866     	; Set max allowed power
1537    C2AF          7867     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
1539    7561FF        7868     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
153C    120A73        7869     	CALL SET_STARTUP_PWM
153F    852261        7870     	MOV	PWM_LIMIT, REQUESTED_PWM
1542    852262        7871     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
1545    852263        7872     	MOV	PWM_LIMIT_BY_RPM, REQUESTED_PWM
1548    D2AF          7873     	SETB	EA
154A    752201        7874     	MOV	REQUESTED_PWM, #1			; Set low pwm again after calling set_startup_pwm
154D    752401        7875     	MOV	CURRENT_PWM, #1
1550    752501        7876     	MOV	CURRENT_PWM_LIMITED, #1	
1553    752601        7877     	MOV	CURRENT_PWM_LIM_DITH, #1
1556    856069        7878     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1559    756A01        7879     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      7880     	; Begin startup sequence
                      7881     IF MCU_48MHZ == 1
                      7882     	SET_MCU_CLK_48MHZ
155C    75B690        7882+1   MOV FLSCL , # 90H  ; SET FLASH TIMING FOR 48MHZ
155F    75A903        7882+1   MOV CLKSEL , # 3  ; SET CLOCK TO 48MHZ
1562    757A01        7882+1   MOV CLOCK_SET_AT_48MHZ , # 1 
                      7883     ENDIF
1565    7888          7884     MOV R0 , # PGM_DIRECTION 
1567    E6            7885     MOV A , @ R0 
1568    B40307        7886     	CJNE	A, #3, INIT_START_BIDIR_DONE
                      7887     
156B    C27D          7888     CLR FLAGS3 . 5 
156D    307602        7889     JNB FLAGS2 . 6 , ( $+5 ) 
1570    D27D          7890     SETB FLAGS3 . 5 
                      7891     
                      7892     INIT_START_BIDIR_DONE: 
1572    D268          7893     SETB FLAGS1 . 0 
1574    D269          7894     SETB FLAGS1 . 1 
1576    753300        7895     	MOV	STARTUP_CNT, #0			; Reset counter
1579    120FB3        7896     	CALL COMM5COMM6				; Initialize commutation
157C    120FD8        7897     	CALL COMM6COMM1				
157F    120A9A        7898     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
1582    120A9A        7899     	CALL	CALC_NEXT_COMM_TIMING		
1585    120A93        7900     	CALL INITIALIZE_TIMING			; Initialize timing
1588    120A9A        7901     	CALL	CALC_NEXT_COMM_TIMING		
158B    120BF7        7902     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
158E    120A93        7903     	CALL	INITIALIZE_TIMING			; Initialize timing
1591    120CBA        7904     	CALL	WAIT_BEFORE_ZC_SCAN			; Set up comparator timeout
1594    0215A3        7905     	JMP	RUN1
                      7906     
                      7907     
                      7908     
                      7909     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7910     ;
                      7911     ; Run entry point
                      7912     ;
                      7913     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7914     DAMPED_TRANSITION: 
                      7915     	; Transition from nondamped to damped if applicable
1597    C2AF          7916     	CLR	EA
1599    11CB          7917     	CALL	DECODE_PARAMETERS		; Set programmed parameters
159B    D2AF          7918     	SETB	EA
159D    757000        7919     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      7920     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
15A0    75BB09        7920+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      7921     
                      7922     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      7923     ; Out_cA changes from low to high
                      7924     RUN1: 
15A3    120D0F        7925     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
15A6    120E14        7926     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
15A9    120DF5        7927     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
15AC    1206D0        7928     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
15AF    120E31        7929     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
15B2    120E7B        7930     	CALL COMM1COMM2			; Commutate
15B5    120A9A        7931     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
15B8    120BE6        7932     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
15BB    120BF7        7933     	CALL CALC_NEW_WAIT_TIMES
15BE    120CBA        7934     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      7935     
                      7936     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      7937     ; Out_cB changes from high to low
                      7938     RUN2: 
15C1    120CFE        7939     	CALL WAIT_FOR_COMP_OUT_LOW
15C4    120E14        7940     	CALL SETUP_COMM_WAIT	
15C7    120DF5        7941     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
15CA    306D03        7942     JNB FLAGS1 . 5 , ( $+6 ) 
15CD    120770        7943     	LCALL CALC_GOVERNOR_PROP_ERROR
15D0    206703        7944     JB FLAGS0 . 7 , ( $+6 ) 
15D3    1208C4        7945     	LCALL SET_PWM_LIMIT_LOW_RPM
15D6    306703        7946     JNB FLAGS0 . 7 , ( $+6 ) 
15D9    12090B        7947     	LCALL SET_PWM_LIMIT_HIGH_RPM
15DC    120E31        7948     	CALL WAIT_FOR_COMM
15DF    120EA0        7949     	CALL COMM2COMM3
15E2    120A9A        7950     	CALL CALC_NEXT_COMM_TIMING
15E5    120BE6        7951     	CALL WAIT_ADVANCE_TIMING
15E8    120BF7        7952     	CALL CALC_NEW_WAIT_TIMES
15EB    120CBA        7953     	CALL WAIT_BEFORE_ZC_SCAN	
                      7954     
                      7955     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      7956     ; Out_cC changes from low to high
                      7957     RUN3: 
15EE    120D0F        7958     	CALL WAIT_FOR_COMP_OUT_HIGH
15F1    120E14        7959     	CALL SETUP_COMM_WAIT	
15F4    120DF5        7960     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
15F7    306D03        7961     JNB FLAGS1 . 5 , ( $+6 ) 
15FA    1207AC        7962     	LCALL CALC_GOVERNOR_INT_ERROR
15FD    120E31        7963     	CALL WAIT_FOR_COMM
1600    120F17        7964     	CALL COMM3COMM4
1603    120A9A        7965     	CALL CALC_NEXT_COMM_TIMING
1606    120BE6        7966     	CALL WAIT_ADVANCE_TIMING
1609    120BF7        7967     	CALL CALC_NEW_WAIT_TIMES
160C    120CBA        7968     	CALL WAIT_BEFORE_ZC_SCAN	
                      7969     
                      7970     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      7971     ; Out_cA changes from high to low
                      7972     RUN4: 
160F    120CFE        7973     	CALL WAIT_FOR_COMP_OUT_LOW
1612    120E14        7974     	CALL SETUP_COMM_WAIT	
1615    120DF5        7975     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
1618    306D03        7976     JNB FLAGS1 . 5 , ( $+6 ) 
161B    12080A        7977     	LCALL CALC_GOVERNOR_PROP_CORRECTION
161E    120E31        7978     	CALL WAIT_FOR_COMM
1621    120F3C        7979     	CALL COMM4COMM5
1624    120A9A        7980     	CALL CALC_NEXT_COMM_TIMING
1627    120BE6        7981     	CALL WAIT_ADVANCE_TIMING
162A    120BF7        7982     	CALL CALC_NEW_WAIT_TIMES
162D    120CBA        7983     	CALL WAIT_BEFORE_ZC_SCAN	
                      7984     
                      7985     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      7986     ; Out_cB changes from low to high
                      7987     RUN5: 
1630    120D0F        7988     	CALL WAIT_FOR_COMP_OUT_HIGH
1633    120E14        7989     	CALL SETUP_COMM_WAIT	
1636    120DF5        7990     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
1639    306D03        7991     JNB FLAGS1 . 5 , ( $+6 ) 
163C    120868        7992     	LCALL CALC_GOVERNOR_INT_CORRECTION
163F    120E31        7993     	CALL WAIT_FOR_COMM
1642    120FB3        7994     	CALL COMM5COMM6
1645    120A9A        7995     	CALL CALC_NEXT_COMM_TIMING
1648    120BE6        7996     	CALL WAIT_ADVANCE_TIMING
164B    120BF7        7997     	CALL CALC_NEW_WAIT_TIMES
164E    120CBA        7998     	CALL WAIT_BEFORE_ZC_SCAN	
                      7999     
                      8000     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      8001     ; Out_cC changes from high to low
                      8002     RUN6: 
1651    1209B4        8003     	CALL START_ADC_CONVERSION
1654    120CFE        8004     	CALL WAIT_FOR_COMP_OUT_LOW
1657    120E14        8005     	CALL SETUP_COMM_WAIT	
165A    120DF5        8006     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
165D    120E31        8007     	CALL WAIT_FOR_COMM
1660    120FD8        8008     	CALL COMM6COMM1
1663    1209B8        8009     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1666    120A9A        8010     	CALL CALC_NEXT_COMM_TIMING
1669    120BE6        8011     	CALL WAIT_ADVANCE_TIMING
166C    120BF7        8012     	CALL CALC_NEW_WAIT_TIMES
166F    120CBA        8013     	CALL WAIT_BEFORE_ZC_SCAN	
                      8014     
                      8015     	; Check if it is direct startup
1672    30692F        8016     JNB FLAGS1 . 1 , NORMAL_RUN_CHECKS 
1675    206B2C        8017     JB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      8018     
                      8019     	; Set spoolup power variables
1678    856461        8020     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
167B    856462        8021     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
167E    856069        8022     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1681    756A01        8023     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8024     	; Check startup counter
1684    7918          8025     MOV R1 , # 24 
1686    7A0C          8026     MOV R2 , # 12 
1688    C3            8027     	CLR	C
1689    E533          8028     	MOV	A, STARTUP_CNT				; Load counter
168B    99            8029     SUBB A , R1 
168C    4009          8030     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      8031     
168E    C269          8032     CLR FLAGS1 . 1 
1690    D26A          8033     SETB FLAGS1 . 2 
1692    8A34          8034     MOV INITIAL_RUN_ROT_CNT , R2 
                      8035     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               ENDIF
                      8038     IF MODE == 2	; Multi
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG
                               	MOV	PWM_LIMIT_BY_RPM, PWM_SPOOLUP_BEG
                               ENDIF
1694    0216A4        8042     	JMP	NORMAL_RUN_CHECKS
                      8043     
                      8044     DIRECT_START_CHECK_RCP: 
1697    C3            8045     	CLR	C
1698    E55C          8046     	MOV	A, NEW_RCP				; Load new pulse value
169A    9401          8047     SUBB A , # 1 
169C    4003          8048     	JC	($+5)
                      8049     
169E    0215A3        8050     	LJMP	RUN1						; Continue to run 
                      8051     
16A1    0216FB        8052     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8053     
                      8054     
                      8055     NORMAL_RUN_CHECKS: 
                      8056     	; Check if it is initial run phase
16A4    306A1B        8057     JNB FLAGS1 . 2 , INITIAL_RUN_PHASE_DONE 
16A7    206B18        8058     JB FLAGS1 . 3 , INITIAL_RUN_PHASE_DONE 
                      8059     
                      8060     	; Decrement startup rotaton count
16AA    E534          8061     	MOV	A, INITIAL_RUN_ROT_CNT
16AC    14            8062     	DEC	A
                      8063     	; Check number of nondamped rotations
16AD    7004          8064     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      8065     
16AF    C26A          8066     CLR FLAGS1 . 2 
16B1    A197          8067     	JMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      8068     
                      8069     NORMAL_RUN_CHECK_STARTUP_ROT: 
16B3    F534          8070     	MOV	INITIAL_RUN_ROT_CNT, A		; Not zero - store counter
                      8071     
16B5    C3            8072     	CLR	C
16B6    E55C          8073     	MOV	A, NEW_RCP				; Load new pulse value
16B8    9401          8074     SUBB A , # 1 
16BA    4003          8075     	JC	($+5)
                      8076     
16BC    0215A3        8077     	LJMP	RUN1						; Continue to run 
                      8078     
16BF    0216FB        8079     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8080     
                      8081     INITIAL_RUN_PHASE_DONE: 
                      8082     IF MODE == 0	; Main
                      8083     	; Check if throttle is zeroed
16C2    C3            8084     	CLR	C
16C3    E55F          8085     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
16C5    9401          8086     	SUBB	A, #1					; Is number of stop RC pulses above limit?
16C7    4009          8087     	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                      8088     
16C9    856462        8089     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
16CC    856069        8090     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
16CF    756A01        8091     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8092     
                      8093     RUN6_CHECK_RCP_STOP_COUNT: 
                      8094     ENDIF
                      8095     	; Exit run loop after a given time
16D2    C3            8096     	CLR	C
16D3    E55F          8097     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
16D5    78FA          8098     MOV R0 , # 250 
16D7    98            8099     SUBB A , R0 
16D8    5021          8100     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      8101     
16DA    307404        8102     JNB FLAGS2 . 4 , RUN6_CHECK_DIR 
                      8103     
16DD    E52A          8104     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
16DF    601A          8105     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      8106     
                      8107     RUN6_CHECK_DIR: 
                      8108     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION		; Check if bidirectional operation
                               	MOV	A, @TEMP1				
                               	CJNE	A, #3, RUN6_CHECK_SPEED
                               
                               	JB	FLAGS3.PGM_DIR_REV, RUN6_CHECK_DIR_REV		; Check if actual rotation direction
                               	JB	FLAGS2.RCP_DIR_REV, RUN6_CHECK_DIR_CHANGE	; Matches force direction
                               	AJMP	RUN6_CHECK_SPEED
                               
                               RUN6_CHECK_DIR_REV:
                               	JNB	FLAGS2.RCP_DIR_REV, RUN6_CHECK_DIR_CHANGE
                               	AJMP	RUN6_CHECK_SPEED
                               
                               RUN6_CHECK_DIR_CHANGE:
                               	JB	FLAGS1.DIR_CHANGE_BRAKE, RUN6_CHECK_SPEED
                               
                               	SETB	FLAGS1.DIR_CHANGE_BRAKE		; Set brake flag
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set max power while braking
                               	JMP	RUN4						; Go back to run 4, thereby changing force direction
                               
                               RUN6_CHECK_SPEED:
                               ENDIF
16E1    78F0          8130     MOV R0 , # 0F0H 
16E3    306B05        8131     JNB FLAGS1 . 3 , RUN6_BRAKE_DONE 
                      8132     
16E6    856461        8133     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG 	; Set max power while braking
16E9    7820          8134     MOV R0 , # 20H 
                      8135     
                      8136     RUN6_BRAKE_DONE: 
16EB    C3            8137     	CLR	C
16EC    E53E          8138     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
16EE    98            8139     SUBB A , R0 
16EF    5002          8140     	JNC	($+4)					; Yes - stop or turn direction 
16F1    A1A3          8141     	AJMP	RUN1						; No - go back to run 1
                      8142     
                      8143     IF MODE >= 1	; Tail or multi
                               	JNB	FLAGS1.DIR_CHANGE_BRAKE, RUN_TO_WAIT_FOR_POWER_ON	; If it is not a direction change - stop
                               
                               	CLR	FLAGS1.DIR_CHANGE_BRAKE		; Clear brake flag
                               	CLR	FLAGS3.PGM_DIR_REV			; Set spinning direction. Default fwd
                               	JNB	FLAGS2.RCP_DIR_REV, ($+5)	; Check force direction
                               	SETB	FLAGS3.PGM_DIR_REV			; Set spinning direction
                               	SETB	FLAGS1.INITIAL_RUN_PHASE		
                               	MOV	INITIAL_RUN_ROT_CNT, #18
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set initial max power
                               	AJMP	RUN1						; Go back to run 1 
                               ENDIF
                      8155     
                      8156     RUN_TO_WAIT_FOR_POWER_ON_FAIL: 	
16F3    0535          8157     	INC	STALL_CNT					; Increment stall count
16F5    E55C          8158     	MOV	A, NEW_RCP				; Check if RCP is zero, then it is a normal stop			
16F7    6002          8159     	JZ	RUN_TO_WAIT_FOR_POWER_ON
16F9    C1FE          8160     	AJMP	RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE
                      8161     
                      8162     RUN_TO_WAIT_FOR_POWER_ON: 	
16FB    753500        8163     	MOV	STALL_CNT, #0
                      8164     
                      8165     RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE: 
16FE    C2AF          8166     	CLR	EA
1700    114D          8167     	CALL SWITCH_POWER_OFF
1702    7887          8168     MOV R0 , # PGM_PWM_FREQ 
1704    E6            8169     MOV A , @ R0 
1705    FE            8170     MOV R6 , A 
1706    7602          8171     MOV @ R0 , # 2 
1708    11CB          8172     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
170A    7887          8173     MOV R0 , # PGM_PWM_FREQ 
170C    EE            8174     MOV A , R6 
170D    F6            8175     MOV @ R0 , A 
170E    E4            8176     	CLR	A
170F    F522          8177     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
1711    F523          8178     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
1713    F524          8179     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1715    F525          8180     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1717    F526          8181     	MOV	CURRENT_PWM_LIM_DITH, A	
1719    F565          8182     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
171B    C268          8183     CLR FLAGS1 . 0 
                      8184     IF MCU_48MHZ == 1
                      8185     	SET_MCU_CLK_24MHZ
171D    75B680        8185+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
1720    75A900        8185+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
1723    757A00        8185+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      8186     ENDIF
1726    D2AF          8187     	SETB	EA
1728    1205C7        8188     	CALL	WAIT1MS					; Wait for pwm to be stopped
172B    114D          8189     	CALL SWITCH_POWER_OFF
                      8190     IF MODE == 0	; Main
172D    307406        8191     JNB FLAGS2 . 4 , RUN_TO_NEXT_STATE_MAIN 
                      8192     
1730    E52A          8193     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1732    7002          8194     	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                      8195     
1734    416D          8196     	JMP	INIT_NO_SIGNAL				; If it is zero (pulses missing) - go back to detect input signal
                      8197     
                      8198     RUN_TO_NEXT_STATE_MAIN: 
1736    788D          8199     MOV R0 , # PGM_MAIN_REARM_START 
1738    E6            8200     MOV A , @ R0 
1739    C3            8201     	CLR	C
173A    9401          8202     	SUBB	A, #1					; Is re-armed start enabled?
173C    4002          8203     	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                      8204     
173E    6149          8205     	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                      8206     
                      8207     JMP_WAIT_FOR_POWER_ON: 
1740    8172          8208     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      8209     ENDIF
                      8210     IF MODE >= 1	; Tail or multi
                               	JNB	FLAGS2.RCP_PPM, JMP_WAIT_FOR_POWER_ON	; If flag is not set (PWM) - branch
                               
                               	CLR	C
                               	MOV	A, STALL_CNT
                               	SUBB	A, #5
                               	JC	JMP_WAIT_FOR_POWER_ON
                               	JMP	INIT_NO_SIGNAL
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      8222     
                      8223     
                      8224     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8225     
                      8226     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      8886     $INCLUDE (BLHELIBOOTLOAD.INC)			; Include source code for bootloader
                      9279     
                      9280     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      9281     
                      9282     
------                9283     CSEG AT 19FDH
                      9284     RESET: 
19FD    0211CB        9285     LJMP	PGM_START
                      9286     
                      9287     
                      9288     
                      9289     
                      9290     END
MACRO ASSEMBLER BLHELI                                      12/28/15 18:36:01 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

SET4 . . . . . . .  C ADDR   1CC5H   A 
ID3. . . . . . . .  C ADDR   1C52H   A 
BYTE_CNTH. . . . .  D ADDR   0028H   A 
CRCH . . . . . . .  D ADDR   0023H   A 
CMDL . . . . . . .    REG    R4             
XH . . . . . . . .    REG    R1             
NORMAL_RUN_CHECK_~  C ADDR   16B3H   A 
DECODE_DEMAG_HIGH.  C ADDR   1152H   A 
COMM61_DAMP_REV. .  C ADDR   0FFEH   A 
COMP_WAIT_ON_COMP~  C ADDR   0D46H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CFDH   A 
CHECK_TEMP_VOLTAG~  C ADDR   09B8H   A 
MEASURE_LIPO_WAIT~  C ADDR   0932H   A 
GOVERNOR_LIMIT_IN~  C ADDR   088FH   A 
GOVERNOR_CORR_NEG~  C ADDR   0857H   A 
PCA_INT_PPM_BELOW~  C ADDR   04FFH   A 
EEP_PGM_MAIN_SPOO~  C ADDR   1A22H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
TIMER0_OVERFLOW_V~  D ADDR   0079H   A 
PPM_THROTTLE_GAIN.  D ADDR   0072H   A 
LIPO_ADC_LIMIT_H .  D ADDR   006FH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005EH   A 
RCP_EDGE_H . . . .  D ADDR   0058H   A 
FLAGS3 . . . . . .  D ADDR   002FH   A 
RCP_PREV_EDGE_L. .  D ADDR   0027H   A 
ADC_IP . . . . . .  N NUMB   0001h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
POLARIS_THUNDER_4~  N NUMB   008Fh            
POLARIS_THUNDER_3~  N NUMB   008Dh            
POLARIS_THUNDER_1~  N NUMB   0087h            
SET5 . . . . . . .  C ADDR   1CCBH   A 
ID4. . . . . . . .  C ADDR   1C5DH   A 
BOOT_START . . . .  N NUMB   1C00h            
FUNCTION_BEEP. . .  C ADDR   18D3H   A 
INIT_START . . . .  C ADDR   14DAH   A 
PROGRAM_BY_TX_ENT~  C ADDR   1391H   A 
FIND_THROTTLE_GAI~  C ADDR   1183H   A 
COMM45_NONDAMP . .  C ADDR   0F82H   A 
COMM4COMM5 . . . .  C ADDR   0F3CH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B41H   A 
CHECK_VOLTAGE_SPO~  C ADDR   0A56H   A 
SET_PWM_LIMIT_HIG~  C ADDR   091BH   A 
SET_PWM_DEMAG_DONE  C ADDR   08E0H   A 
CALC_GOVERNOR_SUB~  C ADDR   0763H   A 
PCA_INT_RESTORE_E~  C ADDR   047CH   A 
T2H_INT_RCP_STOP .  C ADDR   028BH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0140H   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
EEP_MAIN_REARM_ST~  C ADDR   1A10H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006DH   A 
RANDOM . . . . . .  D ADDR   0068H   A 
PWM_MOTOR_IDLE . .  D ADDR   0065H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005DH   A 
NEXT_WT_START_L. .  D ADDR   0053H   A 
COMM_PERIOD4X_H. .  D ADDR   003EH   A 
PWM_START. . . . .  N NUMB   0032h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D6h            
EMAX_NANO_20A_TAIL  N NUMB   00B3h            
PLATINUM_50AV3_TA~  N NUMB   00A1h            
PLATINUM_PRO_30A_~  N NUMB   009Ah            
POLARIS_THUNDER_4~  N NUMB   0090h            
H_KING_35A_TAIL. .  N NUMB   0080h            
SET6 . . . . . . .  C ADDR   1CD3H   A 
ID5. . . . . . . .  C ADDR   1C6AH   A 
ERRORPROG. . . . .  N NUMB   00C5h            
ERRORCRC . . . . .  N NUMB   00C2h            
BOOT_DELAY . . . .  N NUMB   5F5E10h            
PARAVAL_BEEP . . .  C ADDR   18E1H   A 
COMM45_DAMP_REV. .  C ADDR   0F62H   A 
COMM23_NFET_DONE .  C ADDR   0EF8H   A 
GOVERNOR_CHECK_PWM  C ADDR   07E5H   A 
GOVERNOR_ACTIVATE.  C ADDR   071CH   A 
PWM_AFET_DAMPED_D~  C ADDR   018AH   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
DEMAG_DETECTED_ME~  D ADDR   0036H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
SIGNATURE_001. . .  N NUMB   00F3h            
RTX_PORT . . . . .  N NUMB   0080h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
EMAX_NANO_20A_MUL~  N NUMB   00B4h            
PLATINUM_50AV3_MU~  N NUMB   00A2h            
POLARIS_THUNDER_6~  N NUMB   0092h            
H_KING_35A_MULTI .  N NUMB   0081h            
TURNIGY_AE_25A_MA~  N NUMB   0043h            
TURNIGY_AE_20A_TA~  N NUMB   0041h            
TURNIGY_PLUSH_10A~  N NUMB   001Fh            
XP_35A_SW_TAIL . .  N NUMB   0014h            
GETC . . . . . . .  C ADDR   1D7FH   A 
BIT_CNT. . . . . .  D ADDR   0026H   A 
BOOT_PAGES . . . .  N NUMB   0001h            
WRITE_EEPROM_SIGN~  C ADDR   17F5H   A 
WAIT_FOR_POWER_ON.  C ADDR   1472H   A 
THROTTLE_LOW_CAL_~  C ADDR   13F4H   A 
ERASE_AND_STORE_A~  C ADDR   1783H   A 
PROGRAM_BY_TX_CHE~  C ADDR   1440H   A 
ARMING_INITIAL_AR~  C ADDR   137AH   A 
FIND_THROTTLE_GAI~  C ADDR   117CH   A 
SET_DEFAULT_PARAM~  C ADDR   1062H   A 
COMM56_REV . . . .  C ADDR   0FC7H   A 
COMM23_NFET_OFF_R~  C ADDR   0EDCH   A 
COMP_READ_OK . . .  C ADDR   0DDEH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0BE1H   A 
CALC_NEXT_COMM_TI~  C ADDR   0A9AH   A 
COMM5COMM6 . . . .  C ADDR   0FB3H   A 
CALC_GOVERNOR_TAR~  C ADDR   076FH   A 
PCA_INT_STORE_DATA  C ADDR   04A1H   A 
T2_INT_RCP_UPDATE~  C ADDR   0231H   A 
PWM_BFET_DAMPED_D~  C ADDR   019BH   A 
RESET. . . . . . .  C ADDR   19FDH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   00A4H   A 
PGM_ENABLE_TEMP_P~  I ADDR   00A0H   A 
_PGM_THROTTLE_RATE  I ADDR   009BH   A 
_PGM_STARTUP_RPM .  I ADDR   008FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   0062H   A 
RCP_PREPREV_EDGE_H  D ADDR   0056H   A 
WT_ZC_SCAN_START_L  D ADDR   004DH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0003h            
STARTUP_PHASE. . .  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
SIGNATURE_002. . .  N NUMB   0090h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C5h            
POLARIS_THUNDER_6~  N NUMB   0093h            
SKYWALKER_20A_MAIN  N NUMB   0058h            
TURNIGY_AE_30A_TA~  N NUMB   0047h            
TURNIGY_AE_20A_MU~  N NUMB   0042h            
XP_35A_SW_MULTI. .  N NUMB   0015h            
XP_7A_MAIN . . . .  N NUMB   0004h            
PRO3 . . . . . . .  C ADDR   1D01H   A 
BOOT_SIGN. . . . .  C ADDR   1DD6H   A 
BYTE_CNTL. . . . .  D ADDR   0027H   A 
BAUDH. . . . . . .  D ADDR   0025H   A 
CRCL . . . . . . .  D ADDR   0022H   A 
XL . . . . . . . .    REG    R0             
FUNCTION_NEXT. . .  C ADDR   194BH   A 
THROTTLE_HIGH_CAL.  C ADDR   13BEH   A 
COMM61_NFET_DONE .  C ADDR   102FH   A 
STORE_TIMES_INCRE~  C ADDR   0CACH   A 
STARTUP_PWM_SET_P~  C ADDR   0A88H   A 
PWM_CFET_DAMPED_D~  C ADDR   01ACH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006EH   A 
RCP_EDGE_L . . . .  D ADDR   0057H   A 
COMM_DIFF. . . . .  D ADDR   003FH   A 
STALL_CNT. . . . .  D ADDR   0035H   A 
GOV_SPOOLRATE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
RTX_PIN. . . . . .  N NUMB   0005h            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C6h            
POLARIS_THUNDER_8~  N NUMB   0095h            
TURNIGY_KFORCE_12~  N NUMB   0053h            
TURNIGY_AE_45A_MA~  N NUMB   0049h            
TURNIGY_AE_30A_MU~  N NUMB   0048h            
TURNIGY_PLUSH_30A~  N NUMB   002Bh            
TURNIGY_PLUSH_12A~  N NUMB   0022h            
XP_3A_TAIL . . . .  N NUMB   0002h            
PRO4 . . . . . . .  C ADDR   1D0DH   A 
MAIN . . . . . . .  C ADDR   1C7CH   A 
PARAVAL_NEXT . . .  C ADDR   1936H   A 
WRITE_EEPROM_BYTE.  C ADDR   17C9H   A 
TEST_FOR_ONESHOT .  C ADDR   1335H   A 
MEASURE_PWM_FREQ_~  C ADDR   12E2H   A 
COMM61_NFET_OFF_R~  C ADDR   1014H   A 
COMM_EXIT. . . . .  C ADDR   104AH   A 
CALC_GOVERNOR_INT~  C ADDR   0868H   A 
PCA_INT_PPM_CHECK~  C ADDR   051AH   A 
PCA_INT_FALL_CHEC~  C ADDR   04F1H   A 
PCA_INT_PWM_DIVIDE  C ADDR   0566H   A 
PCA_INT_LIMITED. .  C ADDR   0589H   A 
T2H_INT_RCP_SET_L~  C ADDR   0304H   A 
T2H_INT_START. . .  C ADDR   026FH   A 
T2_INT_PWM_UPDATE.  C ADDR   0242H   A 
T0_INT_PWM_OFF_DA~  C ADDR   012EH   A 
EEP_DUMMY. . . . .  C ADDR   1A27H   A 
EEP_PGM_ENABLE_PW~  C ADDR   1A25H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A13H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
CLOCK_SET_AT_48MHZ  D ADDR   007AH   A 
COMM_PERIOD4X_L. .  D ADDR   003DH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
RTX_MDIN . . . . .  N NUMB   00F1h            
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0000h            
POLARIS_THUNDER_8~  N NUMB   0096h            
SKYWALKER_40A_MAIN  N NUMB   005Bh            
TURNIGY_KFORCE_12~  N NUMB   0054h            
TURNIGY_PLUSH_40A~  N NUMB   002Eh            
SUPERMICRO_3P5A_M~  N NUMB   0019h            
XP_3A_MULTI. . . .  N NUMB   0003h            
WAIT1. . . . . . .  C ADDR   1DCFH   A 
PRO5 . . . . . . .  C ADDR   1D13H   A 
FUNC_PARAVAL_WAIT.  C ADDR   18FFH   A 
WRITE_TAG. . . . .  C ADDR   1820H   A 
READ_EEPROM_STORE~  C ADDR   175BH   A 
RUN6_CHECK_DIR . .  C ADDR   16E1H   A 
RUN1 . . . . . . .  C ADDR   15A3H   A 
WAIT_FOR_POWER_ON~  C ADDR   14D3H   A 
MEASURE_PWM_FREQ_~  C ADDR   12F3H   A 
CLEAR_RAM. . . . .  C ADDR   1238H   A 
SET_BEC_VOLTAGE. .  C ADDR   1168H   A 
DECODE_DEMAG_DONE.  C ADDR   115BH   A 
COMM45_NFET_DONE .  C ADDR   0F94H   A 
WAIT_FOR_COMM. . .  C ADDR   0E31H   A 
ADJUST_TIMING_TWO~  C ADDR   0C9FH   A 
MEASURE_LIPO_ADD_~  C ADDR   09A7H   A 
CALC_GOVERNOR_PRO~  C ADDR   07ABH   A 
DIV_U16_BY_U16_DI~  C ADDR   0649H   A 
WAIT100MS. . . . .  C ADDR   05DBH   A 
WAIT1MS. . . . . .  C ADDR   05C7H   A 
T0_INT_PWM_OFF_TI~  C ADDR   010CH   A 
T0_INT_PWM_OFF_SE~  C ADDR   010AH   A 
STARTUP_POWER_TAB~  C ADDR   008DH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
SKIP_T2_INT. . . .  D ADDR   0077H   A 
TX_PGM_BEEP_NO . .  D ADDR   0076H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   006AH   A 
WT_ZC_TOUT_START_H  D ADDR   0050H   A 
RCP_SKIP_RATE. . .  N NUMB   0020h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
RTX_MDOUT. . . . .  N NUMB   00A4h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D7h            
PLATINUM_PRO_30A_~  N NUMB   009Bh            
TURNIGY_KFORCE_12~  N NUMB   0055h            
RD1. . . . . . . .  C ADDR   1D2AH   A 
PRO6 . . . . . . .  C ADDR   1D20H   A 
ABD. . . . . . . .  C ADDR   1C2BH   A 
FUNCTION_PARAVAL_~  C ADDR   18CDH   A 
STORE_NEW_VALUE_I~  C ADDR   1829H   A 
RUN2 . . . . . . .  C ADDR   15C1H   A 
ARMING_PPM_CHECK .  C ADDR   1384H   A 
COMM45_NFET_OFF_R~  C ADDR   0F78H   A 
COMM23_FETS_DONE .  C ADDR   0EBEH   A 
COMP_READ_WRONG_T~  C ADDR   0DBEH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CBAH   A 
STORE_TIMES_EXIT .  C ADDR   0C85H   A 
MEASURE_LIPO_UPDA~  C ADDR   09AFH   A 
GOVERNOR_CORR_INT~  C ADDR   08AEH   A 
GOVERNOR_STORE_PR~  C ADDR   07A7H   A 
DIV_U16_BY_U16_DI~  C ADDR   0653H   A 
WAIT200MS. . . . .  C ADDR   05E0H   A 
T2_INT_CURRENT_PW~  C ADDR   0244H   A 
T2_INT_PULSES_ABS~  C ADDR   01DCH   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_MAIN_SPOOLUP_~  I ADDR   009FH   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0055H   A 
GOV_ACTIVE . . . .  N NUMB   0005h            
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D8h            
PLATINUM_PRO_30A_~  N NUMB   009Ch            
TURNIGY_AE_25A_TA~  N NUMB   0044h            
TURNIGY_PLUSH_60A~  N NUMB   0031h            
TURNIGY_PLUSH_10A~  N NUMB   0020h            
MAI1 . . . . . . .  C ADDR   1C7EH   A 
IN1. . . . . . . .  C ADDR   1C74H   A 
BAUDL. . . . . . .  D ADDR   0024H   A 
RUN3 . . . . . . .  C ADDR   15EEH   A 
CHECK_VOLTAGE_EXIT  C ADDR   0A66H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0896H   A 
GOVERNOR_CHECK_IN~  C ADDR   07CDH   A 
DIV_U16_BY_U16_DI~  C ADDR   066AH   A 
WAIT3MS. . . . . .  C ADDR   05CCH   A 
T2_INT_PULSES_ABS~  C ADDR   0211H   A 
T0_INT_PWM_ON_TIM~  C ADDR   00EAH   A 
T0_INT_PWM_ON_SET~  C ADDR   00E8H   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0045H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
RCP_PPM_ONESHOT125  N NUMB   0005h            
DIR_CHANGE_BRAKE .  N NUMB   0003h            
DEMAG_ENABLED. . .  N NUMB   0004h            
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
POLARIS_THUNDER_1~  N NUMB   0097h            
SKYWALKER_20A_TAIL  N NUMB   0059h            
TURNIGY_AE_25A_MU~  N NUMB   0045h            
TURNIGY_PLUSH_25A~  N NUMB   0028h            
TURNIGY_PLUSH_10A~  N NUMB   0021h            
XP_7A_TAIL . . . .  N NUMB   0005h            
PUTP . . . . . . .  C ADDR   1D40H   A 
SETBUF . . . . . .  C ADDR   1CBFH   A 
MAI2 . . . . . . .  C ADDR   1CA0H   A 
ERRORCOMMAND . . .  N NUMB   00C1h            
BEEP_NO_ENTRY. . .  C ADDR   18F8H   A 
JMP_WAIT_FOR_POWE~  C ADDR   1740H   A 
DIRECT_START_CHEC~  C ADDR   1697H   A 
RUN4 . . . . . . .  C ADDR   160FH   A 
COMM61_FETS_DONE .  C ADDR   0FF6H   A 
COMM23_NONDAMP_REV  C ADDR   0F00H   A 
COMP_READ_OK_JMP .  C ADDR   0DF0H   A 
STORE_TIMES_UP_OR~  C ADDR   0C43H   A 
STORE_TIMES_DECRE~  C ADDR   0C56H   A 
CALC_NEXT_COMM_NE~  C ADDR   0B26H   A 
TEMP_AVERAGE_INC .  C ADDR   09F2H   A 
GOVERNOR_CORR_INT~  C ADDR   08BFH   A 
MULT_S16_BY_U8_DI~  C ADDR   0679H   A 
PCA_INT_PPM_NEG_C~  C ADDR   053EH   A 
T2_INT_EXIT. . . .  C ADDR   0255H   A 
_EEP_PGM_DAMPING_~  C ADDR   1A16H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PWM_DITHER_EXCESS~  D ADDR   0067H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   005Ah            
TURNIGY_AE_45A_TA~  N NUMB   004Ah            
TURNIGY_PLUSH_80A~  N NUMB   0034h            
TURNIGY_PLUSH_30A~  N NUMB   002Ch            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
XP_7A_MULTI. . . .  N NUMB   0006h            
PUT1 . . . . . . .  C ADDR   1D46H   A 
READ_TAGS. . . . .  C ADDR   1805H   A 
RUN5 . . . . . . .  C ADDR   1630H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B98H   A 
SET_PWM_LIMIT_HIG~  C ADDR   090BH   A 
GOVERNOR_CORR_NEG~  C ADDR   08B3H   A 
GOVERNOR_LIMIT_PR~  C ADDR   079CH   A 
GOVERNOR_TARGET_C~  C ADDR   071EH   A 
CALC_GOVERNOR_TAR~  C ADDR   06D0H   A 
PCA_INT_PWM_DIVID~  C ADDR   056DH   A 
PCA_INT_CHECK_12K~  C ADDR   0420H   A 
T2H_INT_RCP_BAILO~  C ADDR   0335H   A 
_EEP_PGM_MOTOR_GA~  C ADDR   1A07H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
CURRENT_PWM_LIMIT~  D ADDR   007CH   A 
BEEP_STRENGTH. . .  D ADDR   0073H   A 
RCP_PREV_PERIOD_H.  D ADDR   005AH   A 
WT_COMM_START_H. .  D ADDR   0052H   A 
WT_ZC_TOUT_START_L  D ADDR   004FH   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
F85_3A_MAIN. . . .  N NUMB   00D3h            
SKYWALKER_40A_TAIL  N NUMB   005Ch            
TURNIGY_AE_45A_MU~  N NUMB   004Bh            
TURNIGY_PLUSH_40A~  N NUMB   002Fh            
TURNIGY_PLUSH_30A~  N NUMB   002Dh            
TURNIGY_PLUSH_18A~  N NUMB   0025h            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
SUPERMICRO_3P5A_T~  N NUMB   001Ah            
PUT2 . . . . . . .  C ADDR   1D59H   A 
MAI4 . . . . . . .  C ADDR   1CD6H   A 
BAUDTIME . . . . .  N NUMB   0198h            
RUN6 . . . . . . .  C ADDR   1651H   A 
ARMING_START . . .  C ADDR   136CH   A 
MEASURE_PWM_FREQ_~  C ADDR   12E8H   A 
COMM61_NONDAMP_REV  C ADDR   1036H   A 
COMM45_FETS_DONE .  C ADDR   0F5AH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CC2H   A 
GOVERNOR_DEACTIVA~  C ADDR   06FDH   A 
PCA_INT_CHECK_LEG~  C ADDR   057EH   A 
PCA_INT_FALL_NOT_~  C ADDR   04D2H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
PREV_PREV_COMM_H .  D ADDR   003CH   A 
RCP_UPDATED. . . .  N NUMB   0000h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0040h            
MUX_A1 . . . . . .  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Ah            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
FLYCOLOR_FAIRY_30~  N NUMB   00C7h            
ROTORGEEKS_20A_MA~  N NUMB   00C1h            
ALIGN_RCE_BL15P_M~  N NUMB   006Dh            
SKYWALKER_40A_MUL~  N NUMB   005Dh            
TURNIGY_KFORCE_12~  N NUMB   0056h            
TURNIGY_PLUSH_40A~  N NUMB   0030h            
SUPERMICRO_3P5A_M~  N NUMB   001Bh            
DP_3A_MAIN . . . .  N NUMB   0016h            
PUT3 . . . . . . .  C ADDR   1D65H   A 
MAI5 . . . . . . .  C ADDR   1D25H   A 
WAIT_FOR_LOW . . .  C ADDR   1C42H   A 
PARAH. . . . . . .    REG    R3             
STORE_MAIN_FUNC_1.  C ADDR   182DH   A 
ARM_TARGET_UPDATED  C ADDR   144AH   A 
EVALUATE_COMPARAT~  C ADDR   0DF5H   A 
COMP_WAIT_READ_CO~  C ADDR   0D85H   A 
TEMP_CHECK_EXIT. .  C ADDR   0A1CH   A 
GOVERNOR_APPLY_PR~  C ADDR   083EH   A 
T2H_INT_RCP_GOV_B~  C ADDR   02C1H   A 
PWM_AFET_EXIT. . .  C ADDR   0167H   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_PWM_IN~  I ADDR   00A2H   A 
_PGM_STARTUP_ACCEL  I ADDR   0090H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
CURRENT_PWM_LIM_D~  D ADDR   007DH   A 
GOV_INTEGRAL_L . .  D ADDR   0044H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0025h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
TURNIGY_KFORCE_12~  N NUMB   0057h            
TURNIGY_PLUSH_60A~  N NUMB   0032h            
PUT4 . . . . . . .  C ADDR   1D77H   A 
MAI6 . . . . . . .  C ADDR   1D36H   A 
CNTH . . . . . . .    REG    R7             
STORE_MAIN_FUNC_2.  C ADDR   1832H   A 
WRITE_EEPROM_BLOC~  C ADDR   17A6H   A 
NORMAL_RUN_CHECKS.  C ADDR   16A4H   A 
INIT_NO_SIGNAL . .  C ADDR   126DH   A 
COMM45_NONDAMP_REV  C ADDR   0F9CH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D1DH   A 
WAIT_ADVANCE_TIMI~  C ADDR   0BE6H   A 
CALC_NEW_WAIT_PER~  C ADDR   0B50H   A 
CALC_GOVERNOR_PRO~  C ADDR   0770H   A 
T2_INT_PPM_TIMEOU~  C ADDR   021DH   A 
PWM_BFET_EXIT. . .  C ADDR   0171H   A 
T0_INT_PWM_OFF_EX~  C ADDR   0119H   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
POLARIS_THUNDER_1~  N NUMB   0098h            
ALIGN_RCE_BL35P_M~  N NUMB   0073h            
TURNIGY_PLUSH_60A~  N NUMB   0033h            
TURNIGY_PLUSH_25A~  N NUMB   0029h            
POLYNOM. . . . . .  N NUMB   A001h            
STORE_MAIN_FUNC_3.  C ADDR   1837H   A 
WRITE_EEPROM_BLOC~  C ADDR   17B4H   A 
PROGRAM_BY_TX_ENT~  C ADDR   1431H   A 
READ_ALL_EEPROM_P~  C ADDR   1742H   A 
COMM23_NFET_DONE_~  C ADDR   0F0FH   A 
CALC_NEXT_COMM_NE~  C ADDR   0B2FH   A 
PWM_CFET_EXIT. . .  C ADDR   017BH   A 
T0_INT . . . . . .  C ADDR   00AAH   A 
_EEP_PGM_PWM_DITH~  C ADDR   1A26H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A18H   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
SKIP_T2H_INT . . .  D ADDR   0078H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006BH   A 
RCP_STOP_CNT . . .  D ADDR   005FH   A 
NEW_RCP. . . . . .  D ADDR   005CH   A 
RCP_PREV_PERIOD_L.  D ADDR   0059H   A 
WT_COMM_START_L. .  D ADDR   0051H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
INITIAL_RUN_PHASE.  N NUMB   0002h            
HIGH_RPM . . . . .  N NUMB   0007h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00D0h            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0003h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
POLARIS_THUNDER_1~  N NUMB   0099h            
TURNIGY_PLUSH_80A~  N NUMB   0035h            
TURNIGY_PLUSH_25A~  N NUMB   002Ah            
STORE_MAIN_FUNC_4.  C ADDR   183CH   A 
INIT_START_BIDIR_~  C ADDR   1572H   A 
EVAL_COMP_EXIT . .  C ADDR   0E13H   A 
MEASURE_LIPO_ADJU~  C ADDR   0976H   A 
PCA_INT_SET_TIMEO~  C ADDR   05A1H   A 
PWM_NOFET. . . . .  C ADDR   015DH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00D6H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
PREV_PREV_COMM_L .  D ADDR   003BH   A 
PREV_COMM_H. . . .  D ADDR   003AH   A 
RCP_DIR_REV. . . .  N NUMB   0006h            
RCP_TIMEOUT_CNT. .  D ADDR   002AH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0004h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
F85_3A_TAIL. . . .  N NUMB   00D4h            
FVT_LITTLEBEE_20A~  N NUMB   00CAh            
MDRX62H_MAIN . . .  N NUMB   00BEh            
TURNIGY_PLUSH_80A~  N NUMB   0036h            
TURNIGY_PLUSH_18A~  N NUMB   0026h            
XP_12A_MAIN. . . .  N NUMB   000Ah            
PUTW . . . . . . .  C ADDR   1D38H   A 
PARAL. . . . . . .    REG    R2             
STORE_MAIN_FUNC_5.  C ADDR   1841H   A 
BOOTLOADER_DONE. .  C ADDR   127DH   A 
AVERAGE_THROTTLE .  C ADDR   11A0H   A 
DECODE_PARAMS_DIR~  C ADDR   10E0H   A 
COMM61_NFET_DONE_~  C ADDR   1045H   A 
SETUP_COMM_WAIT. .  C ADDR   0E14H   A 
CALC_NEXT_COMM_TI~  C ADDR   0B99H   A 
CHECK_VOLTAGE_LIM.  C ADDR   0A4CH   A 
CALC_GOVERNOR_INT~  C ADDR   0809H   A 
T2_INT . . . . . .  C ADDR   01B0H   A 
_PGM_DAMPING_FORCE  I ADDR   0093H   A 
AUTO_BAILOUT_ARMED  D ADDR   0060H   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
MOTOR_PPM_LOW_SLO~  N NUMB   002Bh            
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0002h            
CNFET. . . . . . .  N NUMB   0007h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
F85_3A_MULTI . . .  N NUMB   00D5h            
FVT_LITTLEBEE_30A~  N NUMB   00CDh            
FLYCOLOR_FAIRY_30~  N NUMB   00C8h            
ROTORGEEKS_20A_TA~  N NUMB   00C2h            
ALIGN_RCE_BL15P_T~  N NUMB   006Eh            
RCTIMER_6A_MAIN. .  N NUMB   0067h            
TURNIGY_PLUSH_NFE~  N NUMB   003Dh            
TURNIGY_PLUSH_18A~  N NUMB   0027h            
DP_3A_TAIL . . . .  N NUMB   0017h            
XP_7A_FAST_MAIN. .  N NUMB   0007h            
GET1 . . . . . . .  C ADDR   1D84H   A 
BYTE_REG . . . . .  D ADDR   0021H   A 
CNTL . . . . . . .    REG    R6             
STORE_MAIN_FUNC_6.  C ADDR   1846H   A 
ARM_END_BEEP . . .  C ADDR   145FH   A 
THROTTLE_HIGH_CAL~  C ADDR   13BCH   A 
PGM_START. . . . .  C ADDR   11CBH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0CFEH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0BF7H   A 
LOAD_MIN_TIME. . .  C ADDR   0B94H   A 
SET_STARTUP_PWM. .  C ADDR   0A73H   A 
GOVERNOR_STORE_IN~  C ADDR   0803H   A 
T2H_INT_RCP_GOV_B~  C ADDR   02AEH   A 
T2H_INT_EXIT . . .  C ADDR   0340H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   034AH   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0075H   A 
ADC_CONVERSION_CNT  D ADDR   0070H   A 
GOV_ARM_TARGET . .  D ADDR   004AH   A 
RCP_PPM. . . . . .  N NUMB   0004h            
RCP_OUTSIDE_RANGE~  D ADDR   0029H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0005h            
ADC_LIMIT_L. . . .  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
GRAUPNER_ULTRA_20~  N NUMB   00D0h            
FLYCOLOR_FAIRY_30~  N NUMB   00C9h            
ROTORGEEKS_20A_MU~  N NUMB   00C3h            
EMAX_20A_MAIN. . .  N NUMB   00ACh            
TAROT_30A_MAIN . .  N NUMB   00A6h            
ALIGN_RCE_BL15P_M~  N NUMB   006Fh            
DP_3A_MULTI. . . .  N NUMB   0018h            
GET2 . . . . . . .  C ADDR   1D99H   A 
FUNC_PARAVAL . . .  C ADDR   18FBH   A 
WAIT1S_LOOP. . . .  C ADDR   1869H   A 
STORE_MAIN_FUNC_7.  C ADDR   184BH   A 
AVERAGE_THROTTLE_~  C ADDR   11BCH   A 
MEASURE_LIPO_DIVI~  C ADDR   098CH   A 
CALC_GOVERNOR_PRO~  C ADDR   0867H   A 
GOVERNOR_INT_MIN_~  C ADDR   07FEH   A 
GOVERNOR_LIMIT_PR~  C ADDR   07A3H   A 
BEEP_F1. . . . . .  C ADDR   05F0H   A 
PCA_INT_PPM_OUTSI~  C ADDR   0508H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   0071H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0064H   A 
PWM_LIMIT. . . . .  D ADDR   0061H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0006h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
ALIGN_RCE_BL35P_T~  N NUMB   0074h            
GET3 . . . . . . .  C ADDR   1DBDH   A 
STORE_MAIN_FUNC_8.  C ADDR   1850H   A 
INITIAL_RUN_PHASE~  C ADDR   16C2H   A 
TEST_THROTTLE_GAIN  C ADDR   1191H   A 
COMM23_FETS_DONE_~  C ADDR   0EDEH   A 
CALC_NEXT_COMM_ST~  C ADDR   0AF7H   A 
GOVERNOR_STORE_PR~  C ADDR   0865H   A 
GOVERNOR_CHECK_PR~  C ADDR   0829H   A 
MULT_S16_BY_U8_PO~  C ADDR   0693H   A 
DIV_U16_BY_U16 . .  C ADDR   0641H   A 
BEEP_ONOFF . . . .  C ADDR   060EH   A 
BEEP_F2. . . . . .  C ADDR   05F7H   A 
PCA_INT_CHECK_DIFF  C ADDR   0494H   A 
T2H_INT_RCP_INC_L~  C ADDR   0329H   A 
T2H_INT_RCP_GOV_P~  C ADDR   02CEH   A 
T2_INT_SKIP_START.  C ADDR   0221H   A 
PWM_AFET . . . . .  C ADDR   015FH   A 
T0_INT_PWM_OFF_FU~  C ADDR   014FH   A 
EEP_PGM_ENABLE_PO~  C ADDR   1A24H   A 
EEPROM_LAYOUT_REV~  N NUMB   0014h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
PREV_COMM_L. . . .  D ADDR   0039H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
XROTOR_10A_MAIN. .  N NUMB   00B5h            
EMAX_40A_MAIN. . .  N NUMB   00AFh            
ALIGN_RCE_BL35P_M~  N NUMB   0075h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ah            
TURNIGY_KFORCE_70~  N NUMB   004Fh            
TURNIGY_KFORCE_40~  N NUMB   004Ch            
XP_25A_MAIN. . . .  N NUMB   0010h            
INIT . . . . . . .  C ADDR   1C00H   A 
PARAVAL_NO_ENTRY .  C ADDR   18F5H   A 
STORE_MAIN_FUNC_9.  C ADDR   1855H   A 
RUN6_BRAKE_DONE. .  C ADDR   16EBH   A 
SUCCESS_BEEP_INVE~  C ADDR   189EH   A 
SUCCESS_BEEP . . .  C ADDR   186FH   A 
FIND_THROTTLE_GAIN  C ADDR   1169H   A 
DECODE_SETTINGS. .  C ADDR   10FEH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   16F3H   A 
TEMP_AVERAGE_INC_~  C ADDR   09E2H   A 
GOVERNOR_INT_MAX_~  C ADDR   07F6H   A 
GOVERNOR_LIMIT_IN~  C ADDR   07D6H   A 
BEEP_F3. . . . . .  C ADDR   05FEH   A 
PCA_INT_FAIL_MINI~  C ADDR   03ADH   A 
PWM_BFET . . . . .  C ADDR   0169H   A 
T0_INT_PWM_OFF_EX~  C ADDR   0140H   A 
EEP_PGM_GOV_RANGE.  C ADDR   1A17H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0069H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
SKIP_DAMP_ON . . .  N NUMB   0006h            
P1_INIT. . . . . .  N NUMB   0002h            
RTX_SKIP . . . . .  N NUMB   00D4h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
FVT_LITTLEBEE_20A~  N NUMB   00CBh            
MDRX62H_TAIL . . .  N NUMB   00BFh            
XROTOR_20A_MAIN. .  N NUMB   00B8h            
PLATINUM_PRO_150A~  N NUMB   009Dh            
TURNIGY_PLUSH_NFE~  N NUMB   003Ah            
XP_12A_TAIL. . . .  N NUMB   000Bh            
UART_LOOP. . . . .  N NUMB   001Ah            
DAMPED_TRANSITION.  C ADDR   1597H   A 
BEEP_DELAY_SET . .  C ADDR   149AH   A 
PROGRAM_BY_TX_ENT~  C ADDR   13A2H   A 
LOCK_BYTE_OK . . .  C ADDR   11EAH   A 
AVERAGE_THROTTLE_~  C ADDR   11ADH   A 
DECODE_PWM_FREQ_L~  C ADDR   10F8H   A 
COMM61_FETS_DONE_~  C ADDR   1016H   A 
COMP_READ_WRONG_L~  C ADDR   0DC8H   A 
SET_PWM_LIMIT_LOW~  C ADDR   0908H   A 
GOVERNOR_ACT_LIM_~  C ADDR   06F7H   A 
BEEP_F4. . . . . .  C ADDR   0605H   A 
PCA_INT_PPM_MAX_C~  C ADDR   054DH   A 
PCA_INT_RESTORE_E~  C ADDR   047EH   A 
PWM_CFET . . . . .  C ADDR   0173H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A6H   A 
_PGM_STARTUP_METH~  I ADDR   0095H   A 
_PGM_VOLT_COMP . .  I ADDR   0091H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0006h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
FVT_LITTLEBEE_30A~  N NUMB   00CEh            
FVT_LITTLEBEE_20A~  N NUMB   00CCh            
MDRX62H_MULTI. . .  N NUMB   00C0h            
H_KING_10A_MAIN. .  N NUMB   0079h            
ALIGN_RCE_BL35X_M~  N NUMB   0070h            
RCTIMER_6A_TAIL. .  N NUMB   0068h            
TURNIGY_PLUSH_NFE~  N NUMB   003Eh            
XP_18A_MAIN. . . .  N NUMB   000Dh            
XP_12A_MULTI . . .  N NUMB   000Ch            
XP_7A_FAST_TAIL. .  N NUMB   0008h            
PROGRAM_BY_TX_EXIT  C ADDR   195AH   A 
READ_EEPROM_BYTE .  C ADDR   17C5H   A 
THROTTLE_LOW_CAL .  C ADDR   13F6H   A 
COMP_READ_WRONG. .  C ADDR   0D91H   A 
STORE_TIMES_UP_OR~  C ADDR   0CA6H   A 
STORE_TIMES_DECRE~  C ADDR   0CB3H   A 
TEMP_AVERAGE_UPDA~  C ADDR   09FAH   A 
SET_PWM_LIMIT_HIG~  C ADDR   091CH   A 
GOVERNOR_APPLY_IN~  C ADDR   089AH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0834H   A 
CALC_GOVERNOR_STO~  C ADDR   076BH   A 
BEEP_OFF . . . . .  C ADDR   0637H   A 
WAIT10MS . . . . .  C ADDR   05D1H   A 
T2H_INT_RCP_NO_LI~  C ADDR   0333H   A 
PWM_AFET_DAMPED_E~  C ADDR   018CH   A 
T0_INT_PWM_ON_EXIT  C ADDR   00D8H   A 
TX_PGM_PARAMS_MAIN  C ADDR   009FH   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Eh            
PGM_PWM_DITHER . .  I ADDR   00A3H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0074H   A 
INITIAL_RUN_ROT_C~  D ADDR   0034H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
GRAUPNER_ULTRA_20~  N NUMB   00D1h            
FVT_LITTLEBEE_30A~  N NUMB   00CFh            
XROTOR_40A_MAIN. .  N NUMB   00BBh            
EMAX_20A_TAIL. . .  N NUMB   00ADh            
TAROT_30A_TAIL . .  N NUMB   00A7h            
H_KING_20A_MAIN. .  N NUMB   007Ch            
RCTIMER_6A_MULTI .  N NUMB   0069h            
HIMODEL_COOL_22A_~  N NUMB   005Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0037h            
XP_7A_FAST_MULTI .  N NUMB   0009h            
GETW . . . . . . .  C ADDR   1D7BH   A 
READ_TAG . . . . .  C ADDR   180EH   A 
RESET_CAL_DONE . .  C ADDR   1210H   A 
DECODE_PARAMETERS.  C ADDR   10CBH   A 
COMM45_FETS_DONE_~  C ADDR   0F7AH   A 
COMM23_NFET_OFF. .  C ADDR   0EBCH   A 
STORE_TIMES_INCRE~  C ADDR   0C49H   A 
CHECK_VOLTAGE_GOOD  C ADDR   0A45H   A 
MEASURE_LIPO_CELLS  C ADDR   0921H   A 
CALC_GOVERNOR_INT~  C ADDR   07ACH   A 
GOVERNOR_FIRST_DE~  C ADDR   0709H   A 
PCA_INT_PPM_CALCU~  C ADDR   0528H   A 
PCA_INT_EXIT . . .  C ADDR   05B5H   A 
T2H_INT_RCP_LIMIT~  C ADDR   02F8H   A 
PWM_BFET_DAMPED_E~  C ADDR   019DH   A 
RCP_PERIOD_DIFF_A~  D ADDR   005BH   A 
COMPARATOR_READ_C~  D ADDR   0041H   A 
STARTUP_CNT. . . .  D ADDR   0033H   A 
PWM_TIMER0_OVERFL~  N NUMB   0003h            
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
GRAUPNER_ULTRA_20~  N NUMB   00D2h            
EMAX_20A_MULTI . .  N NUMB   00AEh            
TAROT_30A_MULTI. .  N NUMB   00A8h            
HIMODEL_COOL_41A_~  N NUMB   0064h            
TURNIGY_PLUSH_6A_~  N NUMB   001Ch            
GETX . . . . . . .  C ADDR   1D89H   A 
WAIT_FOR_POWER_ON~  C ADDR   14C3H   A 
COMP_READ_WRONG_N~  C ADDR   0DA8H   A 
CALC_NEW_WAIT_PER~  C ADDR   0B6CH   A 
SWITCH_POWER_OFF .  C ADDR   104DH   A 
CALC_GOVERNOR_TAR~  C ADDR   0737H   A 
WAIT30MS . . . . .  C ADDR   05D6H   A 
PCA_INT_CHECK_1KHZ  C ADDR   046DH   A 
T2H_INT. . . . . .  C ADDR   0262H   A 
PWM_CFET_DAMPED_E~  C ADDR   01AEH   A 
GOV_INTEGRAL_X . .  D ADDR   0046H   A 
COMP_TIMED_OUT . .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   000Ch            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
XROTOR_10A_TAIL. .  N NUMB   00B6h            
EMAX_40A_TAIL. . .  N NUMB   00B0h            
EAZY_3AV2_MAIN . .  N NUMB   00A3h            
ALIGN_RCE_BL15X_T~  N NUMB   006Bh            
HIMODEL_COOL_33A_~  N NUMB   0061h            
TURNIGY_KFORCE_70~  N NUMB   0050h            
TURNIGY_KFORCE_40~  N NUMB   004Dh            
XP_25A_TAIL. . . .  N NUMB   0011h            
RST. . . . . . . .  C ADDR   1CBDH   A 
SUCCESS. . . . . .  N NUMB   0030h            
BOOT_VERSION . . .  N NUMB   0006h            
XTAL . . . . . . .  N NUMB   17D7840h            
FUNC_PARAVAL_CONT~  C ADDR   1929H   A 
WRITE_TAGS . . . .  C ADDR   1819H   A 
RUN_TO_NEXT_STATE~  C ADDR   1736H   A 
RUN6_CHECK_RCP_ST~  C ADDR   16D2H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   16FBH   A 
WAIT1S . . . . . .  C ADDR   1867H   A 
COMM61_NFET_OFF. .  C ADDR   0FF4H   A 
EVAL_COMP_CHECK_T~  C ADDR   0E03H   A 
COMP_WAIT_ON_COMP~  C ADDR   0D52H   A 
ADJUST_TIMING_TWO~  C ADDR   0C30H   A 
INITIALIZE_TIMING.  C ADDR   0A93H   A 
CHECK_VOLTAGE_RET.  C ADDR   0A72H   A 
WAITXMS_M. . . . .  C ADDR   05E7H   A 
PCA_INT_CHECK_2KHZ  C ADDR   045CH   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
WT_ADV_START_H . .  D ADDR   004CH   A 
GOV_TARGET_H . . .  D ADDR   0043H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
XROTOR_20A_TAIL. .  N NUMB   00B9h            
XROTOR_10A_MULTI .  N NUMB   00B7h            
EMAX_40A_MULTI . .  N NUMB   00B1h            
SKYIII_30A_MAIN. .  N NUMB   00A9h            
PLATINUM_PRO_150A~  N NUMB   009Eh            
POLARIS_THUNDER_2~  N NUMB   0088h            
H_KING_50A_MAIN. .  N NUMB   0082h            
GAUI_GE_183_18A_M~  N NUMB   0076h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ch            
TURNIGY_KFORCE_70~  N NUMB   0051h            
TURNIGY_KFORCE_40~  N NUMB   004Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Bh            
XP_25A_MULTI . . .  N NUMB   0012h            
EXIT . . . . . . .  C ADDR   1CB4H   A 
BOOT_MSG . . . . .  C ADDR   1DDCH   A 
READ_INITIAL_TEMP.  C ADDR   1513H   A 
WAIT_FOR_POWER_ON~  C ADDR   14B7H   A 
DECODE_PWM_FREQ_E~  C ADDR   10FDH   A 
WAIT_FOR_COMM_WAIT  C ADDR   0E6AH   A 
START_ADC_CONVERS~  C ADDR   09B4H   A 
MULT_S16_BY_U8_EX~  C ADDR   06C7H   A 
PCA_INT_PPM_LIMIT~  C ADDR   055FH   A 
GET_RCP_END. . . .  C ADDR   0384H   A 
T2H_INT_RCP_GOV_P~  C ADDR   029CH   A 
T2_INT_PWM_MIN_RUN  C ADDR   0242H   A 
PWM_DITHER_TABLE .  C ADDR   009AH   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
PGM_ENABLE_POWER_~  I ADDR   00A1H   A 
PWM_DITHER_DECODED  D ADDR   0066H   A 
PWM_LIMIT_BY_RPM .  D ADDR   0063H   A 
LOW_RPM_PWR_SLOPE.  D ADDR   0038H   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   000Ch            
HIGH_BEC_VOLTAGE .  N NUMB   0000h            
PSW. . . . . . . .  D ADDR   00D0H   A 
XROTOR_20A_MULTI .  N NUMB   00BAh            
PLATINUM_PRO_150A~  N NUMB   009Fh            
POLARIS_THUNDER_3~  N NUMB   008Bh            
POLARIS_THUNDER_1~  N NUMB   0085h            
H_KING_10A_TAIL. .  N NUMB   007Ah            
ALIGN_RCE_BL35X_T~  N NUMB   0071h            
TURNIGY_PLUSH_NFE~  N NUMB   003Ch            
XP_18A_TAIL. . . .  N NUMB   000Eh            
WAITF. . . . . . .  C ADDR   1DC9H   A 
BOOT_BAUDRATE. . .  N NUMB   4B00h            
STORE_IN_RAM_EXIT.  C ADDR   1864H   A 
VALIDATE_RCP_START  C ADDR   1349H   A 
LOCK_BYTE_TEST . .  C ADDR   11E3H   A 
COMM45_NFET_OFF. .  C ADDR   0F58H   A 
COMM12_REV . . . .  C ADDR   0E8FH   A 
COMM1COMM2 . . . .  C ADDR   0E7BH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CC4H   A 
TEMP_AVERAGE_UPDA~  C ADDR   09F8H   A 
TEMP_AVERAGE_DEC .  C ADDR   09EEH   A 
CALC_GOVERNOR_PRO~  C ADDR   080AH   A 
CALC_GOVERNOR_TAR~  C ADDR   0750H   A 
WAITXMS_O. . . . .  C ADDR   05E5H   A 
PCA_INT_PPM_TIMEO~  C ADDR   05AAH   A 
PCA_INT_CHECK_4KHZ  C ADDR   044BH   A 
T0_INT_PWM_OFF . .  C ADDR   00FBH   A 
T0_INT_START . . .  C ADDR   00B7H   A 
EEPROM_FW_SUB_REV~  N NUMB   0003h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0048H   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
XROTOR_40A_TAIL. .  N NUMB   00BCh            
POLARIS_THUNDER_4~  N NUMB   008Eh            
H_KING_20A_TAIL. .  N NUMB   007Dh            
H_KING_10A_MULTI .  N NUMB   007Bh            
ALIGN_RCE_BL35X_M~  N NUMB   0072h            
HIMODEL_COOL_22A_~  N NUMB   005Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0038h            
XP_18A_MULTI . . .  N NUMB   000Fh            
PUTC . . . . . . .  C ADDR   1D5CH   A 
BIT_REG. . . . . .  D ADDR   0020H   A 
CMDH . . . . . . .    REG    R5             
STORE_MAIN_FUNC_10  C ADDR   185AH   A 
READ_EEPROM_EXIT .  C ADDR   1782H   A 
WAIT_FOR_POWER_ON~  C ADDR   1477H   A 
INPUT_HIGH_CHECK_1  C ADDR   1271H   A 
CHECK_VOLTAGE_STA~  C ADDR   0A20H   A 
SET_PWM_LIMIT_LOW~  C ADDR   08C4H   A 
CALC_GOVERNOR_INT~  C ADDR   08C3H   A 
GOVERNOR_LIMIT_IN~  C ADDR   07DFH   A 
MULT_S16_BY_U8_DI~  C ADDR   06ACH   A 
BEEP . . . . . . .  C ADDR   060CH   A 
PCA_INT_FALL . . .  C ADDR   04AFH   A 
T2_INT_PWM_EXIT. .  C ADDR   024CH   A 
T2_INT_SKIP_END. .  C ADDR   022CH   A 
EEP_PGM_TEMP_PROT~  C ADDR   1A23H   A 
_EEP_PGM_THROTTLE~  C ADDR   1A1EH   A 
_EEP_PGM_STARTUP_~  C ADDR   1A12H   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A5H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006CH   A 
COMM_PHASE . . . .  D ADDR   0040H   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
XROTOR_40A_MULTI .  N NUMB   00BDh            
EMAX_NANO_20A_MAIN  N NUMB   00B2h            
PLATINUM_50AV3_MA~  N NUMB   00A0h            
H_KING_35A_MAIN. .  N NUMB   007Fh            
H_KING_20A_MULTI .  N NUMB   007Eh            
HIMODEL_COOL_41A_~  N NUMB   0065h            
HIMODEL_COOL_22A_~  N NUMB   0060h            
TURNIGY_PLUSH_NFE~  N NUMB   0039h            
TURNIGY_PLUSH_6A_~  N NUMB   001Dh            
WAITH. . . . . . .  C ADDR   1DCDH   A 
STORE_MAIN_FUNC_11  C ADDR   185FH   A 
ERASE_FLASH. . . .  C ADDR   17DEH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   16FEH   A 
PROGRAM_BY_TX. . .  C ADDR   18ECH   A 
INPUT_HIGH_CHECK_2  C ADDR   1273H   A 
COMM23_NONDAMP . .  C ADDR   0EE6H   A 
COMM2COMM3 . . . .  C ADDR   0EA0H   A 
CALC_NEXT_COMM_AV~  C ADDR   0B13H   A 
MEASURE_LIPO_CELL~  C ADDR   095BH   A 
GOVERNOR_STORE_IN~  C ADDR   08C1H   A 
GOVERNOR_CHECK_IN~  C ADDR   0883H   A 
GOVERNOR_CORR_PRO~  C ADDR   0852H   A 
T2_INT_START . . .  C ADDR   01CCH   A 
PWM_AFET_DAMPED. .  C ADDR   017DH   A 
_EEP_PGM_PPM_CENT~  C ADDR   1A21H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
NEXT_WT_START_H. .  D ADDR   0054H   A 
WT_ADV_START_L . .  D ADDR   004BH   A 
GOV_TARGET_L . . .  D ADDR   0042H   A 
DEMAG_PWR_OFF_THR~  D ADDR   0037H   A 
FLAGS0 . . . . . .  D ADDR   002CH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
EAZY_3AV2_TAIL . .  N NUMB   00A4h            
POLARIS_THUNDER_6~  N NUMB   0091h            
HIMODEL_COOL_41A_~  N NUMB   0066h            
HIMODEL_COOL_33A_~  N NUMB   0062h            
TURNIGY_AE_20A_MA~  N NUMB   0040h            
TURNIGY_PLUSH_6A_~  N NUMB   001Eh            
XP_35A_SW_MAIN . .  N NUMB   0013h            
ID1. . . . . . . .  C ADDR   1C47H   A 
FUNC_PARAVAL_STORE  C ADDR   191BH   A 
WRITE_EEPROM_BYTE~  C ADDR   17CAH   A 
READ_EEPROM_BLOCK1  C ADDR   176AH   A 
READ_EEPROM_READ .  C ADDR   1763H   A 
COMM23_DAMP_REV. .  C ADDR   0EC6H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0C86H   A 
LOAD_MIN_TIME_FAST  C ADDR   0BDFH   A 
MEASURE_LIPO_EXIT.  C ADDR   09B3H   A 
GOVERNOR_LIMIT_PR~  C ADDR   083AH   A 
GOVERNOR_CHECK_PR~  C ADDR   0790H   A 
PCA_INT_SECOND_ME~  C ADDR   03D6H   A 
T2H_INT_RCP_STOP_~  C ADDR   027FH   A 
PWM_BFET_DAMPED. .  C ADDR   018EH   A 
PCA_INT. . . . . .  C ADDR   0364H   A 
EEP_PGM_GOV_SETUP~  C ADDR   1A11H   A 
FLAGS1 . . . . . .  D ADDR   002DH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C4h            
SKYIII_30A_TAIL. .  N NUMB   00AAh            
EAZY_3AV2_MULTI. .  N NUMB   00A5h            
POLARIS_THUNDER_2~  N NUMB   0089h            
H_KING_50A_TAIL. .  N NUMB   0083h            
GAUI_GE_183_18A_T~  N NUMB   0077h            
HIMODEL_COOL_33A_~  N NUMB   0063h            
TURNIGY_AE_30A_MA~  N NUMB   0046h            
BOOT_INFO. . . . .  C ADDR   1DE0H   A 
ERRORVERIFY. . . .  N NUMB   00C0h            
READ_EEPROM_BLOCK2  C ADDR   1778H   A 
MEASURE_PWM_FREQ_~  C ADDR   12E6H   A 
COMM61_NONDAMP . .  C ADDR   101DH   A 
COMM6COMM1 . . . .  C ADDR   0FD8H   A 
COMM34_REV . . . .  C ADDR   0F2BH   A 
COMM3COMM4 . . . .  C ADDR   0F17H   A 
COMP_WAIT_NO_OF_R~  C ADDR   0D41H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D0FH   A 
MEASURE_LIPO_LIMI~  C ADDR   09A3H   A 
GOVERNOR_CORR_PRO~  C ADDR   0863H   A 
GOVERNOR_SPEED_CH~  C ADDR   06D8H   A 
PCA_INT_CHECK_8KHZ  C ADDR   043AH   A 
T2H_INT_RCP_GOV_P~  C ADDR   02D0H   A 
PWM_CFET_DAMPED. .  C ADDR   019FH   A 
DAMPINGFET . . . .  D ADDR   007BH   A 
WT_ZC_SCAN_START_H  D ADDR   004EH   A 
GOV_PROP_PWM . . .  D ADDR   0049H   A 
GOV_PROPORTIONAL_L  D ADDR   0047H   A 
FLAGS2 . . . . . .  D ADDR   002EH   A 
DEMAG_DETECTED . .  N NUMB   0005h            
RCP_SKIP_CNT . . .  D ADDR   002BH   A 
CURRENT_PWM_LIM_D~  D ADDR   0026H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
MCU_48MHZ. . . . .  N NUMB   0001h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
SKYIII_30A_MULTI .  N NUMB   00ABh            
POLARIS_THUNDER_8~  N NUMB   0094h            
POLARIS_THUNDER_3~  N NUMB   008Ch            
POLARIS_THUNDER_2~  N NUMB   008Ah            
POLARIS_THUNDER_1~  N NUMB   0086h            
H_KING_50A_MULTI .  N NUMB   0084h            
GAUI_GE_183_18A_M~  N NUMB   0078h            
TURNIGY_KFORCE_12~  N NUMB   0052h            
XP_3A_MAIN . . . .  N NUMB   0001h            



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6965    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =    103    ----
   IDATA SIZE       =     87    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
