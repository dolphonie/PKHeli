MACRO ASSEMBLER BLHELI                                      01/01/16 17:30:02 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\XROTOR_40A_REV14_3.OBJ
ASSEMBLER INVOKED BY: PRINT SET(BESCNO=187) OBJECT(OUTPUT\XROTOR_40A_REV14_3.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ;
                         4     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                         5     ;
                         6     ; Copyright 2011, 2012 Steffen Skaug
                         7     ; This program is distributed under the terms of the GNU General Public License
                         8     ;
                         9     ; This file is part of BLHeli.
                        10     ;
                        11     ; BLHeli is free software: you can redistribute it and/or modify
                        12     ; it under the terms of the GNU General Public License as published by
                        13     ; the Free Software Foundation, either version 3 of the License, or
                        14     ; (at your option) any later version.
                        15     ;
                        16     ; BLHeli is distributed in the hope that it will be useful,
                        17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        19     ; GNU General Public License for more details.
                        20     ;
                        21     ; You should have received a copy of the GNU General Public License
                        22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                        23     ;
                        24     ;**** **** **** **** ****
                        25     ;
                        26     ; The software was initially designed for use with Eflite mCP X, but is now adapted to copters/planes in general
                        27     ;
                        28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.versanet.de/~bkonze/blc_6a/blc_6a.htm
                        29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                        30     ;
                        31     ; This file is best viewed with tab width set to 5
                        32     ;
                        33     ; The input signal can be positive 1kHz, 2kHz, 4kHz, 8kHz or 12kHz PWM (e.g. taken from the "resistor tap" on mCPx)
                        34     ; And the input signal can be PPM (1-2ms) or OneShot125 (125-250us) at rates up to several hundred Hz.
                        35     ; The code autodetects the various input modes/frequencies
                        36     ; The code can also be programmed to accept inverted input signal.
                        37     ;
                        38     ; The first lines of the software must be modified according to the chosen environment:
                        39     ; Uncomment the selected ESC and main/tail/multi mode
                        40     ; BESCNO EQU "ESC"_"mode" 						
                        41     ; 
                        42     ;**** **** **** **** ****
                        43     ; Revision history:
                        44     ; - Rev1.0: Initial revision based upon BLHeli for AVR controllers
                        45     ; - Rev2.0: Changed "Eeprom" initialization, layout and defaults
                        46     ;           Various changes and improvements to comparator reading. Now using timer1 for time from pwm on/off
                        47     ;           Beeps are made louder
                        48     ;           Added programmable low voltage limit
                        49     ;           Added programmable damped tail mode (only for 1S ESCs)
                        50     ;           Added programmable motor rotation direction
                        51     ; - Rev2.1: (minor changes by 4712)
                        52     ;		  Added Disable TX Programming by PC Setup Application 
                        53     ;		  therfore changed EEPROM_LAYOUT_REVISION = 8					
                        54     ;		  Added Vdd Monitor as reset source when writing to "EEProm"
                        55     ;		  Changed for use of batch file to assemble, link and make hex files	
                        56     ; - Rev2.2: (minor changes by 4712)
                        57     ;           Added Disable Throttle Re-Arming every motor start by PC Setup Application 
                        58     ; - Rev2.3: (minor changes by 4712)
                        59     ;           Added bugfixed (2x CLR C before j(n)c operations)thx Steffen!			
                        60     ; - Rev2.4: Revisions 2.1 to 2.3 integrated
                        61     ; - Rev3.0: Added PPM (1050us-1866us) as accepted input signal
                        62     ;           Added startup rpm as a programming parameter
                        63     ;           Added startup acceleration as a programming parameter
                        64     ;           Added option for using voltage measurements to compensate motor power
                        65     ;           Added governor target by setup as a governor mode option
                        66     ;           Governor is kept active regardless of rpm
                        67     ;           Smooth governor spoolup/down in arm and setup modes
                        68     ;           Increased governor P and I gain programming ranges
                        69     ;           Increased and changed low voltage limit programming range
                        70     ;           Disabled tx programming entry for all but the first arming sequence after power on
                        71     ;           Made it possible to skip parameters in tx programming by setting throttle midstick
                        72     ;           Made it default not to rearm for every restart
                        73     ; - Rev3.1: Fixed bug that prevented chosen parameter to be set in tx programming
                        74     ; - Rev3.2: ...also updated the EEPROM revision parameter
                        75     ; - Rev3.3: Fixed negative number bug in voltage compensation
                        76     ;           Fixed bug in startup power calculation for non-default power
                        77     ;           Prevented possibility for voltage compensation fighting low voltage limiting
                        78     ;           Applied overall spoolup control to ensure soft spoolup in any mode
                        79     ;           Added a delay of 3 seconds from initiation of main motor stop until new startup is allowed
                        80     ;           Reduced beep power to reduce power consumption for very strong motors/ESCs
                        81     ; - Rev3.4: Fixed bug that prevented full power in governor arm and setup modes
                        82     ;           Increased NFETON_DELAY for XP_7A and XP_12A to allow for more powerful fets
                        83     ;           Increased initial spoolup power, and linked to startup power
                        84     ; - Rev4.0: Fixed bug that made tail tx program beeps very weak
                        85     ;           Added thermal protection feature
                        86     ;           Governor P and I gain ranges are extended up to 8.0x gain
                        87     ;           Startup sequence is aborted upon zero throttle
                        88     ;           Avoided voltage compensation function induced latency for tail when voltage compensation is not enabled
                        89     ;           Improved input signal frequency detection robustness
                        90     ; - Rev4.1: Increased thermal protection temperature limits
                        91     ; - Rev5.0: Added multi(copter) operating mode. TAIL define changed to MODE with three modes: MAIN, TAIL and MULTI
                        92     ;           Added programmable commutation timing
                        93     ;           Added a damped light mode that has less damping, but that can be used with all escs
                        94     ;           Added programmable damping force
                        95     ;           Added thermal protection for startup too
                        96     ;           Added wait beeps when waiting more than 30 sec for throttle above zero (after having been armed)
                        97     ;           Modified tail idling to provide option for very low speeds
                        98     ;           Changed PPM range to 1150-1830us
                        99     ;           Arming sequence is dropped for PPM input, unless it is governor arm mode
                       100     ;           Loss of input signal will immediately stop the motor for PPM input
                       101     ;           Bug corrected in Turnigy Plush 6A voltage measurement setup
                       102     ;           FET switching delays are set for original fets. Stronger/doubled/tripled etc fets may require faster pfet off switching
                       103     ;           Miscellaneous other changes
                       104     ; - Rev6.0: Reverted comparator reading routine to rev5.0 equivalent, in order to avoid tail motor stops
                       105     ;           Added governor range programmability
                       106     ;           Implemented startup retry sequence with varying startup power for multi mode
                       107     ;           In damped light mode, damping is now applied to the active nfet phase for fully damped capable ESCs
                       108     ; - Rev6.1: Added input signal qualification criteria for PPM, to avoid triggering on noise spikes (fix for plush hardware)
                       109     ;           Changed main and multi mode stop criteria. Will now be in run mode, even if RC pulse input is zero
                       110     ;           Fixed bug in commutation that caused rough running in damped light mode
                       111     ;           Miscellaneous other changes
                       112     ; - Rev7.0  Added direct startup mode programmability
                       113     ;           Added throttle calibration. Min>=1000us and Max<=2000us. Difference must be >520us, otherwise max is shifted so that difference=520us
                       114     ;           Added programmable throttle change rate
                       115     ;           Added programmable beep strength, beacon strength and beacon delay
                       116     ;           Reduced power step to full power significantly
                       117     ;           Miscellaneous other changes
                       118     ; - Rev8.0  Added a 2 second delay after power up, to wait for receiver initialization
                       119     ;           Added a programming option for disabling low voltage limit, and made it default for MULTI
                       120     ;           Added programable demag compensation, using the concept of SimonK
                       121     ;           Improved robustness against noisy input signal
                       122     ;           Refined direct startup
                       123     ;           Removed voltage compensation
                       124     ;           Miscellaneous other changes
                       125     ; - Rev9.0  Increased programming range for startup power, and made its default ESC dependent
                       126     ;           Made default startup method ESC dependent
                       127     ;           Even more smooth and gentle spoolup for MAIN, to suit larger helis
                       128     ;           Improved transition from stepped startup to run
                       129     ;           Refined direct startup
                       130     ; - Rev9.1  Fixed bug that changed FW revision after throttle calibration or TX programming
                       131     ; - Rev9.2  Altered timing of throttle calibration in order to work with MultiWii calibration firmware
                       132     ;           Reduced main spoolup time to around 5 seconds
                       133     ;           Changed default beacon delay to 3 minutes
                       134     ; - Rev9.3  Fixed bug in Plush 60/80A temperature reading, that caused failure in operation above 4S
                       135     ;           Corrected temperature limit for HiModel cool 22/33/41A, RCTimer 6A, Skywalker 20/40A, Turnigy AE45A, Plush 40/60/80A. Limit was previously set too high
                       136     ; - Rev9.4  Improved timing for increased maximum rpm limit
                       137     ; - Rev10.0 Added closed loop mode for multi
                       138     ;           Added high/low BEC voltage option (for the ESCs where HW supports it)
                       139     ;           Added method of resetting all programmed parameter values to defaults by TX programming
                       140     ;           Added Turnigy K-force 40A and Turnigy K-force 120A HV ESCs
                       141     ;           Enabled fully damped mode for several ESCs
                       142     ;           Extended startup power range downwards to enable very smooth start for large heli main motors
                       143     ;           Extended damping force with a highest setting
                       144     ;           Corrected temperature limits for F310 chips (Plush 40A and AE 45A)
                       145     ;           Implemented temperature reading average in order to avoid problems with ADC noise on Skywalkers
                       146     ;           Increased switching delays for XP 7A fast, in order to avoid cross conduction of N and P fets
                       147     ;           Miscellaneous other changes
                       148     ; - Rev10.1 Relaxed RC signal jitter requirement during frequency measurement
                       149     ;           Corrected bug that prevented using governor low
                       150     ;           Enabled vdd monitor always, in order to reduce likelihood of accidental overwriting of adjustments
                       151     ;           Fixed bug that caused stop for PPM input above 2048us, and moved upper accepted limit to 2160us
                       152     ; - Rev10.2 Corrected temperature limit for AE20-30/XP7-25, where limit was too high
                       153     ;           Corrected temperature limit for 120HV, where limit was too low
                       154     ;           Fixed bug that caused AE20/25/30A not to run in reverse
                       155     ; - Rev10.3 Removed vdd monitor for 1S capable ESCs, in order to avoid brownouts/resets
                       156     ;           Made auto bailout spoolup for main more smooth
                       157     ; - Rev10.4 Ensured that main spoolup and governor activation will always be smooth, regardless of throttle input
                       158     ;           Added capability to operate on 12kHz input signal too
                       159     ; - Rev11.0 Fixed bug of programming default values for governor in MULTI mode
                       160     ;           Disabled interrupts explicitly some places, to avoid possibilities for unintentional fet switching
                       161     ;           Changed interrupt disable strategy, to always allow pwm interrupts, to avoid noise when running at low rpms
                       162     ;           Added governor middle range for MAIN mode
                       163     ;           Added bidirectional mode for TAIL and MULTI mode with PPM input
                       164     ;           Changed and improved demag compensation
                       165     ;           Miscellaneous other changes
                       166     ; - Rev11.1 Fixed bug of slow acceleration response for MAIN mode running without governor
                       167     ;           Fixed bug with PWM input, where throttle remains high even when zeroing throttle (seen on V922 tail)
                       168     ;           Fixed bug in bidirectional operation, where direction change could cause reset
                       169     ;           Improved autorotation bailout for MAIN
                       170     ;           Reduced min speed back to 1220 erpm
                       171     ;           Misc code cleanups
                       172     ; - Rev11.2 Fixed throttle calibration bug
                       173     ;           Added high side driver precharge for all-nfet ESCs
                       174     ;           Optimized timing in general and for demag compensation in particular
                       175     ;           Auto bailout functionality modified
                       176     ;           Governor is deactivated for throttle inputs below 10%
                       177     ;           Increased beacon delay times
                       178     ; - Rev12.0 Added programmable main spoolup time
                       179     ;           Added programmable temperature protection enable
                       180     ;           Bidirectional mode stop/start improved. Motor is now stopped before starting
                       181     ;           Power is limited for very low rpms (when BEMF is low), in order to avoid sync loss 
                       182     ;           Damped light mode is made more smooth and quiet, particularly at low and high rpms
                       183     ;           Comparator signal qualification scheme is changed
                       184     ;           Demag compensation scheme is significantly changed
                       185     ;           Increased jitter tolerance for PPM frequency measurement
                       186     ;           Fully damped mode removed, and damped light only supported on damped capable ESCs
                       187     ;           Default tail mode changed to damped light
                       188     ;           Miscellaneous other changes
                       189     ; - Rev12.1 Fixed bug in tail code
                       190     ;           Improved startup for Atmel
                       191     ;           Added support for multiple high BEC voltages
                       192     ;           Added support for RPM output
                       193     ; - Rev12.2 Improved running smoothness, particularly for damped light
                       194     ;           Avoiding lockup at full throttle when input signal is noisy
                       195     ;           Avoiding detection of 1-wire programming signal as valid throttle signal
                       196     ; - Rev13.0 Removed stepped start
                       197     ;           Removed throttle change rate and damping force parameters
                       198     ;           Added support for OneShot125
                       199     ;           Improved commutation timing accuracy
                       200     ; - Rev13.1 Removed startup ramp for MULTI
                       201     ;           Improved startup for some odd ESCs
                       202     ; - Rev13.2 Still tweaking startup to make it more reliable and faster for all ESC/motor combos
                       203     ;           Increased deadband for bidirectional operation
                       204     ;           Relaxed signal detection criteria
                       205     ;           Added support for running 48MHz capable SiLabs MCUs at 48MHz
                       206     ;           Added bootlader to SiLabs code
                       207     ;           Miscellaneous other changes
                       208     ; - Rev14.0 Improved running at high timing
                       209     ;           Improved running at high RPMs and increased max RPM limit
                       210     ;           Avoid being locked in bootloader (implemented in Suite 13202)
                       211     ;           Improved reliability of 3D (bidirectional) mode and startup
                       212     ;           Smoother running and greatly reduced step to full power in damped light mode
                       213     ;           Removed low voltage limiting for MULTI
                       214     ;           Added pwm dither parameter
                       215     ;           Added setting for enable/disable of low RPM power protection
                       216     ;           Added setting for enable/disable of PWM input
                       217     ;           Better AFW and damping for some ESCs (that have a slow high side driver)
                       218     ;           Miscellaneous other changes
                       219     ; - Rev14.1 Fixed max throttle calibration bug (for non-oneshot)
                       220     ;           Fixed some closed loop mode bugs
                       221     ;           Relaxed signal jitter requirement for looptimes below 1000
                       222     ;           Added skipping of damping fet switching near max power, for improved high end throttle linearity, using the concept of SimonK
                       223     ;           Improved sync hold at high rpms
                       224     ; - Rev14.2 Added stalled motor shutoff after about 10 seconds (for tail and multi code with PPM input)
                       225     ;           Greatly increased maximum rpm limit, and added rpm limiting at 250k erpm (48MHz MCUs at 400k erpm)
                       226     ;           Improved bidirectional operation
                       227     ; - Rev14.3 Moved reset vector to be just before the settings segment, in order to better recover from partially failed flashing operation
                       228     ;           Added 100ms intialization delay for the Graupner Ultra 20A ESC
                       229     ;           Shortened stall detect time to about 5sec, and prevented going into tx programming after a stall
                       230     ;           Optimizations of software timing and running reliability
                       231     ;
                       232     ;           
                       233     ;
                       234     ;**** **** **** **** ****
                       235     ; Up to 8K Bytes of In-System Self-Programmable Flash
                       236     ; 768 Bytes Internal SRAM
                       237     ;
                       238     ;**** **** **** **** ****
                       239     ; Master clock is internal 24MHz oscillator
                       240     ; Timer 0 (167/500ns counts) always counts up and is used for
                       241     ; - PWM generation
                       242     ; Timer 1 (167/500ns counts) always counts up and is used for
                       243     ; - Time from pwm on/off event
                       244     ; Timer 2 (500ns counts) always counts up and is used for
                       245     ; - RC pulse timeout/skip counts and commutation times
                       246     ; Timer 3 (500ns counts) always counts up and is used for
                       247     ; - Commutation timeouts
                       248     ; PCA0 (500ns counts) always counts up and is used for
                       249     ; - RC pulse measurement
                       250     ;
                       251     ;**** **** **** **** ****
                       252     ; Interrupt handling
                       253     ; The F330 does not disable interrupts when entering an interrupt routine.
                       254     ; Also some interrupt flags need to be cleared by software
                       255     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                       256     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                       257     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                       258     ;
                       259     ;**** **** **** **** ****
                       260     ; Motor control:
                       261     ; - Brushless motor control with 6 states for each electrical 360 degrees
                       262     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                       263     ; - Timing advance in this implementation is set to 15deg nominally
                       264     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                       265     ; Motor sequence starting from zero crossing:
                       266     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                       267     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                       268     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                       269     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                       270     ;
                       271     ; Motor startup:
                       272     ; Startup is the only phase, before normal bemf commutation run begins.
                       273     ;
                       274     ;**** **** **** **** ****
                       275     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0001                 276     XP_3A_MAIN 					EQU 1
  0002                 277     XP_3A_TAIL 					EQU 2
  0003                 278     XP_3A_MULTI 					EQU 3
  0004                 279     XP_7A_MAIN 					EQU 4
  0005                 280     XP_7A_TAIL 					EQU 5
  0006                 281     XP_7A_MULTI 					EQU 6
  0007                 282     XP_7A_FAST_MAIN 				EQU 7
  0008                 283     XP_7A_FAST_TAIL 				EQU 8
  0009                 284     XP_7A_FAST_MULTI 				EQU 9
  000A                 285     XP_12A_MAIN 					EQU 10
  000B                 286     XP_12A_TAIL 					EQU 11
  000C                 287     XP_12A_MULTI 					EQU 12
  000D                 288     XP_18A_MAIN 					EQU 13
  000E                 289     XP_18A_TAIL 					EQU 14
  000F                 290     XP_18A_MULTI 					EQU 15
  0010                 291     XP_25A_MAIN 					EQU 16
  0011                 292     XP_25A_TAIL 					EQU 17
  0012                 293     XP_25A_MULTI 					EQU 18
  0013                 294     XP_35A_SW_MAIN 				EQU 19
  0014                 295     XP_35A_SW_TAIL 				EQU 20
  0015                 296     XP_35A_SW_MULTI 				EQU 21
  0016                 297     DP_3A_MAIN 					EQU 22
  0017                 298     DP_3A_TAIL  					EQU 23
  0018                 299     DP_3A_MULTI  					EQU 24
  0019                 300     SUPERMICRO_3P5A_MAIN 			EQU 25
  001A                 301     SUPERMICRO_3P5A_TAIL 			EQU 26   
  001B                 302     SUPERMICRO_3P5A_MULTI 			EQU 27   
  001C                 303     TURNIGY_PLUSH_6A_MAIN 			EQU 28
  001D                 304     TURNIGY_PLUSH_6A_TAIL 			EQU 29   
  001E                 305     TURNIGY_PLUSH_6A_MULTI 			EQU 30   
  001F                 306     TURNIGY_PLUSH_10A_MAIN 			EQU 31
  0020                 307     TURNIGY_PLUSH_10A_TAIL 			EQU 32   
  0021                 308     TURNIGY_PLUSH_10A_MULTI 			EQU 33   
  0022                 309     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                 310     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                 311     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  0025                 312     TURNIGY_PLUSH_18A_MAIN 			EQU 37
  0026                 313     TURNIGY_PLUSH_18A_TAIL 			EQU 38   
  0027                 314     TURNIGY_PLUSH_18A_MULTI 			EQU 39   
  0028                 315     TURNIGY_PLUSH_25A_MAIN 			EQU 40
  0029                 316     TURNIGY_PLUSH_25A_TAIL 			EQU 41   
  002A                 317     TURNIGY_PLUSH_25A_MULTI 			EQU 42   
  002B                 318     TURNIGY_PLUSH_30A_MAIN 			EQU 43
  002C                 319     TURNIGY_PLUSH_30A_TAIL 			EQU 44   
  002D                 320     TURNIGY_PLUSH_30A_MULTI 			EQU 45   
  002E                 321     TURNIGY_PLUSH_40A_MAIN 			EQU 46
  002F                 322     TURNIGY_PLUSH_40A_TAIL 			EQU 47   
  0030                 323     TURNIGY_PLUSH_40A_MULTI 			EQU 48   
  0031                 324     TURNIGY_PLUSH_60A_MAIN 			EQU 49
  0032                 325     TURNIGY_PLUSH_60A_TAIL 			EQU 50   
  0033                 326     TURNIGY_PLUSH_60A_MULTI 			EQU 51   
  0034                 327     TURNIGY_PLUSH_80A_MAIN 			EQU 52
  0035                 328     TURNIGY_PLUSH_80A_TAIL 			EQU 53   
  0036                 329     TURNIGY_PLUSH_80A_MULTI 			EQU 54   
  0037                 330     TURNIGY_PLUSH_NFET_18A_MAIN 		EQU 55
  0038                 331     TURNIGY_PLUSH_NFET_18A_TAIL 		EQU 56   
  0039                 332     TURNIGY_PLUSH_NFET_18A_MULTI 		EQU 57   
  003A                 333     TURNIGY_PLUSH_NFET_25A_MAIN 		EQU 58
  003B                 334     TURNIGY_PLUSH_NFET_25A_TAIL 		EQU 59   
  003C                 335     TURNIGY_PLUSH_NFET_25A_MULTI 		EQU 60   
  003D                 336     TURNIGY_PLUSH_NFET_30A_MAIN 		EQU 61
  003E                 337     TURNIGY_PLUSH_NFET_30A_TAIL 		EQU 62   
  003F                 338     TURNIGY_PLUSH_NFET_30A_MULTI 		EQU 63   
  0040                 339     TURNIGY_AE_20A_MAIN 			EQU 64
  0041                 340     TURNIGY_AE_20A_TAIL 			EQU 65   
  0042                 341     TURNIGY_AE_20A_MULTI 			EQU 66   
  0043                 342     TURNIGY_AE_25A_MAIN 			EQU 67
  0044                 343     TURNIGY_AE_25A_TAIL 			EQU 68   
  0045                 344     TURNIGY_AE_25A_MULTI 			EQU 69   
  0046                 345     TURNIGY_AE_30A_MAIN 			EQU 70
  0047                 346     TURNIGY_AE_30A_TAIL 			EQU 71   
  0048                 347     TURNIGY_AE_30A_MULTI 			EQU 72   
  0049                 348     TURNIGY_AE_45A_MAIN 			EQU 73
  004A                 349     TURNIGY_AE_45A_TAIL 			EQU 74   
  004B                 350     TURNIGY_AE_45A_MULTI 			EQU 75   
  004C                 351     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                 352     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                 353     TURNIGY_KFORCE_40A_MULTI 		EQU 78   
  004F                 354     TURNIGY_KFORCE_70A_HV_MAIN 		EQU 79   
  0050                 355     TURNIGY_KFORCE_70A_HV_TAIL 		EQU 80   
  0051                 356     TURNIGY_KFORCE_70A_HV_MULTI 		EQU 81   
  0052                 357     TURNIGY_KFORCE_120A_HV_MAIN 		EQU 82   
  0053                 358     TURNIGY_KFORCE_120A_HV_TAIL 		EQU 83   
  0054                 359     TURNIGY_KFORCE_120A_HV_MULTI 		EQU 84   
  0055                 360     TURNIGY_KFORCE_120A_HV_V2_MAIN	EQU 85   
  0056                 361     TURNIGY_KFORCE_120A_HV_V2_TAIL 	EQU 86   
  0057                 362     TURNIGY_KFORCE_120A_HV_V2_MULTI 	EQU 87   
  0058                 363     SKYWALKER_20A_MAIN 				EQU 88
  0059                 364     SKYWALKER_20A_TAIL 				EQU 89   
  005A                 365     SKYWALKER_20A_MULTI 			EQU 90   
  005B                 366     SKYWALKER_40A_MAIN 				EQU 91
  005C                 367     SKYWALKER_40A_TAIL 				EQU 92   
  005D                 368     SKYWALKER_40A_MULTI 			EQU 93   
  005E                 369     HIMODEL_COOL_22A_MAIN 			EQU 94
  005F                 370     HIMODEL_COOL_22A_TAIL 			EQU 95   
  0060                 371     HIMODEL_COOL_22A_MULTI 			EQU 96   
  0061                 372     HIMODEL_COOL_33A_MAIN 			EQU 97
  0062                 373     HIMODEL_COOL_33A_TAIL 			EQU 98   
  0063                 374     HIMODEL_COOL_33A_MULTI 			EQU 99  
  0064                 375     HIMODEL_COOL_41A_MAIN 			EQU 100
  0065                 376     HIMODEL_COOL_41A_TAIL 			EQU 101  
  0066                 377     HIMODEL_COOL_41A_MULTI 			EQU 102  
  0067                 378     RCTIMER_6A_MAIN 				EQU 103   
  0068                 379     RCTIMER_6A_TAIL 				EQU 104  
  0069                 380     RCTIMER_6A_MULTI 				EQU 105  
  006A                 381     ALIGN_RCE_BL15X_MAIN			EQU 106   
  006B                 382     ALIGN_RCE_BL15X_TAIL 			EQU 107  
  006C                 383     ALIGN_RCE_BL15X_MULTI 			EQU 108  
  006D                 384     ALIGN_RCE_BL15P_MAIN			EQU 109  
  006E                 385     ALIGN_RCE_BL15P_TAIL 			EQU 110  
  006F                 386     ALIGN_RCE_BL15P_MULTI 			EQU 111  
  0070                 387     ALIGN_RCE_BL35X_MAIN			EQU 112  
  0071                 388     ALIGN_RCE_BL35X_TAIL 			EQU 113  
  0072                 389     ALIGN_RCE_BL35X_MULTI 			EQU 114  
  0073                 390     ALIGN_RCE_BL35P_MAIN			EQU 115   
  0074                 391     ALIGN_RCE_BL35P_TAIL 			EQU 116  
  0075                 392     ALIGN_RCE_BL35P_MULTI 			EQU 117  
  0076                 393     GAUI_GE_183_18A_MAIN			EQU 118   
  0077                 394     GAUI_GE_183_18A_TAIL 			EQU 119  
  0078                 395     GAUI_GE_183_18A_MULTI 			EQU 120  
  0079                 396     H_KING_10A_MAIN				EQU 121   
  007A                 397     H_KING_10A_TAIL 				EQU 122  
  007B                 398     H_KING_10A_MULTI 				EQU 123  
  007C                 399     H_KING_20A_MAIN				EQU 124   
  007D                 400     H_KING_20A_TAIL 				EQU 125  
  007E                 401     H_KING_20A_MULTI 				EQU 126  
  007F                 402     H_KING_35A_MAIN				EQU 127   
  0080                 403     H_KING_35A_TAIL 				EQU 128 
  0081                 404     H_KING_35A_MULTI 				EQU 129  
  0082                 405     H_KING_50A_MAIN				EQU 130   
  0083                 406     H_KING_50A_TAIL 				EQU 131  
  0084                 407     H_KING_50A_MULTI 				EQU 132  
  0085                 408     POLARIS_THUNDER_12A_MAIN			EQU 133   
  0086                 409     POLARIS_THUNDER_12A_TAIL 		EQU 134  
  0087                 410     POLARIS_THUNDER_12A_MULTI 		EQU 135  
  0088                 411     POLARIS_THUNDER_20A_MAIN			EQU 136   
  0089                 412     POLARIS_THUNDER_20A_TAIL 		EQU 137  
  008A                 413     POLARIS_THUNDER_20A_MULTI 		EQU 138  
  008B                 414     POLARIS_THUNDER_30A_MAIN			EQU 139   
  008C                 415     POLARIS_THUNDER_30A_TAIL 		EQU 140  
  008D                 416     POLARIS_THUNDER_30A_MULTI 		EQU 141  
  008E                 417     POLARIS_THUNDER_40A_MAIN			EQU 142   
  008F                 418     POLARIS_THUNDER_40A_TAIL 		EQU 143  
  0090                 419     POLARIS_THUNDER_40A_MULTI 		EQU 144  
  0091                 420     POLARIS_THUNDER_60A_MAIN			EQU 145   
  0092                 421     POLARIS_THUNDER_60A_TAIL 		EQU 146  
  0093                 422     POLARIS_THUNDER_60A_MULTI 		EQU 147  
  0094                 423     POLARIS_THUNDER_80A_MAIN			EQU 148   
  0095                 424     POLARIS_THUNDER_80A_TAIL 		EQU 149  
  0096                 425     POLARIS_THUNDER_80A_MULTI 		EQU 150  
  0097                 426     POLARIS_THUNDER_100A_MAIN		EQU 151   
  0098                 427     POLARIS_THUNDER_100A_TAIL 		EQU 152  
  0099                 428     POLARIS_THUNDER_100A_MULTI 		EQU 153  
  009A                 429     PLATINUM_PRO_30A_MAIN			EQU 154   
  009B                 430     PLATINUM_PRO_30A_TAIL 			EQU 155  
  009C                 431     PLATINUM_PRO_30A_MULTI 			EQU 156  
  009D                 432     PLATINUM_PRO_150A_MAIN			EQU 157   
  009E                 433     PLATINUM_PRO_150A_TAIL 			EQU 158  
  009F                 434     PLATINUM_PRO_150A_MULTI 			EQU 159  
  00A0                 435     PLATINUM_50AV3_MAIN				EQU 160   
  00A1                 436     PLATINUM_50AV3_TAIL 			EQU 161  
  00A2                 437     PLATINUM_50AV3_MULTI 			EQU 162  
  00A3                 438     EAZY_3AV2_MAIN					EQU 163   
  00A4                 439     EAZY_3AV2_TAIL 				EQU 164  
  00A5                 440     EAZY_3AV2_MULTI 				EQU 165  
  00A6                 441     TAROT_30A_MAIN					EQU 166   
  00A7                 442     TAROT_30A_TAIL 				EQU 167  
  00A8                 443     TAROT_30A_MULTI 				EQU 168  
  00A9                 444     SKYIII_30A_MAIN				EQU 169   
  00AA                 445     SKYIII_30A_TAIL 				EQU 170  
  00AB                 446     SKYIII_30A_MULTI 				EQU 171  
  00AC                 447     EMAX_20A_MAIN					EQU 172   
  00AD                 448     EMAX_20A_TAIL 					EQU 173  
  00AE                 449     EMAX_20A_MULTI 				EQU 174  
  00AF                 450     EMAX_40A_MAIN					EQU 175   
  00B0                 451     EMAX_40A_TAIL 					EQU 176  
  00B1                 452     EMAX_40A_MULTI 				EQU 177  
  00B2                 453     EMAX_NANO_20A_MAIN				EQU 178   
  00B3                 454     EMAX_NANO_20A_TAIL 				EQU 179  
  00B4                 455     EMAX_NANO_20A_MULTI 			EQU 180  
  00B5                 456     XROTOR_10A_MAIN				EQU 181   
  00B6                 457     XROTOR_10A_TAIL 				EQU 182  
  00B7                 458     XROTOR_10A_MULTI 				EQU 183  
  00B8                 459     XROTOR_20A_MAIN				EQU 184   
  00B9                 460     XROTOR_20A_TAIL 				EQU 185  
  00BA                 461     XROTOR_20A_MULTI 				EQU 186  
  00BB                 462     XROTOR_40A_MAIN				EQU 187   
  00BC                 463     XROTOR_40A_TAIL 				EQU 188  
  00BD                 464     XROTOR_40A_MULTI 				EQU 189  
  00BE                 465     MDRX62H_MAIN					EQU 190   
  00BF                 466     MDRX62H_TAIL 					EQU 191  
  00C0                 467     MDRX62H_MULTI 					EQU 192  
  00C1                 468     ROTORGEEKS_20A_MAIN				EQU 193   
  00C2                 469     ROTORGEEKS_20A_TAIL 			EQU 194  
  00C3                 470     ROTORGEEKS_20A_MULTI 			EQU 195  
  00C4                 471     FLYCOLOR_FAIRY_6A_MAIN			EQU 196   
  00C5                 472     FLYCOLOR_FAIRY_6A_TAIL 			EQU 197  
  00C6                 473     FLYCOLOR_FAIRY_6A_MULTI 			EQU 198  
  00C7                 474     FLYCOLOR_FAIRY_30A_MAIN			EQU 199   
  00C8                 475     FLYCOLOR_FAIRY_30A_TAIL 			EQU 200  
  00C9                 476     FLYCOLOR_FAIRY_30A_MULTI 		EQU 201  
  00CA                 477     FVT_LITTLEBEE_20A_MAIN			EQU 202  
  00CB                 478     FVT_LITTLEBEE_20A_TAIL			EQU 203  
  00CC                 479     FVT_LITTLEBEE_20A_MULTI			EQU 204  
  00CD                 480     FVT_LITTLEBEE_30A_MAIN			EQU 205  
  00CE                 481     FVT_LITTLEBEE_30A_TAIL			EQU 206  
  00CF                 482     FVT_LITTLEBEE_30A_MULTI			EQU 207  
  00D0                 483     GRAUPNER_ULTRA_20A_MAIN			EQU 208  
  00D1                 484     GRAUPNER_ULTRA_20A_TAIL			EQU 209  
  00D2                 485     GRAUPNER_ULTRA_20A_MULTI			EQU 210  
  00D3                 486     F85_3A_MAIN					EQU 211  
  00D4                 487     F85_3A_TAIL					EQU 212  
  00D5                 488     F85_3A_MULTI					EQU 213  
  00D6                 489     ZTW_SPIDER_PRO_20A_MAIN			EQU 214  
  00D7                 490     ZTW_SPIDER_PRO_20A_TAIL			EQU 215  
  00D8                 491     ZTW_SPIDER_PRO_20A_MULTI			EQU 216  
                       492     
                       493     
                       494     ;**** **** **** **** ****
                       495     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                       496     ;BESCNO EQU XP_3A_Main 
                       497     ;BESCNO EQU XP_3A_Tail
                       498     ;BESCNO EQU XP_3A_Multi
                       499     ;BESCNO EQU XP_7A_Main
                       500     ;BESCNO EQU XP_7A_Tail
                       501     ;BESCNO EQU XP_7A_Multi
                       502     ;BESCNO EQU XP_7A_Fast_Main
                       503     ;BESCNO EQU XP_7A_Fast_Tail
                       504     ;BESCNO EQU XP_7A_Fast_Multi
                       505     ;BESCNO EQU XP_12A_Main
                       506     ;BESCNO EQU XP_12A_Tail 
                       507     ;BESCNO EQU XP_12A_Multi
                       508     ;BESCNO EQU XP_18A_Main 
                       509     ;BESCNO EQU XP_18A_Tail 
                       510     ;BESCNO EQU XP_18A_Multi
                       511     ;BESCNO EQU XP_25A_Main 
                       512     ;BESCNO EQU XP_25A_Tail 
                       513     ;BESCNO EQU XP_25A_Multi
                       514     ;BESCNO EQU XP_35A_SW_Main
                       515     ;BESCNO EQU XP_35A_SW_Tail 
                       516     ;BESCNO EQU XP_35A_SW_Multi
                       517     ;BESCNO EQU DP_3A_Main 						
                       518     ;BESCNO EQU DP_3A_Tail 
                       519     ;BESCNO EQU DP_3A_Multi 
                       520     ;BESCNO EQU Supermicro_3p5A_Main
                       521     ;BESCNO EQU Supermicro_3p5A_Tail 
                       522     ;BESCNO EQU Supermicro_3p5A_Multi
                       523     ;BESCNO EQU Turnigy_Plush_6A_Main 
                       524     ;BESCNO EQU Turnigy_Plush_6A_Tail 
                       525     ;BESCNO EQU Turnigy_Plush_6A_Multi
                       526     ;BESCNO EQU Turnigy_Plush_10A_Main 
                       527     ;BESCNO EQU Turnigy_Plush_10A_Tail 
                       528     ;BESCNO EQU Turnigy_Plush_10A_Multi
                       529     ;BESCNO EQU Turnigy_Plush_12A_Main 
                       530     ;BESCNO EQU Turnigy_Plush_12A_Tail 
                       531     ;BESCNO EQU Turnigy_Plush_12A_Multi 
                       532     ;BESCNO EQU Turnigy_Plush_18A_Main 
                       533     ;BESCNO EQU Turnigy_Plush_18A_Tail 
                       534     ;BESCNO EQU Turnigy_Plush_18A_Multi
                       535     ;BESCNO EQU Turnigy_Plush_25A_Main 
                       536     ;BESCNO EQU Turnigy_Plush_25A_Tail
                       537     ;BESCNO EQU Turnigy_Plush_25A_Multi
                       538     ;BESCNO EQU Turnigy_Plush_30A_Main 
                       539     ;BESCNO EQU Turnigy_Plush_30A_Tail 
                       540     ;BESCNO EQU Turnigy_Plush_30A_Multi
                       541     ;BESCNO EQU Turnigy_Plush_40A_Main 
                       542     ;BESCNO EQU Turnigy_Plush_40A_Tail 
                       543     ;BESCNO EQU Turnigy_Plush_40A_Multi 
                       544     ;BESCNO EQU Turnigy_Plush_60A_Main
                       545     ;BESCNO EQU Turnigy_Plush_60A_Tail 
                       546     ;BESCNO EQU Turnigy_Plush_60A_Multi
                       547     ;BESCNO EQU Turnigy_Plush_80A_Main
                       548     ;BESCNO EQU Turnigy_Plush_80A_Tail 
                       549     ;BESCNO EQU Turnigy_Plush_80A_Multi
                       550     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Main
                       551     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Tail 
                       552     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Multi 
                       553     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Main 
                       554     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Tail
                       555     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Multi
                       556     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Main  
                       557     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Tail 
                       558     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Multi
                       559     ;BESCNO EQU Turnigy_AE_20A_Main 
                       560     ;BESCNO EQU Turnigy_AE_20A_Tail 
                       561     ;BESCNO EQU Turnigy_AE_20A_Multi
                       562     ;BESCNO EQU Turnigy_AE_25A_Main 
                       563     ;BESCNO EQU Turnigy_AE_25A_Tail 
                       564     ;BESCNO EQU Turnigy_AE_25A_Multi
                       565     ;BESCNO EQU Turnigy_AE_30A_Main 
                       566     ;BESCNO EQU Turnigy_AE_30A_Tail 
                       567     ;BESCNO EQU Turnigy_AE_30A_Multi
                       568     ;BESCNO EQU Turnigy_AE_45A_Main
                       569     ;BESCNO EQU Turnigy_AE_45A_Tail 
                       570     ;BESCNO EQU Turnigy_AE_45A_Multi
                       571     ;BESCNO EQU Turnigy_KForce_40A_Main
                       572     ;BESCNO EQU Turnigy_KForce_40A_Tail 
                       573     ;BESCNO EQU Turnigy_KForce_40A_Multi 
                       574     ;BESCNO EQU Turnigy_KForce_70A_HV_Main
                       575     ;BESCNO EQU Turnigy_KForce_70A_HV_Tail 
                       576     ;BESCNO EQU Turnigy_KForce_70A_HV_Multi
                       577     ;BESCNO EQU Turnigy_KForce_120A_HV_Main
                       578     ;BESCNO EQU Turnigy_KForce_120A_HV_Tail 
                       579     ;BESCNO EQU Turnigy_KForce_120A_HV_Multi
                       580     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Main
                       581     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Tail 
                       582     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Multi
                       583     ;BESCNO EQU Skywalker_20A_Main
                       584     ;BESCNO EQU Skywalker_20A_Tail
                       585     ;BESCNO EQU Skywalker_20A_Multi 
                       586     ;BESCNO EQU Skywalker_40A_Main 
                       587     ;BESCNO EQU Skywalker_40A_Tail 
                       588     ;BESCNO EQU Skywalker_40A_Multi
                       589     ;BESCNO EQU HiModel_Cool_22A_Main
                       590     ;BESCNO EQU HiModel_Cool_22A_Tail
                       591     ;BESCNO EQU HiModel_Cool_22A_Multi
                       592     ;BESCNO EQU HiModel_Cool_33A_Main
                       593     ;BESCNO EQU HiModel_Cool_33A_Tail
                       594     ;BESCNO EQU HiModel_Cool_33A_Multi
                       595     ;BESCNO EQU HiModel_Cool_41A_Main
                       596     ;BESCNO EQU HiModel_Cool_41A_Tail
                       597     ;BESCNO EQU HiModel_Cool_41A_Multi
                       598     ;BESCNO EQU RCTimer_6A_Main
                       599     ;BESCNO EQU RCTimer_6A_Tail
                       600     ;BESCNO EQU RCTimer_6A_Multi
                       601     ;BESCNO EQU Align_RCE_BL15X_Main
                       602     ;BESCNO EQU Align_RCE_BL15X_Tail
                       603     ;BESCNO EQU Align_RCE_BL15X_Multi
                       604     ;BESCNO EQU Align_RCE_BL15P_Main
                       605     ;BESCNO EQU Align_RCE_BL15P_Tail
                       606     ;BESCNO EQU Align_RCE_BL15P_Multi 
                       607     ;BESCNO EQU Align_RCE_BL35X_Main 
                       608     ;BESCNO EQU Align_RCE_BL35X_Tail
                       609     ;BESCNO EQU Align_RCE_BL35X_Multi
                       610     ;BESCNO EQU Align_RCE_BL35P_Main
                       611     ;BESCNO EQU Align_RCE_BL35P_Tail
                       612     ;BESCNO EQU Align_RCE_BL35P_Multi
                       613     ;BESCNO EQU Gaui_GE_183_18A_Main
                       614     ;BESCNO EQU Gaui_GE_183_18A_Tail
                       615     ;BESCNO EQU Gaui_GE_183_18A_Multi
                       616     ;BESCNO EQU H_King_10A_Main 
                       617     ;BESCNO EQU H_King_10A_Tail 
                       618     ;BESCNO EQU H_King_10A_Multi
                       619     ;BESCNO EQU H_King_20A_Main
                       620     ;BESCNO EQU H_King_20A_Tail
                       621     ;BESCNO EQU H_King_20A_Multi
                       622     ;BESCNO EQU H_King_35A_Main
                       623     ;BESCNO EQU H_King_35A_Tail
                       624     ;BESCNO EQU H_King_35A_Multi
                       625     ;BESCNO EQU H_King_50A_Main
                       626     ;BESCNO EQU H_King_50A_Tail
                       627     ;BESCNO EQU H_King_50A_Multi
                       628     ;BESCNO EQU Polaris_Thunder_12A_Main
                       629     ;BESCNO EQU Polaris_Thunder_12A_Tail
                       630     ;BESCNO EQU Polaris_Thunder_12A_Multi
                       631     ;BESCNO EQU Polaris_Thunder_20A_Main
                       632     ;BESCNO EQU Polaris_Thunder_20A_Tail
                       633     ;BESCNO EQU Polaris_Thunder_20A_Multi
                       634     ;BESCNO EQU Polaris_Thunder_30A_Main
                       635     ;BESCNO EQU Polaris_Thunder_30A_Tail
                       636     ;BESCNO EQU Polaris_Thunder_30A_Multi
                       637     ;BESCNO EQU Polaris_Thunder_40A_Main
                       638     ;BESCNO EQU Polaris_Thunder_40A_Tail
                       639     ;BESCNO EQU Polaris_Thunder_40A_Multi
                       640     ;BESCNO EQU Polaris_Thunder_60A_Main
                       641     ;BESCNO EQU Polaris_Thunder_60A_Tail
                       642     ;BESCNO EQU Polaris_Thunder_60A_Multi
                       643     ;BESCNO EQU Polaris_Thunder_80A_Main
                       644     ;BESCNO EQU Polaris_Thunder_80A_Tail
                       645     ;BESCNO EQU Polaris_Thunder_80A_Multi
                       646     ;BESCNO EQU Polaris_Thunder_100A_Main
                       647     ;BESCNO EQU Polaris_Thunder_100A_Tail
                       648     ;BESCNO EQU Polaris_Thunder_100A_Multi
                       649     ;BESCNO EQU Platinum_Pro_30A_Main
                       650     ;BESCNO EQU Platinum_Pro_30A_Tail
                       651     ;BESCNO EQU Platinum_Pro_30A_Multi 
                       652     ;BESCNO EQU Platinum_Pro_150A_Main
                       653     ;BESCNO EQU Platinum_Pro_150A_Tail
                       654     ;BESCNO EQU Platinum_Pro_150A_Multi
                       655     ;BESCNO EQU Platinum_50Av3_Main
                       656     ;BESCNO EQU Platinum_50Av3_Tail
                       657     ;BESCNO EQU Platinum_50Av3_Multi 
                       658     ;BESCNO EQU EAZY_3Av2_Main
                       659     ;BESCNO EQU EAZY_3Av2_Tail
                       660     ;BESCNO EQU EAZY_3Av2_Multi
                       661     ;BESCNO EQU Tarot_30A_Main
                       662     ;BESCNO EQU Tarot_30A_Tail
                       663     ;BESCNO EQU Tarot_30A_Multi
                       664     ;BESCNO EQU SkyIII_30A_Main
                       665     ;BESCNO EQU SkyIII_30A_Tail
                       666     ;BESCNO EQU SkyIII_30A_Multi
                       667     ;BESCNO EQU EMAX_20A_Main
                       668     ;BESCNO EQU EMAX_20A_Tail
                       669     ;BESCNO EQU EMAX_20A_Multi 
                       670     ;BESCNO EQU EMAX_40A_Main
                       671     ;BESCNO EQU EMAX_40A_Tail
                       672     ;BESCNO EQU EMAX_40A_Multi 
                       673     ;BESCNO EQU EMAX_Nano_20A_Main
                       674     ;BESCNO EQU EMAX_Nano_20A_Tail
                       675     ;BESCNO EQU EMAX_Nano_20A_Multi 
                       676     ;BESCNO EQU XRotor_10A_Main 
                       677     ;BESCNO EQU XRotor_10A_Tail
                       678     ;BESCNO EQU XRotor_10A_Multi 
                       679     ;BESCNO EQU XRotor_20A_Main
                       680     ;BESCNO EQU XRotor_20A_Tail
                       681     ;BESCNO EQU XRotor_20A_Multi 
                       682     ;BESCNO EQU XRotor_40A_Main
                       683     ;BESCNO EQU XRotor_40A_Tail
                       684     ;BESCNO EQU XRotor_40A_Multi 
                       685     ;BESCNO EQU MDRX62H_Main
                       686     ;BESCNO EQU MDRX62H_Tail
                       687     ;BESCNO EQU MDRX62H_Multi 
                       688     ;BESCNO EQU RotorGeeks_20A_Main
                       689     ;BESCNO EQU RotorGeeks_20A_Tail
                       690     ;BESCNO EQU RotorGeeks_20A_Multi
                       691     ;BESCNO EQU Flycolor_Fairy_6A_Main
                       692     ;BESCNO EQU Flycolor_Fairy_6A_Tail
                       693     ;BESCNO EQU Flycolor_Fairy_6A_Multi
                       694     ;BESCNO EQU Flycolor_Fairy_30A_Main
                       695     ;BESCNO EQU Flycolor_Fairy_30A_Tail
                       696     ;BESCNO EQU Flycolor_Fairy_30A_Multi
                       697     ;BESCNO EQU FVT_Littlebee_20A_Main
                       698     ;BESCNO EQU FVT_Littlebee_20A_Tail
                       699     ;BESCNO EQU FVT_Littlebee_20A_Multi 
                       700     ;BESCNO EQU FVT_Littlebee_30A_Main
                       701     ;BESCNO EQU FVT_Littlebee_30A_Tail
                       702     ;BESCNO EQU FVT_Littlebee_30A_Multi 
                       703     ;BESCNO EQU Graupner_Ultra_20A_Main
                       704     ;BESCNO EQU Graupner_Ultra_20A_Tail
                       705     ;BESCNO EQU Graupner_Ultra_20A_Multi 
                       706     ;BESCNO EQU F85_3A_Main
                       707     ;BESCNO EQU F85_3A_Tail
                       708     ;BESCNO EQU F85_3A_Multi
                       709     ;BESCNO EQU ZTW_Spider_Pro_20A_Main
                       710     ;BESCNO EQU ZTW_Spider_Pro_20A_Tail
                       711     ;BESCNO EQU ZTW_Spider_Pro_20A_Multi
                       712     
                       713     
                       714     ;**** **** **** **** ****
                       715     ; ESC selection statements
                       716     IF BESCNO == XP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       720     
                       721     IF BESCNO == XP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       725     
                       726     IF BESCNO == XP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       730     
                       731     IF BESCNO == XP_7A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       735     
                       736     IF BESCNO == XP_7A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       740     
                       741     IF BESCNO == XP_7A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       745     
                       746     IF BESCNO == XP_7A_FAST_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       750     
                       751     IF BESCNO == XP_7A_FAST_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       755     
                       756     IF BESCNO == XP_7A_FAST_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       760     
                       761     IF BESCNO == XP_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       765     
                       766     IF BESCNO == XP_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       770     
                       771     IF BESCNO == XP_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       775     
                       776     IF BESCNO == XP_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       780     
                       781     IF BESCNO == XP_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       785     
                       786     IF BESCNO == XP_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       790     
                       791     IF BESCNO == XP_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       795     
                       796     IF BESCNO == XP_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       800     
                       801     IF BESCNO == XP_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       805     
                       806     IF BESCNO == XP_35A_SW_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       810     
                       811     IF BESCNO == XP_35A_SW_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       815     
                       816     IF BESCNO == XP_35A_SW_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       820     
                       821     IF BESCNO == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       825     
                       826     IF BESCNO == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       830     
                       831     IF BESCNO == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       835     
                       836     IF BESCNO == SUPERMICRO_3P5A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       840     
                       841     IF BESCNO == SUPERMICRO_3P5A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       845     
                       846     IF BESCNO == SUPERMICRO_3P5A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       850     
                       851     IF BESCNO == TURNIGY_PLUSH_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       855     
                       856     IF BESCNO == TURNIGY_PLUSH_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       860     
                       861     IF BESCNO == TURNIGY_PLUSH_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       865     
                       866     IF BESCNO == TURNIGY_PLUSH_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       870     
                       871     IF BESCNO == TURNIGY_PLUSH_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       875     
                       876     IF BESCNO == TURNIGY_PLUSH_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       880     
                       881     IF BESCNO == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       885     
                       886     IF BESCNO == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       890     
                       891     IF BESCNO == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       895     
                       896     IF BESCNO == TURNIGY_PLUSH_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       900     
                       901     IF BESCNO == TURNIGY_PLUSH_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       905     
                       906     IF BESCNO == TURNIGY_PLUSH_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       910     
                       911     IF BESCNO == TURNIGY_PLUSH_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       915     
                       916     IF BESCNO == TURNIGY_PLUSH_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       920     
                       921     IF BESCNO == TURNIGY_PLUSH_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       925     
                       926     IF BESCNO == TURNIGY_PLUSH_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       930     
                       931     IF BESCNO == TURNIGY_PLUSH_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       935     
                       936     IF BESCNO == TURNIGY_PLUSH_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       940     
                       941     IF BESCNO == TURNIGY_PLUSH_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       945     
                       946     IF BESCNO == TURNIGY_PLUSH_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       950     
                       951     IF BESCNO == TURNIGY_PLUSH_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       955     
                       956     IF BESCNO == TURNIGY_PLUSH_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       960     
                       961     IF BESCNO == TURNIGY_PLUSH_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       965     
                       966     IF BESCNO == TURNIGY_PLUSH_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       970     
                       971     IF BESCNO == TURNIGY_PLUSH_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       975     
                       976     IF BESCNO == TURNIGY_PLUSH_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       980     
                       981     IF BESCNO == TURNIGY_PLUSH_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       985     
                       986     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       990     
                       991     IF BESCNO == TURNIGY_PLUSH_NFET_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       995     
                       996     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1000     
                      1001     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1005     
                      1006     IF BESCNO == TURNIGY_PLUSH_NFET_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1010     
                      1011     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1015     
                      1016     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1020     
                      1021     IF BESCNO == TURNIGY_PLUSH_NFET_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1025     
                      1026     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1030     
                      1031     IF BESCNO == TURNIGY_AE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1035     
                      1036     IF BESCNO == TURNIGY_AE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1040     
                      1041     IF BESCNO == TURNIGY_AE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1045     
                      1046     IF BESCNO == TURNIGY_AE_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1050     
                      1051     IF BESCNO == TURNIGY_AE_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1055     
                      1056     IF BESCNO == TURNIGY_AE_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1060     
                      1061     IF BESCNO == TURNIGY_AE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1065     
                      1066     IF BESCNO == TURNIGY_AE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1070     
                      1071     IF BESCNO == TURNIGY_AE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1075     
                      1076     IF BESCNO == TURNIGY_AE_45A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1080     
                      1081     IF BESCNO == TURNIGY_AE_45A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1085     
                      1086     IF BESCNO == TURNIGY_AE_45A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1090     
                      1091     IF BESCNO == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1095     
                      1096     IF BESCNO == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1100     
                      1101     IF BESCNO == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1105     
                      1106     IF BESCNO == TURNIGY_KFORCE_70A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1110     
                      1111     IF BESCNO == TURNIGY_KFORCE_70A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1115     
                      1116     IF BESCNO == TURNIGY_KFORCE_70A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1120     
                      1121     IF BESCNO == TURNIGY_KFORCE_120A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1125     
                      1126     IF BESCNO == TURNIGY_KFORCE_120A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1130     
                      1131     IF BESCNO == TURNIGY_KFORCE_120A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1135     
                      1136     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1140     
                      1141     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1145     
                      1146     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1150     
                      1151     IF BESCNO == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1155     
                      1156     IF BESCNO == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1160     
                      1161     IF BESCNO == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1165     
                      1166     IF BESCNO == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1170     
                      1171     IF BESCNO == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1175     
                      1176     IF BESCNO == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1180     
                      1181     IF BESCNO == HIMODEL_COOL_22A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1185     
                      1186     IF BESCNO == HIMODEL_COOL_22A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1190     
                      1191     IF BESCNO == HIMODEL_COOL_22A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1195     
                      1196     IF BESCNO == HIMODEL_COOL_33A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1200     
                      1201     IF BESCNO == HIMODEL_COOL_33A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1205     
                      1206     IF BESCNO == HIMODEL_COOL_33A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1210     
                      1211     IF BESCNO == HIMODEL_COOL_41A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1215     
                      1216     IF BESCNO == HIMODEL_COOL_41A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1220     
                      1221     IF BESCNO == HIMODEL_COOL_41A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1225     
                      1226     IF BESCNO == RCTIMER_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1230     
                      1231     IF BESCNO == RCTIMER_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1235     
                      1236     IF BESCNO == RCTIMER_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1240     
                      1241     IF BESCNO == ALIGN_RCE_BL15X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1245     
                      1246     IF BESCNO == ALIGN_RCE_BL15X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1250     
                      1251     IF BESCNO == ALIGN_RCE_BL15X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1255     
                      1256     IF BESCNO == ALIGN_RCE_BL15P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1260     
                      1261     IF BESCNO == ALIGN_RCE_BL15P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1265     
                      1266     IF BESCNO == ALIGN_RCE_BL15P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1270     
                      1271     IF BESCNO == ALIGN_RCE_BL35X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1275     
                      1276     IF BESCNO == ALIGN_RCE_BL35X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1280     
                      1281     IF BESCNO == ALIGN_RCE_BL35X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1285     
                      1286     IF BESCNO == ALIGN_RCE_BL35P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1290     
                      1291     IF BESCNO == ALIGN_RCE_BL35P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1295     
                      1296     IF BESCNO == ALIGN_RCE_BL35P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1300     
                      1301     IF BESCNO == GAUI_GE_183_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1305     
                      1306     IF BESCNO == GAUI_GE_183_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1310     
                      1311     IF BESCNO == GAUI_GE_183_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1315     
                      1316     IF BESCNO == H_KING_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1320     
                      1321     IF BESCNO == H_KING_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1325     
                      1326     IF BESCNO == H_KING_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1330     
                      1331     IF BESCNO == H_KING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1335     
                      1336     IF BESCNO == H_KING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1340     
                      1341     IF BESCNO == H_KING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1345     
                      1346     IF BESCNO == H_KING_35A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1350     
                      1351     IF BESCNO == H_KING_35A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1355     
                      1356     IF BESCNO == H_KING_35A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1360     
                      1361     IF BESCNO == H_KING_50A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1365     
                      1366     IF BESCNO == H_KING_50A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1370     
                      1371     IF BESCNO == H_KING_50A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1375     
                      1376     IF BESCNO == POLARIS_THUNDER_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1380     
                      1381     IF BESCNO == POLARIS_THUNDER_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1385     
                      1386     IF BESCNO == POLARIS_THUNDER_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1390     
                      1391     IF BESCNO == POLARIS_THUNDER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1395     
                      1396     IF BESCNO == POLARIS_THUNDER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1400     
                      1401     IF BESCNO == POLARIS_THUNDER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1405     
                      1406     IF BESCNO == POLARIS_THUNDER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1410     
                      1411     IF BESCNO == POLARIS_THUNDER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1415     
                      1416     IF BESCNO == POLARIS_THUNDER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1420     
                      1421     IF BESCNO == POLARIS_THUNDER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1425     
                      1426     IF BESCNO == POLARIS_THUNDER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1430     
                      1431     IF BESCNO == POLARIS_THUNDER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1435     
                      1436     IF BESCNO == POLARIS_THUNDER_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1440     
                      1441     IF BESCNO == POLARIS_THUNDER_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1445     
                      1446     IF BESCNO == POLARIS_THUNDER_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1450     
                      1451     IF BESCNO == POLARIS_THUNDER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1455     
                      1456     IF BESCNO == POLARIS_THUNDER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1460     
                      1461     IF BESCNO == POLARIS_THUNDER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1465     
                      1466     IF BESCNO == POLARIS_THUNDER_100A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1470     
                      1471     IF BESCNO == POLARIS_THUNDER_100A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1475     
                      1476     IF BESCNO == POLARIS_THUNDER_100A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1480     
                      1481     IF BESCNO == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1485     
                      1486     IF BESCNO == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1490     
                      1491     IF BESCNO == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1495     
                      1496     IF BESCNO == PLATINUM_PRO_150A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1500     
                      1501     IF BESCNO == PLATINUM_PRO_150A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1505     
                      1506     IF BESCNO == PLATINUM_PRO_150A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1510     
                      1511     IF BESCNO == PLATINUM_50AV3_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1515     
                      1516     IF BESCNO == PLATINUM_50AV3_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1520     
                      1521     IF BESCNO == PLATINUM_50AV3_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1525     
                      1526     IF BESCNO == EAZY_3AV2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1530     
                      1531     IF BESCNO == EAZY_3AV2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1535     
                      1536     IF BESCNO == EAZY_3AV2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1540     
                      1541     IF BESCNO == TAROT_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1545     
                      1546     IF BESCNO == TAROT_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1550     
                      1551     IF BESCNO == TAROT_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1555     
                      1556     IF BESCNO == SKYIII_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1560     
                      1561     IF BESCNO == SKYIII_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1565     
                      1566     IF BESCNO == SKYIII_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1570     
                      1571     IF BESCNO == EMAX_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1575     
                      1576     IF BESCNO == EMAX_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1580     
                      1581     IF BESCNO == EMAX_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1585     
                      1586     IF BESCNO == EMAX_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1590     
                      1591     IF BESCNO == EMAX_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1595     
                      1596     IF BESCNO == EMAX_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1600     
                      1601     IF BESCNO == EMAX_NANO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1605     
                      1606     IF BESCNO == EMAX_NANO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1610     
                      1611     IF BESCNO == EMAX_NANO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1615     
                      1616     IF BESCNO == XROTOR_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1620     
                      1621     IF BESCNO == XROTOR_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1625     
                      1626     IF BESCNO == XROTOR_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1630     
                      1631     IF BESCNO == XROTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1635     
                      1636     IF BESCNO == XROTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1640     
                      1641     IF BESCNO == XROTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1645     
                      1646     IF BESCNO == XROTOR_40A_MAIN
  0000                1647     MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                      1648     $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                      2262     ENDIF
                      2263     
                      2264     IF BESCNO == XROTOR_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      2268     
                      2269     IF BESCNO == XROTOR_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      2273     
                      2274     IF BESCNO == MDRX62H_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2278     
                      2279     IF BESCNO == MDRX62H_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2283     
                      2284     IF BESCNO == MDRX62H_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2288     
                      2289     IF BESCNO == ROTORGEEKS_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2293     
                      2294     IF BESCNO == ROTORGEEKS_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2298     
                      2299     IF BESCNO == ROTORGEEKS_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2303     
                      2304     IF BESCNO == FLYCOLOR_FAIRY_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2308     
                      2309     IF BESCNO == FLYCOLOR_FAIRY_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2313     
                      2314     IF BESCNO == FLYCOLOR_FAIRY_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2318     
                      2319     IF BESCNO == FLYCOLOR_FAIRY_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2323     
                      2324     IF BESCNO == FLYCOLOR_FAIRY_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2328     
                      2329     IF BESCNO == FLYCOLOR_FAIRY_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2333     
                      2334     IF BESCNO == FVT_LITTLEBEE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2338     
                      2339     IF BESCNO == FVT_LITTLEBEE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2343     
                      2344     IF BESCNO == FVT_LITTLEBEE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2348     
                      2349     IF BESCNO == FVT_LITTLEBEE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2353     
                      2354     IF BESCNO == FVT_LITTLEBEE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2358     
                      2359     IF BESCNO == FVT_LITTLEBEE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2363     
                      2364     IF BESCNO == GRAUPNER_ULTRA_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2368     
                      2369     IF BESCNO == GRAUPNER_ULTRA_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2373     
                      2374     IF BESCNO == GRAUPNER_ULTRA_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2378     
                      2379     IF BESCNO == F85_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2383     
                      2384     IF BESCNO == F85_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2388     
                      2389     IF BESCNO == F85_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2393     
                      2394     IF BESCNO == ZTW_SPIDER_PRO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2398     
                      2399     IF BESCNO == ZTW_SPIDER_PRO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2403     
                      2404     IF BESCNO == ZTW_SPIDER_PRO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2408     
                      2409     
                      2410     ;**** **** **** **** ****
                      2411     ; TX programming defaults
                      2412     ;
                      2413     ; Parameter dependencies:
                      2414     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                      2415     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                      2416     ;
                      2417     ; MAIN
  0007                2418     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                2419     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                2420     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                2421     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                2422     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                2423     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2424     IF DAMPED_MODE_ENABLE == 1
  0002                2425     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
                      2426     ELSE
                               DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low	
                               ENDIF
  0001                2429     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2430     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                2431     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                2432     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                2433     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                2434     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                2435     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                2436     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                      2437     
                      2438     ; TAIL
  0003                2439     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                2440     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                2441     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2442     IF DAMPED_MODE_ENABLE == 1
  0003                2443     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                      2444     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		
                               ENDIF
  0001                2447     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2448     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2449     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                2450     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                2451     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                2452     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2453     DEFAULT_PGM_TAIL_PWM_DITHER		EQU 3 	; 1=Off		2=7			3=15			4=31			5=63
                      2454     
                      2455     ; MULTI
  0009                2456     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                2457     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                2458     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                2459     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0003                2460     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2461     IF DAMPED_MODE_ENABLE == 1
  0001                2462     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight 
                      2463     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low
                               ENDIF
  0002                2466     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                2467     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2468     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0028                2469     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0050                2470     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0004                2471     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2472     DEFAULT_PGM_MULTI_PWM_DITHER		EQU 3 	; 1=Off		2=7			3=15			4=31			5=63
                      2473     
                      2474     ; COMMON
  0001                2475     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 1 	; 1=Enabled 	0=Disabled
  0025                2476     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 37	; 4*37+1000=1148
  00D0                2477     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 208	; 4*208+1000=1832
  007A                2478     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 122	; 4*122+1000=1488 (used in bidirectional mode)
  0000                2479     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0=Low		1+= High or higher	
  0001                2480     DEFAULT_PGM_ENABLE_TEMP_PROT	 	EQU 1 	; 1=Enabled 	0=Disabled
  0001                2481     DEFAULT_PGM_ENABLE_POWER_PROT 	EQU 1 	; 1=Enabled 	0=Disabled
  0000                2482     DEFAULT_PGM_ENABLE_PWM_INPUT	 	EQU 0 	; 1=Enabled 	0=Disabled
                      2483     
                      2484     ; PATRICK'S CHANGES
  002B                2485     MOTOR_PPM_LOW_SLOPE				EQU 43   ; 256/6 = 43; Slope is 1/6 -Patrick
  008E                2486     MOTOR_PPM_HIGH_SLOPE			EQU 142  ; Slope = 2.254 modifier = 63 * 2.254 to avoid overflow -Patrick
  0099                2487     MOTOR_PPM_REMAP_THRESHOLD		EQU 153  ; Threshold is at 60% throttle 255*.6 = 153 -Patrick
  001D                2488     MOTOR_PPM_REMAP_THRESHOLD_VALUE	EQU 29   ; (255/6) * .6: Threshold is at 60% throttle, value = (threshold/6) + 4 for final offset -Patrick
                      2489     
                      2490     ;**** **** **** **** ****
                      2491     ; Constant definitions for main
                      2492     IF MODE == 0
                      2493     
  0002                2494     GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
  000A                2495     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0040                2496     RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0020                2497     RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                2498     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                2499     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                2500     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                2501     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                2502     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                      2503     
  0032                2504     PWM_START			EQU	50 	; PWM used as max power during start
                      2505     
  0001                2506     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                      2507     
  0008                2508     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                      2509     
                      2510     ENDIF
                      2511     ; Constant definitions for tail
                      2512     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2531     ; Constant definitions for multi
                      2532     IF MODE == 2
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2551     
                      2552     ;**** **** **** **** ****
                      2553     ; Temporary register definitions
  REG                 2554     TEMP1		EQU	R0
  REG                 2555     TEMP2		EQU	R1
  REG                 2556     TEMP3		EQU	R2
  REG                 2557     TEMP4		EQU	R3
  REG                 2558     TEMP5		EQU	R4
  REG                 2559     TEMP6		EQU	R5
  REG                 2560     TEMP7		EQU	R6
  REG                 2561     TEMP8		EQU	R7
                      2562     
                      2563     ;**** **** **** **** ****
                      2564     ; Register definitions
------                2565     DSEG AT 20H					; Variables segment 
                      2566     
0020                  2567     BIT_ACCESS: 				DS	1		; MUST BE AT THIS ADDRESS. Variable at bit accessible address (for non interrupt routines)
0021                  2568     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                      2569     
0022                  2570     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                  2571     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                  2572     CURRENT_PWM: 				DS	1		; Current pwm
0025                  2573     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited
0026                  2574     CURRENT_PWM_LIM_DITH: 		DS	1		; Current pwm that is limited and dithered (applied to the motor output)
0027                  2575     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0028                  2576     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0029                  2577     RCP_OUTSIDE_RANGE_CNT: 		DS	1		; RC pulse outside range counter (incrementing) 
002A                  2578     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
002B                  2579     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
                      2580     
002C                  2581     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                2582     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                2583     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                2584     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                2585     PWM_TIMER0_OVERFLOW			EQU	3		; Set for 48MHz MCUs when PWM timer 0 overflows
  0004                2586     DEMAG_ENABLED				EQU 	4		; Set when demag compensation is enabled (above a min speed and throttle)
  0005                2587     DEMAG_DETECTED				EQU 	5		; Set when excessive demag time is detected
  0006                2588     DEMAG_CUT_POWER			EQU 	6		; Set when demag compensation cuts power
  0007                2589     HIGH_RPM					EQU 	7		; Set when motor rpm is high (Comm_Period4x_H less than 2)
                      2590     
002D                  2591     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                2592     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                2593     STARTUP_PHASE				EQU 	1		; Set when in startup phase
  0002                2594     INITIAL_RUN_PHASE			EQU	2		; Set when in initial run phase, before synchronized run is achieved
  0003                2595     DIR_CHANGE_BRAKE			EQU 	3		; Set when braking before direction change
  0004                2596     COMP_TIMED_OUT				EQU 	4		; Set when comparator reading timed out
  0005                2597     GOV_ACTIVE				EQU 	5		; Set when governor is active (enabled when speed is above minimum)
  0006                2598     SKIP_DAMP_ON				EQU 	6 		; Set when turning damping fet on is skipped
                      2599     ;						EQU 	7 		
                      2600     
002E                  2601     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                2602     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                2603     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                2604     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode
  0003                2605     PGM_PWM_HIGH_FREQ			EQU	3		; Progremmed pwm high frequency
  0004                2606     RCP_PPM					EQU 	4		; RC pulse ppm type input (set also when oneshot is set)
  0005                2607     RCP_PPM_ONESHOT125			EQU 	5		; RC pulse ppm type input is OneShot125
  0006                2608     RCP_DIR_REV				EQU 	6		; RC pulse direction in bidirectional mode
                      2609     ;						EQU 	7	
                      2610     
002F                  2611     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                2612     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                2613     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                2614     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                2615     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                2616     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                2617     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                2618     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                2619     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                      2620     
                      2621     
                      2622     ;**** **** **** **** ****
                      2623     ; RAM definitions
------                2624     DSEG AT 30H						; Ram data segment, direct addressing
                      2625     
0030                  2626     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                      2627     
0031                  2628     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                  2629     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                      2630     
0033                  2631     STARTUP_CNT: 				DS	1		; Startup phase commutations counter (incrementing)
0034                  2632     INITIAL_RUN_ROT_CNT: 		DS	1		; Initial run rotations counter (incrementing)
0035                  2633     STALL_CNT: 				DS	1		; Counts start/run attempts that resulted in stall. Reset upon a proper stop
0036                  2634     DEMAG_DETECTED_METRIC: 		DS	1		; Metric used to gauge demag event frequency
0037                  2635     DEMAG_PWR_OFF_THRESH: 		DS	1		; Metric threshold above which power is cut
0038                  2636     LOW_RPM_PWR_SLOPE: 			DS	1		; Sets the slope of power increase for low rpms
                      2637     
0039                  2638     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003A                  2639     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003B                  2640     PREV_PREV_COMM_L: 			DS	1		; Pre-previous commutation timer3 timestamp (lo byte)
003C                  2641     PREV_PREV_COMM_H: 			DS	1		; Pre-previous commutation timer3 timestamp (hi byte)
003D                  2642     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003E                  2643     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003F                  2644     COMM_DIFF: 				DS	1		; Timer3 count difference between the last two commutations
0040                  2645     COMM_PHASE: 				DS	1		; Current commutation phase
0041                  2646     COMPARATOR_READ_CNT:  		DS	1		; Number of comparator reads done
                      2647     
0042                  2648     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0043                  2649     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0044                  2650     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0045                  2651     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0046                  2652     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0047                  2653     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0048                  2654     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0049                  2655     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
004A                  2656     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
                      2657     
004B                  2658     WT_ADV_START_L: 			DS	1		; Timer3 start point for commutation advance timing (lo byte)
004C                  2659     WT_ADV_START_H: 			DS	1		; Timer3 start point for commutation advance timing (hi byte)
004D                  2660     WT_ZC_SCAN_START_L: 			DS	1		; Timer3 start point from commutation to zero cross scan (lo byte)
004E                  2661     WT_ZC_SCAN_START_H: 			DS	1		; Timer3 start point from commutation to zero cross scan (hi byte)
004F                  2662     WT_ZC_TOUT_START_L: 			DS	1		; Timer3 start point for zero cross scan timeout (lo byte)
0050                  2663     WT_ZC_TOUT_START_H: 			DS	1		; Timer3 start point for zero cross scan timeout (hi byte)
0051                  2664     WT_COMM_START_L: 			DS	1		; Timer3 start point from zero cross to commutation (lo byte)
0052                  2665     WT_COMM_START_H: 			DS	1		; Timer3 start point from zero cross to commutation (hi byte)
0053                  2666     NEXT_WT_START_L: 			DS	1		; Timer3 start point for next wait period (lo byte)
0054                  2667     NEXT_WT_START_H: 			DS	1		; Timer3 start point for next wait period (hi byte)
                      2668     
0055                  2669     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0056                  2670     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0057                  2671     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0058                  2672     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0059                  2673     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
005A                  2674     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
005B                  2675     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
005C                  2676     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005D                  2677     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005E                  2678     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005F                  2679     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
0060                  2680     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      2681     
0061                  2682     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
0062                  2683     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup
0063                  2684     PWM_LIMIT_BY_RPM: 			DS	1		; Maximum allowed pwm for low or high rpms
0064                  2685     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0065                  2686     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0066                  2687     PWM_DITHER_DECODED: 			DS	1		; Decoded pwm dither value
0067                  2688     PWM_DITHER_EXCESS_POWER: 		DS	1		; Excess power (above max) from pwm dither
0068                  2689     RANDOM: 					DS	1		; Random number from LFSR 
                      2690     
0069                  2691     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
006A                  2692     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
006B                  2693     MAIN_SPOOLUP_TIME_3X: 		DS	1		; Main spoolup time x3
006C                  2694     MAIN_SPOOLUP_TIME_10X: 		DS	1		; Main spoolup time x10
006D                  2695     MAIN_SPOOLUP_TIME_15X: 		DS	1		; Main spoolup time x15
                      2696     
006E                  2697     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006F                  2698     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
0070                  2699     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      2700     
0071                  2701     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      2702     
0072                  2703     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
0073                  2704     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      2705     
0074                  2706     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0075                  2707     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0076                  2708     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      2709     
0077                  2710     SKIP_T2_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 interrupt shall be ignored 
0078                  2711     SKIP_T2H_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 high interrupt shall be ignored 
0079                  2712     TIMER0_OVERFLOW_VALUE: 		DS	1		; Remaining timer 0 wait time used with 48MHz MCUs
007A                  2713     CLOCK_SET_AT_48MHZ: 			DS	1		; Variable set if 48MHz MCUs run at 48MHz
007B                  2714     DAMPINGFET: 				DS	1		; Port position of fet used for damping
007C                  2715     CURRENT_PWM_LIMITED_REMAPPED: 	DS	1
007D                  2716     CURRENT_PWM_LIM_DITH_REMAPPED:  DS	1
                      2717     
                      2718     ; Indirect addressing data segment. The variables below must be in this sequence
------                2719     ISEG AT 080H					
0080                  2720     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  2721     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  2722     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  2723     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  2724     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  2725     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  2726     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  2727     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  2728     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  2729     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  2730     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  2731     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  2732     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  2733     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  2734     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  2735     _PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm (unused - place holder)
0090                  2736     _PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration (unused - place holder)
0091                  2737     _PGM_VOLT_COMP: 			DS	1		; Place holder
0092                  2738     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  2739     _PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force (unused - place holder)
0094                  2740     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  2741     _PGM_STARTUP_METHOD: 		DS	1		; Programmed startup method (unused - place holder)
0096                  2742     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  2743     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  2744     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  2745     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  2746     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  2747     _PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate (unused - place holder)
009C                  2748     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  2749     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  2750     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
009F                  2751     PGM_MAIN_SPOOLUP_TIME: 		DS	1		; Programmed main spoolup time
00A0                  2752     PGM_ENABLE_TEMP_PROT: 		DS	1		; Programmed temperature protection enable
00A1                  2753     PGM_ENABLE_POWER_PROT: 		DS	1		; Programmed low rpm power protection enable
00A2                  2754     PGM_ENABLE_PWM_INPUT: 		DS	1		; Programmed PWM input signal enable
00A3                  2755     PGM_PWM_DITHER: 			DS	1		; Programmed output PWM dither
                      2756     
                      2757     ; The sequence of the variables below is no longer of importance
00A4                  2758     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A5                  2759     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A6                  2760     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
                      2761     
                      2762     
                      2763     ; Indirect addressing data segment
------                2764     ISEG AT 0D0H					
00D0                  2765     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      2766     
                      2767     
                      2768     ;**** **** **** **** ****
------                2769     CSEG AT 1A00H            ; "Eeprom" segment
  000E                2770     EEPROM_FW_MAIN_REVISION		EQU	14		; Main revision of the firmware
  0003                2771     EEPROM_FW_SUB_REVISION		EQU	3		; Sub revision of the firmware
  0014                2772     EEPROM_LAYOUT_REVISION		EQU	20		; Revision of the EEPROM layout
                      2773     
1A00    0E            2774     EEP_FW_MAIN_REVISION:  DB 14 
1A01    03            2775     EEP_FW_SUB_REVISION:  DB 3 
1A02    14            2776     EEP_LAYOUT_REVISION:  DB 20 
                      2777     
                      2778     IF MODE == 0
1A03    07            2779     EEP_PGM_GOV_P_GAIN:  DB 7 
1A04    07            2780     EEP_PGM_GOV_I_GAIN:  DB 7 
1A05    01            2781     EEP_PGM_GOV_MODE:  DB 1 
1A06    04            2782     EEP_PGM_LOW_VOLTAGE_LIM:  DB 4 
1A07    FF            2783     _EEP_PGM_MOTOR_GAIN: 		DB	0FFH							
1A08    FF            2784     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							
1A09    09            2785     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    02            2786     EEP_PGM_PWM_FREQ:  DB 2 
1A0B    01            2787     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            2788     EEP_PGM_INPUT_POL:  DB 1 
1A0D    A5            2789     EEP_INITIALIZED_L: 			DB	0A5H							; EEPROM initialized signature low byte
1A0E    5A            2790     EEP_INITIALIZED_H: 			DB	05AH							; EEPROM initialized signature high byte
1A0F    01            2791     EEP_ENABLE_TX_PROGRAM:  DB 1 
1A10    00            2792     EEP_MAIN_REARM_START:  DB 0 
1A11    B4            2793     EEP_PGM_GOV_SETUP_TARGET:  DB 180 
1A12    FF            2794     _EEP_PGM_STARTUP_RPM: 		DB	0FFH	
1A13    FF            2795     _EEP_PGM_STARTUP_ACCEL: 		DB	0FFH	
1A14    FF            2796     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            2797     EEP_PGM_COMM_TIMING:  DB 3 
1A16    FF            2798     _EEP_PGM_DAMPING_FORCE: 		DB	0FFH						
1A17    01            2799     EEP_PGM_GOV_RANGE:  DB 1 
1A18    FF            2800     _EEP_PGM_STARTUP_METHOD: 		DB	0FFH	
1A19    25            2801     EEP_PGM_PPM_MIN_THROTTLE:  DB 37 
1A1A    D0            2802     EEP_PGM_PPM_MAX_THROTTLE:  DB 208 
1A1B    78            2803     EEP_PGM_BEEP_STRENGTH:  DB 120 
1A1C    C8            2804     EEP_PGM_BEACON_STRENGTH:  DB 200 
1A1D    04            2805     EEP_PGM_BEACON_DELAY:  DB 4 
1A1E    FF            2806     _EEP_PGM_THROTTLE_RATE: 		DB	0FFH	
1A1F    01            2807     EEP_PGM_DEMAG_COMP:  DB 1 
1A20    00            2808     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    FF            2809     _EEP_PGM_PPM_CENTER_THROTTLE: 	DB	0FFH							
1A22    0A            2810     EEP_PGM_MAIN_SPOOLUP_TIME:  DB 10 
1A23    01            2811     EEP_PGM_TEMP_PROT_ENABLE:  DB 1 
1A24    01            2812     EEP_PGM_ENABLE_POWER_PROT:  DB 1 
1A25    00            2813     EEP_PGM_ENABLE_PWM_INPUT:  DB 0 
1A26    FF            2814     _EEP_PGM_PWM_DITHER: 		DB	0FFH	
                      2815     ENDIF 
                      2816     
                      2817     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               EEP_PGM_PWM_DITHER:			DB	DEFAULT_PGM_TAIL_PWM_DITHER		; EEPROM copy of programmed output PWM dither
                               ENDIF
                      2855     
                      2856     IF MODE == 2
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MULTI_P_GAIN			; EEPROM copy of programmed closed loop P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MULTI_I_GAIN			; EEPROM copy of programmed closed loop I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MULTI_GOVERNOR_MODE	; EEPROM copy of programmed closed loop mode
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_MULTI_GAIN			; EEPROM copy of programmed tail gain
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MULTI_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MULTI_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MULTI_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MULTI_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	055H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0AAH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MULTI_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MULTI_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MULTI_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MULTI_BEACON_DELAY	; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MULTI_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               EEP_PGM_PWM_DITHER:			DB	DEFAULT_PGM_MULTI_PWM_DITHER		; EEPROM copy of programmed output PWM dither
                               ENDIF
                      2894     
1A27    FF            2895     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      2896     
------                2897     CSEG AT 1A60H
1A60    20202020      2898     EEP_NAME: 					DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      2899     
                      2900     ;**** **** **** **** ****
                      2901     INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                2901+1   CSEG AT 0  ; CODE SEGMENT START
0000    0219FD        2901+1   JMP RESET 
------                2901+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200CF        2901+1   JMP T0_INT 
------                2901+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0201C7        2901+1   JMP T2_INT 
------                2901+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    02037B        2901+1   JMP PCA_INT 
------                2901+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    020361        2901+1   JMP T3_INT 
------                2902     CSEG AT 80H			; Code segment after interrupt vectors 
                      2903     
                      2904     ;**** **** **** **** ****
                      2905     
                      2906     ; Table definitions
0080    02030406      2907     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    0406080C      2908     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
0091    10182030
0095    406080A0
0099    C0
009A    00070F1F      2909     PWM_DITHER_TABLE:   		DB 	00H, 07H, 0FH, 1FH, 3FH
009E    3F
                      2910     IF MODE == 0
                      2911       IF DAMPED_MODE_ENABLE == 1
009F    0D0D0403      2912     	TX_PGM_PARAMS_MAIN:   	DB 	13, 13, 4, 3, 6, 13, 5, 3, 3, 2, 2
00A3    060D0503
00A7    030202
                      2913       ENDIF
                      2914       IF DAMPED_MODE_ENABLE == 0
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 2, 3, 2, 2
                                 ENDIF
                      2917     ENDIF
                      2918     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF
                               ENDIF
                      2926     IF MODE == 2
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF 
                               ENDIF
                      2934     
                      2935     ; Subroutine remaps pwm value (implements throttle curve)
                      2936     ; Input: A holds value to be remapped and ranges from 0 to 255
                      2937     ; Output: A holds remapped value
                      2938     ; -Patrick
                      2939     MOTOR_PWM_REMAP: 
00AA    C0F0          2940         PUSH B
                      2941         ;Test if value is below or above threshold
00AC    C3            2942         CLR C
00AD    9499          2943     SUBB A , # 153 
00AF    4013          2944         JC REMAP_LOW_SLOPE
                      2945         
                      2946         ; If throttle higher than threshold use high slope
00B1    75F08E        2947     MOV B , # 142 
00B4    A4            2948         MUL  AB	 ; 16 bit product in BA
                      2949         ; compute BA << 2
00B5    33            2950         RLC  A
00B6    C5F0          2951         XCH A, B
00B8    33            2952         RLC  A  ; left shift MSB
00B9    C5F0          2953         XCH A, B
00BB    33            2954         RLC  A
00BC    C5F0          2955         XCH A, B 
00BE    33            2956         RLC  A  ; left shift MSB
00BF    241D          2957     ADD A , # 29 
00C1    D0F0          2958         POP  B
00C3    22            2959         RET
                      2960     
                      2961         REMAP_LOW_SLOPE: 
                      2962         ; If throttle less than threshold use low slope
00C4    2499          2963     ADD A , # 153 
00C6    75F02B        2964     MOV B , # 43 
00C9    A4            2965         MUL  AB
00CA    E5F0          2966         MOV  A, B ; Divide by 256
00CC    D0F0          2967         POP  B
00CE    22            2968         RET
                      2969     
                      2970     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2971     ;
                      2972     ; Timer0 interrupt routine
                      2973     ;
                      2974     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      2975     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      2976     ;
                      2977     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2978     T0_INT: 	; Used for pwm control
00CF    C2AF          2979     	CLR 	EA			; Disable all interrupts
                      2980     IF MCU_48MHZ == 1
                      2981     	; Check overflow flag
00D1    306308        2982     JNB FLAGS0 . 3 , T0_INT_START 
                      2983     
00D4    C263          2984     CLR FLAGS0 . 3 
00D6    85798A        2985     	MOV	TL0, TIMER0_OVERFLOW_VALUE	; Set timer 
00D9    D2AF          2986     	SETB	EA			; Enable all interrupts
00DB    32            2987     	RETI
                      2988     
                      2989     T0_INT_START: 
                      2990     ENDIF
00DC    C0D0          2991     	PUSH	PSW			; Preserve registers through interrupt
00DE    C0E0          2992     	PUSH	ACC	
                      2993     	
                      2994     	; Scale Current_Pwm_Limited and Current_Pwm_Lim_Dith by MOTOR_PPM_LOW_SLOPE -Patrick
                      2995     
                      2996     	; Scale Current_Pwm_Limited -Patrick
00E0    E525          2997     	MOV	A, CURRENT_PWM_LIMITED
00E2    11AA          2998     	CALL MOTOR_PWM_REMAP
00E4    F57C          2999     	MOV  CURRENT_PWM_LIMITED_REMAPPED, A
                      3000     
                      3001     	; Scale Current_Pwm_Lim_Dith -Patrick
00E6    E526          3002     	MOV	A, CURRENT_PWM_LIM_DITH
00E8    11AA          3003     	CALL MOTOR_PWM_REMAP
00EA    F57D          3004     	MOV  CURRENT_PWM_LIM_DITH_REMAPPED, A
                      3005     
                      3006     	; Check if pwm is on
00EC    206227        3007     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      3008     
                      3009     	; Pwm on cycle
00EF    E57C          3010     	MOV	A, CURRENT_PWM_LIMITED_REMAPPED ; Replace with remapped value -Patrick
00F1    6002          3011     	JZ	T0_INT_PWM_ON_EXIT
                      3012     
                      3013     T0_INT_PWM_ON_EXECUTE: 
00F3    E4            3014     	CLR	A					
00F4    73            3015     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      3016     
                      3017     T0_INT_PWM_ON_EXIT: 
                      3018     	; Set timer for coming on cycle length
00F5    E57C          3019     	MOV 	A, CURRENT_PWM_LIMITED_REMAPPED		; Load current pwm and replace with remapped value -Patrick
00F7    F4            3020     	CPL	A						; cpl is 255-x
                      3021     IF MCU_48MHZ == 0
                               	MOV	TL0, A					; Write start point for timer
                               ELSE
00F8    C3            3024     	CLR	C
00F9    33            3025     	RLC	A
00FA    4009          3026     	JC	T0_INT_PWM_ON_SET_TIMER
                      3027     
00FC    758A00        3028     	MOV	TL0, #0
00FF    D263          3029     SETB FLAGS0 . 3 
0101    F579          3030     	MOV	TIMER0_OVERFLOW_VALUE, A
0103    2107          3031     	AJMP	T0_INT_PWM_ON_TIMER_SET
                      3032     
                      3033     T0_INT_PWM_ON_SET_TIMER: 
0105    F58A          3034     	MOV	TL0, A
                      3035     T0_INT_PWM_ON_TIMER_SET: 
                      3036     ENDIF
                      3037     	; Set other variables
0107    758B00        3038     	MOV	TL1, #0					; Reset timer1	
                      3039     IF MCU_48MHZ == 1
010A    758D00        3040     	MOV	TH1, #0		
                      3041     ENDIF
010D    D262          3042     SETB FLAGS0 . 2 
                      3043     	; Exit interrupt
010F    D0E0          3044     	POP	ACC			; Restore preserved registers
0111    D0D0          3045     	POP	PSW
0113    D2AF          3046     	SETB	EA			; Enable all interrupts
0115    32            3047     	RETI
                      3048     
                      3049     
                      3050     	; Pwm off cycle
                      3051     T0_INT_PWM_OFF: 
                      3052     IF MCU_48MHZ == 0
                               	MOV	TL0, CURRENT_PWM_LIM_DITH_REMAPPED	; Load new timer setting and replace with remapped value -Patrick
                               ELSE
0116    C3            3055     	CLR	C
0117    E57D          3056     	MOV	A, CURRENT_PWM_LIM_DITH_REMAPPED ; Replace with remapped value -Patrick
0119    33            3057     	RLC	A
011A    4009          3058     	JC	T0_INT_PWM_OFF_SET_TIMER 
                      3059     
011C    758A00        3060     	MOV	TL0, #0
011F    D263          3061     SETB FLAGS0 . 3 
0121    F579          3062     	MOV	TIMER0_OVERFLOW_VALUE, A
0123    2127          3063     	AJMP	T0_INT_PWM_OFF_TIMER_SET
                      3064     
                      3065     T0_INT_PWM_OFF_SET_TIMER: 
0125    F58A          3066     	MOV	TL0, A
                      3067     T0_INT_PWM_OFF_TIMER_SET: 
                      3068     ENDIF
                      3069     	; Clear pwm on flag
0127    C262          3070     CLR FLAGS0 . 2 
                      3071     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
0129    E57D          3072     	MOV	A, CURRENT_PWM_LIM_DITH_REMAPPED		; Load current pwm and replace with remapped value -Patrick
012B    F4            3073     	CPL	A						; Full pwm?
012C    6038          3074     	JZ	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      3075     
                      3076     IF DAMPED_MODE_ENABLE == 1
                      3077     	; Do not execute damped pwm when stopped
012E    306803        3078     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_EXIT_NFETS_OFF 
                      3079     
                      3080     	; If damped operation, set pFETs on in pwm_off
0131    207213        3081     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      3082     ENDIF
                      3083     
                      3084     T0_INT_PWM_OFF_EXIT_NFETS_OFF: 	
                      3085     	; Separate exit commands here for minimum delay
0134    758B00        3086     	MOV	TL1, #0		; Reset timer1	
                      3087     IF MCU_48MHZ == 1
0137    758D00        3088     	MOV	TH1, #0		
                      3089     ENDIF
013A    D0E0          3090     	POP	ACC			; Restore preserved registers
013C    D0D0          3091     	POP	PSW
                      3092     	ALL_NFETS_OFF 		; Switch off all nfets
013E    C293          3092+1   CLR P1 . 3 
0140    C297          3092+1   CLR P1 . 7 
0142    C294          3092+1   CLR P1 . 4 
0144    D2AF          3093     	SETB	EA			; Enable all interrupts
0146    32            3094     	RETI
                      3095     
                      3096     T0_INT_PWM_OFF_DAMPED: 
                      3097     IF PFETON_DELAY < 128
                      3098     	ALL_NFETS_OFF 				; Switch off all nfets
0147    C293          3098+1   CLR P1 . 3 
0149    C297          3098+1   CLR P1 . 7 
014B    C294          3098+1   CLR P1 . 4 
014D    206E09        3099     JB FLAGS1 . 6 , T0_INT_PWM_OFF_DAMP_DONE 
                      3100     IF PFETON_DELAY NE 0
0150    740C          3101     MOV A , # 12 
0152    D5E0FD        3102     	DJNZ	ACC, $	
                      3103     ENDIF
                      3104     	DAMPING_FET_ON
0155    E57B          3104+1   MOV A , DAMPINGFET 
0157    4290          3104+1   ORL P1 , A 
                      3105     T0_INT_PWM_OFF_DAMP_DONE: 
                      3106     ENDIF
                      3107     IF PFETON_DELAY >= 128			; "Negative", 1's complement
                               	JB	FLAGS1.SKIP_DAMP_ON, T0_INT_PWM_OFF_DAMP_DONE
                               	DAMPING_FET_ON				; Damping fet on
                               	MOV	A, #PFETON_DELAY
                               	CPL	A
                               T0_INT_PWM_OFF_DAMP_DONE:
                               	ALL_NFETS_OFF 				; Switch off all nfets
                               ENDIF
                      3115     T0_INT_PWM_OFF_EXIT: 	
0159    758B00        3116     	MOV	TL1, #0		; Reset timer1	
                      3117     IF MCU_48MHZ == 1
015C    758D00        3118     	MOV	TH1, #0		
                      3119     ENDIF
015F    D0E0          3120     	POP	ACC			; Restore preserved registers
0161    D0D0          3121     	POP	PSW
0163    D2AF          3122     	SETB	EA			; Enable all interrupts
0165    32            3123     	RETI
                      3124     
                      3125     T0_INT_PWM_OFF_FULLPOWER_EXIT: 
0166    758A00        3126     	MOV	TL0, #0		; Set long time till next interrupt
                      3127     IF MCU_48MHZ == 1
0169    D263          3128     SETB FLAGS0 . 3 
016B    757900        3129     	MOV	TIMER0_OVERFLOW_VALUE, #0
                      3130     ENDIF
016E    C28D          3131     	CLR	TF0			; Clear interrupt flag
0170    D262          3132     SETB FLAGS0 . 2 
0172    2159          3133     	AJMP	T0_INT_PWM_OFF_EXIT
                      3134     
                      3135     
                      3136     PWM_NOFET: 	; Dummy pwm on cycle
0174    01F5          3137     	AJMP	T0_INT_PWM_ON_EXIT
                      3138     
                      3139     PWM_AFET: 		; Pwm on cycle afet on
0176    306805        3140     JNB FLAGS1 . 0 , PWM_AFET_EXIT 
0179    206602        3141     JB FLAGS0 . 6 , PWM_AFET_EXIT 
                      3142     	ANFET_ON	
017C    D293          3142+1   SETB P1 . 3 
                      3143     PWM_AFET_EXIT: 
017E    01F5          3144     	AJMP	T0_INT_PWM_ON_EXIT
                      3145     
                      3146     PWM_BFET: 		; Pwm on cycle bfet on
0180    306805        3147     JNB FLAGS1 . 0 , PWM_BFET_EXIT 
0183    206602        3148     JB FLAGS0 . 6 , PWM_BFET_EXIT 
                      3149     	BNFET_ON
0186    D294          3149+1   SETB P1 . 4 
                      3150     PWM_BFET_EXIT: 
0188    01F5          3151     	AJMP	T0_INT_PWM_ON_EXIT
                      3152     
                      3153     PWM_CFET: 		; Pwm on cycle cfet on
018A    306805        3154     JNB FLAGS1 . 0 , PWM_CFET_EXIT 
018D    206602        3155     JB FLAGS0 . 6 , PWM_CFET_EXIT 
                      3156     	CNFET_ON
0190    D297          3156+1   SETB P1 . 7 
                      3157     PWM_CFET_EXIT: 
0192    01F5          3158     	AJMP	T0_INT_PWM_ON_EXIT
                      3159     
                      3160     PWM_AFET_DAMPED: 	
                      3161     	APFET_OFF
0194    C292          3161+1   CLR P1 . 2 
0196    30680A        3162     JNB FLAGS1 . 0 , PWM_AFET_DAMPED_EXIT 
0199    206607        3163     JB FLAGS0 . 6 , PWM_AFET_DAMPED_EXIT 
                      3164     IF NFETON_DELAY NE 0
019C    740C          3165     MOV A , # 12 
019E    D5E0FD        3166     	DJNZ ACC,	$
                      3167     ENDIF
                      3168     PWM_AFET_DAMPED_DONE: 
                      3169     	ANFET_ON								; Switch nFET
01A1    D293          3169+1   SETB P1 . 3 
                      3170     PWM_AFET_DAMPED_EXIT: 
01A3    01F5          3171     	AJMP	T0_INT_PWM_ON_EXIT
                      3172     
                      3173     PWM_BFET_DAMPED: 
                      3174     	BPFET_OFF
01A5    C295          3174+1   CLR P1 . 5 
01A7    30680A        3175     JNB FLAGS1 . 0 , PWM_BFET_DAMPED_EXIT 
01AA    206607        3176     JB FLAGS0 . 6 , PWM_BFET_DAMPED_EXIT 
                      3177     IF NFETON_DELAY NE 0
01AD    740C          3178     MOV A , # 12 
01AF    D5E0FD        3179     	DJNZ ACC,	$
                      3180     ENDIF
                      3181     PWM_BFET_DAMPED_DONE: 
                      3182     	BNFET_ON								; Switch nFET
01B2    D294          3182+1   SETB P1 . 4 
                      3183     PWM_BFET_DAMPED_EXIT: 
01B4    01F5          3184     	AJMP	T0_INT_PWM_ON_EXIT
                      3185     
                      3186     PWM_CFET_DAMPED: 	
                      3187     	CPFET_OFF
01B6    C296          3187+1   CLR P1 . 6 
01B8    30680A        3188     JNB FLAGS1 . 0 , PWM_CFET_DAMPED_EXIT 
01BB    206607        3189     JB FLAGS0 . 6 , PWM_CFET_DAMPED_EXIT 
                      3190     IF NFETON_DELAY NE 0
01BE    740C          3191     MOV A , # 12 
01C0    D5E0FD        3192     	DJNZ ACC,	$
                      3193     ENDIF
                      3194     PWM_CFET_DAMPED_DONE: 
                      3195     	CNFET_ON								; Switch nFET
01C3    D297          3195+1   SETB P1 . 7 
                      3196     PWM_CFET_DAMPED_EXIT:  
01C5    01F5          3197     	AJMP	T0_INT_PWM_ON_EXIT
                      3198     
                      3199     
                      3200     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3201     ;
                      3202     ; Timer2 interrupt routine
                      3203     ;
                      3204     ; No assumptions
                      3205     ;
                      3206     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3207     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
01C7    C2AF          3208     	CLR	EA
01C9    C2AD          3209     	CLR	ET2			; Disable timer2 interrupts
01CB    53E6EF        3210     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
01CE    C0D0          3211     	PUSH	PSW			; Preserve registers through interrupt
01D0    C0E0          3212     	PUSH	ACC
01D2    D2D3          3213     	SETB	PSW.3		; Select register bank 1 for interrupt routines
01D4    D2AF          3214     	SETB	EA
                      3215     IF MCU_48MHZ == 1
01D6    E57A          3216     	MOV	A, CLOCK_SET_AT_48MHZ
01D8    6009          3217     	JZ 	T2_INT_START
                      3218     
                      3219     	; Check skip variable
01DA    E577          3220     	MOV	A, SKIP_T2_INT
01DC    6005          3221     	JZ	T2_INT_START				; Execute this interrupt
                      3222     
01DE    757700        3223     	MOV	SKIP_T2_INT, #0
01E1    416C          3224     	AJMP	T2_INT_EXIT
                      3225     
                      3226     T2_INT_START: 
01E3    757701        3227     	MOV	SKIP_T2_INT, #1			; Skip next interrupt
                      3228     ENDIF
                      3229     	; Clear low byte interrupt flag
01E6    C2CE          3230     	CLR	TF2L						; Clear interrupt flag
                      3231     	; Check RC pulse timeout counter
01E8    E52A          3232     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
01EA    6007          3233     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      3234     
                      3235     	; Decrement timeout counter (if PWM)
01EC    207449        3236     JB FLAGS2 . 4 , T2_INT_SKIP_START 
                      3237     
01EF    152A          3238     	DEC	RCP_TIMEOUT_CNT			; No - decrement
01F1    4138          3239     	AJMP	T2_INT_SKIP_START
                      3240     
                      3241     T2_INT_PULSES_ABSENT: 
                      3242     	; Timeout counter has reached zero, pulses are absent
01F3    7800          3243     MOV R0 , # 0 
01F5    7900          3244     MOV R1 , # 0 
01F7    20742E        3245     JB FLAGS2 . 4 , T2_INT_PULSES_ABSENT_NO_MAX 
                      3246     
                      3247     	READ_RCP_INT 					; Look at value of Rcp_In
01FA    E580          3247+1   MOV A , P0 
01FC    307E01        3247+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
01FF    F4            3247+1   CPL A  ; YES - INVERT
0200    30E502        3248     JNB ACC . 5 , ( $+5 ) 
0203    78FF          3249     MOV R0 , # 255 
                      3250     	RCP_INT_FIRST 					; Set interrupt trig to first again
0205    53DACF        3250+1   ANL PCA0CPM0 , # 0CFH 
0208    207E03        3250+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
020B    43DA20        3250+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
020E    307E03        3250+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0211    43DA10        3250+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3251     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0214    C2D8          3251+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0216    C271          3252     CLR FLAGS2 . 1 
                      3253     	READ_RCP_INT 					; Look once more at value of Rcp_In
0218    E580          3253+1   MOV A , P0 
021A    307E01        3253+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
021D    F4            3253+1   CPL A  ; YES - INVERT
021E    30E502        3254     JNB ACC . 5 , ( $+5 ) 
0221    79FF          3255     MOV R1 , # 255 
0223    C3            3256     	CLR	C
0224    E8            3257     MOV A , R0 
0225    99            3258     SUBB A , R1 
0226    70CB          3259     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      3260     
                      3261     T2_INT_PULSES_ABSENT_NO_MAX: 
0228    306103        3262     JNB FLAGS0 . 1 , ( $+6 ) 
                      3263     
022B    752A40        3264     MOV RCP_TIMEOUT_CNT , # 64 
                      3265     
022E    207403        3266     JB FLAGS2 . 4 , T2_INT_PPM_TIMEOUT_SET 
                      3267     
0231    752A40        3268     MOV RCP_TIMEOUT_CNT , # 64 
                      3269     
                      3270     T2_INT_PPM_TIMEOUT_SET: 
0234    885C          3271     MOV NEW_RCP , R0 
0236    D270          3272     SETB FLAGS2 . 0 
                      3273     
                      3274     T2_INT_SKIP_START: 
0238    20740D        3275     JB FLAGS2 . 4 , T2_INT_RCP_UPDATE_START 
                      3276     
                      3277     	; Check RC pulse skip counter
023B    E52B          3278     	MOV	A, RCP_SKIP_CNT			
023D    6004          3279     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      3280     	
                      3281     	; Decrement skip counter (only if edge counter is zero)
023F    152B          3282     	DEC	RCP_SKIP_CNT				; Decrement
0241    4148          3283     	AJMP	T2_INT_RCP_UPDATE_START
                      3284     
                      3285     T2_INT_SKIP_END: 
                      3286     	; Skip counter has reached zero, start looking for RC pulses again
                      3287     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0243    43DA01        3287+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      3288     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0246    C2D8          3288+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3289     	
                      3290     T2_INT_RCP_UPDATE_START: 
                      3291     	; Process updated RC pulse
0248    207002        3292     JB FLAGS2 . 0 , ( $+5 ) 
024B    415B          3293     	AJMP	T2_INT_CURRENT_PWM_UPDATE	; No - update pwm limits and exit
                      3294     
024D    A85C          3295     MOV R0 , NEW_RCP 
024F    206102        3296     JB FLAGS0 . 1 , ( $+5 ) 
                      3297     
0252    C270          3298     CLR FLAGS2 . 0 
                      3299     
                      3300     	; Use a gain of 1.0625x for pwm input if not governor mode
0254    207402        3301     JB FLAGS2 . 4 , T2_INT_PWM_MIN_RUN 
                      3302     
                      3303     IF MODE == 0	; Main - do not adjust gain
0257    4159          3304     	AJMP	T2_INT_PWM_MIN_RUN
                      3305     ELSE
                               
                               IF MODE == 2	; Multi 
                               	MOV	TEMP2, #PGM_GOV_MODE		; Closed loop mode?
                               	CJNE	@TEMP2, #4, T2_INT_PWM_MIN_RUN; Yes - branch
                               ENDIF
                               
                               	; Limit the maximum value to avoid wrap when scaled to pwm range
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
                               	JC	T2_INT_RCP_UPDATE_MULT
                               
                               	MOV	A, #240			; Set requested pwm to max
                               	MOV	TEMP1, A		
                               
                               T2_INT_RCP_UPDATE_MULT:	
                               	; Multiply by 1.0625 (optional adjustment gyro gain)
                               	MOV	A, TEMP1
                               	SWAP	A			; After this "0.0625"
                               	ANL	A, #0FH
                               	ADD	A, TEMP1
                               	MOV	TEMP1, A		
                               	; Adjust tail gain
                               	MOV	TEMP2, #PGM_MOTOR_GAIN
                               	CJNE	@TEMP2, #3, ($+5)			; Is gain 1?
                               	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                               
                               	CLR	C
                               	RRC	A			; After this "0.5"
                               	CLR	C
                               	RRC	A			; After this "0.25"
                               	MOV	BIT_ACCESS_INT, @TEMP2				; (Temp2 has #Pgm_Motor_Gain)
                               	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                               
                               	CLR	C
                               	RRC	A			; After this "0.125"
                               
                               T2_INT_RCP_GAIN_CORR:
                               	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                               
                               	CLR	C
                               	XCH	A, TEMP1
                               	SUBB	A, TEMP1					; Apply negative correction
                               	MOV	TEMP1, A
                               	AJMP	T2_INT_PWM_MIN_RUN
                               
                               T2_INT_RCP_GAIN_POS:
                               	ADD	A, TEMP1					; Apply positive correction
                               	MOV	TEMP1, A
                               	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                               
                               	MOV	A, #0FFH					; Yes - limit
                               	MOV	TEMP1, A
                               ENDIF
                      3360     
                      3361     T2_INT_PWM_MIN_RUN:  
                      3362     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      3372     
                      3373     T2_INT_PWM_UPDATE:  
                      3374     	; Update requested_pwm
0259    8822          3375     MOV REQUESTED_PWM , R0 
                      3376     IF MODE >= 1	; Tail or multi
                               	; Boost pwm during direct start
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JZ	T2_INT_CURRENT_PWM_UPDATE
                               
                               	MOV	A, STARTUP_CNT				; Add an extra power boost during start
                               	CLR	C
                               	RRC	A
                               	CLR	C
                               	RRC	A
                               	ADD	A, REQUESTED_PWM			
                               	MOV	REQUESTED_PWM, A
                               	JNC	($+5)
                               
                               	MOV	REQUESTED_PWM, #0FFH
                               
                               ENDIF
                      3394     T2_INT_CURRENT_PWM_UPDATE:  
                      3395     IF MODE == 0 OR MODE == 2	; Main or multi
025B    7882          3396     MOV R0 , # PGM_GOV_MODE 
025D    B60403        3397     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      3398     ENDIF
                      3399     
0260    852224        3400     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      3401     IF MODE >= 1	; Tail or multi
                               	; Set current_pwm_limited
                               	MOV	TEMP1, CURRENT_PWM			; Default not limited
                               	CLR	C
                               	MOV	A, CURRENT_PWM				; Check against limit
                               	SUBB	A, PWM_LIMIT
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT			; Limit pwm
                               
                               IF MODE == 2	; Multi
                               	; Limit pwm for low rpms
                               	CLR	C
                               	MOV	A, TEMP1					; Check against limit
                               	SUBB	A, PWM_LIMIT_BY_RPM
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT_BY_RPM		; Limit pwm
                               
                               ENDIF
                               	MOV	CURRENT_PWM_LIMITED, TEMP1
                               	; Dither
                               	MOV	A, PWM_DITHER_DECODED		; Load pwm dither
                               	JNZ	($+4)					; If active - branch
                               	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                               
                               	CLR	C
                               	MOV	A, TEMP1
                               	MOV	TEMP3, PWM_DITHER_DECODED				
                               	SUBB	A, TEMP3					; Calculate pwm minus dither value
                               	JNC	T2_INT_CURRENT_PWM_FULL_DITHER; If pwm more than dither value, then do full dither
                               
                               	MOV	A, TEMP1					; Set dither level to current pwm
                               	MOV	TEMP3, A				
                               	CLR	A						; Set pwm minus dither
                               
                               T2_INT_CURRENT_PWM_FULL_DITHER:
                               	MOV	TEMP2, A					; Load pwm minus dither value
                               	MOV	A, TEMP3					; Load dither	
                               	CLR	C
                               	RLC	A						; Shift left once
                               	MOV	TEMP4, A
                               	MOV	A, RANDOM					; Load random number
                               	CPL	A						; Invert to create proper DC bias in random code
                               	ANL	A, TEMP4					; And with double dither value
                               	ADD	A, TEMP2					; Add pwm minus dither
                               	JC	T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER	; If dither cause power above max - branch and increase excess 
                               
                               	ADD	A, PWM_DITHER_EXCESS_POWER	; Add excess power from previous cycles
                               	MOV	TEMP1, A
                               	MOV	A, PWM_DITHER_EXCESS_POWER	; Decrement excess power
                               	JZ	($+4)
                               	DEC	PWM_DITHER_EXCESS_POWER
                               	JC	T2_INT_CURRENT_PWM_DITHER_MAX_POWER; If dither cause power above max - branch
                               
                               	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                               
                               T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER:
                               	INC	TEMP3					; Add one to dither in order to always reach max power
                               	CLR	C
                               	MOV	A, PWM_DITHER_EXCESS_POWER
                               	SUBB	A, TEMP3					; Limit excess power 
                               	JNC	($+4)
                               	INC	PWM_DITHER_EXCESS_POWER
                               
                               T2_INT_CURRENT_PWM_DITHER_MAX_POWER:
                               	MOV	TEMP1, #255				; Set power to max
                               
                               T2_INT_CURRENT_PWM_NO_DITHER:
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               IF DAMPED_MODE_ENABLE == 1
                               	; Skip damping fet switching for high throttle
                               	CLR	FLAGS1.SKIP_DAMP_ON
                               	CLR	C
                               	MOV	A, CURRENT_PWM_LIM_DITH
                               	SUBB	A, #248
                               	JC	T2_INT_PWM_EXIT
                               	SETB	FLAGS1.SKIP_DAMP_ON
                               ENDIF
                               ENDIF
                      3481     T2_INT_PWM_EXIT: 	
                      3482     	; Set demag enabled if pwm is above limit
0263    C3            3483     	CLR	C
0264    E525          3484     	MOV	A, CURRENT_PWM_LIMITED	
0266    9440          3485     	SUBB	A, #40H					; Set if above 25%
0268    4002          3486     	JC	($+4)
                      3487     
026A    D264          3488     SETB FLAGS0 . 4 
                      3489     
                      3490     T2_INT_EXIT: 	
                      3491     	; Check if high byte flag is set
026C    20CF0A        3492     	JB	TF2H, T2H_INT		
026F    D0E0          3493     	POP	ACC			; Restore preserved registers
0271    D0D0          3494     	POP	PSW
0273    43E610        3495     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0276    D2AD          3496     	SETB	ET2			; Enable timer2 interrupts
0278    32            3497     	RETI
                      3498     
                      3499     T2H_INT: 
                      3500     IF MCU_48MHZ == 1
0279    E57A          3501     	MOV	A, CLOCK_SET_AT_48MHZ
027B    6009          3502     	JZ 	T2H_INT_START
                      3503     
                      3504     	; Check skip variable
027D    E578          3505     	MOV	A, SKIP_T2H_INT
027F    6005          3506     	JZ	T2H_INT_START				; Execute this interrupt
                      3507     
0281    757800        3508     	MOV	SKIP_T2H_INT, #0
0284    6157          3509     	AJMP	T2H_INT_EXIT
                      3510     
                      3511     T2H_INT_START: 
0286    757801        3512     	MOV	SKIP_T2H_INT, #1			; Skip next interrupt
                      3513     ENDIF
                      3514     	; High byte interrupt (happens every 32ms)
0289    C2CF          3515     	CLR	TF2H					; Clear interrupt flag
028B    7802          3516     MOV R0 , # 2 
                      3517     	; Check RC pulse timeout counter (used here for PPM only)
028D    E52A          3518     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
028F    6005          3519     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      3520     
                      3521     	; Decrement timeout counter (if PPM)
0291    307402        3522     JNB FLAGS2 . 4 , T2H_INT_RCP_STOP_CHECK 
                      3523     
0294    152A          3524     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      3525     
                      3526     T2H_INT_RCP_STOP_CHECK: 
                      3527     	; Check RC pulse against stop value
0296    C3            3528     	CLR	C
0297    E55C          3529     	MOV	A, NEW_RCP				; Load new pulse value
0299    9401          3530     SUBB A , # 1 
029B    4005          3531     	JC	T2H_INT_RCP_STOP
                      3532     
                      3533     	; RC pulse higher than stop value, reset stop counter
029D    755F00        3534     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
02A0    41B3          3535     	AJMP	T2H_INT_RCP_GOV_PWM
                      3536     
                      3537     T2H_INT_RCP_STOP: 	
                      3538     	; RC pulse less than stop value
02A2    756000        3539     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
02A5    756900        3540     	MOV	SPOOLUP_LIMIT_CNT, #0
02A8    E55F          3541     	MOV	A, RCP_STOP_CNT			; Increment stop counter
02AA    2401          3542     	ADD	A, #1
02AC    F55F          3543     	MOV	RCP_STOP_CNT, A
02AE    5003          3544     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      3545     
02B0    755FFF        3546     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      3547     
                      3548     T2H_INT_RCP_GOV_PWM: 
                      3549     IF MODE == 0	; Main
                      3550     	; Update governor variables
02B3    7982          3551     MOV R1 , # PGM_GOV_MODE 
02B5    B7020D        3552     CJNE @ R1 , # 2 , T2H_INT_RCP_GOV_BY_SETUP 
                      3553     
02B8    306D1D        3554     JNB FLAGS1 . 5 , T2H_INT_RCP_GOV_BY_TX 
                      3555     
02BB    C3            3556     	CLR	C
02BC    E522          3557     	MOV	A, REQUESTED_PWM
02BE    9432          3558     	SUBB	A, #50						; Is requested pwm below 20%?
02C0    4016          3559     	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                      3560     
02C2    854A22        3561     	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                      3562     
                      3563     T2H_INT_RCP_GOV_BY_SETUP: 
02C5    7982          3564     MOV R1 , # PGM_GOV_MODE 
02C7    B7030E        3565     CJNE @ R1 , # 3 , T2H_INT_RCP_GOV_BY_TX 
                      3566     
02CA    306D0B        3567     JNB FLAGS1 . 5 , T2H_INT_RCP_GOV_BY_TX 
                      3568     
02CD    C3            3569     	CLR	C
02CE    E522          3570     	MOV	A, REQUESTED_PWM
02D0    9432          3571     	SUBB	A, #50						; Is requested pwm below 20%?
02D2    4004          3572     	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                      3573     
02D4    798E          3574     MOV R1 , # PGM_GOV_SETUP_TARGET 
02D6    8722          3575     MOV REQUESTED_PWM , @ R1 
                      3576     
                      3577     T2H_INT_RCP_GOV_BY_TX: 
02D8    C3            3578     	CLR	C
02D9    E523          3579     	MOV	A, GOVERNOR_REQ_PWM
02DB    9522          3580     	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
02DD    6008          3581     	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                      3582     
02DF    4004          3583     	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                      3584     
02E1    1523          3585     	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
02E3    41E7          3586     	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                      3587     
                      3588     T2H_INT_RCP_GOV_PWM_INC: 
02E5    0523          3589     	INC	GOVERNOR_REQ_PWM				; Increment
                      3590     
                      3591     T2H_INT_RCP_GOV_PWM_DONE: 
02E7    D8CA          3592     DJNZ R0 , T2H_INT_RCP_GOV_PWM 
                      3593     
02E9    0569          3594     	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
02EB    E569          3595     	MOV	A, SPOOLUP_LIMIT_CNT
02ED    7002          3596     	JNZ	($+4)						; Wrapped?
                      3597     
02EF    1569          3598     	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                      3599     
02F1    D56A63        3600     	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_EXIT	; Jump if skip count is not reached
                      3601     
02F4    756A01        3602     	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
02F7    7805          3603     MOV R0 , # 5 
02F9    C3            3604     	CLR	C
02FA    E569          3605     	MOV	A, SPOOLUP_LIMIT_CNT
02FC    956B          3606     	SUBB	A, MAIN_SPOOLUP_TIME_3X			; No spoolup until 3*N*32ms
                      3607     
02FE    4057          3608     	JC	T2H_INT_EXIT
                      3609     
0300    C3            3610     	CLR	C
0301    E569          3611     	MOV	A, SPOOLUP_LIMIT_CNT
0303    956C          3612     	SUBB	A, MAIN_SPOOLUP_TIME_10X			; Slow spoolup until "100"*N*32ms
0305    5008          3613     	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                      3614     
0307    7801          3615     MOV R0 , # 1 
0309    756A03        3616     	MOV	SPOOLUP_LIMIT_SKIP, #3			
030C    02031B        3617     	JMP	T2H_INT_RCP_SET_LIMIT
                      3618     
                      3619     T2H_INT_RCP_LIMIT_MIDDLE_RAMP: 
030F    C3            3620     	CLR	C
0310    E569          3621     	MOV	A, SPOOLUP_LIMIT_CNT
0312    956D          3622     	SUBB	A, MAIN_SPOOLUP_TIME_15X			; Faster spoolup until "150"*N*32ms
0314    5005          3623     	JNC	T2H_INT_RCP_SET_LIMIT
                      3624     
0316    7801          3625     MOV R0 , # 1 
0318    756A01        3626     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      3627     
                      3628     T2H_INT_RCP_SET_LIMIT: 
                      3629     	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
031B    C3            3630     	CLR	C
031C    E562          3631     	MOV	A, PWM_LIMIT_SPOOLUP
031E    9524          3632     	SUBB	A, CURRENT_PWM
0320    401E          3633     	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                      3634     
0322    7982          3635     MOV R1 , # PGM_GOV_MODE 
0324    B70402        3636     CJNE @ R1 , # 4 , ( $+5 ) 
0327    614C          3637     	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                      3638     
0329    206D14        3639     JB FLAGS1 . 5 , T2H_INT_RCP_INC_LIMIT 
                      3640     
032C    852462        3641     	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
032F    E569          3642     	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
0331    04            3643     	INC	A
0332    6003          3644     	JZ	($+5)
                      3645     
0334    856B69        3646     	MOV	SPOOLUP_LIMIT_CNT, MAIN_SPOOLUP_TIME_3X	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                      3647     
0337    756A01        3648     	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
033A    75233C        3649     	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                      3650     									; 20=Fail on jerk when governor activates
                      3651     									; 30=Ok
                      3652     									; 100=Fail on small governor settling overshoot on low headspeeds
                      3653     									; 200=Fail on governor settling overshoot
033D    020357        3654     	JMP	T2H_INT_EXIT					; Exit
                      3655     
                      3656     T2H_INT_RCP_INC_LIMIT: 
0340    E562          3657     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
0342    28            3658     ADD A , R0 
0343    5005          3659     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      3660     
0345    7562FF        3661     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
0348    614C          3662     	AJMP	T2H_INT_RCP_BAILOUT_ARM
                      3663     
                      3664     T2H_INT_RCP_NO_LIMIT: 
034A    F562          3665     	MOV	PWM_LIMIT_SPOOLUP, A
                      3666     T2H_INT_RCP_BAILOUT_ARM: 
034C    E562          3667     	MOV	A, PWM_LIMIT_SPOOLUP
034E    04            3668     	INC	A
034F    7006          3669     	JNZ	T2H_INT_EXIT
                      3670     
0351    7560FF        3671     	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
0354    7569FF        3672     	MOV	SPOOLUP_LIMIT_CNT, #255			
                      3673     
                      3674     ENDIF
                      3675     T2H_INT_EXIT: 
0357    D0E0          3676     	POP	ACC			; Restore preserved registers
0359    D0D0          3677     	POP	PSW
035B    43E610        3678     	ORL	EIE1, #10H	; Enable PCA0 interrupts
035E    D2AD          3679     	SETB	ET2			; Enable timer2 interrupts
0360    32            3680     	RETI
                      3681     
                      3682     
                      3683     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3684     ;
                      3685     ; Timer3 interrupt routine
                      3686     ;
                      3687     ; No assumptions
                      3688     ;
                      3689     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3690     T3_INT: 	; Used for commutation timing
0361    C2AF          3691     	CLR 	EA				; Disable all interrupts
0363    C0D0          3692     	PUSH	PSW				; Preserve registers through interrupt
0365    53E67F        3693     	ANL	EIE1, #7FH		; Disable timer3 interrupts
0368    C260          3694     CLR FLAGS0 . 0 
                      3695     	; Set up next wait
036A    759100        3696     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
036D    855394        3697     	MOV	TMR3L, NEXT_WT_START_L	; Set wait value	
0370    855495        3698     	MOV	TMR3H, NEXT_WT_START_H
0373    759104        3699     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
0376    D0D0          3700     	POP	PSW
0378    D2AF          3701     	SETB	EA				; Enable all interrupts
037A    32            3702     	RETI
                      3703     
                      3704     
                      3705     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3706     ;
                      3707     ; PCA interrupt routine
                      3708     ;
                      3709     ; No assumptions
                      3710     ;
                      3711     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3712     PCA_INT: 	; Used for RC pulse timing
037B    C2AF          3713     	CLR	EA
037D    53E6EF        3714     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
0380    C2AD          3715     	CLR	ET2			; Disable timer2 interrupts
0382    C0D0          3716     	PUSH	PSW			; Preserve registers through interrupt
0384    C0E0          3717     	PUSH	ACC
0386    C0F0          3718     	PUSH	B
0388    D2D3          3719     	SETB	PSW.3		; Select register bank 1 for interrupt routines
038A    D2AF          3720     	SETB	EA
                      3721     	; Get the PCA counter values
                      3722     	GET_RCP_CAPTURE_VALUES
038C    A8FB          3722+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
038E    A9FC          3722+1   MOV R1 , PCA0CPH0 
                      3722+1   IF 1 ==1 
0390    E57A          3722+1   MOV A , CLOCK_SET_AT_48MHZ 
0392    6007          3722+1   JZ GET_RCP_END 
0394    C3            3722+1   CLR C 
0395    E9            3722+1   MOV A , R1 
0396    13            3722+1   RRC A 
0397    F9            3722+1   MOV R1 , A 
0398    E8            3722+1   MOV A , R0 
0399    13            3722+1   RRC A 
039A    F8            3722+1   MOV R0 , A 
                      3722+1   GET_RCP_END:  
                      3722+1   ENDIF 
                      3723     	; Clear interrupt flag
                      3724     	RCP_CLEAR_INT_FLAG 				
039B    C2D8          3724+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3725     	; Check which edge it is
039D    307102        3726     JNB FLAGS2 . 1 , ( $+5 ) 
03A0    61ED          3727     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      3728     
                      3729     	RCP_INT_SECOND					; Yes - set second edge trig
03A2    53DACF        3729+1   ANL PCA0CPM0 , # 0CFH 
03A5    207E03        3729+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03A8    43DA10        3729+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03AB    307E03        3729+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03AE    43DA20        3729+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03B1    D271          3730     SETB FLAGS2 . 1 
                      3731     	; Read RC signal level
                      3732     	READ_RCP_INT			
03B3    E580          3732+1   MOV A , P0 
03B5    307E01        3732+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
03B8    F4            3732+1   CPL A  ; YES - INVERT
                      3733     	; Test RC signal level
03B9    20E502        3734     JB ACC . 5 , ( $+5 ) 
03BC    61C4          3735     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      3736     
                      3737     	; RC pulse was high, store RC pulse start timestamp
03BE    8827          3738     MOV RCP_PREV_EDGE_L , R0 
03C0    8928          3739     MOV RCP_PREV_EDGE_H , R1 
03C2    A1CC          3740     	AJMP	PCA_INT_EXIT				; Exit
                      3741     
                      3742     PCA_INT_FAIL_MINIMUM: 
                      3743     	; Prepare for next interrupt
                      3744     	RCP_INT_FIRST					; Set interrupt trig to first again
03C4    53DACF        3744+1   ANL PCA0CPM0 , # 0CFH 
03C7    207E03        3744+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03CA    43DA20        3744+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03CD    307E03        3744+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03D0    43DA10        3744+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3745     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03D3    C2D8          3745+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03D5    C271          3746     CLR FLAGS2 . 1 
03D7    307402        3747     JNB FLAGS2 . 4 , ( $+5 ) 
                      3748     
03DA    A1B8          3749     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      3750     
03DC    7800          3751     MOV R0 , # 0 
                      3752     	READ_RCP_INT 					; Test RC signal level again
03DE    E580          3752+1   MOV A , P0 
03E0    307E01        3752+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
03E3    F4            3752+1   CPL A  ; YES - INVERT
03E4    30E502        3753     JNB ACC . 5 , ( $+5 ) 
                      3754     
03E7    A1B8          3755     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      3756     
03E9    885C          3757     MOV NEW_RCP , R0 
03EB    A1A0          3758     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      3759     
                      3760     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      3761     	; Prepare for next interrupt
                      3762     	RCP_INT_FIRST 					; Set first edge trig
03ED    53DACF        3762+1   ANL PCA0CPM0 , # 0CFH 
03F0    207E03        3762+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03F3    43DA20        3762+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03F6    307E03        3762+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03F9    43DA10        3762+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03FC    C271          3763     CLR FLAGS2 . 1 
                      3764     	; Check if pwm frequency shall be measured
03FE    206102        3765     JB FLAGS0 . 1 , ( $+5 ) 
0401    81C6          3766     	AJMP	PCA_INT_FALL				; No - skip measurements
                      3767     
                      3768     	; Set second edge trig only during pwm frequency measurement
                      3769     	RCP_INT_SECOND 				; Set second edge trig
0403    53DACF        3769+1   ANL PCA0CPM0 , # 0CFH 
0406    207E03        3769+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0409    43DA10        3769+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
040C    307E03        3769+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
040F    43DA20        3769+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      3770     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0412    C2D8          3770+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0414    D271          3771     SETB FLAGS2 . 1 
                      3772     	; Store edge data to RAM
0416    8857          3773     MOV RCP_EDGE_L , R0 
0418    8958          3774     MOV RCP_EDGE_H , R1 
                      3775     	; Calculate pwm frequency
041A    C3            3776     	CLR	C
041B    E8            3777     MOV A , R0 
041C    9555          3778     	SUBB	A, RCP_PREPREV_EDGE_L	
041E    F8            3779     MOV R0 , A 
041F    E9            3780     MOV A , R1 
0420    9556          3781     	SUBB	A, RCP_PREPREV_EDGE_H
0422    F9            3782     MOV R1 , A 
0423    7B00          3783     MOV R3 , # 0 
0425    7E08          3784     MOV R6 , # 8 
0427    7A00          3785     MOV R2 , # 0 
                      3786     	; Check if pulse is too short
0429    C3            3787     	CLR	C
042A    E8            3788     MOV A , R0 
042B    948C          3789     	SUBB	A, #LOW(140)				; If pulse below 70us, not accepted
042D    E9            3790     MOV A , R1 
042E    9400          3791     	SUBB	A, #HIGH(140)
0430    5005          3792     	JNC	PCA_INT_CHECK_12KHZ
                      3793     
0432    755B00        3794     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0	; Set not accepted 
0435    81B8          3795     	AJMP	PCA_INT_STORE_DATA
                      3796     
                      3797     PCA_INT_CHECK_12KHZ: 
0437    8821          3798     MOV BIT_ACCESS_INT , R0 
0439    78A2          3799     MOV R0 , # PGM_ENABLE_PWM_INPUT 
043B    E6            3800     MOV A , @ R0 
043C    A821          3801     MOV R0 , BIT_ACCESS_INT 
043E    6055          3802     	JZ	PCA_INT_RESTORE_EDGE		; If it is not - branch
                      3803     
                      3804     	; Check if pwm frequency is 12kHz
0440    C3            3805     	CLR	C
0441    E8            3806     MOV A , R0 
0442    94C8          3807     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
0444    E9            3808     MOV A , R1 
0445    9400          3809     	SUBB	A, #HIGH(200)
0447    5008          3810     	JNC	PCA_INT_CHECK_8KHZ
                      3811     
0449    E4            3812     	CLR	A
044A    D2E4          3813     SETB ACC . 4 
044C    FB            3814     MOV R3 , A 
044D    7A0A          3815     MOV R2 , # 10 
044F    8193          3816     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3817     
                      3818     PCA_INT_CHECK_8KHZ: 
                      3819     	; Check if pwm frequency is 8kHz
0451    C3            3820     	CLR	C
0452    E8            3821     MOV A , R0 
0453    9468          3822     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0455    E9            3823     MOV A , R1 
0456    9401          3824     	SUBB	A, #HIGH(360)
0458    5008          3825     	JNC	PCA_INT_CHECK_4KHZ
                      3826     
045A    E4            3827     	CLR	A
045B    D2E3          3828     SETB ACC . 3 
045D    FB            3829     MOV R3 , A 
045E    7A0F          3830     MOV R2 , # 15 
0460    8193          3831     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3832     
                      3833     PCA_INT_CHECK_4KHZ: 
                      3834     	; Check if pwm frequency is 4kHz
0462    C3            3835     	CLR	C
0463    E8            3836     MOV A , R0 
0464    94D0          3837     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0466    E9            3838     MOV A , R1 
0467    9402          3839     	SUBB	A, #HIGH(720)
0469    5008          3840     	JNC	PCA_INT_CHECK_2KHZ
                      3841     
046B    E4            3842     	CLR	A
046C    D2E2          3843     SETB ACC . 2 
046E    FB            3844     MOV R3 , A 
046F    7A1E          3845     MOV R2 , # 30 
0471    8193          3846     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3847     
                      3848     PCA_INT_CHECK_2KHZ: 
                      3849     	; Check if pwm frequency is 2kHz
0473    C3            3850     	CLR	C
0474    E8            3851     MOV A , R0 
0475    94A0          3852     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0477    E9            3853     MOV A , R1 
0478    9405          3854     	SUBB	A, #HIGH(1440)
047A    5008          3855     	JNC	PCA_INT_CHECK_1KHZ
                      3856     
047C    E4            3857     	CLR	A
047D    D2E1          3858     SETB ACC . 1 
047F    FB            3859     MOV R3 , A 
0480    7A3C          3860     MOV R2 , # 60 
0482    8193          3861     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3862     
                      3863     PCA_INT_CHECK_1KHZ: 
                      3864     	; Check if pwm frequency is 1kHz
0484    C3            3865     	CLR	C
0485    E8            3866     MOV A , R0 
0486    9498          3867     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0488    E9            3868     MOV A , R1 
0489    9408          3869     	SUBB	A, #HIGH(2200)
048B    5008          3870     	JNC	PCA_INT_RESTORE_EDGE
                      3871     
048D    E4            3872     	CLR	A
048E    D2E0          3873     SETB ACC . 0 
0490    FB            3874     MOV R3 , A 
0491    7A78          3875     MOV R2 , # 120 
                      3876     
                      3877     PCA_INT_RESTORE_EDGE_SET_MSB: 
0493    7E00          3878     MOV R6 , # 0 
                      3879     PCA_INT_RESTORE_EDGE: 
                      3880     	; Calculate difference between this period and previous period
0495    C3            3881     	CLR	C
0496    E8            3882     MOV A , R0 
0497    9559          3883     	SUBB	A, RCP_PREV_PERIOD_L
0499    FC            3884     MOV R4 , A 
049A    E9            3885     MOV A , R1 
049B    955A          3886     	SUBB	A, RCP_PREV_PERIOD_H
049D    FD            3887     MOV R5 , A 
                      3888     	; Make positive
049E    30E70A        3889     	JNB	ACC.7, PCA_INT_CHECK_DIFF
04A1    EC            3890     MOV A , R4 
04A2    F4            3891     	CPL	A
04A3    2401          3892     	ADD	A, #1
04A5    FC            3893     MOV R4 , A 
04A6    ED            3894     MOV A , R5 
04A7    F4            3895     	CPL	A
04A8    3400          3896     	ADDC	A, #0
04AA    FD            3897     MOV R5 , A 
                      3898     
                      3899     PCA_INT_CHECK_DIFF: 
                      3900     	; Check difference
04AB    755B00        3901     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
04AE    C3            3902     	CLR	C
04AF    EC            3903     MOV A , R4 
04B0    9A            3904     SUBB A , R2 
04B1    ED            3905     MOV A , R5 
04B2    9E            3906     SUBB A , R6 
04B3    5003          3907     	JNC	PCA_INT_STORE_DATA
                      3908     
04B5    755B01        3909     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      3910     
                      3911     PCA_INT_STORE_DATA: 
                      3912     	; Store previous period
04B8    8859          3913     MOV RCP_PREV_PERIOD_L , R0 
04BA    895A          3914     MOV RCP_PREV_PERIOD_H , R1 
                      3915     	; Store pre previous edge
04BC    855755        3916     	MOV	RCP_PREPREV_EDGE_L, RCP_EDGE_L
04BF    855856        3917     	MOV	RCP_PREPREV_EDGE_H, RCP_EDGE_H
04C2    7802          3918     MOV R0 , # 2 
04C4    A1A0          3919     	AJMP	PCA_INT_LIMITED
                      3920     
                      3921     PCA_INT_FALL: 
                      3922     	; RC pulse edge was second, calculate new pulse length
04C6    C3            3923     	CLR	C
04C7    E8            3924     MOV A , R0 
04C8    9527          3925     	SUBB	A, RCP_PREV_EDGE_L	
04CA    F8            3926     MOV R0 , A 
04CB    E9            3927     MOV A , R1 
04CC    9528          3928     	SUBB	A, RCP_PREV_EDGE_H
04CE    F9            3929     MOV R1 , A 
04CF    307C02        3930     JNB FLAGS3 . 4 , ( $+5 ) 
04D2    A184          3931     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3932     
04D4    307B02        3933     JNB FLAGS3 . 3 , ( $+5 ) 
04D7    A184          3934     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3935     
04D9    307A02        3936     JNB FLAGS3 . 2 , ( $+5 ) 
04DC    A17D          3937     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3938     
04DE    207502        3939     JB FLAGS2 . 5 , ( $+5 ) 
04E1    81E9          3940     	AJMP	PCA_INT_FALL_NOT_ONESHOT
                      3941     
04E3    E9            3942     MOV A , R1 
04E4    FD            3943     MOV R5 , A 
04E5    E8            3944     MOV A , R0 
04E6    FC            3945     MOV R4 , A 
04E7    A108          3946     	AJMP	PCA_INT_FALL_CHECK_RANGE
                      3947     
                      3948     PCA_INT_FALL_NOT_ONESHOT: 
04E9    E9            3949     MOV A , R1 
04EA    C3            3950     	CLR	C
04EB    13            3951     	RRC	A
04EC    F9            3952     MOV R1 , A 
04ED    E8            3953     MOV A , R0 
04EE    13            3954     	RRC	A
04EF    F8            3955     MOV R0 , A 
                      3956     
04F0    307902        3957     JNB FLAGS3 . 1 , ( $+5 ) 
04F3    A17D          3958     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3959     
04F5    E9            3960     MOV A , R1 
04F6    C3            3961     	CLR	C
04F7    13            3962     	RRC	A
04F8    F9            3963     MOV R1 , A 
04F9    E8            3964     MOV A , R0 
04FA    13            3965     	RRC	A
04FB    F8            3966     MOV R0 , A 
                      3967     
04FC    307802        3968     JNB FLAGS3 . 0 , ( $+5 ) 
04FF    A17D          3969     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3970     
0501    E9            3971     MOV A , R1 
0502    C3            3972     	CLR	C
0503    13            3973     	RRC	A
0504    FD            3974     MOV R5 , A 
0505    E8            3975     MOV A , R0 
0506    13            3976     	RRC	A
0507    FC            3977     MOV R4 , A 
                      3978     PCA_INT_FALL_CHECK_RANGE: 
                      3979     	; Skip range limitation if pwm frequency measurement
0508    206126        3980     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      3981     
                      3982     	; Check if 2160us or above (in order to ignore false pulses)
050B    C3            3983     	CLR	C
050C    EC            3984     MOV A , R4 
050D    941C          3985     	SUBB	A, #28
050F    ED            3986     MOV A , R5 
0510    9402          3987     	SUBB A, #2
0512    4002          3988     	JC	($+4)						; No - proceed
                      3989     
0514    A11F          3990     	AJMP	PCA_INT_PPM_OUTSIDE_RANGE		; Yes - ignore pulse
                      3991     
                      3992     PCA_INT_PPM_BELOW_FULL_RANGE: 
                      3993     	; Check if below 800us (in order to ignore false pulses)
0516    ED            3994     MOV A , R5 
0517    7018          3995     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      3996     
0519    C3            3997     	CLR	C
051A    EC            3998     MOV A , R4 
051B    94C8          3999     	SUBB	A, #200
051D    5012          4000     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      4001     
                      4002     PCA_INT_PPM_OUTSIDE_RANGE: 
051F    0529          4003     	INC	RCP_OUTSIDE_RANGE_CNT
0521    C3            4004     	CLR	C
0522    E529          4005     	MOV	A, RCP_OUTSIDE_RANGE_CNT
0524    940A          4006     	SUBB	A, #10						; Allow a given number of outside pulses
0526    5002          4007     	JNC	($+4)			
0528    A1B8          4008     	AJMP	PCA_INT_SET_TIMEOUT				; If below limit - ignore pulse
                      4009     
052A    755C00        4010     	MOV	NEW_RCP, #0					; Set pulse length to zero
052D    D270          4011     SETB FLAGS2 . 0 
052F    A1B8          4012     	AJMP	PCA_INT_SET_TIMEOUT			
                      4013     
                      4014     PCA_INT_PPM_CHECK_FULL_RANGE: 
0531    E529          4015     	MOV	A, RCP_OUTSIDE_RANGE_CNT
0533    6002          4016     	JZ	($+4)
                      4017     
0535    1529          4018     	DEC	RCP_OUTSIDE_RANGE_CNT
                      4019     
                      4020     	; Calculate "1000us" plus throttle minimum
                      4021     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION			; Check if bidirectional operation (store in Temp2)
                               	MOV	A, @TEMP1				
                               	MOV	TEMP2, A				
                               ENDIF
0537    7400          4026     	MOV	A, #0						; Set 1000us as default minimum
0539    207F03        4027     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      4028     
053C    7896          4029     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      4030     IF MODE >= 1	; Tail or multi
                               	CJNE	TEMP2, #3, ($+5)
                               
                               	MOV	TEMP1, #PGM_PPM_CENTER_THROTTLE	; Center throttle value is in 4us units
                               ENDIF
053E    E6            4035     MOV A , @ R0 
                      4036     
                      4037     PCA_INT_PPM_CALCULATE: 
053F    24FA          4038     	ADD	A, #250						; Add 1000us to minimum
0541    FE            4039     MOV R6 , A 
0542    E4            4040     	CLR	A
0543    3400          4041     	ADDC	A, #0
0545    FF            4042     MOV R7 , A 
                      4043     
0546    C3            4044     	CLR	C
0547    EC            4045     MOV A , R4 
0548    9E            4046     SUBB A , R6 
0549    FC            4047     MOV R4 , A 
054A    ED            4048     MOV A , R5 
054B    9F            4049     SUBB A , R7 
054C    FD            4050     MOV R5 , A 
                      4051     IF MODE >= 1	; Tail or multi
                               	MOV	BIT_ACCESS_INT.0, C
                               	CJNE	TEMP2, #3, PCA_INT_PPM_BIDIR_DIR_SET; If not bidirectional operation - branch
                               
                               	MOV	C, BIT_ACCESS_INT.0
                               	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                               
                               PCA_INT_PPM_BIDIR_REV:
                               	JB	FLAGS2.RCP_DIR_REV, PCA_INT_PPM_BIDIR_DIR_SET	; If same direction - branch
                               
                               	SETB	FLAGS2.RCP_DIR_REV
                               	AJMP	PCA_INT_PPM_BIDIR_DIR_SET
                               
                               PCA_INT_PPM_BIDIR_FWD:
                               	JNB	FLAGS2.RCP_DIR_REV, PCA_INT_PPM_BIDIR_DIR_SET	; If same direction - branch
                               
                               	CLR	FLAGS2.RCP_DIR_REV
                               
                               PCA_INT_PPM_BIDIR_DIR_SET:
                               	MOV	C, BIT_ACCESS_INT.0
                               ENDIF
054D    5006          4072     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      4073     
                      4074     IF MODE >= 1	; Tail or multi
                               	CJNE	TEMP2, #3, PCA_INT_PPM_UNIDIR_NEG 	; If not bidirectional operation - branch
                               
                               	MOV	A, TEMP5						; Change sign		
                               	CPL	A
                               	ADD	A, #1
                               	MOV	TEMP5, A
                               	MOV	A, TEMP6							
                               	CPL	A
                               	ADDC	A, #0
                               	MOV	TEMP6, A
                               	JMP	PCA_INT_PPM_NEG_CHECKED
                               
                               PCA_INT_PPM_UNIDIR_NEG:
                               ENDIF
054F    7800          4089     MOV R0 , # 0 
0551    7900          4090     MOV R1 , # 0 
0553    A184          4091     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4092     
                      4093     PCA_INT_PPM_NEG_CHECKED: 
                      4094     IF MODE >= 1	; Tail or multi
                               	CJNE	TEMP2, #3, PCA_INT_PPM_BIDIR_DONE	; If not bidirectional operation - branch
                               
                               	MOV	A, TEMP5						; Multiply value by 2
                               	RLC	A
                               	MOV	TEMP5 A
                               	MOV	A, TEMP6
                               	RLC	A
                               	MOV	TEMP6 A
                               	CLR	C							; Subtract deadband
                               	MOV	A, TEMP5
                               	SUBB	A, #10		
                               	MOV	TEMP5, A
                               	MOV	A, TEMP6
                               	SUBB	A, #0
                               	MOV	TEMP6, A
                               	JNC	PCA_INT_PPM_BIDIR_DONE
                               
                               	MOV	TEMP5, #RCP_MIN
                               	MOV	TEMP6, #0
                               
                               PCA_INT_PPM_BIDIR_DONE:
                               ENDIF
0555    C3            4117     	CLR	C							; Check that RC pulse is within legal range (max 255)
0556    EC            4118     MOV A , R4 
0557    94FF          4119     SUBB A , # 255 
0559    ED            4120     MOV A , R5 
055A    9400          4121     	SUBB	A, #0
055C    4006          4122     	JC	PCA_INT_PPM_MAX_CHECKED
                      4123     
055E    78FF          4124     MOV R0 , # 255 
0560    7900          4125     MOV R1 , # 0 
0562    A184          4126     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4127     
                      4128     PCA_INT_PPM_MAX_CHECKED: 
0564    EC            4129     MOV A , R4 
0565    8572F0        4130     	MOV	B, PPM_THROTTLE_GAIN
0568    A4            4131     	MUL	AB
0569    C5F0          4132     	XCH	A, B
056B    A2F7          4133     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
056D    33            4134     	RLC	A
056E    F8            4135     MOV R0 , A 
056F    7900          4136     MOV R1 , # 0 
0571    4003          4137     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      4138     	
0573    0205A0        4139     	JMP	PCA_INT_LIMITED			
                      4140     
                      4141     PCA_INT_PPM_LIMIT_AFTER_MULT: 
0576    78FF          4142     MOV R0 , # 255 
0578    7900          4143     MOV R1 , # 0 
057A    0205A0        4144     	JMP	PCA_INT_LIMITED			
                      4145     
                      4146     PCA_INT_PWM_DIVIDE: 
057D    E9            4147     MOV A , R1 
057E    C3            4148     	CLR	C
057F    13            4149     	RRC	A
0580    F9            4150     MOV R1 , A 
0581    E8            4151     MOV A , R0 
0582    13            4152     	RRC	A
0583    F8            4153     MOV R0 , A 
                      4154     
                      4155     PCA_INT_PWM_DIVIDE_DONE: 
0584    307C0E        4156     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
0587    E9            4157     MOV A , R1 
0588    6002          4158     	JZ	($+4)
                      4159     
058A    78FF          4160     MOV R0 , # 255 
                      4161     
058C    C3            4162     	CLR	C
058D    E8            4163     MOV A , R0 
058E    13            4164     	RRC	A
058F    38            4165     ADDC A , R0 
0590    F8            4166     MOV R0 , A 
0591    E4            4167     	CLR	A
0592    3400          4168     	ADDC	A, #0
0594    F9            4169     MOV R1 , A 
                      4170     
                      4171     PCA_INT_CHECK_LEGAL_RANGE: 
                      4172     	; Check that RC pulse is within legal range
0595    C3            4173     	CLR	C
0596    E8            4174     MOV A , R0 
0597    94FF          4175     SUBB A , # 255 
0599    E9            4176     MOV A , R1 
059A    9400          4177     	SUBB	A, #0
059C    4002          4178     	JC	PCA_INT_LIMITED
                      4179     
059E    78FF          4180     MOV R0 , # 255 
                      4181     
                      4182     PCA_INT_LIMITED: 
                      4183     	; RC pulse value accepted
05A0    885C          4184     MOV NEW_RCP , R0 
05A2    D270          4185     SETB FLAGS2 . 0 
05A4    206102        4186     JB FLAGS0 . 1 , ( $+5 ) 
                      4187     
05A7    A1B8          4188     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      4189     
05A9    741F          4190     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
05AB    F4            4191     	CPL	A
05AC    552F          4192     	ANL	A, FLAGS3					; Clear all pwm frequency flags
05AE    4B            4193     ORL A , R3 
05AF    F52F          4194     	MOV	FLAGS3, A
05B1    C274          4195     CLR FLAGS2 . 4 
05B3    EB            4196     MOV A , R3 
05B4    7002          4197     	JNZ	PCA_INT_SET_TIMEOUT
                      4198     
05B6    D274          4199     SETB FLAGS2 . 4 
                      4200     
                      4201     PCA_INT_SET_TIMEOUT: 
05B8    752A40        4202     MOV RCP_TIMEOUT_CNT , # 64 
05BB    307403        4203     JNB FLAGS2 . 4 , PCA_INT_PPM_TIMEOUT_SET 
                      4204     
05BE    752A0A        4205     MOV RCP_TIMEOUT_CNT , # 10 
                      4206     
                      4207     PCA_INT_PPM_TIMEOUT_SET: 
05C1    306102        4208     JNB FLAGS0 . 1 , ( $+5 ) 
                      4209     
05C4    A1CC          4210     	AJMP PCA_INT_EXIT				; Yes - exit
                      4211     
05C6    207403        4212     JB FLAGS2 . 4 , PCA_INT_EXIT 
                      4213     
                      4214     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
05C9    53DAFE        4214+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      4215     
                      4216     PCA_INT_EXIT: 	; Exit interrupt routine	
05CC    207403        4217     JB FLAGS2 . 4 , ( $+6 ) 
                      4218     
05CF    752B20        4219     MOV RCP_SKIP_CNT , # 32 
                      4220     
05D2    D0F0          4221     	POP	B			; Restore preserved registers
05D4    D0E0          4222     	POP	ACC			
05D6    D0D0          4223     	POP	PSW
05D8    D2AD          4224     	SETB	ET2			; Enable timer2 interrupts
05DA    43E610        4225     	ORL	EIE1, #10H	; Enable PCA0 interrupts
05DD    32            4226     	RETI
                      4227     
                      4228     
                      4229     
                      4230     
                      4231     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4232     ;
                      4233     ; Wait xms ~(x*4*250)  (Different entry points)	
                      4234     ;
                      4235     ; No assumptions
                      4236     ;
                      4237     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4238     WAIT1MS: 	
05DE    7901          4239     MOV R1 , # 1 
05E0    0205FC        4240     	JMP	WAITXMS_O
                      4241     
                      4242     WAIT3MS: 	
05E3    7903          4243     MOV R1 , # 3 
05E5    0205FC        4244     	JMP	WAITXMS_O
                      4245     
                      4246     WAIT10MS: 	
05E8    790A          4247     MOV R1 , # 10 
05EA    0205FC        4248     	JMP	WAITXMS_O
                      4249     
                      4250     WAIT30MS: 	
05ED    791E          4251     MOV R1 , # 30 
05EF    0205FC        4252     	JMP	WAITXMS_O
                      4253     
                      4254     WAIT100MS: 	
05F2    7964          4255     MOV R1 , # 100 
05F4    0205FC        4256     	JMP	WAITXMS_O
                      4257     
                      4258     WAIT200MS: 	
05F7    79C8          4259     MOV R1 , # 200 
05F9    0205FC        4260     	JMP	WAITXMS_O
                      4261     
                      4262     WAITXMS_O: 	; Outer loop
05FC    7817          4263     MOV R0 , # 23 
                      4264     WAITXMS_M: 	; Middle loop
05FE    E4            4265     	CLR	A
05FF    D5E0FD        4266      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0602    D8FA          4267     DJNZ R0 , WAITXMS_M 
0604    D9F6          4268     DJNZ R1 , WAITXMS_O 
0606    22            4269     	RET
                      4270     
                      4271     
                      4272     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4273     ;
                      4274     ; Beeper routines (4 different entry points) 
                      4275     ;
                      4276     ; No assumptions
                      4277     ;
                      4278     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4279     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
0607    7A14          4280     MOV R2 , # 20 
0609    7B78          4281     MOV R3 , # 120 
060B    020623        4282     	JMP	BEEP
                      4283     
                      4284     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
060E    7A10          4285     MOV R2 , # 16 
0610    7B8C          4286     MOV R3 , # 140 
0612    020623        4287     	JMP	BEEP
                      4288     
                      4289     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
0615    7A0D          4290     MOV R2 , # 13 
0617    7BB4          4291     MOV R3 , # 180 
0619    020623        4292     	JMP	BEEP
                      4293     
                      4294     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
061C    7A0B          4295     MOV R2 , # 11 
061E    7BC8          4296     MOV R3 , # 200 
0620    020623        4297     	JMP	BEEP
                      4298     
                      4299     BEEP: 	; Beep loop start
0623    7902          4300     MOV R1 , # 2 
                      4301     BEEP_ONOFF: 
0625    B27D          4302     CPL FLAGS3 . 5 
0627    E4            4303     	CLR	A
                      4304     	BPFET_OFF			; BpFET off
0628    C295          4304+1   CLR P1 . 5 
062A    D5E0FD        4305     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      4306     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
062D    D294          4306+1   SETB P1 . 4 
062F    D5E0FD        4307     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      4308     	BNFET_OFF			; BnFET off again
0632    C294          4308+1   CLR P1 . 4 
0634    D5E0FD        4309     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      4310     	BPFET_ON			; BpFET on
0637    D295          4310+1   SETB P1 . 5 
0639    D5E0FD        4311     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      4312     	; Turn on nfet
                      4313     	ANFET_ON			; AnFET on
063C    D293          4313+1   SETB P1 . 3 
063E    E573          4314     	MOV	A, BEEP_STRENGTH
0640    D5E0FD        4315     	DJNZ	ACC, $		
                      4316     	; Turn off nfet
                      4317     	ANFET_OFF			; AnFET off
0643    C293          4317+1   CLR P1 . 3 
0645    7496          4318     	MOV	A, #150		; 25s off
0647    D5E0FD        4319     	DJNZ	ACC, $		
064A    D9D9          4320     DJNZ R1 , BEEP_ONOFF 
                      4321     	; Copy variable
064C    EA            4322     MOV A , R2 
064D    F8            4323     MOV R0 , A 
                      4324     BEEP_OFF: 		; Fets off loop
064E    D5E0FD        4325     	DJNZ	ACC, $
0651    D8FB          4326     DJNZ R0 , BEEP_OFF 
0653    DBCE          4327     DJNZ R3 , BEEP 
                      4328     	BPFET_OFF			; BpFET off
0655    C295          4328+1   CLR P1 . 5 
0657    22            4329     	RET
                      4330     
                      4331     
                      4332     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4333     ;
                      4334     ; Division 16bit unsigned by 16bit unsigned
                      4335     ;
                      4336     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      4337     ; Result will be in Temp2/Temp1
                      4338     ;
                      4339     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4340     DIV_U16_BY_U16: 	
0658    C3            4341     	CLR	C       
0659    7C00          4342     MOV R4 , # 0 
065B    7D00          4343     MOV R5 , # 0 
065D    75F000        4344     	MOV	B, #0
                      4345     DIV_U16_BY_U16_DIV1: 
0660    05F0          4346     	INC	B      			; Increment counter for each left shift
0662    EA            4347     MOV A , R2 
0663    33            4348     	RLC	A      		
0664    FA            4349     MOV R2 , A 
0665    EB            4350     MOV A , R3 
0666    33            4351     	RLC	A      	  	
0667    FB            4352     MOV R3 , A 
0668    50F6          4353     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      4354     DIV_U16_BY_U16_DIV2:         
066A    EB            4355     MOV A , R3 
066B    13            4356     	RRC	A      
066C    FB            4357     MOV R3 , A 
066D    EA            4358     MOV A , R2 
066E    13            4359     	RRC	A      
066F    FA            4360     MOV R2 , A 
0670    C3            4361     	CLR	C      
0671    E9            4362     MOV A , R1 
0672    FF            4363     MOV R7 , A 
0673    E8            4364     MOV A , R0 
0674    FE            4365     MOV R6 , A 
0675    E8            4366     MOV A , R0 
0676    9A            4367     SUBB A , R2 
0677    F8            4368     MOV R0 , A 
0678    E9            4369     MOV A , R1 
0679    9B            4370     SUBB A , R3 
067A    F9            4371     MOV R1 , A 
067B    5004          4372     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
067D    EF            4373     MOV A , R7 
067E    F9            4374     MOV R1 , A 
067F    EE            4375     MOV A , R6 
0680    F8            4376     MOV R0 , A 
                      4377     DIV_U16_BY_U16_DIV3: 
0681    B3            4378     	CPL	C      			; Invert carry, so it can be directly copied into result
0682    EC            4379     MOV A , R4 
0683    33            4380     	RLC	A      			; Shift carry flag into temporary result
0684    FC            4381     MOV R4 , A 
0685    ED            4382     MOV A , R5 
0686    33            4383     	RLC	A
0687    FD            4384     MOV R5 , A 
0688    D5F0DF        4385     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
068B    ED            4386     MOV A , R5 
068C    F9            4387     MOV R1 , A 
068D    EC            4388     MOV A , R4 
068E    F8            4389     MOV R0 , A 
068F    22            4390     	RET
                      4391     
                      4392     
                      4393     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4394     ;
                      4395     ; Multiplication 16bit signed by 8bit unsigned
                      4396     ;
                      4397     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      4398     ; Result will be in Temp2/Temp1. Result will divided by 16
                      4399     ;
                      4400     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4401     MULT_S16_BY_U8_DIV_16: 
0690    E8            4402     MOV A , R0 
0691    89F0          4403     MOV B , R1 
0693    8A20          4404     MOV BIT_ACCESS , R2 
0695    D2D4          4405     	SETB	PSW.4		; Select register bank 2 for math routines
0697    F8            4406     MOV R0 , A 
0698    A9F0          4407     MOV R1 , B 
069A    7B00          4408     MOV R3 , # 0 
069C    30F70B        4409     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      4410     
069F    7BFF          4411     MOV R3 , # 0FFH 
06A1    F4            4412     	CPL	A
06A2    2401          4413     	ADD	A, #1
06A4    F8            4414     MOV R0 , A 
06A5    E9            4415     MOV A , R1 
06A6    F4            4416     	CPL	A
06A7    3400          4417     	ADDC	A, #0
06A9    F9            4418     MOV R1 , A 
                      4419     MULT_S16_BY_U8_POSITIVE: 
06AA    E8            4420     MOV A , R0 
06AB    8520F0        4421     	MOV	B, BIT_ACCESS
06AE    A4            4422     	MUL	AB
06AF    ADF0          4423     MOV R5 , B 
06B1    F8            4424     MOV R0 , A 
06B2    E9            4425     MOV A , R1 
06B3    8520F0        4426     	MOV	B, BIT_ACCESS
06B6    A4            4427     	MUL	AB
06B7    AFF0          4428     MOV R7 , B 
06B9    FE            4429     MOV R6 , A 
06BA    ED            4430     MOV A , R5 
06BB    2E            4431     ADD A , R6 
06BC    F9            4432     MOV R1 , A 
06BD    7400          4433     	MOV	A, #0
06BF    3F            4434     ADDC A , R7 
06C0    FA            4435     MOV R2 , A 
06C1    7C04          4436     MOV R4 , # 4 
                      4437     MULT_S16_BY_U8_DIV_LOOP: 
06C3    C3            4438     	CLR	C			; Rotate right 
06C4    EA            4439     MOV A , R2 
06C5    13            4440     	RRC	A
06C6    FA            4441     MOV R2 , A 
06C7    E9            4442     MOV A , R1 
06C8    13            4443     	RRC	A
06C9    F9            4444     MOV R1 , A 
06CA    E8            4445     MOV A , R0 
06CB    13            4446     	RRC	A
06CC    F8            4447     MOV R0 , A 
06CD    DCF4          4448     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      4449     
06CF    8BF0          4450     MOV B , R3 
06D1    30F70A        4451     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      4452     
06D4    E8            4453     MOV A , R0 
06D5    F4            4454     	CPL	A
06D6    2401          4455     	ADD	A, #1
06D8    F8            4456     MOV R0 , A 
06D9    E9            4457     MOV A , R1 
06DA    F4            4458     	CPL	A
06DB    3400          4459     	ADDC	A, #0
06DD    F9            4460     MOV R1 , A 
                      4461     
                      4462     MULT_S16_BY_U8_EXIT: 
06DE    E8            4463     MOV A , R0 
06DF    89F0          4464     MOV B , R1 
06E1    C2D4          4465     	CLR	PSW.4		; Select normal register bank
06E3    F8            4466     MOV R0 , A 
06E4    A9F0          4467     MOV R1 , B 
06E6    22            4468     	RET
                      4469     
                      4470     
                      4471     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4472     ;
                      4473     ; Calculate governor routines
                      4474     ;
                      4475     ; No assumptions
                      4476     ;
                      4477     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      4478     ; The governor task is split into several routines in order to distribute processing time
                      4479     ;
                      4480     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4481     ; First governor routine - calculate governor target
                      4482     IF MODE == 0	; Main
                      4483     CALC_GOVERNOR_TARGET: 
06E7    7882          4484     MOV R0 , # PGM_GOV_MODE 
06E9    B60403        4485     CJNE @ R0 , # 4 , GOVERNOR_SPEED_CHECK 
06EC    020786        4486     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      4487     
                      4488     GOVERNOR_SPEED_CHECK: 
                      4489     	; Stop governor for stop RC pulse	
06EF    C3            4490     	CLR	C
06F0    E55C          4491     	MOV	A, NEW_RCP				; Check RC pulse against stop value
06F2    9419          4492     	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
06F4    401E          4493     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      4494     
06F6    E52D          4495     	MOV	A, FLAGS1
06F8    5406          4496     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
06FA    7018          4497     	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                      4498     
                      4499     	; Skip speed check if governor is already active
06FC    206D36        4500     JB FLAGS1 . 5 , GOVERNOR_TARGET_CALC 
                      4501     
                      4502     	; Check speed (do not run governor for low speeds)
06FF    7805          4503     MOV R0 , # 05H 
0701    7994          4504     MOV R1 , # PGM_GOV_RANGE 
0703    E7            4505     MOV A , @ R1 
0704    14            4506     	DEC	A
0705    6007          4507     	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                      4508     
0707    780A          4509     MOV R0 , # 0AH 
0709    14            4510     	DEC	A
070A    6002          4511     	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                      4512     	
070C    7812          4513     MOV R0 , # 12H 
                      4514     
                      4515     GOVERNOR_ACT_LIM_SET: 
070E    C3            4516     	CLR	C
070F    E53E          4517     	MOV	A, COMM_PERIOD4X_H
0711    98            4518     SUBB A , R0 
0712    401F          4519     	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                      4520     
                      4521     GOVERNOR_DEACTIVATE: 
0714    306D09        4522     JNB FLAGS1 . 5 , GOVERNOR_FIRST_DEACTIVATE_DONE 
                      4523      
0717    856462        4524     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
071A    7569FF        4525     	MOV	SPOOLUP_LIMIT_CNT, #255
071D    756A01        4526     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      4527     
                      4528     GOVERNOR_FIRST_DEACTIVATE_DONE: 
0720    852224        4529     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0723    E4            4530     	CLR	A
0724    F542          4531     	MOV	GOV_TARGET_L, A			; Set target to zero
0726    F543          4532     	MOV	GOV_TARGET_H, A
0728    F544          4533     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
072A    F545          4534     	MOV	GOV_INTEGRAL_H, A
072C    F546          4535     	MOV	GOV_INTEGRAL_X, A
072E    C26D          4536     CLR FLAGS1 . 5 
0730    020786        4537     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      4538     
                      4539     GOVERNOR_ACTIVATE: 
0733    D26D          4540     SETB FLAGS1 . 5 
                      4541     
                      4542     GOVERNOR_TARGET_CALC: 
                      4543     	; Governor calculations
0735    7994          4544     MOV R1 , # PGM_GOV_RANGE 
0737    E7            4545     MOV A , @ R1 
0738    14            4546     	DEC	A
0739    7013          4547     	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                      4548     
073B    E523          4549     	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
073D    F4            4550     	CPL	A					; Calculate 255-pwm (invert pwm) 
                      4551     	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
073E    33            4552     	RLC	A					; Msb to carry
073F    33            4553     	RLC	A					; To bit0
0740    F9            4554     MOV R1 , A 
0741    13            4555     	RRC	A					
0742    F8            4556     MOV R0 , A 
0743    E9            4557     MOV A , R1 
0744    5401          4558     	ANL	A, #01H				; Calculate H byte
0746    04            4559     	INC	A					; Add 1
0747    F9            4560     MOV R1 , A 
0748    E8            4561     MOV A , R0 
0749    54FE          4562     	ANL	A, #0FEH				; Calculate L byte
074B    02077A        4563     	JMP	CALC_GOVERNOR_SUBTRACT_025
                      4564     
                      4565     CALC_GOVERNOR_TARGET_MIDDLE: 
074E    E7            4566     MOV A , @ R1 
074F    14            4567     	DEC	A
0750    14            4568     	DEC	A
0751    7014          4569     	JNZ	CALC_GOVERNOR_TARGET_LOW
                      4570     
0753    E523          4571     	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
0755    F4            4572     	CPL	A					; Calculate 255-pwm (invert pwm) 
                      4573     	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
0756    33            4574     	RLC	A					; Msb to carry
0757    33            4575     	RLC	A					; To bit0
0758    33            4576     	RLC	A					; To bit1
0759    F9            4577     MOV R1 , A 
075A    13            4578     	RRC	A					
075B    F8            4579     MOV R0 , A 
075C    E9            4580     MOV A , R1 
075D    5403          4581     	ANL	A, #03H				; Calculate H byte
075F    04            4582     	INC	A					; Add 1
0760    F9            4583     MOV R1 , A 
0761    E8            4584     MOV A , R0 
0762    54FC          4585     	ANL	A, #0FCH				; Calculate L byte
0764    020782        4586     	JMP	CALC_GOVERNOR_STORE_TARGET
                      4587     
                      4588     CALC_GOVERNOR_TARGET_LOW: 
0767    E523          4589     	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
0769    F4            4590     	CPL	A					; Calculate 255-pwm (invert pwm) 
                      4591     	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
076A    33            4592     	RLC	A					; Msb to carry
076B    33            4593     	RLC	A					; To bit0
076C    33            4594     	RLC	A					; To bit1
076D    33            4595     	RLC	A					; To bit2
076E    F9            4596     MOV R1 , A 
076F    13            4597     	RRC	A					
0770    F8            4598     MOV R0 , A 
0771    E9            4599     MOV A , R1 
0772    5407          4600     	ANL	A, #07H				; Calculate H byte
0774    04            4601     	INC	A					; Add 1
0775    04            4602     	INC	A					; Add 1 more
0776    F9            4603     MOV R1 , A 
0777    E8            4604     MOV A , R0 
0778    54F8          4605     	ANL	A, #0F8H				; Calculate L byte
                      4606     CALC_GOVERNOR_SUBTRACT_025: 
077A    C3            4607     	CLR	C
077B    9440          4608     	SUBB	A, #40H				; Subtract 0.25
077D    F8            4609     MOV R0 , A 
077E    E9            4610     MOV A , R1 
077F    9400          4611     	SUBB	A, #0
0781    F9            4612     MOV R1 , A 
                      4613     CALC_GOVERNOR_STORE_TARGET: 
                      4614     	; Store governor target
0782    8842          4615     MOV GOV_TARGET_L , R0 
0784    8943          4616     MOV GOV_TARGET_H , R1 
                      4617     CALC_GOVERNOR_TARGET_EXIT: 
0786    22            4618     	RET						
                      4619     ENDIF
                      4620     IF MODE == 1	; Tail
                               CALC_GOVERNOR_TARGET:
                               	RET						
                               ENDIF
                      4624     IF MODE == 2	; Multi
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Closed loop mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_TARGET_CALC	; Yes - branch
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_TARGET_CALC:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #RCP_STOP				; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	JMP	GOVERNOR_ACTIVATE			; No - activate
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	CLR	FLAGS1.GOV_ACTIVE
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	TEMP1, #PGM_GOV_MODE		; Store gov mode
                               	MOV	A, @TEMP1
                               	MOV	TEMP5, A
                               	SETB	FLAGS1.GOV_ACTIVE
                               	MOV	A, REQUESTED_PWM			; Load requested pwm
                               	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                               	; Calculate comm period target 2*(51000/Requested_Pwm)
                               	MOV	TEMP1, #38H				; Load 51000
                               	MOV	TEMP2, #0C7H
                               	MOV	TEMP3, COMM_PERIOD4X_L		; Load comm period
                               	MOV	TEMP4, COMM_PERIOD4X_H		
                               	; Set speed range 
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 200k eRPM range here
                               	; Check range
                               	MOV	A, TEMP5
                               	DEC	A
                               	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                               GOVERNOR_ACTIVATE_100K:
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 100k eRPM range here
                               	MOV	A, TEMP5					; Check range again
                               	DEC	A
                               	DEC	A
                               	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                               GOVERNOR_ACTIVATE_50K:
                               	CLR	C
                               	MOV	A, TEMP4
                               	RRC	A
                               	MOV	TEMP4, A
                               	MOV	A, TEMP3
                               	RRC	A
                               	MOV	TEMP3, A  				; 50k eRPM range here
                               GOVERNOR_ACTIVATE_RANGE_SET:
                               	CALL	DIV_U16_BY_U16
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      4702     
                      4703     
                      4704     ; Second governor routine - calculate governor proportional error
                      4705     CALC_GOVERNOR_PROP_ERROR: 
                      4706     IF MODE <= 1	; Main or tail
                      4707     	; Load comm period and divide by 2
0787    C3            4708     	CLR	C
0788    E53E          4709     	MOV	A, COMM_PERIOD4X_H
078A    13            4710     	RRC	A
078B    F9            4711     MOV R1 , A 
078C    E53D          4712     	MOV	A, COMM_PERIOD4X_L
078E    13            4713     	RRC	A
078F    F8            4714     MOV R0 , A 
                      4715     	; Calculate error
0790    C3            4716     	CLR	C
0791    E542          4717     	MOV	A, GOV_TARGET_L
0793    98            4718     SUBB A , R0 
0794    F8            4719     MOV R0 , A 
0795    E543          4720     	MOV	A, GOV_TARGET_H
0797    99            4721     SUBB A , R1 
0798    F9            4722     MOV R1 , A 
                      4723     ENDIF
                      4724     IF MODE == 2	; Multi
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, GOVERNOR_REQ_PWM
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               ENDIF
                      4734     	; Check error and limit
0799    500C          4735     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      4736     
079B    C3            4737     	CLR	C
079C    E8            4738     MOV A , R0 
079D    9480          4739     	SUBB	A, #80H					; Is error too negative?
079F    E9            4740     MOV A , R1 
07A0    94FF          4741     	SUBB	A, #0FFH
07A2    4016          4742     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
07A4    0207BE        4743     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4744     
                      4745     GOVERNOR_CHECK_PROP_LIMIT_POS: 
07A7    C3            4746     	CLR	C
07A8    E8            4747     MOV A , R0 
07A9    947F          4748     	SUBB	A, #7FH					; Is error too positive?
07AB    E9            4749     MOV A , R1 
07AC    9400          4750     	SUBB	A, #00H
07AE    5003          4751     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
07B0    0207BE        4752     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4753     
                      4754     GOVERNOR_LIMIT_PROP_ERROR_POS: 
07B3    787F          4755     MOV R0 , # 7FH 
07B5    7900          4756     MOV R1 , # 00H 
07B7    0207BE        4757     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4758     
                      4759     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
07BA    7880          4760     MOV R0 , # 80H 
07BC    79FF          4761     MOV R1 , # 0FFH 
                      4762     
                      4763     GOVERNOR_STORE_PROP_ERROR: 
                      4764     	; Store proportional
07BE    8847          4765     MOV GOV_PROPORTIONAL_L , R0 
07C0    8948          4766     MOV GOV_PROPORTIONAL_H , R1 
                      4767     CALC_GOVERNOR_PROP_ERROR_EXIT: 
07C2    22            4768     	RET						
                      4769     
                      4770     
                      4771     ; Third governor routine - calculate governor integral error
                      4772     CALC_GOVERNOR_INT_ERROR: 
                      4773     	; Add proportional to integral
07C3    E547          4774     	MOV	A, GOV_PROPORTIONAL_L
07C5    2544          4775     	ADD	A, GOV_INTEGRAL_L
07C7    F8            4776     MOV R0 , A 
07C8    E548          4777     	MOV	A, GOV_PROPORTIONAL_H
07CA    3545          4778     	ADDC	A, GOV_INTEGRAL_H
07CC    F9            4779     MOV R1 , A 
07CD    854820        4780     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
07D0    E4            4781     	CLR	A
07D1    300701        4782     	JNB	BIT_ACCESS.7, ($+4)			
07D4    F4            4783     	CPL	A
07D5    3546          4784     	ADDC	A, GOV_INTEGRAL_X
07D7    FA            4785     MOV R2 , A 
                      4786     	; Check integral and limit
07D8    30E709        4787     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      4788     
07DB    C3            4789     	CLR	C
07DC    EA            4790     MOV A , R2 
07DD    94F0          4791     	SUBB	A, #0F0H					; Is error too negative?
07DF    4015          4792     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
07E1    0207FC        4793     	JMP	GOVERNOR_CHECK_PWM
                      4794     
                      4795     GOVERNOR_CHECK_INT_LIMIT_POS: 
07E4    C3            4796     	CLR	C
07E5    EA            4797     MOV A , R2 
07E6    940F          4798     	SUBB	A, #0FH					; Is error too positive?
07E8    5003          4799     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
07EA    0207FC        4800     	JMP	GOVERNOR_CHECK_PWM
                      4801     
                      4802     GOVERNOR_LIMIT_INT_ERROR_POS: 
07ED    78FF          4803     MOV R0 , # 0FFH 
07EF    79FF          4804     MOV R1 , # 0FFH 
07F1    7A0F          4805     MOV R2 , # 0FH 
07F3    0207FC        4806     	JMP	GOVERNOR_CHECK_PWM
                      4807     
                      4808     GOVERNOR_LIMIT_INT_ERROR_NEG: 
07F6    7800          4809     MOV R0 , # 00H 
07F8    7900          4810     MOV R1 , # 00H 
07FA    7AF0          4811     MOV R2 , # 0F0H 
                      4812     
                      4813     GOVERNOR_CHECK_PWM: 
                      4814     	; Check current pwm
07FC    C3            4815     	CLR	C
07FD    E524          4816     	MOV	A, CURRENT_PWM
07FF    9561          4817     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
0801    500A          4818     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      4819     
0803    C3            4820     	CLR	C
0804    7401          4821     	MOV	A, #1
0806    9524          4822     	SUBB	A, CURRENT_PWM				; Is current pwm at minimum?
0808    500B          4823     	JNC	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      4824     
080A    02081A        4825     	JMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      4826     
                      4827     GOVERNOR_INT_MAX_PWM: 
080D    E548          4828     	MOV	A, GOV_PROPORTIONAL_H
080F    20E70E        4829     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      4830     
0812    02081A        4831     	JMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      4832     
                      4833     GOVERNOR_INT_MIN_PWM: 
0815    E548          4834     	MOV	A, GOV_PROPORTIONAL_H
0817    30E706        4835     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      4836     
                      4837     GOVERNOR_STORE_INT_ERROR: 
                      4838     	; Store integral
081A    8844          4839     MOV GOV_INTEGRAL_L , R0 
081C    8945          4840     MOV GOV_INTEGRAL_H , R1 
081E    8A46          4841     MOV GOV_INTEGRAL_X , R2 
                      4842     CALC_GOVERNOR_INT_ERROR_EXIT: 
0820    22            4843     	RET						
                      4844     
                      4845     
                      4846     ; Fourth governor routine - calculate governor proportional correction
                      4847     CALC_GOVERNOR_PROP_CORRECTION: 
                      4848     	; Load proportional gain
0821    78A4          4849     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0823    E6            4850     MOV A , @ R0 
0824    FA            4851     MOV R2 , A 
                      4852     	; Load proportional
0825    C3            4853     	CLR	C
0826    E547          4854     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0828    33            4855     	RLC	A
0829    F8            4856     MOV R0 , A 
082A    E548          4857     	MOV	A, GOV_PROPORTIONAL_H
082C    33            4858     	RLC	A
082D    F9            4859     MOV R1 , A 
                      4860     	; Apply gain
082E    120690        4861     	CALL	MULT_S16_BY_U8_DIV_16
                      4862     	; Check error and limit (to low byte)
0831    E9            4863     MOV A , R1 
0832    30E70B        4864     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      4865     
0835    C3            4866     	CLR	C
0836    E8            4867     MOV A , R0 
0837    9480          4868     	SUBB	A, #80H					; Is error too negative?
0839    E9            4869     MOV A , R1 
083A    94FF          4870     	SUBB	A, #0FFH
083C    4013          4871     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
083E    0155          4872     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4873     
                      4874     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0840    C3            4875     	CLR	C
0841    E8            4876     MOV A , R0 
0842    947F          4877     	SUBB	A, #7FH					; Is error too positive?
0844    E9            4878     MOV A , R1 
0845    9400          4879     	SUBB	A, #00H
0847    5002          4880     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0849    0155          4881     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4882     
                      4883     GOVERNOR_LIMIT_PROP_CORR_POS: 
084B    787F          4884     MOV R0 , # 7FH 
084D    7900          4885     MOV R1 , # 00H 
084F    0155          4886     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4887     
                      4888     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0851    7880          4889     MOV R0 , # 80H 
0853    79FF          4890     MOV R1 , # 0FFH 
                      4891     
                      4892     GOVERNOR_APPLY_PROP_CORR: 
                      4893     	; Test proportional sign
0855    E8            4894     MOV A , R0 
0856    20E715        4895     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      4896     
                      4897     	; Subtract positive proportional
0859    C3            4898     	CLR	C
085A    E523          4899     	MOV	A, GOVERNOR_REQ_PWM
085C    98            4900     SUBB A , R0 
085D    F8            4901     MOV R0 , A 
                      4902     	; Check result
085E    4009          4903     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      4904     
0860    C3            4905     	CLR	C
0861    E8            4906     MOV A , R0 
0862    9401          4907     	SUBB	A, #1
0864    4003          4908     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0866    02087C        4909     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4910     
                      4911     GOVERNOR_CORR_PROP_MIN_PWM: 
0869    7801          4912     MOV R0 , # 1 
086B    02087C        4913     	JMP	GOVERNOR_STORE_PROP_CORR
                      4914     
                      4915     GOVERNOR_CORR_NEG_PROP: 
                      4916     	; Add negative proportional
086E    E8            4917     MOV A , R0 
086F    F4            4918     	CPL	A
0870    2401          4919     	ADD	A, #1
0872    2523          4920     	ADD	A, GOVERNOR_REQ_PWM
0874    F8            4921     MOV R0 , A 
                      4922     	; Check result
0875    4003          4923     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0877    02087C        4924     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4925     
                      4926     GOVERNOR_CORR_PROP_MAX_PWM: 
087A    78FF          4927     MOV R0 , # 255 
                      4928     GOVERNOR_STORE_PROP_CORR: 
                      4929     	; Store proportional pwm
087C    8849          4930     MOV GOV_PROP_PWM , R0 
                      4931     CALC_GOVERNOR_PROP_CORR_EXIT: 
087E    22            4932     	RET
                      4933     
                      4934     
                      4935     ; Fifth governor routine - calculate governor integral correction
                      4936     CALC_GOVERNOR_INT_CORRECTION: 
                      4937     	; Load integral gain
087F    78A5          4938     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0881    E6            4939     MOV A , @ R0 
0882    FA            4940     MOV R2 , A 
                      4941     	; Load integral
0883    A845          4942     MOV R0 , GOV_INTEGRAL_H 
0885    A946          4943     MOV R1 , GOV_INTEGRAL_X 
                      4944     	; Apply gain
0887    120690        4945     	CALL	MULT_S16_BY_U8_DIV_16
                      4946     	; Check integral and limit
088A    E9            4947     MOV A , R1 
088B    30E70C        4948     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      4949     
088E    C3            4950     	CLR	C
088F    E8            4951     MOV A , R0 
0890    9401          4952     	SUBB	A, #01H					; Is integral too negative?
0892    E9            4953     MOV A , R1 
0893    94FF          4954     	SUBB	A, #0FFH
0895    4016          4955     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0897    0208B1        4956     	JMP	GOVERNOR_APPLY_INT_CORR
                      4957     
                      4958     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
089A    C3            4959     	CLR	C
089B    E8            4960     MOV A , R0 
089C    94FF          4961     	SUBB	A, #0FFH					; Is integral too positive?
089E    E9            4962     MOV A , R1 
089F    9400          4963     	SUBB	A, #00H
08A1    5003          4964     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
08A3    0208B1        4965     	JMP	GOVERNOR_APPLY_INT_CORR
                      4966     
                      4967     GOVERNOR_LIMIT_INT_CORR_POS: 
08A6    78FF          4968     MOV R0 , # 0FFH 
08A8    7900          4969     MOV R1 , # 00H 
08AA    0208B1        4970     	JMP	GOVERNOR_APPLY_INT_CORR
                      4971     
                      4972     GOVERNOR_LIMIT_INT_CORR_NEG: 
08AD    7801          4973     MOV R0 , # 01H 
08AF    79FF          4974     MOV R1 , # 0FFH 
                      4975     
                      4976     GOVERNOR_APPLY_INT_CORR: 
                      4977     	; Test integral sign
08B1    E9            4978     MOV A , R1 
08B2    20E715        4979     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      4980     
                      4981     	; Subtract positive integral
08B5    C3            4982     	CLR	C
08B6    E549          4983     	MOV	A, GOV_PROP_PWM
08B8    98            4984     SUBB A , R0 
08B9    F8            4985     MOV R0 , A 
                      4986     	; Check result
08BA    4009          4987     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      4988     
08BC    C3            4989     	CLR	C
08BD    E8            4990     MOV A , R0 
08BE    9401          4991     	SUBB	A, #1
08C0    4003          4992     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
08C2    0208D8        4993     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4994     
                      4995     GOVERNOR_CORR_INT_MIN_PWM: 
08C5    7801          4996     MOV R0 , # 1 
08C7    0208D8        4997     	JMP	GOVERNOR_STORE_INT_CORR
                      4998     
                      4999     GOVERNOR_CORR_NEG_INT: 
                      5000     	; Add negative integral
08CA    E8            5001     MOV A , R0 
08CB    F4            5002     	CPL	A
08CC    2401          5003     	ADD	A, #1
08CE    2549          5004     	ADD	A, GOV_PROP_PWM
08D0    F8            5005     MOV R0 , A 
                      5006     	; Check result
08D1    4003          5007     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
08D3    0208D8        5008     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      5009     
                      5010     GOVERNOR_CORR_INT_MAX_PWM: 
08D6    78FF          5011     MOV R0 , # 255 
                      5012     GOVERNOR_STORE_INT_CORR: 
                      5013     	; Store current pwm
08D8    8824          5014     MOV CURRENT_PWM , R0 
                      5015     CALC_GOVERNOR_INT_CORR_EXIT: 
08DA    22            5016     	RET
                      5017     
                      5018     
                      5019     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5020     ;
                      5021     ; Set pwm limit low rpm
                      5022     ;
                      5023     ; No assumptions
                      5024     ;
                      5025     ; Sets power limit for low rpms and disables demag for low rpms
                      5026     ;
                      5027     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5028     SET_PWM_LIMIT_LOW_RPM: 
                      5029     	; Set pwm limit and demag disable for low rpms
08DB    78FF          5030     MOV R0 , # 0FFH 
08DD    C264          5031     CLR FLAGS0 . 4 
08DF    20693D        5032     JB FLAGS1 . 1 , SET_PWM_LIMIT_LOW_RPM_EXIT 
08E2    206A12        5033     JB FLAGS1 . 2 , SET_PWM_DEMAG_DONE 
                      5034     
08E5    D264          5035     SETB FLAGS0 . 4 
08E7    C3            5036     	CLR	C
08E8    E53E          5037     	MOV	A, COMM_PERIOD4X_H
08EA    940A          5038     	SUBB	A, #0AH						; ~31250 eRPM
08EC    4009          5039     	JC	SET_PWM_DEMAG_DONE				; If speed above - branch
                      5040     
08EE    C3            5041     	CLR	C
08EF    E525          5042     	MOV	A, CURRENT_PWM_LIMITED	
08F1    9440          5043     	SUBB	A, #40H						; Do not disable if pwm above 25%
08F3    5002          5044     	JNC	SET_PWM_DEMAG_DONE
                      5045     
08F5    C264          5046     CLR FLAGS0 . 4 
                      5047     
                      5048     SET_PWM_DEMAG_DONE: 
08F7    79A1          5049     MOV R1 , # PGM_ENABLE_POWER_PROT 
08F9    E7            5050     MOV A , @ R1 
08FA    6023          5051     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Exit if disabled
                      5052     
08FC    E53E          5053     	MOV	A, COMM_PERIOD4X_H
08FE    601F          5054     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Avoid divide by zero
                      5055     
0900    74FF          5056     	MOV	A, #255						; Divide 255 by Comm_Period4x_H
0902    853EF0        5057     	MOV	B, COMM_PERIOD4X_H
0905    84            5058     	DIV	AB
0906    8538F0        5059     	MOV	B, LOW_RPM_PWR_SLOPE			; Multiply by slope
0909    306A03        5060     JNB FLAGS1 . 2 , ( $+6 ) 
090C    75F005        5061     	MOV	B, #5
090F    A4            5062     	MUL	AB
0910    F8            5063     MOV R0 , A 
0911    C5F0          5064     	XCH	A, B
0913    6002          5065     	JZ	($+4)						; Limit to max
                      5066     	
0915    78FF          5067     MOV R0 , # 0FFH 
                      5068     
0917    C3            5069     	CLR	C
0918    E8            5070     MOV A , R0 
0919    9564          5071     	SUBB	A, PWM_SPOOLUP_BEG
091B    5002          5072     	JNC	SET_PWM_LIMIT_LOW_RPM_EXIT
                      5073     
091D    A864          5074     MOV R0 , PWM_SPOOLUP_BEG 
                      5075     
                      5076     SET_PWM_LIMIT_LOW_RPM_EXIT: 
091F    8863          5077     MOV PWM_LIMIT_BY_RPM , R0 
0921    22            5078     	RET
                      5079     	
                      5080     
                      5081     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5082     ;
                      5083     ; Set pwm limit high rpm
                      5084     ;
                      5085     ; No assumptions
                      5086     ;
                      5087     ; Sets power limit for high rpms
                      5088     ;
                      5089     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5090     SET_PWM_LIMIT_HIGH_RPM: 
                      5091     IF MCU_48MHZ == 1
0922    C3            5092     	CLR	C
0923    E53D          5093     	MOV	A, COMM_PERIOD4X_L
0925    94C8          5094     	SUBB	A, #0C8H				; Limit Comm_Period to 200, which is 400k erpm
0927    E53E          5095     	MOV	A, COMM_PERIOD4X_H
0929    9400          5096     	SUBB	A, #00H
                      5097     ELSE
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_L
                               	SUBB	A, #40H				; Limit Comm_Period to 320, which is 250k erpm
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, #01H
                               ENDIF
092B    E563          5104     	MOV	A, PWM_LIMIT_BY_RPM
092D    5003          5105     	JNC	SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT
                      5106     	
092F    14            5107     	DEC	A
0930    2133          5108     	AJMP	SET_PWM_LIMIT_HIGH_RPM_STORE
                      5109     	
                      5110     SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT: 
0932    04            5111     	INC	A
                      5112     SET_PWM_LIMIT_HIGH_RPM_STORE: 
0933    6002          5113     	JZ	($+4)
                      5114     
0935    F563          5115     	MOV	PWM_LIMIT_BY_RPM, A
                      5116     
0937    22            5117     	RET
                      5118     
                      5119     
                      5120     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5121     ;
                      5122     ; Measure lipo cells
                      5123     ;
                      5124     ; No assumptions
                      5125     ;
                      5126     ; Measure voltage and calculate lipo cells
                      5127     ;
                      5128     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5129     MEASURE_LIPO_CELLS: 
                      5130     IF MODE >= 1	; Tail or multi
                               	; If not supported, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      5134     IF MODE == 0	; Main
                      5135     	; Load programmed low voltage limit
0938    7883          5136     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
093A    E6            5137     MOV A , @ R0 
093B    F520          5138     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      5139     	; Set commutation to BpFET on
093D    120FCA        5140     	CALL	COMM5COMM6			
                      5141     	; Start adc
                      5142     	START_ADC 
0940    75E890        5142+1   MOV ADC0CN , # 90H  ; ADC START
                      5143     	; Wait for ADC reference to settle, and then start again
0943    1205DE        5144     	CALL	WAIT1MS
                      5145     	START_ADC
0946    75E890        5145+1   MOV ADC0CN , # 90H  ; ADC START
                      5146     	; Wait for ADC conversion to complete
                      5147     MEASURE_LIPO_WAIT_ADC: 
                      5148     	GET_ADC_STATUS 
0949    E5E8          5148+1   MOV A , ADC0CN 
094B    20ECFB        5149     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      5150     	; Read ADC result
                      5151     	READ_ADC_RESULT
094E    A8BD          5151+1   MOV R0 , ADC0L 
0950    A9BE          5151+1   MOV R1 , ADC0H 
                      5152     	; Stop ADC
                      5153     	STOP_ADC
                      5154     	; Switch power off
0952    121064        5155     	CALL	SWITCH_POWER_OFF		
                      5156     	; Set limit step
0955    756E00        5157     MOV LIPO_ADC_LIMIT_L , # 0 
0958    756F00        5158     MOV LIPO_ADC_LIMIT_H , # 0 
095B    C3            5159     	CLR	C
095C    7400          5160     MOV A , # 0 
095E    13            5161     	RRC	A
095F    FD            5162     MOV R5 , A 
0960    7400          5163     MOV A , # 0 
0962    6066          5164     	JZ	MEASURE_LIPO_EXIT		; Exit if disabled
                      5165     
0964    13            5166     	RRC	A
0965    FC            5167     MOV R4 , A 
0966    7400          5168     MOV A , # 0 
0968    2C            5169     ADD A , R4 
0969    FC            5170     MOV R4 , A 
096A    7400          5171     MOV A , # 0 
096C    3D            5172     ADDC A , R5 
096D    FD            5173     MOV R5 , A 
096E    EC            5174     MOV A , R4 
096F    FA            5175     MOV R2 , A 
0970    ED            5176     MOV A , R5 
0971    FB            5177     MOV R3 , A 
                      5178     MEASURE_LIPO_CELL_LOOP: 
                      5179     	; Check voltage against xS lower limit
0972    C3            5180     	CLR	C
0973    E8            5181     MOV A , R0 
0974    9A            5182     SUBB A , R2 
0975    E9            5183     MOV A , R1 
0976    9B            5184     SUBB A , R3 
0977    4014          5185     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      5186     
                      5187     	; Set xS voltage limit
0979    E56E          5188     	MOV	A, LIPO_ADC_LIMIT_L		
097B    2400          5189     ADD A , # 0 
097D    F56E          5190     	MOV	LIPO_ADC_LIMIT_L, A
097F    E56F          5191     	MOV	A, LIPO_ADC_LIMIT_H		
0981    3400          5192     ADDC A , # 0 
0983    F56F          5193     	MOV	LIPO_ADC_LIMIT_H, A
                      5194     	; Set (x+1)S lower limit
0985    EA            5195     MOV A , R2 
0986    2C            5196     ADD A , R4 
0987    FA            5197     MOV R2 , A 
0988    EB            5198     MOV A , R3 
0989    3D            5199     ADDC A , R5 
098A    FB            5200     MOV R3 , A 
098B    80E5          5201     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      5202     
                      5203     MEASURE_LIPO_ADJUST: 
098D    AE6E          5204     MOV R6 , LIPO_ADC_LIMIT_L 
098F    AF6F          5205     MOV R7 , LIPO_ADC_LIMIT_H 
                      5206     	; Calculate 3.125%
0991    C3            5207     	CLR	C
0992    E56F          5208     	MOV	A, LIPO_ADC_LIMIT_H
0994    13            5209     	RRC	A
0995    F9            5210     MOV R1 , A 
0996    E56E          5211     	MOV	A, LIPO_ADC_LIMIT_L	
0998    13            5212     	RRC	A
0999    F8            5213     MOV R0 , A 
099A    C3            5214     	CLR	C
099B    E9            5215     MOV A , R1 
099C    13            5216     	RRC	A
099D    F9            5217     MOV R1 , A 
099E    E8            5218     MOV A , R0 
099F    13            5219     	RRC	A
09A0    F8            5220     MOV R0 , A 
                      5221     	; Divide three times to get to 3.125%
09A1    7A03          5222     MOV R2 , # 3 
                      5223     MEASURE_LIPO_DIVIDE_LOOP: 
09A3    C3            5224     	CLR	C
09A4    E9            5225     MOV A , R1 
09A5    13            5226     	RRC	A
09A6    F9            5227     MOV R1 , A 
09A7    E8            5228     MOV A , R0 
09A8    13            5229     	RRC	A
09A9    F8            5230     MOV R0 , A 
09AA    DAF7          5231     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      5232     
                      5233     	; Add the programmed number of 0.1V (or 3.125% increments)
09AC    AA20          5234     MOV R2 , BIT_ACCESS 
09AE    1A            5235     DEC R2 
09AF    7009          5236     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      5237     
09B1    756E00        5238     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
09B4    756F00        5239     	MOV	LIPO_ADC_LIMIT_H, #0
09B7    0209CA        5240     	JMP	MEASURE_LIPO_EXIT	
                      5241     
                      5242     MEASURE_LIPO_LIMIT_ON: 
09BA    1A            5243     DEC R2 
09BB    EA            5244     MOV A , R2 
09BC    6008          5245     	JZ	MEASURE_LIPO_UPDATE
                      5246     
                      5247     MEASURE_LIPO_ADD_LOOP: 
09BE    EE            5248     MOV A , R6 
09BF    28            5249     ADD A , R0 
09C0    FE            5250     MOV R6 , A 
09C1    EF            5251     MOV A , R7 
09C2    39            5252     ADDC A , R1 
09C3    FF            5253     MOV R7 , A 
09C4    DAF8          5254     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      5255     
                      5256     MEASURE_LIPO_UPDATE: 
                      5257     	; Set ADC limit
09C6    8E6E          5258     MOV LIPO_ADC_LIMIT_L , R6 
09C8    8F6F          5259     MOV LIPO_ADC_LIMIT_H , R7 
                      5260     ENDIF
                      5261     MEASURE_LIPO_EXIT: 
09CA    22            5262     	RET
                      5263     
                      5264     
                      5265     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5266     ;
                      5267     ; Start ADC conversion
                      5268     ;
                      5269     ; No assumptions
                      5270     ;
                      5271     ; Start conversion used for measuring power supply voltage
                      5272     ;
                      5273     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5274     START_ADC_CONVERSION: 
                      5275     	; Start adc
                      5276     	START_ADC 
09CB    75E890        5276+1   MOV ADC0CN , # 90H  ; ADC START
09CE    22            5277     	RET
                      5278     
                      5279     
                      5280     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5281     ;
                      5282     ; Check temperature, power supply voltage and limit power
                      5283     ;
                      5284     ; No assumptions
                      5285     ;
                      5286     ; Used to limit main motor power in order to maintain the required voltage
                      5287     ;
                      5288     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5289     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      5290     	; Load programmed low voltage limit
09CF    7883          5291     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
09D1    E6            5292     MOV A , @ R0 
09D2    FF            5293     MOV R7 , A 
                      5294     	; Wait for ADC conversion to complete
                      5295     	GET_ADC_STATUS 
09D3    E5E8          5295+1   MOV A , ADC0CN 
09D5    20ECF7        5296     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      5297     	; Read ADC result
                      5298     	READ_ADC_RESULT
09D8    A8BD          5298+1   MOV R0 , ADC0L 
09DA    A9BE          5298+1   MOV R1 , ADC0H 
                      5299     	; Stop ADC
                      5300     	STOP_ADC
                      5301     
09DC    0570          5302     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
09DE    C3            5303     	CLR	C
09DF    E570          5304     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
09E1    9408          5305     SUBB A , # 8 
09E3    4052          5306     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      5307     
09E5    757000        5308     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
09E8    E9            5309     MOV A , R1 
09E9    FA            5310     MOV R2 , A 
09EA    79A0          5311     MOV R1 , # PGM_ENABLE_TEMP_PROT 
09EC    E7            5312     MOV A , @ R1 
09ED    6044          5313     	JZ	TEMP_CHECK_EXIT			; No - branch
                      5314     
09EF    EA            5315     MOV A , R2 
09F0    7007          5316     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      5317     
09F2    E571          5318     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
09F4    601B          5319     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
09F6    020A05        5320     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      5321     
                      5322     TEMP_AVERAGE_INC_DEC: 
09F9    C3            5323     	CLR	C
09FA    E8            5324     MOV A , R0 
09FB    9571          5325     	SUBB	A, CURRENT_AVERAGE_TEMP
09FD    6010          5326     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      5327     
09FF    E571          5328     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0A01    5006          5329     	JNC	TEMP_AVERAGE_INC				
                      5330     
0A03    600C          5331     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      5332     TEMP_AVERAGE_DEC: 
0A05    14            5333     	DEC	A						; Decrement average
0A06    020A11        5334     	JMP	TEMP_AVERAGE_UPDATED
                      5335     
                      5336     TEMP_AVERAGE_INC: 
0A09    04            5337     	INC	A						; Increment average
0A0A    60F9          5338     	JZ	TEMP_AVERAGE_DEC
0A0C    020A11        5339     	JMP	TEMP_AVERAGE_UPDATED
                      5340     
                      5341     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0A0F    E571          5342     	MOV	A, CURRENT_AVERAGE_TEMP
                      5343     TEMP_AVERAGE_UPDATED: 
0A11    F571          5344     	MOV	CURRENT_AVERAGE_TEMP, A
0A13    C3            5345     	CLR	C
0A14    9472          5346     SUBB A , # 114 
0A16    401B          5347     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5348     
0A18    7561C0        5349     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      5350     
0A1B    C3            5351     	CLR	C
0A1C    9404          5352     SUBB A , # 4 
0A1E    4013          5353     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5354     
0A20    756180        5355     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      5356     
0A23    C3            5357     	CLR	C
0A24    9404          5358     SUBB A , # 4 
0A26    400B          5359     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5360     
0A28    756140        5361     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      5362     
0A2B    C3            5363     	CLR	C
0A2C    9404          5364     SUBB A , # 4 
0A2E    4003          5365     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5366     
0A30    756100        5367     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      5368     
                      5369     TEMP_CHECK_EXIT: 
                      5370     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0A33    75BB09        5370+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0A36    22            5371     	RET
                      5372     
                      5373     CHECK_VOLTAGE_START: 
                      5374     IF MODE == 0	; Main 
                      5375     	; Check if low voltage limiting is enabled
0A37    EF            5376     MOV A , R7 
0A38    C3            5377     	CLR	C
0A39    9401          5378     	SUBB	A, #1					; Is low voltage limit disabled?
0A3B    601F          5379     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      5380     
0A3D    7400          5381     MOV A , # 0 
0A3F    601B          5382     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      5383     
                      5384     	; Check if ADC is saturated
0A41    C3            5385     	CLR	C
0A42    E8            5386     MOV A , R0 
0A43    94FF          5387     	SUBB	A, #0FFH
0A45    E9            5388     MOV A , R1 
0A46    9403          5389     	SUBB	A, #03H
0A48    5012          5390     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      5391     
                      5392     	; Check voltage against limit
0A4A    C3            5393     	CLR	C
0A4B    E8            5394     MOV A , R0 
0A4C    956E          5395     	SUBB	A, LIPO_ADC_LIMIT_L
0A4E    E9            5396     MOV A , R1 
0A4F    956F          5397     	SUBB	A, LIPO_ADC_LIMIT_H
0A51    5009          5398     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      5399     
                      5400     	; Decrease pwm limit
0A53    E561          5401     	MOV  A, PWM_LIMIT
0A55    600C          5402     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      5403     
0A57    1561          5404     	DEC	PWM_LIMIT					; Decrement limit
0A59    020A63        5405     	JMP	CHECK_VOLTAGE_LIM
                      5406     
                      5407     CHECK_VOLTAGE_GOOD: 
                      5408     	; Increase pwm limit
0A5C    E561          5409     	MOV  A, PWM_LIMIT
0A5E    F4            5410     	CPL	A			
0A5F    6002          5411     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      5412     
0A61    0561          5413     	INC	PWM_LIMIT					; Increment limit
                      5414     
                      5415     CHECK_VOLTAGE_LIM: 
0A63    A861          5416     MOV R0 , PWM_LIMIT 
0A65    C3            5417     	CLR	C
0A66    E524          5418     	MOV	A, CURRENT_PWM
0A68    98            5419     SUBB A , R0 
0A69    5002          5420     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      5421     
0A6B    A824          5422     MOV R0 , CURRENT_PWM 
                      5423     
                      5424     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      5425     	; Slow spoolup
0A6D    C3            5426     	CLR	C
0A6E    E8            5427     MOV A , R0 
0A6F    9562          5428     	SUBB	A, PWM_LIMIT_SPOOLUP
0A71    400A          5429     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      5430     
0A73    A862          5431     MOV R0 , PWM_LIMIT_SPOOLUP 
0A75    E562          5432     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0A77    F4            5433     	CPL	A
0A78    6003          5434     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      5435      
0A7A    856261        5436     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      5437     
                      5438     CHECK_VOLTAGE_EXIT: 
0A7D    8825          5439     MOV CURRENT_PWM_LIMITED , R0 
0A7F    8826          5440     MOV CURRENT_PWM_LIM_DITH , R0 
                      5441     ENDIF
                      5442     IF MODE == 1	; Tail
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               ENDIF
                      5452     IF MODE == 2	; Multi
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	ADD	A, #16			
                               	JNC	($+4)					; If not max - branch
                               
                               	MOV	A, #255
                               
                               	MOV	PWM_LIMIT, A				; Increment limit 
                               	; Set current pwm limited if closed loop mode
                               	MOV	TEMP2, #PGM_GOV_MODE		; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)			
                               	AJMP	CHECK_VOLTAGE_PWM_DONE		; No - branch
                               
                               	CLR	C
                               	MOV	TEMP1, PWM_LIMIT			; Set limit
                               	MOV	A, CURRENT_PWM
                               	SUBB	A, TEMP1
                               	JNC	CHECK_VOLTAGE_LOW_RPM		; If current pwm above limit - branch and limit	
                               
                               	MOV	TEMP1, CURRENT_PWM			; Set current pwm (no limiting)
                               
                               CHECK_VOLTAGE_LOW_RPM:
                               	; Limit pwm for low rpms
                               	CLR	C
                               	MOV	A, TEMP1					; Check against limit
                               	SUBB	A, PWM_LIMIT_BY_RPM
                               	JC	($+4)					; If current pwm below limit - branch
                               
                               	MOV	TEMP1, PWM_LIMIT_BY_RPM		; Limit pwm
                               
                               	MOV  CURRENT_PWM_LIMITED, TEMP1
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               CHECK_VOLTAGE_PWM_DONE:
                               ENDIF
                      5487     	; Set adc mux for next conversion
0A81    E570          5488     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0A83    B40703        5489     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      5490     
                      5491     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0A86    75BB10        5491+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5492     
                      5493     CHECK_VOLTAGE_RET: 
0A89    22            5494     	RET
                      5495     
                      5496     
                      5497     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5498     ;
                      5499     ; Set startup PWM routine
                      5500     ;
                      5501     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      5502     ;
                      5503     ; Used for pwm control during startup
                      5504     ;
                      5505     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5506     SET_STARTUP_PWM: 	
                      5507     	; Adjust startup power
0A8A    7432          5508     MOV A , # 50 
0A8C    79A6          5509     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0A8E    87F0          5510     MOV B , @ R1 
0A90    A4            5511     	MUL	AB
0A91    C5F0          5512     	XCH	A, B
0A93    A2F7          5513     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0A95    33            5514     	RLC	A
0A96    F8            5515     MOV R0 , A 
0A97    C3            5516     	CLR	C
0A98    E8            5517     MOV A , R0 
0A99    9561          5518     	SUBB	A, PWM_LIMIT	
0A9B    4002          5519     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      5520     
0A9D    A861          5521     MOV R0 , PWM_LIMIT 
                      5522     
                      5523     STARTUP_PWM_SET_PWM: 
                      5524     	; Set pwm variables
0A9F    8822          5525     MOV REQUESTED_PWM , R0 
0AA1    8824          5526     MOV CURRENT_PWM , R0 
0AA3    8825          5527     MOV CURRENT_PWM_LIMITED , R0 
0AA5    8826          5528     MOV CURRENT_PWM_LIM_DITH , R0 
0AA7    8864          5529     MOV PWM_SPOOLUP_BEG , R0 
0AA9    22            5530     	RET
                      5531     
                      5532     
                      5533     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5534     ;
                      5535     ; Initialize timing routine
                      5536     ;
                      5537     ; No assumptions
                      5538     ;
                      5539     ; Part of initialization before motor start
                      5540     ;
                      5541     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5542     INITIALIZE_TIMING:  
0AAA    753D00        5543     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0AAD    753EF0        5544     	MOV	COMM_PERIOD4X_H, #0F0H
0AB0    22            5545     	RET
                      5546     
                      5547     
                      5548     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5549     ;
                      5550     ; Calculate next commutation timing routine
                      5551     ;
                      5552     ; No assumptions
                      5553     ;
                      5554     ; Called immediately after each commutation
                      5555     ; Also sets up timer 3 to wait advance timing
                      5556     ; Two entry points are used
                      5557     ;
                      5558     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5559     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
                      5560     	; Read commutation time
0AB1    75C820        5561     	MOV	TMR2CN, #20H		; Timer2 disabled
0AB4    A8CC          5562     MOV R0 , TMR2L 
0AB6    A9CD          5563     MOV R1 , TMR2H 
0AB8    75C824        5564     	MOV	TMR2CN, #24H		; Timer2 enabled
                      5565     IF MCU_48MHZ == 1
0ABB    C3            5566     	CLR	C
0ABC    E9            5567     MOV A , R1 
0ABD    13            5568     	RRC	A
0ABE    F9            5569     MOV R1 , A 
0ABF    E8            5570     MOV A , R0 
0AC0    13            5571     	RRC	A
0AC1    F8            5572     MOV R0 , A 
                      5573     ENDIF
                      5574     	; Calculate this commutation time
0AC2    AA39          5575     MOV R2 , PREV_COMM_L 
0AC4    AB3A          5576     MOV R3 , PREV_COMM_H 
0AC6    8839          5577     MOV PREV_COMM_L , R0 
0AC8    893A          5578     MOV PREV_COMM_H , R1 
0ACA    C3            5579     	CLR	C
0ACB    E8            5580     MOV A , R0 
0ACC    9A            5581     SUBB A , R2 
0ACD    F8            5582     MOV R0 , A 
0ACE    E9            5583     MOV A , R1 
0ACF    9B            5584     SUBB A , R3 
                      5585     IF MCU_48MHZ == 1
0AD0    547F          5586     	ANL	A, #7FH
                      5587     ENDIF
0AD2    F9            5588     MOV R1 , A 
0AD3    306702        5589     JNB FLAGS0 . 7 , ( $+5 ) 
0AD6    61B0          5590     	AJMP	CALC_NEXT_COMM_TIMING_FAST
                      5591     
0AD8    306933        5592     JNB FLAGS1 . 1 , CALC_NEXT_COMM_STARTUP_DONE 
                      5593     
0ADB    AC3B          5594     MOV R4 , PREV_PREV_COMM_L 
0ADD    AD3C          5595     MOV R5 , PREV_PREV_COMM_H 
0ADF    8A3B          5596     MOV PREV_PREV_COMM_L , R2 
0AE1    8B3C          5597     MOV PREV_PREV_COMM_H , R3 
0AE3    C3            5598     	CLR	C
0AE4    EB            5599     MOV A , R3 
0AE5    9D            5600     SUBB A , R5 
                      5601     IF MCU_48MHZ == 1
0AE6    547F          5602     	ANL	A, #7FH
                      5603     ENDIF
0AE8    FB            5604     MOV R3 , A 
0AE9    C3            5605     	CLR	C
0AEA    E9            5606     MOV A , R1 
0AEB    9B            5607     SUBB A , R3 
0AEC    F53F          5608     	MOV	COMM_DIFF, A
0AEE    A839          5609     MOV R0 , PREV_COMM_L 
0AF0    A93A          5610     MOV R1 , PREV_COMM_H 
0AF2    C3            5611     	CLR	C
0AF3    E8            5612     MOV A , R0 
0AF4    9C            5613     SUBB A , R4 
0AF5    F8            5614     MOV R0 , A 
0AF6    E9            5615     MOV A , R1 
0AF7    9D            5616     SUBB A , R5 
                      5617     IF MCU_48MHZ == 1
0AF8    547F          5618     	ANL	A, #7FH
                      5619     ENDIF
0AFA    F9            5620     MOV R1 , A 
                      5621     
0AFB    C3            5622     	CLR	C
0AFC    E53E          5623     	MOV	A, COMM_PERIOD4X_H		; Average with previous and save
0AFE    13            5624     	RRC	A
0AFF    FB            5625     MOV R3 , A 
0B00    E53D          5626     	MOV	A, COMM_PERIOD4X_L
0B02    13            5627     	RRC	A
0B03    FA            5628     MOV R2 , A 
0B04    E8            5629     MOV A , R0 
0B05    2A            5630     ADD A , R2 
0B06    F53D          5631     	MOV	COMM_PERIOD4X_L, A
0B08    E9            5632     MOV A , R1 
0B09    3B            5633     ADDC A , R3 
0B0A    F53E          5634     	MOV	COMM_PERIOD4X_H, A
0B0C    6158          5635     	AJMP	CALC_NEW_WAIT_TIMES_SETUP
                      5636     
                      5637     CALC_NEXT_COMM_STARTUP_DONE: 
                      5638     	; Calculate new commutation time 
0B0E    AA3D          5639     MOV R2 , COMM_PERIOD4X_L 
0B10    AB3E          5640     MOV R3 , COMM_PERIOD4X_H 
0B12    AC3D          5641     MOV R4 , COMM_PERIOD4X_L 
0B14    AD3E          5642     MOV R5 , COMM_PERIOD4X_H 
0B16    7E04          5643     MOV R6 , # 4 
0B18    7F02          5644     MOV R7 , # 2 
0B1A    C3            5645     	CLR	C
0B1B    EB            5646     MOV A , R3 
0B1C    9404          5647     	SUBB	A, #04H
0B1E    4002          5648     	JC	($+4)
                      5649     
0B20    1E            5650     DEC R6 
0B21    1F            5651     DEC R7 
                      5652     
0B22    C3            5653     	CLR	C
0B23    EB            5654     MOV A , R3 
0B24    9408          5655     	SUBB	A, #08H
0B26    4002          5656     	JC	($+4)
                      5657     
0B28    1E            5658     DEC R6 
0B29    1F            5659     DEC R7 
                      5660     
                      5661     CALC_NEXT_COMM_AVG_PERIOD_DIV: 
0B2A    C3            5662     	CLR	C
0B2B    ED            5663     MOV A , R5 
0B2C    13            5664     	RRC	A					; Divide by 2
0B2D    FD            5665     MOV R5 , A 
0B2E    EC            5666     MOV A , R4 
0B2F    13            5667     	RRC	A
0B30    FC            5668     MOV R4 , A 
0B31    DEF7          5669     DJNZ R6 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      5670     
0B33    C3            5671     	CLR	C
0B34    EA            5672     MOV A , R2 
0B35    9C            5673     SUBB A , R4 
0B36    FA            5674     MOV R2 , A 
0B37    EB            5675     MOV A , R3 
0B38    9D            5676     SUBB A , R5 
0B39    FB            5677     MOV R3 , A 
0B3A    EF            5678     MOV A , R7 
0B3B    6009          5679     	JZ	CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE
                      5680     
                      5681     CALC_NEXT_COMM_NEW_PERIOD_DIV: 
0B3D    C3            5682     	CLR	C
0B3E    E9            5683     MOV A , R1 
0B3F    13            5684     	RRC	A					; Divide by 2
0B40    F9            5685     MOV R1 , A 
0B41    E8            5686     MOV A , R0 
0B42    13            5687     	RRC	A
0B43    F8            5688     MOV R0 , A 
0B44    DFF7          5689     DJNZ R7 , CALC_NEXT_COMM_NEW_PERIOD_DIV 
                      5690     
                      5691     CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE: 
0B46    EA            5692     MOV A , R2 
0B47    28            5693     ADD A , R0 
0B48    FA            5694     MOV R2 , A 
0B49    EB            5695     MOV A , R3 
0B4A    39            5696     ADDC A , R1 
0B4B    FB            5697     MOV R3 , A 
0B4C    8A3D          5698     MOV COMM_PERIOD4X_L , R2 
0B4E    8B3E          5699     MOV COMM_PERIOD4X_H , R3 
0B50    5006          5700     	JNC	CALC_NEW_WAIT_TIMES_SETUP; If period larger than 0xffff - go to slow case
                      5701     
0B52    7BFF          5702     MOV R3 , # 0FFH 
0B54    8B3D          5703     MOV COMM_PERIOD4X_L , R3 
0B56    8B3E          5704     MOV COMM_PERIOD4X_H , R3 
                      5705     
                      5706     CALC_NEW_WAIT_TIMES_SETUP: 	
                      5707     	; Set high rpm bit (if above 156k erpm)
0B58    C3            5708     	CLR	C
0B59    EB            5709     MOV A , R3 
0B5A    9402          5710     	SUBB	A, #2
0B5C    5002          5711     	JNC	($+4)
                      5712     
0B5E    D267          5713     SETB FLAGS0 . 7 
                      5714     	
                      5715     	; Load programmed commutation timing
0B60    306904        5716     JNB FLAGS1 . 1 , CALC_NEW_WAIT_PER_STARTUP_DONE 
                      5717     
0B63    7F03          5718     MOV R7 , # 3 
0B65    6183          5719     	AJMP	CALC_NEW_WAIT_PER_DEMAG_DONE
                      5720     
                      5721     CALC_NEW_WAIT_PER_STARTUP_DONE: 
0B67    7892          5722     MOV R0 , # PGM_COMM_TIMING 
0B69    E6            5723     MOV A , @ R0 
0B6A    FF            5724     MOV R7 , A 
0B6B    C3            5725     	CLR	C
0B6C    E536          5726     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0B6E    9482          5727     	SUBB	A, #130
0B70    4011          5728     	JC	CALC_NEW_WAIT_PER_DEMAG_DONE
                      5729     
0B72    0F            5730     INC R7 
                      5731     
0B73    C3            5732     	CLR	C
0B74    E536          5733     	MOV	A, DEMAG_DETECTED_METRIC
0B76    94A0          5734     	SUBB	A, #160
0B78    4001          5735     	JC	($+3)
                      5736     
0B7A    0F            5737     INC R7 
                      5738     
0B7B    C3            5739     	CLR	C
0B7C    EF            5740     MOV A , R7 
0B7D    9406          5741     	SUBB	A, #6
0B7F    4002          5742     	JC	($+4)
                      5743     
0B81    7F05          5744     MOV R7 , # 5 
                      5745     
                      5746     CALC_NEW_WAIT_PER_DEMAG_DONE: 
                      5747     	; Set timing reduction
                      5748     IF MCU_48MHZ == 0
                               	MOV	TEMP7, #4
                               ELSE
0B83    7E01          5751     MOV R6 , # 1 
                      5752     ENDIF
                      5753     	; Load current commutation timing
0B85    E53E          5754     	MOV	A, COMM_PERIOD4X_H		; Divide 4 times
0B87    C4            5755     	SWAP	A
0B88    540F          5756     	ANL	A, #00FH
0B8A    F9            5757     MOV R1 , A 
0B8B    E53E          5758     	MOV	A, COMM_PERIOD4X_H
0B8D    C4            5759     	SWAP	A
0B8E    54F0          5760     	ANL	A, #0F0H
0B90    F8            5761     MOV R0 , A 
0B91    E53D          5762     	MOV	A, COMM_PERIOD4X_L
0B93    C4            5763     	SWAP	A
0B94    540F          5764     	ANL	A, #00FH
0B96    28            5765     ADD A , R0 
0B97    F8            5766     MOV R0 , A 
                      5767     
0B98    C3            5768     	CLR	C
0B99    E8            5769     MOV A , R0 
0B9A    9E            5770     SUBB A , R6 
0B9B    FA            5771     MOV R2 , A 
0B9C    E9            5772     MOV A , R1 
0B9D    9400          5773     	SUBB	A, #0
0B9F    FB            5774     MOV R3 , A 
0BA0    4009          5775     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      5776     
0BA2    C3            5777     	CLR	C
0BA3    EA            5778     MOV A , R2 
0BA4    9402          5779     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0BA6    EB            5780     MOV A , R3 
0BA7    9400          5781     	SUBB	A, #0
0BA9    5004          5782     	JNC	CALC_NEW_WAIT_TIMES_EXIT	; Check that result is still above minumum
                      5783     
                      5784     LOAD_MIN_TIME: 
0BAB    7A02          5785     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0BAD    E4            5786     	CLR	A
0BAE    FB            5787     MOV R3 , A 
                      5788     
                      5789     CALC_NEW_WAIT_TIMES_EXIT: 	
0BAF    22            5790     	RET
                      5791     
                      5792     
                      5793     ; Fast calculation (Comm_Period4x_H less than 2)
                      5794     CALC_NEXT_COMM_TIMING_FAST: 			
                      5795     	; Calculate new commutation time
0BB0    AA3D          5796     MOV R2 , COMM_PERIOD4X_L 
0BB2    AB3E          5797     MOV R3 , COMM_PERIOD4X_H 
0BB4    EB            5798     MOV A , R3 
0BB5    C4            5799     	SWAP	A
0BB6    FE            5800     MOV R6 , A 
0BB7    EA            5801     MOV A , R2 
0BB8    C4            5802     	SWAP A
0BB9    540F          5803     	ANL	A, #0FH
0BBB    4E            5804     ORL A , R6 
0BBC    FC            5805     MOV R4 , A 
0BBD    C3            5806     	CLR	C
0BBE    EA            5807     MOV A , R2 
0BBF    9C            5808     SUBB A , R4 
0BC0    FA            5809     MOV R2 , A 
0BC1    EB            5810     MOV A , R3 
0BC2    9400          5811     	SUBB	A, #0
0BC4    FB            5812     MOV R3 , A 
0BC5    C3            5813     	CLR	C
0BC6    E8            5814     MOV A , R0 
0BC7    13            5815     	RRC	A					; Divide by 2 2 times
0BC8    C3            5816     	CLR	C
0BC9    13            5817     	RRC	A
0BCA    F8            5818     MOV R0 , A 
0BCB    EA            5819     MOV A , R2 
0BCC    28            5820     ADD A , R0 
0BCD    FA            5821     MOV R2 , A 
0BCE    EB            5822     MOV A , R3 
0BCF    3400          5823     	ADDC	A, #0
0BD1    FB            5824     MOV R3 , A 
0BD2    8A3D          5825     MOV COMM_PERIOD4X_L , R2 
0BD4    8B3E          5826     MOV COMM_PERIOD4X_H , R3 
0BD6    C3            5827     	CLR	C
0BD7    EB            5828     MOV A , R3 
0BD8    9402          5829     	SUBB	A, #2
0BDA    4002          5830     	JC	($+4)
                      5831     
0BDC    C267          5832     CLR FLAGS0 . 7 
                      5833     	
                      5834     IF MCU_48MHZ == 0
                               	MOV	TEMP1, #4				; Set timing reduction
                               ELSE
0BDE    7801          5837     MOV R0 , # 1 
                      5838     ENDIF
0BE0    EB            5839     MOV A , R3 
0BE1    C4            5840     	SWAP	A
0BE2    FE            5841     MOV R6 , A 
0BE3    7B00          5842     MOV R3 , # 0 
0BE5    EA            5843     MOV A , R2 
0BE6    C4            5844     	SWAP A
0BE7    540F          5845     	ANL	A, #0FH
0BE9    4E            5846     ORL A , R6 
0BEA    FA            5847     MOV R2 , A 
0BEB    C3            5848     	CLR	C
0BEC    EA            5849     MOV A , R2 
0BED    98            5850     SUBB A , R0 
0BEE    FA            5851     MOV R2 , A 
0BEF    4005          5852     	JC	LOAD_MIN_TIME_FAST		; Check that result is still positive
                      5853     
0BF1    C3            5854     	CLR	C
0BF2    9402          5855     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0BF4    5002          5856     	JNC	CALC_NEW_WAIT_TIMES_FAST_DONE	; Check that result is still above minumum
                      5857     
                      5858     LOAD_MIN_TIME_FAST: 
0BF6    7A02          5859     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
                      5860     
                      5861     CALC_NEW_WAIT_TIMES_FAST_DONE: 	
0BF8    7892          5862     MOV R0 , # PGM_COMM_TIMING 
0BFA    E6            5863     MOV A , @ R0 
0BFB    FF            5864     MOV R7 , A 
0BFC    22            5865     	RET
                      5866     
                      5867     
                      5868     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5869     ;
                      5870     ; Wait advance timing routine
                      5871     ;
                      5872     ; No assumptions
                      5873     ; NOTE: Be VERY careful if using temp registers. They are passed over this routine
                      5874     ;
                      5875     ; Waits for the advance timing to elapse and sets up the next zero cross wait
                      5876     ;
                      5877     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5878     WAIT_ADVANCE_TIMING: 	
0BFD    306002        5879     JNB FLAGS0 . 0 , ( $+5 ) 
0C00    61FD          5880     	AJMP	WAIT_ADVANCE_TIMING
                      5881     
                      5882     	; Setup next wait time
0C02    854F53        5883     	MOV	NEXT_WT_START_L, WT_ZC_TOUT_START_L
0C05    855054        5884     	MOV	NEXT_WT_START_H, WT_ZC_TOUT_START_H
0C08    D260          5885     SETB FLAGS0 . 0 
0C0A    43E680        5886     	ORL	EIE1, #80H	; Enable timer3 interrupts
0C0D    22            5887     	RET
                      5888     
                      5889     
                      5890     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5891     ;
                      5892     ; Calculate new wait times routine
                      5893     ;
                      5894     ; No assumptions
                      5895     ;
                      5896     ; Calculates new wait times
                      5897     ;
                      5898     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5899     CALC_NEW_WAIT_TIMES: 	
0C0E    C3            5900     	CLR	C
0C0F    E4            5901     	CLR	A
0C10    9A            5902     SUBB A , R2 
0C11    F8            5903     MOV R0 , A 
0C12    E4            5904     	CLR	A
0C13    9B            5905     SUBB A , R3 
0C14    F9            5906     MOV R1 , A 
                      5907     IF MCU_48MHZ == 1
0C15    C3            5908     	CLR	C
0C16    E8            5909     MOV A , R0 
0C17    33            5910     	RLC	A
0C18    F8            5911     MOV R0 , A 
0C19    E9            5912     MOV A , R1 
0C1A    33            5913     	RLC	A
0C1B    F9            5914     MOV R1 , A 
                      5915     ENDIF
0C1C    306702        5916     JNB FLAGS0 . 7 , ( $+5 ) 
0C1F    819D          5917     	AJMP	CALC_NEW_WAIT_TIMES_FAST
                      5918     
0C21    E8            5919     MOV A , R0 
0C22    FA            5920     MOV R2 , A 
0C23    E9            5921     MOV A , R1 
0C24    FB            5922     MOV R3 , A 
0C25    D3            5923     	SETB	C					; Negative numbers - set carry
0C26    E9            5924     MOV A , R1 
0C27    13            5925     	RRC	A					; Divide by 2
0C28    FD            5926     MOV R5 , A 
0C29    E8            5927     MOV A , R0 
0C2A    13            5928     	RRC	A
0C2B    FC            5929     MOV R4 , A 
0C2C    884F          5930     MOV WT_ZC_TOUT_START_L , R0 
0C2E    8950          5931     MOV WT_ZC_TOUT_START_H , R1 
0C30    C3            5932     	CLR	C
0C31    EF            5933     MOV A , R7 
0C32    9403          5934     	SUBB	A, #3				; Is timing normal?
0C34    6037          5935     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      5936     
0C36    EF            5937     MOV A , R7 
0C37    20E00D        5938     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      5939     
0C3A    E8            5940     MOV A , R0 
0C3B    2C            5941     ADD A , R4 
0C3C    F8            5942     MOV R0 , A 
0C3D    E9            5943     MOV A , R1 
0C3E    3D            5944     ADDC A , R5 
0C3F    F9            5945     MOV R1 , A 
0C40    EC            5946     MOV A , R4 
0C41    FA            5947     MOV R2 , A 
0C42    ED            5948     MOV A , R5 
0C43    FB            5949     MOV R3 , A 
0C44    020C5A        5950     	JMP	STORE_TIMES_UP_OR_DOWN
                      5951     
                      5952     ADJUST_TIMING_TWO_STEPS: 
0C47    E8            5953     MOV A , R0 
0C48    28            5954     ADD A , R0 
0C49    F8            5955     MOV R0 , A 
0C4A    E9            5956     MOV A , R1 
0C4B    39            5957     ADDC A , R1 
0C4C    F9            5958     MOV R1 , A 
0C4D    C3            5959     	CLR	C
0C4E    E8            5960     MOV A , R0 
0C4F    2402          5961     	ADD	A, #(COMM_TIME_MIN SHL 1)
0C51    F8            5962     MOV R0 , A 
0C52    E9            5963     MOV A , R1 
0C53    3400          5964     	ADDC	A, #0
0C55    F9            5965     MOV R1 , A 
0C56    7AFE          5966     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
0C58    7BFF          5967     MOV R3 , # 0FFH 
                      5968     
                      5969     STORE_TIMES_UP_OR_DOWN: 
0C5A    C3            5970     	CLR	C
0C5B    EF            5971     MOV A , R7 
0C5C    9403          5972     	SUBB	A, #3					; Is timing higher than normal?
0C5E    400D          5973     	JC	STORE_TIMES_DECREASE		; No - branch
                      5974     
                      5975     STORE_TIMES_INCREASE: 
0C60    8A51          5976     MOV WT_COMM_START_L , R2 
0C62    8B52          5977     MOV WT_COMM_START_H , R3 
0C64    884B          5978     MOV WT_ADV_START_L , R0 
0C66    894C          5979     MOV WT_ADV_START_H , R1 
0C68    8C4D          5980     MOV WT_ZC_SCAN_START_L , R4 
0C6A    8D4E          5981     MOV WT_ZC_SCAN_START_H , R5 
0C6C    22            5982     	RET
                      5983     
                      5984     STORE_TIMES_DECREASE: 
0C6D    8851          5985     MOV WT_COMM_START_L , R0 
0C6F    8952          5986     MOV WT_COMM_START_H , R1 
0C71    8A4B          5987     MOV WT_ADV_START_L , R2 
0C73    8B4C          5988     MOV WT_ADV_START_H , R3 
0C75    8C4D          5989     MOV WT_ZC_SCAN_START_L , R4 
0C77    8D4E          5990     MOV WT_ZC_SCAN_START_H , R5 
0C79    306920        5991     JNB FLAGS1 . 1 , STORE_TIMES_EXIT 
                      5992     
0C7C    C3            5993     	CLR	C
0C7D    E533          5994     	MOV	A, STARTUP_CNT			
0C7F    9403          5995     	SUBB	A, #3
0C81    4019          5996     	JC	STORE_TIMES_EXIT
                      5997     
0C83    E53F          5998     	MOV	A, COMM_DIFF			; Compensate commutation wait for comparator offset
0C85    A2E7          5999     	MOV	C, ACC.7
0C87    13            6000     	RRC	A
0C88    F8            6001     MOV R0 , A 
0C89    E552          6002     	MOV	A, WT_COMM_START_H
0C8B    F4            6003     	CPL	A
0C8C    2401          6004     	ADD	A, #1
0C8E    38            6005     ADDC A , R0 
0C8F    400B          6006     	JC	STORE_TIMES_EXIT
0C91    20E708        6007     	JB	ACC.7, STORE_TIMES_EXIT
                      6008     
0C94    7551FF        6009     	MOV	WT_COMM_START_L, #0FFH
0C97    F4            6010     	CPL	A
0C98    2401          6011     	ADD	A, #1
0C9A    F552          6012     	MOV	WT_COMM_START_H, A 
                      6013     
                      6014     STORE_TIMES_EXIT: 
0C9C    22            6015     	RET
                      6016     
                      6017     
                      6018     CALC_NEW_WAIT_TIMES_FAST: 	
0C9D    E8            6019     MOV A , R0 
0C9E    FA            6020     MOV R2 , A 
0C9F    D3            6021     	SETB	C					; Negative numbers - set carry
0CA0    E8            6022     MOV A , R0 
0CA1    13            6023     	RRC	A
0CA2    FC            6024     MOV R4 , A 
0CA3    884F          6025     MOV WT_ZC_TOUT_START_L , R0 
0CA5    C3            6026     	CLR	C
0CA6    EF            6027     MOV A , R7 
0CA7    9403          6028     	SUBB	A, #3				; Is timing normal?
0CA9    601F          6029     	JZ	STORE_TIMES_DECREASE_FAST; Yes - branch
                      6030     
0CAB    EF            6031     MOV A , R7 
0CAC    20E007        6032     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS_FAST	; If an odd number - branch
                      6033     
0CAF    E8            6034     MOV A , R0 
0CB0    2C            6035     ADD A , R4 
0CB1    F8            6036     MOV R0 , A 
0CB2    EC            6037     MOV A , R4 
0CB3    FA            6038     MOV R2 , A 
0CB4    81BD          6039     	AJMP	STORE_TIMES_UP_OR_DOWN_FAST
                      6040     
                      6041     ADJUST_TIMING_TWO_STEPS_FAST: 
0CB6    E8            6042     MOV A , R0 
0CB7    28            6043     ADD A , R0 
0CB8    2402          6044     	ADD	A, #(COMM_TIME_MIN SHL 1)
0CBA    F8            6045     MOV R0 , A 
0CBB    7AFE          6046     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
                      6047     
                      6048     STORE_TIMES_UP_OR_DOWN_FAST: 
0CBD    C3            6049     	CLR	C
0CBE    EF            6050     MOV A , R7 
0CBF    9403          6051     	SUBB	A, #3				; Is timing higher than normal?
0CC1    4007          6052     	JC	STORE_TIMES_DECREASE_FAST; No - branch
                      6053     
                      6054     STORE_TIMES_INCREASE_FAST: 
0CC3    8A51          6055     MOV WT_COMM_START_L , R2 
0CC5    884B          6056     MOV WT_ADV_START_L , R0 
0CC7    8C4D          6057     MOV WT_ZC_SCAN_START_L , R4 
0CC9    22            6058     	RET
                      6059     
                      6060     STORE_TIMES_DECREASE_FAST: 
0CCA    8851          6061     MOV WT_COMM_START_L , R0 
0CCC    8A4B          6062     MOV WT_ADV_START_L , R2 
0CCE    8C4D          6063     MOV WT_ZC_SCAN_START_L , R4 
0CD0    22            6064     	RET
                      6065     
                      6066     
                      6067     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6068     ;
                      6069     ; Wait before zero cross scan routine
                      6070     ;
                      6071     ; No assumptions
                      6072     ;
                      6073     ; Waits for the zero cross scan wait time to elapse
                      6074     ; Also sets up timer 3 for the zero cross scan timeout time
                      6075     ;
                      6076     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6077     WAIT_BEFORE_ZC_SCAN: 	
                      6078     	; Calculate random number
0CD1    E568          6079     	MOV	A, RANDOM
0CD3    C3            6080     	CLR	C
0CD4    33            6081     	RLC	A
0CD5    5002          6082     	JNC	WAIT_BEFORE_ZC_SCAN_RAND
                      6083     
0CD7    646B          6084     	XRL	A, #06BH		; Sequence length of 35, when initialized to 1
                      6085     
                      6086     WAIT_BEFORE_ZC_SCAN_RAND:           
0CD9    F568          6087     	MOV	RANDOM, A
                      6088     
                      6089     WAIT_BEFORE_ZC_SCAN_WAIT:           
0CDB    306002        6090     JNB FLAGS0 . 0 , ( $+5 ) 
0CDE    81DB          6091     	AJMP	WAIT_BEFORE_ZC_SCAN_WAIT
                      6092     
0CE0    D260          6093     SETB FLAGS0 . 0 
0CE2    43E680        6094     	ORL	EIE1, #80H			; Enable timer3 interrupts
0CE5    E52D          6095     	MOV	A, FLAGS1
0CE7    5406          6096     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0CE9    6029          6097     	JZ	WAIT_BEFORE_ZC_SCAN_EXIT		
                      6098     
0CEB    A83D          6099     MOV R0 , COMM_PERIOD4X_L 
0CED    A93E          6100     MOV R1 , COMM_PERIOD4X_H 
0CEF    C3            6101     	CLR	C
0CF0    E9            6102     MOV A , R1 
0CF1    13            6103     	RRC	A
0CF2    F9            6104     MOV R1 , A 
0CF3    E8            6105     MOV A , R0 
0CF4    13            6106     	RRC	A
0CF5    F8            6107     MOV R0 , A 
                      6108     IF MCU_48MHZ == 1
0CF6    C3            6109     	CLR	C
0CF7    E8            6110     MOV A , R0 
0CF8    33            6111     	RLC	A
0CF9    F8            6112     MOV R0 , A 
0CFA    E9            6113     MOV A , R1 
0CFB    33            6114     	RLC	A
0CFC    F9            6115     MOV R1 , A 
                      6116     ENDIF
0CFD    53E67F        6117     	ANL	EIE1, #7FH			; Disable timer3 interrupts
0D00    759100        6118     	MOV	TMR3CN, #00H			; Timer3 disabled and interrupt flag cleared
0D03    C3            6119     	CLR	C
0D04    E4            6120     	CLR	A
0D05    98            6121     SUBB A , R0 
0D06    F594          6122     	MOV	TMR3L, A
0D08    E4            6123     	CLR	A
0D09    99            6124     SUBB A , R1 
0D0A    F595          6125     	MOV	TMR3H, A
0D0C    759104        6126     	MOV	TMR3CN, #04H			; Timer3 enabled and interrupt flag cleared
                      6127     
0D0F    D260          6128     SETB FLAGS0 . 0 
0D11    43E680        6129     	ORL	EIE1, #80H			; Enable timer3 interrupts
                      6130     
                      6131     WAIT_BEFORE_ZC_SCAN_EXIT:           
0D14    22            6132     	RET
                      6133     
                      6134     
                      6135     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6136     ;
                      6137     ; Wait for comparator to go low/high routines
                      6138     ;
                      6139     ; No assumptions
                      6140     ;
                      6141     ; Waits for the zero cross scan wait time to elapse
                      6142     ; Then scans for comparator going low/high
                      6143     ;
                      6144     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6145     WAIT_FOR_COMP_OUT_LOW: 
0D15    D265          6146     SETB FLAGS0 . 5 
0D17    754100        6147     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0D1A    752000        6148     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0D1D    306B03        6149     JNB FLAGS1 . 3 , ( $+6 ) 
0D20    752040        6150     	MOV	BIT_ACCESS, #40H		
0D23    020D34        6151     	JMP	WAIT_FOR_COMP_OUT_START
                      6152     
                      6153     WAIT_FOR_COMP_OUT_HIGH: 
0D26    D265          6154     SETB FLAGS0 . 5 
0D28    754100        6155     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0D2B    752040        6156     	MOV	BIT_ACCESS, #40H			; Desired comparator output
0D2E    306B03        6157     JNB FLAGS1 . 3 , ( $+6 ) 
0D31    752000        6158     	MOV	BIT_ACCESS, #00H		
                      6159     
                      6160     WAIT_FOR_COMP_OUT_START: 
0D34    D2AF          6161     	SETB	EA						; Enable interrupts
                      6162     	; Set number of comparator readings
0D36    7801          6163     MOV R0 , # 1 
0D38    206722        6164     JB FLAGS0 . 7 , COMP_WAIT_ON_COMP_ABLE 
                      6165     
0D3B    E52D          6166     	MOV	A, FLAGS1					; Clear demag detected flag if start phases
0D3D    5406          6167     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0D3F    6002          6168     	JZ	($+4)
                      6169     		
0D41    C265          6170     CLR FLAGS0 . 5 
                      6171     
0D43    C3            6172     	CLR	C						; Set number of readings higher for lower speeds
0D44    E53E          6173     	MOV 	A, COMM_PERIOD4X_H			
0D46    9405          6174     	SUBB	A, #05H
0D48    4013          6175     	JC	COMP_WAIT_ON_COMP_ABLE
                      6176     
0D4A    7802          6177     MOV R0 , # 2 
                      6178     
0D4C    9405          6179     	SUBB	A, #05H
0D4E    4008          6180     	JC	COMP_WAIT_NO_OF_READINGS
                      6181     
0D50    7803          6182     MOV R0 , # 3 
                      6183     
0D52    9405          6184     	SUBB	A, #05H					; Set number of consecutive readings higher for lower speeds
0D54    4002          6185     	JC	COMP_WAIT_NO_OF_READINGS
                      6186     
0D56    7806          6187     MOV R0 , # 6 
                      6188     
                      6189     COMP_WAIT_NO_OF_READINGS: 
0D58    306902        6190     JNB FLAGS1 . 1 , ( $+5 ) 
0D5B    780A          6191     MOV R0 , # 10 
                      6192     
                      6193     COMP_WAIT_ON_COMP_ABLE: 
0D5D    206009        6194     JB FLAGS0 . 0 , COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT 
                      6195     
0D60    E541          6196     	MOV	A, COMPARATOR_READ_CNT			; Check that comparator has been read
0D62    6005          6197     	JZ	COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT	; If not read - branch
                      6198     
0D64    D2AF          6199     	SETB	EA							; Enable interrupts
0D66    D26C          6200     SETB FLAGS1 . 4 
0D68    22            6201     	RET								; Yes - return
                      6202     
                      6203     
                      6204     COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT: 
0D69    D2AF          6205     	SETB	EA							; Enable interrupts
0D6B    00            6206     	NOP								; Allocate only just enough time to capture interrupt
0D6C    00            6207     	NOP
0D6D    C2AF          6208     	CLR	EA							; Disable interrupts
0D6F    20672A        6209     JB FLAGS0 . 7 , COMP_WAIT_READ_COMP 
                      6210     
0D72    E53E          6211     	MOV	A, COMM_PERIOD4X_H				; Reduce required distance to pwm transition for higher speeds
0D74    C3            6212     	CLR	C
0D75    FB            6213     MOV R3 , A 
0D76    940F          6214     	SUBB	A, #0FH
0D78    4002          6215     	JC	($+4)
                      6216     
0D7A    7B0F          6217     MOV R3 , # 0FH 
                      6218     
0D7C    EB            6219     MOV A , R3 
0D7D    2405          6220     	ADD	A, #5
0D7F    307301        6221     JNB FLAGS2 . 3 , ( $+4 ) 
                      6222     
0D82    23            6223     	RL	A
                      6224     
0D83    306A02        6225     JNB FLAGS1 . 2 , ( $+5 ) 
0D86    7428          6226     	MOV	A, #40
                      6227     
0D88    206201        6228     JB FLAGS0 . 2 , ( $+4 ) 
                      6229     
0D8B    23            6230     	RL	A
                      6231     
0D8C    F9            6232     MOV R1 , A 
0D8D    306902        6233     JNB FLAGS1 . 1 , ( $+5 ) 
0D90    7982          6234     MOV R1 , # 130 
                      6235     
                      6236     IF MCU_48MHZ == 0
                               	MOV	A, TL1
                               ELSE
0D92    E58D          6239     	MOV	A, TH1
0D94    13            6240     	RRC	A
0D95    E58B          6241     	MOV	A, TL1
0D97    13            6242     	RRC	A
                      6243     ENDIF
0D98    C3            6244     	CLR	C
0D99    99            6245     SUBB A , R1 
0D9A    40C1          6246     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle
                      6247     
                      6248     COMP_WAIT_READ_COMP: 
0D9C    0541          6249     	INC	COMPARATOR_READ_CNT			; Increment comparator read count
                      6250     	READ_COMP_OUT					; Read comparator output
0D9E    E59B          6250+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0DA0    F4            6250+1   CPL A 
0DA1    5440          6251     	ANL	A, #40H
0DA3    B52002        6252     	CJNE	A, BIT_ACCESS, COMP_READ_WRONG
0DA6    A1F5          6253     	AJMP	COMP_READ_OK
                      6254     	
                      6255     COMP_READ_WRONG: 
0DA8    306914        6256     JNB FLAGS1 . 1 , COMP_READ_WRONG_NOT_STARTUP 
                      6257     
0DAB    08            6258     INC R0 
0DAC    C3            6259     	CLR	C
0DAD    E8            6260     MOV A , R0 
0DAE    940A          6261     	SUBB	A, #10					; If above initial requirement - go back and restart
0DB0    4002          6262     	JC	($+4)
0DB2    A134          6263     	AJMP	WAIT_FOR_COMP_OUT_START
                      6264     
0DB4    C3            6265     	CLR	C
0DB5    E533          6266     	MOV	A, STARTUP_CNT				; For the first commutations - go back and restart
0DB7    9406          6267     	SUBB	A, #6
0DB9    5002          6268     	JNC	($+4)
0DBB    A134          6269     	AJMP	WAIT_FOR_COMP_OUT_START
                      6270     
0DBD    A15D          6271     	AJMP	COMP_WAIT_ON_COMP_ABLE		; If below initial requirement - continue to look for good ones
                      6272     
                      6273     COMP_READ_WRONG_NOT_STARTUP: 
0DBF    206502        6274     JB FLAGS0 . 5 , ( $+5 ) 
0DC2    A134          6275     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct, and timeout already extended - go back and restart
                      6276     
0DC4    C265          6277     CLR FLAGS0 . 5 
0DC6    53E67F        6278     	ANL	EIE1, #7FH				; Disable timer3 interrupts
0DC9    759100        6279     	MOV	TMR3CN, #00H				; Timer3 disabled and interrupt flag cleared
0DCC    306710        6280     JNB FLAGS0 . 7 , COMP_READ_WRONG_LOW_RPM 
                      6281     
0DCF    759400        6282     	MOV	TMR3L, #00H				; Set timeout to 256us
                      6283     IF MCU_48MHZ == 1
0DD2    7595FC        6284     	MOV	TMR3H, #0FCH
                      6285     ELSE
                               	MOV	TMR3H, #0FEH
                               ENDIF
                      6288     COMP_READ_WRONG_TIMEOUT_SET: 
0DD5    759104        6289     	MOV	TMR3CN, #04H				; Timer3 enabled and interrupt flag cleared
0DD8    D260          6290     SETB FLAGS0 . 0 
0DDA    43E680        6291     	ORL	EIE1, #80H				; Enable timer3 interrupts
0DDD    A134          6292     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      6293     
                      6294     COMP_READ_WRONG_LOW_RPM: 
0DDF    AE3D          6295     MOV R6 , COMM_PERIOD4X_L 
0DE1    AF3E          6296     MOV R7 , COMM_PERIOD4X_H 
                      6297     IF MCU_48MHZ == 1
0DE3    C3            6298     	CLR	C
0DE4    EE            6299     MOV A , R6 
0DE5    33            6300     	RLC	A
0DE6    FE            6301     MOV R6 , A 
0DE7    EF            6302     MOV A , R7 
0DE8    33            6303     	RLC	A
0DE9    FF            6304     MOV R7 , A 
                      6305     ENDIF
0DEA    C3            6306     	CLR	C
0DEB    E4            6307     	CLR	A
0DEC    9E            6308     SUBB A , R6 
0DED    F594          6309     	MOV	TMR3L, A
0DEF    E4            6310     	CLR	A
0DF0    9F            6311     SUBB A , R7 
0DF1    F595          6312     	MOV	TMR3H, A
0DF3    A1D5          6313     	AJMP	COMP_READ_WRONG_TIMEOUT_SET
                      6314     
                      6315     COMP_READ_OK: 
0DF5    C3            6316     	CLR	C
0DF6    E533          6317     	MOV	A, STARTUP_CNT				; Force a timeout for the first commutations			
0DF8    9402          6318     	SUBB	A, #2
0DFA    5002          6319     	JNC	($+4)
0DFC    A134          6320     	AJMP	WAIT_FOR_COMP_OUT_START
                      6321     
0DFE    306502        6322     JNB FLAGS0 . 5 , ( $+5 ) 
0E01    A134          6323     	AJMP	WAIT_FOR_COMP_OUT_START
                      6324     
0E03    D802          6325     DJNZ R0 , COMP_READ_OK_JMP 
0E05    C109          6326     	AJMP	($+4)
                      6327     
                      6328     COMP_READ_OK_JMP: 
0E07    A15D          6329     	AJMP	COMP_WAIT_ON_COMP_ABLE	
                      6330     
0E09    C26C          6331     CLR FLAGS1 . 4 
0E0B    22            6332     	RET							
                      6333     
                      6334     
                      6335     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6336     ;
                      6337     ; Evaluate comparator integrity
                      6338     ;
                      6339     ; No assumptions
                      6340     ;
                      6341     ; Checks comparator signal behaviour versus expected behaviour
                      6342     ;
                      6343     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6344     EVALUATE_COMPARATOR_INTEGRITY: 
0E0C    E52D          6345     	MOV	A, FLAGS1
0E0E    5406          6346     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0E10    6008          6347     	JZ	EVAL_COMP_CHECK_TIMEOUT
                      6348     
0E12    206A02        6349     JB FLAGS1 . 2 , ( $+5 ) 
0E15    0533          6350     	INC	STARTUP_CNT					; Increment counter
0E17    020E2A        6351     	JMP	EVAL_COMP_EXIT
                      6352     
                      6353     EVAL_COMP_CHECK_TIMEOUT: 
0E1A    306C0D        6354     JNB FLAGS1 . 4 , EVAL_COMP_EXIT 
0E1D    206B0A        6355     JB FLAGS1 . 3 , EVAL_COMP_EXIT 
0E20    206507        6356     JB FLAGS0 . 5 , EVAL_COMP_EXIT 
0E23    1581          6357     	DEC	SP								; Routine exit without "ret" command
0E25    1581          6358     	DEC	SP
0E27    02170A        6359     	LJMP	RUN_TO_WAIT_FOR_POWER_ON_FAIL			; Yes - exit run mode
                      6360     
                      6361     EVAL_COMP_EXIT: 
0E2A    22            6362     	RET
                      6363     
                      6364     
                      6365     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6366     ;
                      6367     ; Setup commutation timing routine
                      6368     ;
                      6369     ; No assumptions
                      6370     ;
                      6371     ; Sets up and starts wait from commutation to zero cross
                      6372     ;
                      6373     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6374     SETUP_COMM_WAIT:  
0E2B    53E67F        6375     	ANL	EIE1, #7FH		; Disable timer3 interrupts
0E2E    759100        6376     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
0E31    855194        6377     	MOV	TMR3L, WT_COMM_START_L
0E34    855295        6378     	MOV	TMR3H, WT_COMM_START_H
0E37    759104        6379     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
                      6380     	; Setup next wait time
0E3A    854B53        6381     	MOV	NEXT_WT_START_L, WT_ADV_START_L
0E3D    854C54        6382     	MOV	NEXT_WT_START_H, WT_ADV_START_H
0E40    D260          6383     SETB FLAGS0 . 0 
0E42    43E680        6384     	ORL	EIE1, #80H		; Enable timer3 interrupts
0E45    D2AF          6385     	SETB	EA				; Enable interrupts again
0E47    22            6386     	RET
                      6387     
                      6388     
                      6389     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6390     ;
                      6391     ; Wait for commutation routine
                      6392     ;
                      6393     ; No assumptions
                      6394     ;
                      6395     ; Waits from zero cross to commutation 
                      6396     ;
                      6397     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6398     WAIT_FOR_COMM:  
                      6399     	; Update demag metric
0E48    7800          6400     MOV R0 , # 0 
0E4A    306405        6401     JNB FLAGS0 . 4 , ( $+8 ) 
0E4D    306502        6402     JNB FLAGS0 . 5 , ( $+5 ) 
                      6403     
0E50    7801          6404     MOV R0 , # 1 
                      6405     
0E52    E536          6406     	MOV	A, DEMAG_DETECTED_METRIC	; Sliding average of 8, 256 when demag and 0 when not. Limited to minimum 120
0E54    75F007        6407     	MOV	B, #7
0E57    A4            6408     	MUL	AB					; Multiply by 7
0E58    F9            6409     MOV R1 , A 
0E59    E5F0          6410     	MOV	A, B					; Add new value for current demag status
0E5B    28            6411     ADD A , R0 
0E5C    F5F0          6412     	MOV	B, A
0E5E    E9            6413     MOV A , R1 
0E5F    A2F0          6414     	MOV	C, B.0				; Divide by 8
0E61    13            6415     	RRC	A					
0E62    A2F1          6416     	MOV	C, B.1
0E64    13            6417     	RRC	A
0E65    A2F2          6418     	MOV	C, B.2
0E67    13            6419     	RRC	A
0E68    F536          6420     	MOV	DEMAG_DETECTED_METRIC, A
0E6A    C3            6421     	CLR	C
0E6B    9478          6422     	SUBB	A, #120				; Limit to minimum 120
0E6D    5003          6423     	JNC	($+5)
                      6424     
0E6F    753678        6425     	MOV	DEMAG_DETECTED_METRIC, #120
                      6426     
0E72    C3            6427     	CLR	C
0E73    E536          6428     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0E75    9537          6429     	SUBB	A, DEMAG_PWR_OFF_THRESH
0E77    4008          6430     	JC	WAIT_FOR_COMM_WAIT		; Cut power if many consecutive demags. This will help retain sync during hard accelerations
                      6431     
0E79    D266          6432     SETB FLAGS0 . 6 
                      6433     	ALL_NFETS_OFF
0E7B    C293          6433+1   CLR P1 . 3 
0E7D    C297          6433+1   CLR P1 . 7 
0E7F    C294          6433+1   CLR P1 . 4 
                      6434     
                      6435     WAIT_FOR_COMM_WAIT: 
0E81    306002        6436     JNB FLAGS0 . 0 , ( $+5 ) 
0E84    C181          6437     	AJMP	WAIT_FOR_COMM_WAIT					
                      6438     
                      6439     	; Setup next wait time
0E86    854D53        6440     	MOV	NEXT_WT_START_L, WT_ZC_SCAN_START_L
0E89    854E54        6441     	MOV	NEXT_WT_START_H, WT_ZC_SCAN_START_H
0E8C    D260          6442     SETB FLAGS0 . 0 
0E8E    43E680        6443     	ORL	EIE1, #80H			; Enable timer3 interrupts
0E91    22            6444     	RET
                      6445     
                      6446     
                      6447     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6448     ;
                      6449     ; Commutation routines
                      6450     ;
                      6451     ; No assumptions
                      6452     ;
                      6453     ; Performs commutation switching 
                      6454     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      6455     ;
                      6456     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6457     ; Comm phase 1 to comm phase 2
                      6458     COMM1COMM2: 	
                      6459     	SET_RPM_OUT
0E92    207D11        6460     JB FLAGS3 . 5 , COMM12_REV 
                      6461     
0E95    C2AF          6462     	CLR 	EA					; Disable all interrupts
0E97    754002        6463     	MOV	COMM_PHASE, #2
                      6464     	BPFET_OFF 				; Turn off pfet
0E9A    C295          6464+1   CLR P1 . 5 
                      6465     	APFET_ON					; Turn on pfet
0E9C    D292          6465+1   SETB P1 . 2 
0E9E    D2AF          6466     	SETB	EA
                      6467     	SET_COMP_PHASE_B 			; Set comparator phase
0EA0    759F80        6467+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EA3    021061        6468     	JMP	COMM_EXIT
                      6469     
                      6470     COMM12_REV: 	
0EA6    C2AF          6471     	CLR 	EA					; Disable all interrupts
0EA8    754002        6472     	MOV	COMM_PHASE, #2
                      6473     	BPFET_OFF 				; Turn off pfet
0EAB    C295          6473+1   CLR P1 . 5 
                      6474     	CPFET_ON					; Turn on pfet (reverse)
0EAD    D296          6474+1   SETB P1 . 6 
0EAF    D2AF          6475     	SETB	EA
                      6476     	SET_COMP_PHASE_B 			; Set comparator phase
0EB1    759F80        6476+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EB4    021061        6477     	JMP	COMM_EXIT
                      6478     
                      6479     
                      6480     ; Comm phase 2 to comm phase 3
                      6481     COMM2COMM3: 	
                      6482     	CLEAR_RPM_OUT
0EB7    307243        6483     JNB FLAGS2 . 2 , COMM23_NONDAMP 
                      6484     
                      6485     	; Comm2Comm3 Damped
0EBA    207D20        6486     JB FLAGS3 . 5 , COMM23_DAMP_REV 
                      6487     
0EBD    C2AF          6488     	CLR 	EA					; Disable all interrupts
0EBF    754003        6489     	MOV	COMM_PHASE, #3
0EC2    9001A5        6490     	MOV	DPTR, #PWM_BFET_DAMPED	
0EC5    757B20        6491     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6492     	CNFET_OFF					; Turn off fets
0EC8    C297          6492+1   CLR P1 . 7 
                      6493     	CPFET_OFF						
0ECA    C296          6493+1   CLR P1 . 6 
0ECC    306204        6494     JNB FLAGS0 . 2 , COMM23_NFET_OFF 
                      6495     	BNFET_ON					; Pwm on - turn on nfet
0ECF    D294          6495+1   SETB P1 . 4 
0ED1    C1D5          6496     	AJMP	COMM23_FETS_DONE
                      6497     COMM23_NFET_OFF: 
                      6498     	BPFET_ON					; Pwm off - switch damping fets	
0ED3    D295          6498+1   SETB P1 . 5 
                      6499     COMM23_FETS_DONE: 
0ED5    D2AF          6500     	SETB	EA
                      6501     	SET_COMP_PHASE_C 			; Set comparator phase
0ED7    759F89        6501+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0EDA    021061        6502     	LJMP	COMM_EXIT
                      6503     
                      6504     	; Comm2Comm3 Damped reverse
                      6505     COMM23_DAMP_REV: 
0EDD    C2AF          6506     	CLR 	EA					; Disable all interrupts
0EDF    754003        6507     	MOV	COMM_PHASE, #3
0EE2    9001A5        6508     	MOV	DPTR, #PWM_BFET_DAMPED	
0EE5    757B20        6509     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6510     	ANFET_OFF					; Turn off fets (reverse)
0EE8    C293          6510+1   CLR P1 . 3 
                      6511     	APFET_OFF						
0EEA    C292          6511+1   CLR P1 . 2 
0EEC    306204        6512     JNB FLAGS0 . 2 , COMM23_NFET_OFF_REV 
                      6513     	BNFET_ON					; Pwm on - turn on nfet
0EEF    D294          6513+1   SETB P1 . 4 
0EF1    C1F5          6514     	AJMP	COMM23_FETS_DONE_REV
                      6515     COMM23_NFET_OFF_REV: 
                      6516     	BPFET_ON					; Pwm off - switch damping fets	
0EF3    D295          6516+1   SETB P1 . 5 
                      6517     COMM23_FETS_DONE_REV: 
0EF5    D2AF          6518     	SETB	EA
                      6519     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0EF7    759F81        6519+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0EFA    021061        6520     	LJMP	COMM_EXIT
                      6521     
                      6522     	; Comm2Comm3 Non-damped
                      6523     COMM23_NONDAMP: 
0EFD    207D17        6524     JB FLAGS3 . 5 , COMM23_NONDAMP_REV 
                      6525     
0F00    C2AF          6526     	CLR 	EA					; Disable all interrupts
0F02    754003        6527     	MOV	COMM_PHASE, #3
0F05    900180        6528     	MOV	DPTR, #PWM_BFET	
                      6529     	CNFET_OFF					; Turn off nfet
0F08    C297          6529+1   CLR P1 . 7 
0F0A    306202        6530     JNB FLAGS0 . 2 , COMM23_NFET_DONE 
                      6531     	BNFET_ON					; Yes - turn on nfet
0F0D    D294          6531+1   SETB P1 . 4 
                      6532     COMM23_NFET_DONE: 
0F0F    D2AF          6533     	SETB	EA
                      6534     	SET_COMP_PHASE_C 			; Set comparator phase
0F11    759F89        6534+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F14    021061        6535     	LJMP	COMM_EXIT
                      6536     
                      6537     	; Comm2Comm3 Non-damped reverse
                      6538     COMM23_NONDAMP_REV: 
0F17    C2AF          6539     	CLR 	EA					; Disable all interrupts
0F19    754003        6540     	MOV	COMM_PHASE, #3
0F1C    900180        6541     	MOV	DPTR, #PWM_BFET	
                      6542     	ANFET_OFF					; Turn off nfet (reverse)
0F1F    C293          6542+1   CLR P1 . 3 
0F21    306202        6543     JNB FLAGS0 . 2 , COMM23_NFET_DONE_REV 
                      6544     	BNFET_ON					; Yes - turn on nfet
0F24    D294          6544+1   SETB P1 . 4 
                      6545     COMM23_NFET_DONE_REV: 
0F26    D2AF          6546     	SETB	EA
                      6547     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0F28    759F81        6547+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F2B    021061        6548     	LJMP	COMM_EXIT
                      6549     
                      6550     
                      6551     ; Comm phase 3 to comm phase 4
                      6552     COMM3COMM4: 	
                      6553     	SET_RPM_OUT
0F2E    207D11        6554     JB FLAGS3 . 5 , COMM34_REV 
                      6555     
0F31    C2AF          6556     	CLR 	EA					; Disable all interrupts
0F33    754004        6557     	MOV	COMM_PHASE, #4
                      6558     	APFET_OFF 				; Turn off pfet
0F36    C292          6558+1   CLR P1 . 2 
                      6559     	CPFET_ON					; Turn on pfet
0F38    D296          6559+1   SETB P1 . 6 
0F3A    D2AF          6560     	SETB	EA
                      6561     	SET_COMP_PHASE_A 			; Set comparator phase
0F3C    759F81        6561+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F3F    021061        6562     	JMP	COMM_EXIT
                      6563     
                      6564     COMM34_REV: 	
0F42    C2AF          6565     	CLR 	EA					; Disable all interrupts
0F44    754004        6566     	MOV	COMM_PHASE, #4
                      6567     	CPFET_OFF 				; Turn off pfet (reverse)
0F47    C296          6567+1   CLR P1 . 6 
                      6568     	APFET_ON					; Turn on pfet (reverse)
0F49    D292          6568+1   SETB P1 . 2 
0F4B    D2AF          6569     	SETB	EA
                      6570     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0F4D    759F89        6570+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F50    021061        6571     	JMP	COMM_EXIT
                      6572     
                      6573     
                      6574     ; Comm phase 4 to comm phase 5
                      6575     COMM4COMM5: 	
                      6576     	CLEAR_RPM_OUT
0F53    307243        6577     JNB FLAGS2 . 2 , COMM45_NONDAMP 
                      6578     
                      6579     	; Comm4Comm5 Damped
0F56    207D20        6580     JB FLAGS3 . 5 , COMM45_DAMP_REV 
                      6581     
0F59    C2AF          6582     	CLR 	EA					; Disable all interrupts
0F5B    754005        6583     	MOV	COMM_PHASE, #5
0F5E    900194        6584     	MOV	DPTR, #PWM_AFET_DAMPED	
0F61    757B04        6585     	MOV	DAMPINGFET, #(1 SHL APFET)
                      6586     	BNFET_OFF					; Turn off fets
0F64    C294          6586+1   CLR P1 . 4 
                      6587     	BPFET_OFF						
0F66    C295          6587+1   CLR P1 . 5 
0F68    306204        6588     JNB FLAGS0 . 2 , COMM45_NFET_OFF 
                      6589     	ANFET_ON					; Pwm on - turn on nfet
0F6B    D293          6589+1   SETB P1 . 3 
0F6D    E171          6590     	AJMP	COMM45_FETS_DONE
                      6591     COMM45_NFET_OFF: 
                      6592     	APFET_ON					; Pwm off - switch damping fets	
0F6F    D292          6592+1   SETB P1 . 2 
                      6593     COMM45_FETS_DONE: 
0F71    D2AF          6594     	SETB	EA
                      6595     	SET_COMP_PHASE_B 			; Set comparator phase
0F73    759F80        6595+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F76    021061        6596     	LJMP	COMM_EXIT
                      6597     
                      6598     	; Comm4Comm5 Damped reverse
                      6599     COMM45_DAMP_REV: 
0F79    C2AF          6600     	CLR 	EA					; Disable all interrupts
0F7B    754005        6601     	MOV	COMM_PHASE, #5
0F7E    9001B6        6602     	MOV	DPTR, #PWM_CFET_DAMPED	; (reverse)
0F81    757B40        6603     	MOV	DAMPINGFET, #(1 SHL CPFET)	; (reverse)
                      6604     	BNFET_OFF					; Turn off fets
0F84    C294          6604+1   CLR P1 . 4 
                      6605     	BPFET_OFF						
0F86    C295          6605+1   CLR P1 . 5 
0F88    306204        6606     JNB FLAGS0 . 2 , COMM45_NFET_OFF_REV 
                      6607     	CNFET_ON					; Pwm on - turn on nfet (reverse)
0F8B    D297          6607+1   SETB P1 . 7 
0F8D    E191          6608     	AJMP	COMM45_FETS_DONE_REV
                      6609     COMM45_NFET_OFF_REV: 
                      6610     	CPFET_ON					; Pwm off - switch damping fets (reverse)	
0F8F    D296          6610+1   SETB P1 . 6 
                      6611     COMM45_FETS_DONE_REV: 
0F91    D2AF          6612     	SETB	EA
                      6613     	SET_COMP_PHASE_B 			; Set comparator phase
0F93    759F80        6613+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F96    021061        6614     	LJMP	COMM_EXIT
                      6615     
                      6616     	; Comm4Comm5 Non-damped
                      6617     COMM45_NONDAMP: 
0F99    207D17        6618     JB FLAGS3 . 5 , COMM45_NONDAMP_REV 
                      6619     
0F9C    C2AF          6620     	CLR 	EA					; Disable all interrupts
0F9E    754005        6621     	MOV	COMM_PHASE, #5
0FA1    900176        6622     	MOV	DPTR, #PWM_AFET	
                      6623     	BNFET_OFF					; Turn off nfet
0FA4    C294          6623+1   CLR P1 . 4 
0FA6    306202        6624     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      6625     	ANFET_ON					; Yes - turn on nfet
0FA9    D293          6625+1   SETB P1 . 3 
                      6626     COMM45_NFET_DONE: 
0FAB    D2AF          6627     	SETB	EA
                      6628     	SET_COMP_PHASE_B 			; Set comparator phase
0FAD    759F80        6628+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0FB0    021061        6629     	LJMP	COMM_EXIT
                      6630     
                      6631     	; Comm4Comm5 Non-damped reverse
                      6632     COMM45_NONDAMP_REV: 
0FB3    C2AF          6633     	CLR 	EA					; Disable all interrupts
0FB5    754005        6634     	MOV	COMM_PHASE, #5
0FB8    90018A        6635     	MOV	DPTR, #PWM_CFET		;  (reverse)
                      6636     	BNFET_OFF					; Turn off nfet
0FBB    C294          6636+1   CLR P1 . 4 
0FBD    3062EB        6637     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      6638     	CNFET_ON					; Yes - turn on nfet (reverse)
0FC0    D297          6638+1   SETB P1 . 7 
0FC2    D2AF          6639     	SETB	EA
                      6640     	SET_COMP_PHASE_B 			; Set comparator phase
0FC4    759F80        6640+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0FC7    021061        6641     	LJMP	COMM_EXIT
                      6642     
                      6643     
                      6644     ; Comm phase 5 to comm phase 6
                      6645     COMM5COMM6: 	
                      6646     	SET_RPM_OUT
0FCA    207D11        6647     JB FLAGS3 . 5 , COMM56_REV 
                      6648     
0FCD    C2AF          6649     	CLR 	EA					; Disable all interrupts
0FCF    754006        6650     	MOV	COMM_PHASE, #6
                      6651     	CPFET_OFF 				; Turn off pfet
0FD2    C296          6651+1   CLR P1 . 6 
                      6652     	BPFET_ON					; Turn on pfet
0FD4    D295          6652+1   SETB P1 . 5 
0FD6    D2AF          6653     	SETB	EA
                      6654     	SET_COMP_PHASE_C 			; Set comparator phase
0FD8    759F89        6654+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0FDB    021061        6655     	JMP	COMM_EXIT
                      6656     
                      6657     COMM56_REV: 
0FDE    C2AF          6658     	CLR 	EA					; Disable all interrupts
0FE0    754006        6659     	MOV	COMM_PHASE, #6
                      6660     	APFET_OFF 				; Turn off pfet (reverse)
0FE3    C292          6660+1   CLR P1 . 2 
                      6661     	BPFET_ON					; Turn on pfet
0FE5    D295          6661+1   SETB P1 . 5 
0FE7    D2AF          6662     	SETB	EA
                      6663     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0FE9    759F81        6663+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0FEC    021061        6664     	JMP	COMM_EXIT
                      6665     
                      6666     
                      6667     ; Comm phase 6 to comm phase 1
                      6668     COMM6COMM1: 	
                      6669     	CLEAR_RPM_OUT
0FEF    307242        6670     JNB FLAGS2 . 2 , COMM61_NONDAMP 
                      6671     
                      6672     	; Comm6Comm1 Damped
0FF2    207D20        6673     JB FLAGS3 . 5 , COMM61_DAMP_REV 
                      6674     
0FF5    C2AF          6675     	CLR 	EA					; Disable all interrupts
0FF7    754001        6676     	MOV	COMM_PHASE, #1
0FFA    9001B6        6677     	MOV	DPTR, #PWM_CFET_DAMPED	
0FFD    757B40        6678     	MOV	DAMPINGFET, #(1 SHL CPFET)
                      6679     	ANFET_OFF					; Turn off fets
1000    C293          6679+1   CLR P1 . 3 
                      6680     	APFET_OFF						
1002    C292          6680+1   CLR P1 . 2 
1004    306204        6681     JNB FLAGS0 . 2 , COMM61_NFET_OFF 
                      6682     	CNFET_ON					; Pwm on - turn on nfet
1007    D297          6682+1   SETB P1 . 7 
1009    010D          6683     	AJMP	COMM61_FETS_DONE
                      6684     COMM61_NFET_OFF: 
                      6685     	CPFET_ON					; Pwm off - switch damping fets	
100B    D296          6685+1   SETB P1 . 6 
                      6686     COMM61_FETS_DONE: 
100D    D2AF          6687     	SETB	EA
                      6688     	SET_COMP_PHASE_A 			; Set comparator phase
100F    759F81        6688+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
1012    021061        6689     	LJMP	COMM_EXIT
                      6690     
                      6691     	; Comm6Comm1 Damped reverse
                      6692     COMM61_DAMP_REV: 
1015    C2AF          6693     	CLR 	EA					; Disable all interrupts
1017    754001        6694     	MOV	COMM_PHASE, #1
101A    900194        6695     	MOV	DPTR, #PWM_AFET_DAMPED	; (reverse)	
101D    757B04        6696     	MOV	DAMPINGFET, #(1 SHL APFET)	; (reverse)
                      6697     	CNFET_OFF					; Turn off fets (reverse)
1020    C297          6697+1   CLR P1 . 7 
                      6698     	CPFET_OFF						
1022    C296          6698+1   CLR P1 . 6 
1024    306204        6699     JNB FLAGS0 . 2 , COMM61_NFET_OFF_REV 
                      6700     	ANFET_ON					; Pwm on - turn on nfet
1027    D293          6700+1   SETB P1 . 3 
1029    012D          6701     	AJMP	COMM61_FETS_DONE_REV
                      6702     COMM61_NFET_OFF_REV: 
                      6703     	APFET_ON					; Pwm off - switch damping fets (reverse)	
102B    D292          6703+1   SETB P1 . 2 
                      6704     COMM61_FETS_DONE_REV: 
102D    D2AF          6705     	SETB	EA
                      6706     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
102F    759F89        6706+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
1032    0161          6707     	AJMP	COMM_EXIT
                      6708     
                      6709     	; Comm6Comm1 Non-damped
                      6710     COMM61_NONDAMP: 
1034    207D16        6711     JB FLAGS3 . 5 , COMM61_NONDAMP_REV 
                      6712     
1037    C2AF          6713     	CLR 	EA					; Disable all interrupts
1039    754001        6714     	MOV	COMM_PHASE, #1
103C    90018A        6715     	MOV	DPTR, #PWM_CFET	
                      6716     	ANFET_OFF					; Turn off nfet
103F    C293          6716+1   CLR P1 . 3 
1041    306202        6717     JNB FLAGS0 . 2 , COMM61_NFET_DONE 
                      6718     	CNFET_ON					; Yes - turn on nfet
1044    D297          6718+1   SETB P1 . 7 
                      6719     COMM61_NFET_DONE: 
1046    D2AF          6720     	SETB	EA
                      6721     	SET_COMP_PHASE_A 			; Set comparator phase
1048    759F81        6721+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
104B    0161          6722     	AJMP	COMM_EXIT
                      6723     
                      6724     	; Comm6Comm1 Non-damped reverse
                      6725     COMM61_NONDAMP_REV: 
104D    C2AF          6726     	CLR 	EA					; Disable all interrupts
104F    754001        6727     	MOV	COMM_PHASE, #1
1052    900176        6728     	MOV	DPTR, #PWM_AFET		; (reverse)
                      6729     	CNFET_OFF					; Turn off nfet (reverse)
1055    C297          6729+1   CLR P1 . 7 
1057    306202        6730     JNB FLAGS0 . 2 , COMM61_NFET_DONE_REV 
                      6731     	ANFET_ON					; Yes - turn on nfet (reverse)
105A    D293          6731+1   SETB P1 . 3 
                      6732     COMM61_NFET_DONE_REV: 
105C    D2AF          6733     	SETB	EA
                      6734     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
105E    759F89        6734+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
                      6735     
                      6736     COMM_EXIT: 
1061    C266          6737     CLR FLAGS0 . 6 
1063    22            6738     	RET
                      6739     
                      6740     
                      6741     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6742     ;
                      6743     ; Switch power off routine
                      6744     ;
                      6745     ; No assumptions
                      6746     ;
                      6747     ; Switches all fets off 
                      6748     ;
                      6749     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6750     SWITCH_POWER_OFF: 
1064    900174        6751     	MOV	DPTR, #PWM_NOFET	; Set DPTR register to pwm_nofet		
1067    757B00        6752     	MOV	DAMPINGFET, #0
                      6753     	ALL_NFETS_OFF			; Turn off all nfets
106A    C293          6753+1   CLR P1 . 3 
106C    C297          6753+1   CLR P1 . 7 
106E    C294          6753+1   CLR P1 . 4 
                      6754     	ALL_PFETS_OFF			; Turn off all pfets
1070    C292          6754+1   CLR P1 . 2 
1072    C296          6754+1   CLR P1 . 6 
1074    C295          6754+1   CLR P1 . 5 
1076    C262          6755     CLR FLAGS0 . 2 
1078    22            6756     	RET			
                      6757     
                      6758     
                      6759     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6760     ;
                      6761     ; Set default parameters
                      6762     ;
                      6763     ; No assumptions
                      6764     ;
                      6765     ; Sets default programming parameters
                      6766     ;
                      6767     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6768     SET_DEFAULT_PARAMETERS: 
                      6769     IF MODE == 0	; Main
1079    7880          6770     MOV R0 , # PGM_GOV_P_GAIN 
107B    7607          6771     MOV @ R0 , # 7 
107D    08            6772     INC R0 
107E    7607          6773     MOV @ R0 , # 7 
1080    08            6774     INC R0 
1081    7601          6775     MOV @ R0 , # 1 
1083    08            6776     INC R0 
1084    7604          6777     MOV @ R0 , # 4 
1086    08            6778     INC R0 
1087    76FF          6779     MOV @ R0 , # 0FFH 
1089    08            6780     INC R0 
108A    76FF          6781     MOV @ R0 , # 0FFH 
108C    08            6782     INC R0 
108D    7609          6783     MOV @ R0 , # 9 
108F    08            6784     INC R0 
1090    7602          6785     MOV @ R0 , # 2 
1092    08            6786     INC R0 
1093    7601          6787     MOV @ R0 , # 1 
1095    08            6788     INC R0 
1096    7601          6789     MOV @ R0 , # 1 
                      6790     
1098    788C          6791     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
109A    7601          6792     MOV @ R0 , # 1 
109C    08            6793     INC R0 
109D    7600          6794     MOV @ R0 , # 0 
109F    08            6795     INC R0 
10A0    76B4          6796     MOV @ R0 , # 180 
10A2    08            6797     INC R0 
10A3    76FF          6798     MOV @ R0 , # 0FFH 
10A5    08            6799     INC R0 
10A6    76FF          6800     MOV @ R0 , # 0FFH 
10A8    08            6801     INC R0 
10A9    76FF          6802     MOV @ R0 , # 0FFH 
10AB    08            6803     INC R0 
10AC    7603          6804     MOV @ R0 , # 3 
10AE    08            6805     INC R0 
10AF    76FF          6806     MOV @ R0 , # 0FFH 
10B1    08            6807     INC R0 
10B2    7601          6808     MOV @ R0 , # 1 
10B4    08            6809     INC R0 
10B5    76FF          6810     MOV @ R0 , # 0FFH 
10B7    08            6811     INC R0 
10B8    7625          6812     MOV @ R0 , # 37 
10BA    08            6813     INC R0 
10BB    76D0          6814     MOV @ R0 , # 208 
10BD    08            6815     INC R0 
10BE    7678          6816     MOV @ R0 , # 120 
10C0    08            6817     INC R0 
10C1    76C8          6818     MOV @ R0 , # 200 
10C3    08            6819     INC R0 
10C4    7604          6820     MOV @ R0 , # 4 
10C6    08            6821     INC R0 
10C7    76FF          6822     MOV @ R0 , # 0FFH 
10C9    08            6823     INC R0 
10CA    7601          6824     MOV @ R0 , # 1 
10CC    08            6825     INC R0 
10CD    7600          6826     MOV @ R0 , # 0 
10CF    08            6827     INC R0 
10D0    767A          6828     MOV @ R0 , # 122 
10D2    08            6829     INC R0 
10D3    760A          6830     MOV @ R0 , # 10 
10D5    08            6831     INC R0 
10D6    7601          6832     MOV @ R0 , # 1 
10D8    08            6833     INC R0 
10D9    7601          6834     MOV @ R0 , # 1 
10DB    08            6835     INC R0 
10DC    7600          6836     MOV @ R0 , # 0 
10DE    08            6837     INC R0 
10DF    76FF          6838     MOV @ R0 , # 0FFH 
                      6839     ENDIF
                      6840     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_DITHER
                               ENDIF
                      6911     IF MODE == 2	; Multi
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MULTI_PWM_DITHER
                               ENDIF
10E1    22            6982     	RET
                      6983     
                      6984     
                      6985     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6986     ;
                      6987     ; Decode parameters
                      6988     ;
                      6989     ; No assumptions
                      6990     ;
                      6991     ; Decodes programming parameters
                      6992     ;
                      6993     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6994     DECODE_PARAMETERS: 
                      6995     	; Load programmed pwm frequency
10E2    7887          6996     MOV R0 , # PGM_PWM_FREQ 
10E4    E6            6997     MOV A , @ R0 
10E5    FF            6998     MOV R7 , A 
10E6    C272          6999     CLR FLAGS2 . 2 
                      7000     IF DAMPED_MODE_ENABLE == 1
10E8    BF0302        7001     CJNE R7 , # 3 , ( $+5 ) 
10EB    D272          7002     SETB FLAGS2 . 2 
                      7003     ENDIF
                      7004     	; Load programmed direction
10ED    7888          7005     MOV R0 , # PGM_DIRECTION 
                      7006     IF MODE >= 1	; Tail or multi
                               	MOV	A, @TEMP1				
                               	CLR	C
                               	SUBB	A, #3
                               	JZ	DECODE_PARAMS_DIR_SET
                               ENDIF
                      7012     
10EF    C27D          7013     CLR FLAGS3 . 5 
10F1    E6            7014     MOV A , @ R0 
10F2    30E102        7015     	JNB	ACC.1, ($+5)
10F5    D27D          7016     SETB FLAGS3 . 5 
                      7017     DECODE_PARAMS_DIR_SET: 
10F7    C27E          7018     CLR FLAGS3 . 6 
10F9    7889          7019     MOV R0 , # PGM_INPUT_POL 
10FB    E6            7020     MOV A , @ R0 
10FC    30E102        7021     	JNB	ACC.1, ($+5)
10FF    D27E          7022     SETB FLAGS3 . 6 
1101    C3            7023     	CLR	C
1102    EF            7024     MOV A , R7 
1103    9402          7025     	SUBB	A, #2
1105    6008          7026     	JZ	DECODE_PWM_FREQ_LOW
                      7027     
1107    758E01        7028     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
110A    D273          7029     SETB FLAGS2 . 3 
110C    021114        7030     	JMP	DECODE_PWM_FREQ_END
                      7031     
                      7032     DECODE_PWM_FREQ_LOW: 
110F    758E00        7033     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
1112    C273          7034     CLR FLAGS2 . 3 
                      7035     
                      7036     DECODE_PWM_FREQ_END: 
1114    22            7037     	RET
                      7038     
                      7039     
                      7040     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7041     ;
                      7042     ; Decode settings
                      7043     ;
                      7044     ; No assumptions
                      7045     ;
                      7046     ; Decodes various settings
                      7047     ;
                      7048     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7049     DECODE_SETTINGS: 
                      7050     	; Decode governor gains
1115    7880          7051     MOV R0 , # PGM_GOV_P_GAIN 
1117    E6            7052     MOV A , @ R0 
1118    14            7053     	DEC	A	
1119    900080        7054     	MOV	DPTR, #GOV_GAIN_TABLE
111C    93            7055     	MOVC A, @A+DPTR	
111D    78A4          7056     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
111F    F6            7057     MOV @ R0 , A 
1120    7881          7058     MOV R0 , # PGM_GOV_I_GAIN 
1122    E6            7059     MOV A , @ R0 
1123    14            7060     	DEC	A	
1124    900080        7061     	MOV	DPTR, #GOV_GAIN_TABLE
1127    93            7062     	MOVC A, @A+DPTR	
1128    78A5          7063     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
112A    F6            7064     MOV @ R0 , A 
                      7065     	; Decode startup power
112B    7886          7066     MOV R0 , # PGM_STARTUP_PWR 
112D    E6            7067     MOV A , @ R0 
112E    14            7068     	DEC	A	
112F    90008D        7069     	MOV	DPTR, #STARTUP_POWER_TABLE
1132    93            7070     	MOVC A, @A+DPTR	
1133    78A6          7071     MOV R0 , # PGM_STARTUP_PWR_DECODED 
1135    F6            7072     MOV @ R0 , A 
                      7073     IF MODE == 0	; Main
                      7074     	; Decode spoolup time
1136    789F          7075     MOV R0 , # PGM_MAIN_SPOOLUP_TIME 
1138    E6            7076     MOV A , @ R0 
1139    F8            7077     MOV R0 , A 
113A    7001          7078     	JNZ	($+3)		; If not zero - branch
                      7079     	
113C    08            7080     INC R0 
                      7081     
113D    C3            7082     	CLR	C
113E    E8            7083     MOV A , R0 
113F    9411          7084     	SUBB	A, #17		; Limit to 17 max
1141    4002          7085     	JC	($+4)
                      7086     
1143    7811          7087     MOV R0 , # 17 
                      7088     
1145    E8            7089     MOV A , R0 
1146    28            7090     ADD A , R0 
1147    28            7091     ADD A , R0 
1148    F56B          7092     	MOV	MAIN_SPOOLUP_TIME_3X, A
114A    256B          7093     	ADD	A, MAIN_SPOOLUP_TIME_3X
114C    256B          7094     	ADD	A, MAIN_SPOOLUP_TIME_3X
114E    28            7095     ADD A , R0 
114F    F56C          7096     	MOV	MAIN_SPOOLUP_TIME_10X, A
1151    256B          7097     	ADD	A, MAIN_SPOOLUP_TIME_3X
1153    28            7098     ADD A , R0 
1154    28            7099     ADD A , R0 
1155    F56D          7100     	MOV	MAIN_SPOOLUP_TIME_15X, A
                      7101     ENDIF
                      7102     	; Decode demag compensation
1157    789C          7103     MOV R0 , # PGM_DEMAG_COMP 
1159    E6            7104     MOV A , @ R0 
115A    7537FF        7105     	MOV	DEMAG_PWR_OFF_THRESH, #255	; Set default
115D    75380C        7106     	MOV	LOW_RPM_PWR_SLOPE, #12		; Set default
                      7107     
1160    B40206        7108     	CJNE	A, #2, DECODE_DEMAG_HIGH
                      7109     
1163    7537A0        7110     	MOV	DEMAG_PWR_OFF_THRESH, #160	; Settings for demag comp low
1166    75380A        7111     	MOV	LOW_RPM_PWR_SLOPE, #10		
                      7112     
                      7113     DECODE_DEMAG_HIGH: 
1169    B40306        7114     	CJNE	A, #3, DECODE_DEMAG_DONE
                      7115     
116C    753782        7116     	MOV	DEMAG_PWR_OFF_THRESH, #130	; Settings for demag comp high
116F    753805        7117     	MOV	LOW_RPM_PWR_SLOPE, #5		
                      7118     
                      7119     DECODE_DEMAG_DONE: 
                      7120     	; Decode pwm dither
1172    78A3          7121     MOV R0 , # PGM_PWM_DITHER 
1174    E6            7122     MOV A , @ R0 
1175    14            7123     	DEC	A	
1176    90009A        7124     	MOV	DPTR, #PWM_DITHER_TABLE
1179    93            7125     	MOVC A, @A+DPTR	
117A    F566          7126     	MOV	PWM_DITHER_DECODED, A
117C    1164          7127     	CALL	SWITCH_POWER_OFF			; Reset DPTR
117E    22            7128     	RET
                      7129     
                      7130     
                      7131     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7132     ;
                      7133     ; Set BEC voltage
                      7134     ;
                      7135     ; No assumptions
                      7136     ;
                      7137     ; Sets the BEC output voltage low or high
                      7138     ;
                      7139     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7140     SET_BEC_VOLTAGE: 
                      7141     	; Set bec voltage
                      7142     IF HIGH_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
                      7152     IF HIGH_BEC_VOLTAGE == 2
                               	SET_BEC_0				; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	CJNE	A, #1, SET_BEC_VOLTAGE_2	
                               
                               	SET_BEC_1				; Set to level 1
                               
                               SET_BEC_VOLTAGE_2:
                               	CJNE	A, #2, SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_2				; Set to level 2
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
117F    22            7167     	RET
                      7168     
                      7169     
                      7170     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7171     ;
                      7172     ; Find throttle gain
                      7173     ;
                      7174     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      7175     ;
                      7176     ; Finds throttle gain from throttle calibration values
                      7177     ;
                      7178     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7179     FIND_THROTTLE_GAIN: 
                      7180     	; Load programmed minimum and maximum throttle
1180    7896          7181     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1182    E6            7182     MOV A , @ R0 
1183    FA            7183     MOV R2 , A 
1184    7897          7184     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1186    E6            7185     MOV A , @ R0 
1187    FB            7186     MOV R3 , A 
1188    7888          7187     MOV R0 , # PGM_DIRECTION 
118A    E6            7188     MOV A , @ R0 
118B    B40305        7189     	CJNE	A, #3, FIND_THROTTLE_GAIN_CHECK_FULL
                      7190     
118E    C3            7191     	CLR	C
118F    EB            7192     MOV A , R3 
1190    940E          7193     	SUBB	A, #14				; Compensate for higher deadband in bidirectional
1192    FB            7194     MOV R3 , A 
                      7195     
                      7196     FIND_THROTTLE_GAIN_CHECK_FULL: 
                      7197     	; Check if full range is chosen
1193    307F04        7198     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      7199     
1196    7A00          7200     MOV R2 , # 0 
1198    7BFF          7201     MOV R3 , # 255 
                      7202     
                      7203     FIND_THROTTLE_GAIN_CALCULATE: 
                      7204     	; Calculate difference
119A    C3            7205     	CLR	C
119B    EB            7206     MOV A , R3 
119C    9A            7207     SUBB A , R2 
119D    FC            7208     MOV R4 , A 
                      7209     	; Check that difference is minimum 130
119E    C3            7210     	CLR	C
119F    9482          7211     	SUBB	A, #130
11A1    5002          7212     	JNC	($+4)
                      7213     
11A3    7C82          7214     MOV R4 , # 130 
                      7215     
                      7216     	; Find gain
11A5    757200        7217     	MOV	PPM_THROTTLE_GAIN, #0
                      7218     TEST_THROTTLE_GAIN: 
11A8    0572          7219     	INC	PPM_THROTTLE_GAIN
11AA    EC            7220     MOV A , R4 
11AB    8572F0        7221     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
11AE    A4            7222     	MUL	AB
11AF    C3            7223     	CLR	C
11B0    E5F0          7224     	MOV	A, B
11B2    947D          7225     	SUBB	A, #125
11B4    40F2          7226     	JC	TEST_THROTTLE_GAIN
11B6    22            7227     	RET
                      7228     
                      7229     
                      7230     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7231     ;
                      7232     ; Average throttle 
                      7233     ;
                      7234     ; Outputs result in Temp3
                      7235     ;
                      7236     ; Averages throttle calibration readings
                      7237     ;
                      7238     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7239     AVERAGE_THROTTLE: 
11B7    D27F          7240     SETB FLAGS3 . 7 
11B9    3180          7241     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
11BB    1205ED        7242     	CALL WAIT30MS		
11BE    7A00          7243     MOV R2 , # 0 
11C0    7B00          7244     MOV R3 , # 0 
11C2    7C10          7245     MOV R4 , # 16 
                      7246     AVERAGE_THROTTLE_MEAS: 
11C4    1205E3        7247     	CALL	WAIT3MS			; Wait for new RC pulse value
11C7    E55C          7248     	MOV	A, NEW_RCP		; Get new RC pulse value
11C9    2A            7249     ADD A , R2 
11CA    FA            7250     MOV R2 , A 
11CB    7400          7251     	MOV	A, #0
11CD    3B            7252     ADDC A , R3 
11CE    FB            7253     MOV R3 , A 
11CF    DCF3          7254     DJNZ R4 , AVERAGE_THROTTLE_MEAS 
                      7255     
11D1    7C04          7256     MOV R4 , # 4 
                      7257     AVERAGE_THROTTLE_DIV: 
11D3    C3            7258     	CLR	C
11D4    EB            7259     MOV A , R3 
11D5    13            7260     	RRC	A      
11D6    FB            7261     MOV R3 , A 
11D7    EA            7262     MOV A , R2 
11D8    13            7263     	RRC	A      
11D9    FA            7264     MOV R2 , A 
11DA    DCF7          7265     DJNZ R4 , AVERAGE_THROTTLE_DIV 
                      7266     
11DC    FE            7267     MOV R6 , A 
11DD    C27F          7268     CLR FLAGS3 . 7 
11DF    3180          7269     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
11E1    22            7270     	RET
                      7271     
                      7272     
                      7273     
                      7274     
                      7275     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7276     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7277     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7278     ;
                      7279     ; Main program start
                      7280     ;
                      7281     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7282     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7283     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7284     PGM_START: 
                      7285     	; Check flash lock byte
11E2    E5EF          7286     	MOV	A, RSTSRC			
11E4    20E603        7287     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      7288     
11E7    752000        7289     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      7290     
11EA    0520          7291     	INC	BIT_ACCESS
11EC    903FFF        7292     MOV DPTR , # 16383 
11EF    E520          7293     	MOV	A, BIT_ACCESS
11F1    14            7294     	DEC	A
11F2    6006          7295     	JZ	LOCK_BYTE_TEST
                      7296     
11F4    901FFF        7297     MOV DPTR , # 8191 
11F7    14            7298     	DEC	A
11F8    6000          7299     	JZ	LOCK_BYTE_TEST
                      7300     
                      7301     LOCK_BYTE_TEST: 
11FA    93            7302     	MOVC A, @A+DPTR		; Read lock byte
11FB    04            7303     	INC	A				
11FC    6003          7304     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      7305     
                      7306     IF ONE_S_CAPABLE == 0		
11FE    75EF12        7307     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      7308     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      7311     
                      7312     LOCK_BYTE_OK: 
                      7313     	; Disable the WDT.
                      7314     IF SIGNATURE_001 == 0F3H		
1201    53D9BF        7315     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      7316     ENDIF
                      7317     IF SIGNATURE_001 == 0F8H		
                               	MOV	WDTCN, #0DEH		; Disable watchdog
                               	MOV	WDTCN, #0ADH		
                               ENDIF
                      7321     	; Initialize stack
1204    7581C0        7322     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      7323     	; Initialize VDD monitor
1207    43FF80        7324     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
120A    1205DE        7325     	CALL	WAIT1MS			; Wait at least 100us
                      7326     IF ONE_S_CAPABLE == 0		
120D    75EF02        7327     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      7328     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      7331     	; Set clock frequency
                      7332     IF SIGNATURE_001 == 0F3H		
1210    43B203        7333     	ORL	OSCICN, #03H		; Set clock divider to 1 (not supported on 'f850)
                      7334     ENDIF
                      7335     IF SIGNATURE_001 == 0F8H		
                               	MOV	CLKSEL, #00H		; Set clock divider to 1 (not supported on 'f3xx)
                               ENDIF
1213    E5B3          7338     	MOV	A, OSCICL				
1215    2404          7339     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
1217    20E70D        7340     	JB	ACC.7, RESET_CAL_DONE	; Is carry (7bit) set? - branch
                      7341     
121A    F521          7342     	MOV	BIT_ACCESS_INT, A
                      7343     IF SIGNATURE_002 <> 010H		
121C    E5E3          7344     	MOV	A, OSCLCN
                      7345     ELSE
                               	MOV	A, OSCXCN
                               ENDIF
121E    20E006        7348     	JB	ACC.0, RESET_CAL_DONE	; Set if cal aleady done
                      7349     
1221    8521B3        7350     	MOV	OSCICL, BIT_ACCESS_INT
                      7351     IF SIGNATURE_002 <> 010H		
1224    43E301        7352     	ORL	OSCLCN, #01H			; Tag that cal is done
                      7353     ELSE
                               	ORL	OSCXCN, #01H			; Tag that cal is done
                               ENDIF
                      7356     
                      7357     RESET_CAL_DONE: 
                      7358     	; Switch power off
1227    1164          7359     	CALL	SWITCH_POWER_OFF
                      7360     	; Ports initialization
1229    7580FF        7361     MOV P0 , # 255 
122C    75A400        7362     MOV P0MDOUT , # 0 
122F    75F1F0        7363     MOV P0MDIN , # -16 
1232    75D4DF        7364     MOV P0SKIP , # -33 
1235    759002        7365     MOV P1 , # 2 
1238    75A5FC        7366     MOV P1MDOUT , # 252 
123B    75F2FD        7367     MOV P1MDIN , # -3 
123E    75D502        7368     MOV P1SKIP , # 2 
                      7369     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
1241    75A610        7372     MOV P2MDOUT , # 16 
                      7373     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      7380     	; Initialize the XBAR and related functionality
                      7381     	INITIALIZE_XBAR
1244    75A0FF        7381+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
1247    75F3F1        7381+1   MOV P2MDIN , # -15 
124A    75E241        7381+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      7382     	; Clear RAM
124D    E4            7383     	CLR	A				; Clear accumulator
124E    F8            7384     MOV R0 , A 
                      7385     CLEAR_RAM: 	
124F    F6            7386     MOV @ R0 , A 
1250    D8FD          7387     DJNZ R0 , CLEAR_RAM 
                      7388     	; Initialize LFSR
1252    756801        7389     	MOV	RANDOM, #1
                      7390     	; Set default programmed parameters
1255    1179          7391     	CALL	SET_DEFAULT_PARAMETERS
                      7392     	; Read all programmed parameters
1257    121759        7393     	CALL READ_ALL_EEPROM_PARAMETERS
                      7394     	; Set beep strength
125A    7898          7395     MOV R0 , # PGM_BEEP_STRENGTH 
125C    8673          7396     MOV BEEP_STRENGTH , @ R0 
                      7397     	; Set initial arm variable
125E    753001        7398     	MOV	INITIAL_ARM, #1
                      7399     	; Initializing beep
1261    C2AF          7400     	CLR	EA				; Disable interrupts explicitly
1263    1205F7        7401     	CALL WAIT200MS	
1266    120607        7402     	CALL BEEP_F1
1269    1205ED        7403     	CALL WAIT30MS
126C    12060E        7404     	CALL BEEP_F2
126F    1205ED        7405     	CALL WAIT30MS
1272    120615        7406     	CALL BEEP_F3
1275    1205ED        7407     	CALL WAIT30MS
                      7408     IF MODE <= 1	; Main or tail
                      7409     	; Wait for receiver to initialize
1278    12187F        7410     	CALL	WAIT1S
127B    1205F7        7411     	CALL	WAIT200MS
127E    1205F7        7412     	CALL	WAIT200MS
1281    1205F2        7413     	CALL	WAIT100MS
                      7414     ENDIF
                      7415     
                      7416     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7417     ;
                      7418     ; No signal entry point
                      7419     ;
                      7420     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7421     INIT_NO_SIGNAL: 
                      7422     	; Disable interrupts explicitly
1284    C2AF          7423     	CLR	EA				
                      7424     	; Check if input signal is high for more than 15ms
1286    78FA          7425     MOV R0 , # 250 
                      7426     INPUT_HIGH_CHECK_1: 
1288    79FA          7427     MOV R1 , # 250 
                      7428     INPUT_HIGH_CHECK_2: 
128A    308507        7429     JNB 128 . 5 , BOOTLOADER_DONE 
128D    D9FB          7430     DJNZ R1 , INPUT_HIGH_CHECK_2 
128F    D8F7          7431     DJNZ R0 , INPUT_HIGH_CHECK_1 
                      7432     
1291    021C00        7433     	LJMP	1C00H			; Jump to bootloader
                      7434     
                      7435     BOOTLOADER_DONE: 
                      7436     	; Decode parameters
1294    11E2          7437     	CALL	DECODE_PARAMETERS
                      7438     	; Decode settings
1296    3115          7439     	CALL	DECODE_SETTINGS
                      7440     	; Set BEC voltage
1298    317F          7441     	CALL	SET_BEC_VOLTAGE
                      7442     	; Find throttle gain from stored min and max settings
129A    3180          7443     	CALL	FIND_THROTTLE_GAIN
                      7444     	; Set beep strength
129C    7898          7445     MOV R0 , # PGM_BEEP_STRENGTH 
129E    8673          7446     MOV BEEP_STRENGTH , @ R0 
                      7447     	; Switch power off
12A0    1164          7448     	CALL	SWITCH_POWER_OFF
                      7449     	; Set clock frequency
                      7450     IF MCU_48MHZ == 1
                      7451     	SET_MCU_CLK_24MHZ
12A2    75B680        7451+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
12A5    75A900        7451+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
12A8    757A00        7451+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      7452     ENDIF
                      7453     	; Timer control
12AB    758850        7454     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      7455     	; Timer mode
12AE    758912        7456     	MOV	TMOD, #12H		; Timer0 as 8bit, timer1 as 16bit
                      7457     	; Timer2: clk/12 for 128us and 32ms interrupts
12B1    75C824        7458     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      7459     	; Timer3: clk/12 for commutation timing
12B4    759104        7460     	MOV	TMR3CN, #04H		; Timer3 enabled
                      7461     	; PCA
12B7    75D840        7462     	MOV	PCA0CN, #40H		; PCA enabled
                      7463     	; Enable interrupts
12BA    75A822        7464     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
12BD    75B802        7465     	MOV	IP, #02H			; High priority to timer0 interrupts
12C0    75E690        7466     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      7467     	; Initialize comparator
12C3    759B80        7468     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
12C6    759D00        7469     	MOV	CPT0MD, #00H		; Comparator response time 100ns
                      7470     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #00H		; Comparator response time 100ns
                               ENDIF
                      7474     	; Initialize ADC
                      7475     	INITIALIZE_ADC			; Initialize ADC operation
12C9    75D10E        7475+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
                      7475+1   IF MCU_50MHZ ==0 
12CC    75BC58        7475+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
                      7475+1   ELSE 
                               MOV ADC0CF , # 0C0H  ; ADC CLOCK 2MHZ
                               ENDIF 
12CF    75BB09        7475+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
12D2    75BA11        7475+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
12D5    75E880        7475+1   MOV ADC0CN , # 80H  ; ADC ENABLED
12D8    1205DE        7476     	CALL	WAIT1MS
12DB    D2AF          7477     	SETB	EA				; Enable all interrupts
                      7478     	; Measure number of lipo cells
12DD    120938        7479     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      7480     	; Initialize RC pulse
                      7481     	RCP_INT_FIRST 					; Enable interrupt and set to first edge
12E0    53DACF        7481+1   ANL PCA0CPM0 , # 0CFH 
12E3    207E03        7481+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
12E6    43DA20        7481+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
12E9    307E03        7481+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
12EC    43DA10        7481+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7482     	RCP_INT_ENABLE		 			; Enable interrupt
12EF    43DA01        7482+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      7483     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
12F2    C2D8          7483+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
12F4    C271          7484     CLR FLAGS2 . 1 
12F6    1205F7        7485     	CALL WAIT200MS
                      7486     
                      7487     	; Measure PWM frequency
                      7488     MEASURE_PWM_FREQ_INIT: 	
12F9    D261          7489     SETB FLAGS0 . 1 
12FB    7B03          7490     MOV R3 , # 3 
                      7491     MEASURE_PWM_FREQ_START: 	
12FD    7A0C          7492     MOV R2 , # 12 
                      7493     MEASURE_PWM_FREQ_LOOP: 	
                      7494     	; Check if period diff was accepted
12FF    E55B          7495     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1301    7007          7496     	JNZ	MEASURE_PWM_FREQ_WAIT
                      7497     
1303    7A0C          7498     MOV R2 , # 12 
1305    DB03          7499     DJNZ R3 , ( $+5 ) 
1307    021284        7500     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      7501     
                      7502     MEASURE_PWM_FREQ_WAIT: 
130A    1205ED        7503     	CALL	WAIT30MS						; Wait 30ms for new pulse
130D    207003        7504     JB FLAGS2 . 0 , ( $+6 ) 
1310    021284        7505     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      7506     
1313    C270          7507     CLR FLAGS2 . 0 
1315    E55C          7508     	MOV	A, NEW_RCP					; Load value
1317    C3            7509     	CLR	C
1318    9402          7510     SUBB A , # 2 
131A    40E1          7511     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      7512     
131C    E52F          7513     	MOV	A, FLAGS3						; Check pwm frequency flags
131E    541F          7514     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1320    855E5D        7515     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
1323    F55E          7516     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
1325    B55DD5        7517     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      7518     
1328    DAD5          7519     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      7520     
                      7521     	; Clear measure pwm frequency flag
132A    C261          7522     CLR FLAGS0 . 1 
                      7523     	; Set up RC pulse interrupts after pwm frequency measurement
                      7524     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
132C    53DACF        7524+1   ANL PCA0CPM0 , # 0CFH 
132F    207E03        7524+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1332    43DA20        7524+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1335    307E03        7524+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1338    43DA10        7524+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7525     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
133B    C2D8          7525+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
133D    C271          7526     CLR FLAGS2 . 1 
133F    78A2          7527     MOV R0 , # PGM_ENABLE_PWM_INPUT 
1341    E6            7528     MOV A , @ R0 
1342    7008          7529     	JNZ	TEST_FOR_ONESHOT				; If it is - proceed
                      7530     
1344    D274          7531     SETB FLAGS2 . 4 
1346    E52F          7532     	MOV	A, FLAGS3						; Clear pwm frequency flags
1348    54E0          7533     	ANL	A, #NOT((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
134A    F52F          7534     	MOV	FLAGS3, A
                      7535     
                      7536     TEST_FOR_ONESHOT: 	
                      7537     	; Test whether signal is OneShot125
134C    C275          7538     CLR FLAGS2 . 5 
134E    752900        7539     	MOV	RCP_OUTSIDE_RANGE_CNT, #0		; Reset out of range counter
1351    1205F2        7540     	CALL WAIT100MS						; Wait for new RC pulse
1354    307409        7541     JNB FLAGS2 . 4 , VALIDATE_RCP_START 
                      7542     
1357    C3            7543     	CLR	C
1358    E529          7544     	MOV	A, RCP_OUTSIDE_RANGE_CNT			; Check how many pulses were outside normal PPM range (800-2160us)
135A    940A          7545     	SUBB	A, #10						
135C    4002          7546     	JC	VALIDATE_RCP_START
                      7547     
135E    D275          7548     SETB FLAGS2 . 5 
                      7549     
                      7550     	; Validate RC pulse
                      7551     VALIDATE_RCP_START: 	
1360    1205E3        7552     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1363    7802          7553     MOV R0 , # 2 
1365    307402        7554     JNB FLAGS2 . 4 , ( $+5 ) 
                      7555     
1368    7800          7556     MOV R0 , # 0 
                      7557     
136A    C3            7558     	CLR	C
136B    E55C          7559     	MOV	A, NEW_RCP					; Load value
136D    98            7560     SUBB A , R0 
136E    40F0          7561     	JC	VALIDATE_RCP_START				; No - start over
                      7562     
                      7563     	; Beep arm sequence start signal
1370    C2AF          7564     	CLR 	EA							; Disable all interrupts
1372    120607        7565     	CALL BEEP_F1						; Signal that RC pulse is ready
1375    120607        7566     	CALL BEEP_F1
1378    120607        7567     	CALL BEEP_F1
137B    D2AF          7568     	SETB	EA							; Enable all interrupts
137D    1205F7        7569     	CALL WAIT200MS	
                      7570     
                      7571     	; Arming sequence start
1380    754A00        7572     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      7573     ARMING_START: 
                      7574     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION	; Check if bidirectional operation
                               	MOV	A, @TEMP1				
                               	CJNE	A, #3, ($+5)
                               
                               	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                               ENDIF
                      7581     
1383    1205E3        7582     	CALL WAIT3MS
1386    788C          7583     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1388    E6            7584     MOV A , @ R0 
1389    C3            7585     	CLR	C
138A    9401          7586     	SUBB	A, #1				; Is TX programming enabled?
138C    5003          7587     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      7588     
138E    021457        7589     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7590     
                      7591     ARMING_INITIAL_ARM_CHECK: 
1391    E530          7592     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
1393    C3            7593     	CLR	C
1394    9401          7594     	SUBB	A, #1				; Is it the initial arm sequence?
1396    5003          7595     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      7596     
1398    021457        7597     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      7598     
                      7599     ARMING_PPM_CHECK: 
139B    207435        7600     JB FLAGS2 . 4 , THROTTLE_HIGH_CAL_START 
                      7601     
                      7602     	; PWM tx program entry
139E    C3            7603     	CLR	C
139F    E55C          7604     	MOV	A, NEW_RCP			; Load new RC pulse value
13A1    94FF          7605     SUBB A , # 255 
13A3    5003          7606     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      7607     
13A5    021457        7608     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7609     
                      7610     PROGRAM_BY_TX_ENTRY_PWM: 	
13A8    C2AF          7611     	CLR	EA					; Disable all interrupts
13AA    12061C        7612     	CALL BEEP_F4
13AD    D2AF          7613     	SETB	EA					; Enable all interrupts
13AF    1205F2        7614     	CALL WAIT100MS
13B2    C3            7615     	CLR	C
13B3    E55C          7616     	MOV	A, NEW_RCP			; Load new RC pulse value
13B5    9401          7617     SUBB A , # 1 
13B7    50EF          7618     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      7619     
                      7620     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
13B9    C2AF          7621     	CLR	EA					; Disable all interrupts
13BB    120607        7622     	CALL BEEP_F1
13BE    1205E8        7623     	CALL WAIT10MS
13C1    120607        7624     	CALL BEEP_F1
13C4    D2AF          7625     	SETB	EA					; Enable all interrupts
13C6    1205F2        7626     	CALL WAIT100MS
13C9    C3            7627     	CLR	C
13CA    E55C          7628     	MOV	A, NEW_RCP			; Load new RC pulse value
13CC    94FF          7629     SUBB A , # 255 
13CE    40E9          7630     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      7631     
13D0    021904        7632     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7633     
                      7634     	; PPM throttle calibration and tx program entry
                      7635     THROTTLE_HIGH_CAL_START: 
                      7636     IF MODE <= 1	; Main or tail
13D3    7F05          7637     MOV R7 , # 5 
                      7638     ELSE
                               	MOV	TEMP8, #2				; Set 1 seconds wait time
                               ENDIF
                      7641     THROTTLE_HIGH_CAL: 			
13D5    D27F          7642     SETB FLAGS3 . 7 
13D7    3180          7643     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13D9    1205F2        7644     	CALL WAIT100MS				; Wait for new throttle value
13DC    C2AF          7645     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
13DE    C27F          7646     CLR FLAGS3 . 7 
13E0    3180          7647     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13E2    AE5C          7648     MOV R6 , NEW_RCP 
13E4    C3            7649     	CLR	C
13E5    E55C          7650     	MOV	A, NEW_RCP			; Load new RC pulse value
13E7    947F          7651     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
13E9    D2AF          7652     	SETB	EA					; Enable interrupts
13EB    4074          7653     	JC	ARM_TARGET_UPDATED		; No - branch
                      7654     
13ED    1205DE        7655     	CALL WAIT1MS		
13F0    C2AF          7656     	CLR	EA					; Disable all interrupts
13F2    12061C        7657     	CALL BEEP_F4
13F5    D2AF          7658     	SETB	EA					; Enable all interrupts
13F7    DFDC          7659     DJNZ R7 , THROTTLE_HIGH_CAL 
                      7660     
13F9    31B7          7661     	CALL	AVERAGE_THROTTLE
13FB    C3            7662     	CLR	C
13FC    EE            7663     MOV A , R6 
13FD    9405          7664     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
13FF    7897          7665     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1401    F6            7666     MOV @ R0 , A 
1402    1205F7        7667     	CALL WAIT200MS				
1405    12179A        7668     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
1408    121887        7669     	CALL	SUCCESS_BEEP
                      7670     
                      7671     THROTTLE_LOW_CAL_START: 
140B    7F0A          7672     MOV R7 , # 10 
                      7673     THROTTLE_LOW_CAL: 			
140D    D27F          7674     SETB FLAGS3 . 7 
140F    3180          7675     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1411    1205F2        7676     	CALL WAIT100MS
1414    C2AF          7677     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
1416    C27F          7678     CLR FLAGS3 . 7 
1418    3180          7679     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
141A    AE5C          7680     MOV R6 , NEW_RCP 
141C    C3            7681     	CLR	C
141D    E55C          7682     	MOV	A, NEW_RCP			; Load new RC pulse value
141F    947F          7683     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
1421    D2AF          7684     	SETB	EA					; Enable interrupts
1423    50E6          7685     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      7686     
1425    1205DE        7687     	CALL WAIT1MS		
1428    C2AF          7688     	CLR	EA					; Disable all interrupts
142A    120607        7689     	CALL BEEP_F1
142D    1205E8        7690     	CALL WAIT10MS
1430    120607        7691     	CALL BEEP_F1
1433    D2AF          7692     	SETB	EA					; Enable all interrupts
1435    DFD6          7693     DJNZ R7 , THROTTLE_LOW_CAL 
                      7694     
1437    31B7          7695     	CALL	AVERAGE_THROTTLE
1439    EE            7696     MOV A , R6 
143A    2405          7697     	ADD	A, #5				; Add about 2%
143C    7896          7698     MOV R0 , # PGM_PPM_MIN_THROTTLE 
143E    F6            7699     MOV @ R0 , A 
143F    1205F7        7700     	CALL WAIT200MS				
1442    12179A        7701     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
1445    1218B6        7702     	CALL	SUCCESS_BEEP_INVERTED
                      7703     
                      7704     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
1448    1205F2        7705     	CALL WAIT100MS
144B    3180          7706     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
144D    C3            7707     	CLR	C
144E    E55C          7708     	MOV	A, NEW_RCP			; Load new RC pulse value
1450    94FF          7709     SUBB A , # 255 
1452    40F4          7710     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      7711     
1454    021904        7712     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7713     
                      7714     PROGRAM_BY_TX_CHECKED: 
1457    C3            7715     	CLR	C
1458    E55C          7716     	MOV	A, NEW_RCP			; Load new RC pulse value
145A    954A          7717     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
145C    4003          7718     	JC	ARM_TARGET_UPDATED		; No - do not update
                      7719     
145E    855C4A        7720     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      7721     
                      7722     ARM_TARGET_UPDATED: 
1461    1205F2        7723     	CALL WAIT100MS				; Wait for new throttle value
1464    7801          7724     MOV R0 , # 1 
1466    7988          7725     MOV R1 , # PGM_DIRECTION 
1468    E7            7726     MOV A , @ R1 
1469    B40302        7727     	CJNE	A, #3, ($+5)			; No - branch
                      7728     
146C    7805          7729     MOV R0 , # ( RCP_STOP+4 ) 
                      7730     
146E    C3            7731     	CLR	C
146F    E55C          7732     	MOV	A, NEW_RCP			; Load new RC pulse value
1471    98            7733     SUBB A , R0 
1472    4002          7734     	JC	ARM_END_BEEP			; Yes - proceed
                      7735     
1474    6183          7736     	JMP	ARMING_START			; No - start over
                      7737     
                      7738     ARM_END_BEEP: 
                      7739     	; Beep arm sequence end signal
1476    C2AF          7740     	CLR 	EA					; Disable all interrupts
1478    12061C        7741     	CALL BEEP_F4				; Signal that rcpulse is ready
147B    12061C        7742     	CALL BEEP_F4
147E    12061C        7743     	CALL BEEP_F4
1481    D2AF          7744     	SETB	EA					; Enable all interrupts
1483    1205F7        7745     	CALL WAIT200MS
                      7746     
                      7747     	; Clear initial arm variable
1486    753000        7748     	MOV	INITIAL_ARM, #0
                      7749     
                      7750     	; Armed and waiting for power on
                      7751     WAIT_FOR_POWER_ON: 
1489    E4            7752     	CLR	A
148A    F531          7753     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
148C    F532          7754     	MOV	POWER_ON_WAIT_CNT_H, A	
                      7755     WAIT_FOR_POWER_ON_LOOP: 
148E    0531          7756     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
1490    E531          7757     	MOV	A, POWER_ON_WAIT_CNT_L
1492    F4            7758     	CPL	A
1493    7039          7759     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      7760     
1495    0532          7761     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
1497    789A          7762     MOV R0 , # PGM_BEACON_DELAY 
1499    E6            7763     MOV A , @ R0 
149A    7819          7764     MOV R0 , # 25 
149C    14            7765     	DEC	A
149D    6012          7766     	JZ	BEEP_DELAY_SET
                      7767     
149F    7832          7768     MOV R0 , # 50 
14A1    14            7769     	DEC	A
14A2    600D          7770     	JZ	BEEP_DELAY_SET
                      7771     
14A4    787D          7772     MOV R0 , # 125 
14A6    14            7773     	DEC	A
14A7    6008          7774     	JZ	BEEP_DELAY_SET
                      7775     
14A9    78FA          7776     MOV R0 , # 250 
14AB    14            7777     	DEC	A
14AC    6003          7778     	JZ	BEEP_DELAY_SET
                      7779     
14AE    753200        7780     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      7781     
                      7782     BEEP_DELAY_SET: 
14B1    C3            7783     	CLR	C
14B2    E532          7784     	MOV	A, POWER_ON_WAIT_CNT_H
14B4    98            7785     SUBB A , R0 
14B5    4017          7786     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      7787     
14B7    1532          7788     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
14B9    7531B4        7789     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
14BC    7899          7790     MOV R0 , # PGM_BEACON_STRENGTH 
14BE    8673          7791     MOV BEEP_STRENGTH , @ R0 
14C0    C2AF          7792     	CLR 	EA					; Disable all interrupts
14C2    12061C        7793     	CALL BEEP_F4				; Signal that there is no signal
14C5    D2AF          7794     	SETB	EA					; Enable all interrupts
14C7    7898          7795     MOV R0 , # PGM_BEEP_STRENGTH 
14C9    8673          7796     MOV BEEP_STRENGTH , @ R0 
14CB    1205F2        7797     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      7798     
                      7799     WAIT_FOR_POWER_ON_NO_BEEP: 
14CE    1205E8        7800     	CALL WAIT10MS
14D1    E52A          7801     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
14D3    7005          7802     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      7803     
14D5    307402        7804     JNB FLAGS2 . 4 , WAIT_FOR_POWER_ON_PPM_NOT_MISSING 
                      7805     
14D8    4184          7806     	JMP	INIT_NO_SIGNAL					; If ppm and pulses missing - go back to detect input signal
                      7807     
                      7808     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
14DA    7801          7809     MOV R0 , # 1 
14DC    207402        7810     JB FLAGS2 . 4 , ( $+5 ) 
                      7811     
14DF    7806          7812     MOV R0 , # ( RCP_STOP+5 ) 
                      7813     
14E1    C3            7814     	CLR	C
14E2    E55C          7815     	MOV	A, NEW_RCP			; Load new RC pulse value
14E4    98            7816     SUBB A , R0 
14E5    40A7          7817     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      7818     
                      7819     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION	; Check if bidirectional operation
                               	MOV	A, @TEMP1				
                               	CLR	C
                               	SUBB	A, #3
                               	JZ 	WAIT_FOR_POWER_ON_CHECK_TIMEOUT	; Do not wait if bidirectional operation
                               ENDIF
                      7826     
14E7    1205F2        7827     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      7828     
                      7829     WAIT_FOR_POWER_ON_CHECK_TIMEOUT: 
14EA    E52A          7830     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
14EC    7003          7831     	JNZ	($+5)				; If it is not zero - proceed
                      7832     
14EE    021284        7833     	LJMP	INIT_NO_SIGNAL			; If it is zero (pulses missing) - go back to detect input signal
                      7834     
                      7835     
                      7836     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7837     ;
                      7838     ; Start entry point
                      7839     ;
                      7840     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7841     INIT_START: 
14F1    C2AF          7842     	CLR	EA
14F3    1164          7843     	CALL SWITCH_POWER_OFF
14F5    E4            7844     	CLR	A
14F6    F522          7845     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
14F8    F523          7846     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
14FA    F524          7847     	MOV	CURRENT_PWM, A			; Set current pwm to zero
14FC    F525          7848     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
14FE    F526          7849     	MOV	CURRENT_PWM_LIM_DITH, A
1500    F567          7850     	MOV	PWM_DITHER_EXCESS_POWER, A
1502    D2AF          7851     	SETB	EA
1504    7885          7852     MOV R0 , # PGM_MOTOR_IDLE 
1506    E6            7853     MOV A , @ R0 
1507    C3            7854     	CLR	C
1508    33            7855     	RLC	A
1509    F565          7856     	MOV	PWM_MOTOR_IDLE, A
150B    E4            7857     	CLR	A
150C    F542          7858     	MOV	GOV_TARGET_L, A		; Set target to zero
150E    F543          7859     	MOV	GOV_TARGET_H, A
1510    F544          7860     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
1512    F545          7861     	MOV	GOV_INTEGRAL_H, A
1514    F546          7862     	MOV	GOV_INTEGRAL_X, A
1516    F570          7863     	MOV	ADC_CONVERSION_CNT, A
1518    F52C          7864     	MOV	FLAGS0, A				; Clear flags0
151A    F52D          7865     	MOV	FLAGS1, A				; Clear flags1
151C    F536          7866     	MOV	DEMAG_DETECTED_METRIC, A	; Clear demag metric
                      7867     	;**** **** **** **** ****
                      7868     	; Motor start beginning
                      7869     	;**** **** **** **** **** 
151E    757008        7870     MOV ADC_CONVERSION_CNT , # 8 
                      7871     	SET_ADC_IP_TEMP
1521    75BB10        7871+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
1524    1205DE        7872     	CALL WAIT1MS
1527    1209CB        7873     	CALL START_ADC_CONVERSION
                      7874     READ_INITIAL_TEMP: 
                      7875     	GET_ADC_STATUS 
152A    E5E8          7875+1   MOV A , ADC0CN 
152C    20ECFB        7876     	JB	AD0BUSY, READ_INITIAL_TEMP
                      7877     	READ_ADC_RESULT						; Read initial temperature
152F    A8BD          7877+1   MOV R0 , ADC0L 
1531    A9BE          7877+1   MOV R1 , ADC0H 
1533    E9            7878     MOV A , R1 
1534    7001          7879     	JNZ	($+3)							; Is reading below 256?
                      7880     
1536    F8            7881     MOV R0 , A 
                      7882     
1537    8871          7883     MOV CURRENT_AVERAGE_TEMP , R0 
1539    1209CF        7884     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
153C    757008        7885     MOV ADC_CONVERSION_CNT , # 8 
                      7886     	SET_ADC_IP_TEMP
153F    75BB10        7886+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      7887     	; Set up start operating conditions
1542    7887          7888     MOV R0 , # PGM_PWM_FREQ 
1544    E6            7889     MOV A , @ R0 
1545    FE            7890     MOV R6 , A 
1546    7602          7891     MOV @ R0 , # 2 
1548    11E2          7892     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
154A    7887          7893     MOV R0 , # PGM_PWM_FREQ 
154C    EE            7894     MOV A , R6 
154D    F6            7895     MOV @ R0 , A 
                      7896     	; Set max allowed power
154E    C2AF          7897     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
1550    7561FF        7898     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1553    120A8A        7899     	CALL SET_STARTUP_PWM
1556    852261        7900     	MOV	PWM_LIMIT, REQUESTED_PWM
1559    852262        7901     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
155C    852263        7902     	MOV	PWM_LIMIT_BY_RPM, REQUESTED_PWM
155F    D2AF          7903     	SETB	EA
1561    752201        7904     	MOV	REQUESTED_PWM, #1			; Set low pwm again after calling set_startup_pwm
1564    752401        7905     	MOV	CURRENT_PWM, #1
1567    752501        7906     	MOV	CURRENT_PWM_LIMITED, #1	
156A    752601        7907     	MOV	CURRENT_PWM_LIM_DITH, #1
156D    856069        7908     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1570    756A01        7909     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      7910     	; Begin startup sequence
                      7911     IF MCU_48MHZ == 1
                      7912     	SET_MCU_CLK_48MHZ
1573    75B690        7912+1   MOV FLSCL , # 90H  ; SET FLASH TIMING FOR 48MHZ
1576    75A903        7912+1   MOV CLKSEL , # 3  ; SET CLOCK TO 48MHZ
1579    757A01        7912+1   MOV CLOCK_SET_AT_48MHZ , # 1 
                      7913     ENDIF
157C    7888          7914     MOV R0 , # PGM_DIRECTION 
157E    E6            7915     MOV A , @ R0 
157F    B40307        7916     	CJNE	A, #3, INIT_START_BIDIR_DONE
                      7917     
1582    C27D          7918     CLR FLAGS3 . 5 
1584    307602        7919     JNB FLAGS2 . 6 , ( $+5 ) 
1587    D27D          7920     SETB FLAGS3 . 5 
                      7921     
                      7922     INIT_START_BIDIR_DONE: 
1589    D268          7923     SETB FLAGS1 . 0 
158B    D269          7924     SETB FLAGS1 . 1 
158D    753300        7925     	MOV	STARTUP_CNT, #0			; Reset counter
1590    120FCA        7926     	CALL COMM5COMM6				; Initialize commutation
1593    120FEF        7927     	CALL COMM6COMM1				
1596    120AB1        7928     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
1599    120AB1        7929     	CALL	CALC_NEXT_COMM_TIMING		
159C    120AAA        7930     	CALL INITIALIZE_TIMING			; Initialize timing
159F    120AB1        7931     	CALL	CALC_NEXT_COMM_TIMING		
15A2    120C0E        7932     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
15A5    120AAA        7933     	CALL	INITIALIZE_TIMING			; Initialize timing
15A8    120CD1        7934     	CALL	WAIT_BEFORE_ZC_SCAN			; Set up comparator timeout
15AB    0215BA        7935     	JMP	RUN1
                      7936     
                      7937     
                      7938     
                      7939     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7940     ;
                      7941     ; Run entry point
                      7942     ;
                      7943     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7944     DAMPED_TRANSITION: 
                      7945     	; Transition from nondamped to damped if applicable
15AE    C2AF          7946     	CLR	EA
15B0    11E2          7947     	CALL	DECODE_PARAMETERS		; Set programmed parameters
15B2    D2AF          7948     	SETB	EA
15B4    757000        7949     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      7950     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
15B7    75BB09        7950+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      7951     
                      7952     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      7953     ; Out_cA changes from low to high
                      7954     RUN1: 
15BA    120D26        7955     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
15BD    120E2B        7956     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
15C0    120E0C        7957     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
15C3    1206E7        7958     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
15C6    120E48        7959     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
15C9    120E92        7960     	CALL COMM1COMM2			; Commutate
15CC    120AB1        7961     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
15CF    120BFD        7962     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
15D2    120C0E        7963     	CALL CALC_NEW_WAIT_TIMES
15D5    120CD1        7964     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      7965     
                      7966     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      7967     ; Out_cB changes from high to low
                      7968     RUN2: 
15D8    120D15        7969     	CALL WAIT_FOR_COMP_OUT_LOW
15DB    120E2B        7970     	CALL SETUP_COMM_WAIT	
15DE    120E0C        7971     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
15E1    306D03        7972     JNB FLAGS1 . 5 , ( $+6 ) 
15E4    120787        7973     	LCALL CALC_GOVERNOR_PROP_ERROR
15E7    206703        7974     JB FLAGS0 . 7 , ( $+6 ) 
15EA    1208DB        7975     	LCALL SET_PWM_LIMIT_LOW_RPM
15ED    306703        7976     JNB FLAGS0 . 7 , ( $+6 ) 
15F0    120922        7977     	LCALL SET_PWM_LIMIT_HIGH_RPM
15F3    120E48        7978     	CALL WAIT_FOR_COMM
15F6    120EB7        7979     	CALL COMM2COMM3
15F9    120AB1        7980     	CALL CALC_NEXT_COMM_TIMING
15FC    120BFD        7981     	CALL WAIT_ADVANCE_TIMING
15FF    120C0E        7982     	CALL CALC_NEW_WAIT_TIMES
1602    120CD1        7983     	CALL WAIT_BEFORE_ZC_SCAN	
                      7984     
                      7985     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      7986     ; Out_cC changes from low to high
                      7987     RUN3: 
1605    120D26        7988     	CALL WAIT_FOR_COMP_OUT_HIGH
1608    120E2B        7989     	CALL SETUP_COMM_WAIT	
160B    120E0C        7990     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
160E    306D03        7991     JNB FLAGS1 . 5 , ( $+6 ) 
1611    1207C3        7992     	LCALL CALC_GOVERNOR_INT_ERROR
1614    120E48        7993     	CALL WAIT_FOR_COMM
1617    120F2E        7994     	CALL COMM3COMM4
161A    120AB1        7995     	CALL CALC_NEXT_COMM_TIMING
161D    120BFD        7996     	CALL WAIT_ADVANCE_TIMING
1620    120C0E        7997     	CALL CALC_NEW_WAIT_TIMES
1623    120CD1        7998     	CALL WAIT_BEFORE_ZC_SCAN	
                      7999     
                      8000     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      8001     ; Out_cA changes from high to low
                      8002     RUN4: 
1626    120D15        8003     	CALL WAIT_FOR_COMP_OUT_LOW
1629    120E2B        8004     	CALL SETUP_COMM_WAIT	
162C    120E0C        8005     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
162F    306D03        8006     JNB FLAGS1 . 5 , ( $+6 ) 
1632    120821        8007     	LCALL CALC_GOVERNOR_PROP_CORRECTION
1635    120E48        8008     	CALL WAIT_FOR_COMM
1638    120F53        8009     	CALL COMM4COMM5
163B    120AB1        8010     	CALL CALC_NEXT_COMM_TIMING
163E    120BFD        8011     	CALL WAIT_ADVANCE_TIMING
1641    120C0E        8012     	CALL CALC_NEW_WAIT_TIMES
1644    120CD1        8013     	CALL WAIT_BEFORE_ZC_SCAN	
                      8014     
                      8015     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      8016     ; Out_cB changes from low to high
                      8017     RUN5: 
1647    120D26        8018     	CALL WAIT_FOR_COMP_OUT_HIGH
164A    120E2B        8019     	CALL SETUP_COMM_WAIT	
164D    120E0C        8020     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
1650    306D03        8021     JNB FLAGS1 . 5 , ( $+6 ) 
1653    12087F        8022     	LCALL CALC_GOVERNOR_INT_CORRECTION
1656    120E48        8023     	CALL WAIT_FOR_COMM
1659    120FCA        8024     	CALL COMM5COMM6
165C    120AB1        8025     	CALL CALC_NEXT_COMM_TIMING
165F    120BFD        8026     	CALL WAIT_ADVANCE_TIMING
1662    120C0E        8027     	CALL CALC_NEW_WAIT_TIMES
1665    120CD1        8028     	CALL WAIT_BEFORE_ZC_SCAN	
                      8029     
                      8030     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      8031     ; Out_cC changes from high to low
                      8032     RUN6: 
1668    1209CB        8033     	CALL START_ADC_CONVERSION
166B    120D15        8034     	CALL WAIT_FOR_COMP_OUT_LOW
166E    120E2B        8035     	CALL SETUP_COMM_WAIT	
1671    120E0C        8036     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
1674    120E48        8037     	CALL WAIT_FOR_COMM
1677    120FEF        8038     	CALL COMM6COMM1
167A    1209CF        8039     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
167D    120AB1        8040     	CALL CALC_NEXT_COMM_TIMING
1680    120BFD        8041     	CALL WAIT_ADVANCE_TIMING
1683    120C0E        8042     	CALL CALC_NEW_WAIT_TIMES
1686    120CD1        8043     	CALL WAIT_BEFORE_ZC_SCAN	
                      8044     
                      8045     	; Check if it is direct startup
1689    30692F        8046     JNB FLAGS1 . 1 , NORMAL_RUN_CHECKS 
168C    206B2C        8047     JB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      8048     
                      8049     	; Set spoolup power variables
168F    856461        8050     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
1692    856462        8051     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
1695    856069        8052     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1698    756A01        8053     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8054     	; Check startup counter
169B    7918          8055     MOV R1 , # 24 
169D    7A0C          8056     MOV R2 , # 12 
169F    C3            8057     	CLR	C
16A0    E533          8058     	MOV	A, STARTUP_CNT				; Load counter
16A2    99            8059     SUBB A , R1 
16A3    4009          8060     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      8061     
16A5    C269          8062     CLR FLAGS1 . 1 
16A7    D26A          8063     SETB FLAGS1 . 2 
16A9    8A34          8064     MOV INITIAL_RUN_ROT_CNT , R2 
                      8065     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               ENDIF
                      8068     IF MODE == 2	; Multi
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG
                               	MOV	PWM_LIMIT_BY_RPM, PWM_SPOOLUP_BEG
                               ENDIF
16AB    0216BB        8072     	JMP	NORMAL_RUN_CHECKS
                      8073     
                      8074     DIRECT_START_CHECK_RCP: 
16AE    C3            8075     	CLR	C
16AF    E55C          8076     	MOV	A, NEW_RCP				; Load new pulse value
16B1    9401          8077     SUBB A , # 1 
16B3    4003          8078     	JC	($+5)
                      8079     
16B5    0215BA        8080     	LJMP	RUN1						; Continue to run 
                      8081     
16B8    021712        8082     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8083     
                      8084     
                      8085     NORMAL_RUN_CHECKS: 
                      8086     	; Check if it is initial run phase
16BB    306A1B        8087     JNB FLAGS1 . 2 , INITIAL_RUN_PHASE_DONE 
16BE    206B18        8088     JB FLAGS1 . 3 , INITIAL_RUN_PHASE_DONE 
                      8089     
                      8090     	; Decrement startup rotaton count
16C1    E534          8091     	MOV	A, INITIAL_RUN_ROT_CNT
16C3    14            8092     	DEC	A
                      8093     	; Check number of nondamped rotations
16C4    7004          8094     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      8095     
16C6    C26A          8096     CLR FLAGS1 . 2 
16C8    A1AE          8097     	JMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      8098     
                      8099     NORMAL_RUN_CHECK_STARTUP_ROT: 
16CA    F534          8100     	MOV	INITIAL_RUN_ROT_CNT, A		; Not zero - store counter
                      8101     
16CC    C3            8102     	CLR	C
16CD    E55C          8103     	MOV	A, NEW_RCP				; Load new pulse value
16CF    9401          8104     SUBB A , # 1 
16D1    4003          8105     	JC	($+5)
                      8106     
16D3    0215BA        8107     	LJMP	RUN1						; Continue to run 
                      8108     
16D6    021712        8109     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8110     
                      8111     INITIAL_RUN_PHASE_DONE: 
                      8112     IF MODE == 0	; Main
                      8113     	; Check if throttle is zeroed
16D9    C3            8114     	CLR	C
16DA    E55F          8115     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
16DC    9401          8116     	SUBB	A, #1					; Is number of stop RC pulses above limit?
16DE    4009          8117     	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                      8118     
16E0    856462        8119     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
16E3    856069        8120     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
16E6    756A01        8121     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8122     
                      8123     RUN6_CHECK_RCP_STOP_COUNT: 
                      8124     ENDIF
                      8125     	; Exit run loop after a given time
16E9    C3            8126     	CLR	C
16EA    E55F          8127     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
16EC    78FA          8128     MOV R0 , # 250 
16EE    98            8129     SUBB A , R0 
16EF    5021          8130     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      8131     
16F1    307404        8132     JNB FLAGS2 . 4 , RUN6_CHECK_DIR 
                      8133     
16F4    E52A          8134     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
16F6    601A          8135     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      8136     
                      8137     RUN6_CHECK_DIR: 
                      8138     IF MODE >= 1	; Tail or multi
                               	MOV	TEMP1, #PGM_DIRECTION		; Check if bidirectional operation
                               	MOV	A, @TEMP1				
                               	CJNE	A, #3, RUN6_CHECK_SPEED
                               
                               	JB	FLAGS3.PGM_DIR_REV, RUN6_CHECK_DIR_REV		; Check if actual rotation direction
                               	JB	FLAGS2.RCP_DIR_REV, RUN6_CHECK_DIR_CHANGE	; Matches force direction
                               	AJMP	RUN6_CHECK_SPEED
                               
                               RUN6_CHECK_DIR_REV:
                               	JNB	FLAGS2.RCP_DIR_REV, RUN6_CHECK_DIR_CHANGE
                               	AJMP	RUN6_CHECK_SPEED
                               
                               RUN6_CHECK_DIR_CHANGE:
                               	JB	FLAGS1.DIR_CHANGE_BRAKE, RUN6_CHECK_SPEED
                               
                               	SETB	FLAGS1.DIR_CHANGE_BRAKE		; Set brake flag
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set max power while braking
                               	JMP	RUN4						; Go back to run 4, thereby changing force direction
                               
                               RUN6_CHECK_SPEED:
                               ENDIF
16F8    78F0          8160     MOV R0 , # 0F0H 
16FA    306B05        8161     JNB FLAGS1 . 3 , RUN6_BRAKE_DONE 
                      8162     
16FD    856461        8163     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG 	; Set max power while braking
1700    7820          8164     MOV R0 , # 20H 
                      8165     
                      8166     RUN6_BRAKE_DONE: 
1702    C3            8167     	CLR	C
1703    E53E          8168     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1705    98            8169     SUBB A , R0 
1706    5002          8170     	JNC	($+4)					; Yes - stop or turn direction 
1708    A1BA          8171     	AJMP	RUN1						; No - go back to run 1
                      8172     
                      8173     IF MODE >= 1	; Tail or multi
                               	JNB	FLAGS1.DIR_CHANGE_BRAKE, RUN_TO_WAIT_FOR_POWER_ON	; If it is not a direction change - stop
                               
                               	CLR	FLAGS1.DIR_CHANGE_BRAKE		; Clear brake flag
                               	CLR	FLAGS3.PGM_DIR_REV			; Set spinning direction. Default fwd
                               	JNB	FLAGS2.RCP_DIR_REV, ($+5)	; Check force direction
                               	SETB	FLAGS3.PGM_DIR_REV			; Set spinning direction
                               	SETB	FLAGS1.INITIAL_RUN_PHASE		
                               	MOV	INITIAL_RUN_ROT_CNT, #18
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set initial max power
                               	AJMP	RUN1						; Go back to run 1 
                               ENDIF
                      8185     
                      8186     RUN_TO_WAIT_FOR_POWER_ON_FAIL: 	
170A    0535          8187     	INC	STALL_CNT					; Increment stall count
170C    E55C          8188     	MOV	A, NEW_RCP				; Check if RCP is zero, then it is a normal stop			
170E    6002          8189     	JZ	RUN_TO_WAIT_FOR_POWER_ON
1710    E115          8190     	AJMP	RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE
                      8191     
                      8192     RUN_TO_WAIT_FOR_POWER_ON: 	
1712    753500        8193     	MOV	STALL_CNT, #0
                      8194     
                      8195     RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE: 
1715    C2AF          8196     	CLR	EA
1717    1164          8197     	CALL SWITCH_POWER_OFF
1719    7887          8198     MOV R0 , # PGM_PWM_FREQ 
171B    E6            8199     MOV A , @ R0 
171C    FE            8200     MOV R6 , A 
171D    7602          8201     MOV @ R0 , # 2 
171F    11E2          8202     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1721    7887          8203     MOV R0 , # PGM_PWM_FREQ 
1723    EE            8204     MOV A , R6 
1724    F6            8205     MOV @ R0 , A 
1725    E4            8206     	CLR	A
1726    F522          8207     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
1728    F523          8208     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
172A    F524          8209     	MOV	CURRENT_PWM, A				; Set current pwm to zero
172C    F525          8210     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
172E    F526          8211     	MOV	CURRENT_PWM_LIM_DITH, A	
1730    F565          8212     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1732    C268          8213     CLR FLAGS1 . 0 
                      8214     IF MCU_48MHZ == 1
                      8215     	SET_MCU_CLK_24MHZ
1734    75B680        8215+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
1737    75A900        8215+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
173A    757A00        8215+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      8216     ENDIF
173D    D2AF          8217     	SETB	EA
173F    1205DE        8218     	CALL	WAIT1MS					; Wait for pwm to be stopped
1742    1164          8219     	CALL SWITCH_POWER_OFF
                      8220     IF MODE == 0	; Main
1744    307406        8221     JNB FLAGS2 . 4 , RUN_TO_NEXT_STATE_MAIN 
                      8222     
1747    E52A          8223     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1749    7002          8224     	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                      8225     
174B    4184          8226     	JMP	INIT_NO_SIGNAL				; If it is zero (pulses missing) - go back to detect input signal
                      8227     
                      8228     RUN_TO_NEXT_STATE_MAIN: 
174D    788D          8229     MOV R0 , # PGM_MAIN_REARM_START 
174F    E6            8230     MOV A , @ R0 
1750    C3            8231     	CLR	C
1751    9401          8232     	SUBB	A, #1					; Is re-armed start enabled?
1753    4002          8233     	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                      8234     
1755    6160          8235     	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                      8236     
                      8237     JMP_WAIT_FOR_POWER_ON: 
1757    8189          8238     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      8239     ENDIF
                      8240     IF MODE >= 1	; Tail or multi
                               	JNB	FLAGS2.RCP_PPM, JMP_WAIT_FOR_POWER_ON	; If flag is not set (PWM) - branch
                               
                               	CLR	C
                               	MOV	A, STALL_CNT
                               	SUBB	A, #5
                               	JC	JMP_WAIT_FOR_POWER_ON
                               	JMP	INIT_NO_SIGNAL
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      8252     
                      8253     
                      8254     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8255     
                      8256     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      8916     $INCLUDE (BLHELIBOOTLOAD.INC)			; Include source code for bootloader
                      9309     
                      9310     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      9311     
                      9312     
------                9313     CSEG AT 19FDH
                      9314     RESET: 
19FD    0211E2        9315     LJMP	PGM_START
                      9316     
                      9317     
                      9318     
                      9319     
                      9320     END
MACRO ASSEMBLER BLHELI                                      01/01/16 17:30:04 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

SET4 . . . . . . .  C ADDR   1CC5H   A 
ID3. . . . . . . .  C ADDR   1C52H   A 
BYTE_CNTH. . . . .  D ADDR   0028H   A 
CRCH . . . . . . .  D ADDR   0023H   A 
CMDL . . . . . . .    REG    R4             
XH . . . . . . . .    REG    R1             
NORMAL_RUN_CHECK_~  C ADDR   16CAH   A 
DECODE_DEMAG_HIGH.  C ADDR   1169H   A 
COMM61_DAMP_REV. .  C ADDR   1015H   A 
COMP_WAIT_ON_COMP~  C ADDR   0D5DH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0D14H   A 
CHECK_TEMP_VOLTAG~  C ADDR   09CFH   A 
MEASURE_LIPO_WAIT~  C ADDR   0949H   A 
GOVERNOR_LIMIT_IN~  C ADDR   08A6H   A 
GOVERNOR_CORR_NEG~  C ADDR   086EH   A 
PCA_INT_PPM_BELOW~  C ADDR   0516H   A 
EEP_PGM_MAIN_SPOO~  C ADDR   1A22H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
TIMER0_OVERFLOW_V~  D ADDR   0079H   A 
PPM_THROTTLE_GAIN.  D ADDR   0072H   A 
LIPO_ADC_LIMIT_H .  D ADDR   006FH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005EH   A 
RCP_EDGE_H . . . .  D ADDR   0058H   A 
FLAGS3 . . . . . .  D ADDR   002FH   A 
RCP_PREV_EDGE_L. .  D ADDR   0027H   A 
ADC_IP . . . . . .  N NUMB   0001h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
POLARIS_THUNDER_4~  N NUMB   008Fh            
POLARIS_THUNDER_3~  N NUMB   008Dh            
POLARIS_THUNDER_1~  N NUMB   0087h            
SET5 . . . . . . .  C ADDR   1CCBH   A 
ID4. . . . . . . .  C ADDR   1C5DH   A 
BOOT_START . . . .  N NUMB   1C00h            
FUNCTION_BEEP. . .  C ADDR   18EBH   A 
INIT_START . . . .  C ADDR   14F1H   A 
PROGRAM_BY_TX_ENT~  C ADDR   13A8H   A 
FIND_THROTTLE_GAI~  C ADDR   119AH   A 
COMM45_NONDAMP . .  C ADDR   0F99H   A 
COMM4COMM5 . . . .  C ADDR   0F53H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B58H   A 
CHECK_VOLTAGE_SPO~  C ADDR   0A6DH   A 
SET_PWM_LIMIT_HIG~  C ADDR   0932H   A 
SET_PWM_DEMAG_DONE  C ADDR   08F7H   A 
CALC_GOVERNOR_SUB~  C ADDR   077AH   A 
PCA_INT_RESTORE_E~  C ADDR   0493H   A 
T2H_INT_RCP_STOP .  C ADDR   02A2H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0159H   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
EEP_MAIN_REARM_ST~  C ADDR   1A10H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006DH   A 
RANDOM . . . . . .  D ADDR   0068H   A 
PWM_MOTOR_IDLE . .  D ADDR   0065H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005DH   A 
NEXT_WT_START_L. .  D ADDR   0053H   A 
COMM_PERIOD4X_H. .  D ADDR   003EH   A 
PWM_START. . . . .  N NUMB   0032h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D6h            
EMAX_NANO_20A_TAIL  N NUMB   00B3h            
PLATINUM_50AV3_TA~  N NUMB   00A1h            
PLATINUM_PRO_30A_~  N NUMB   009Ah            
POLARIS_THUNDER_4~  N NUMB   0090h            
H_KING_35A_TAIL. .  N NUMB   0080h            
SET6 . . . . . . .  C ADDR   1CD3H   A 
ID5. . . . . . . .  C ADDR   1C6AH   A 
ERRORPROG. . . . .  N NUMB   00C5h            
ERRORCRC . . . . .  N NUMB   00C2h            
BOOT_DELAY . . . .  N NUMB   5F5E10h            
PARAVAL_BEEP . . .  C ADDR   18F9H   A 
COMM45_DAMP_REV. .  C ADDR   0F79H   A 
COMM23_NFET_DONE .  C ADDR   0F0FH   A 
GOVERNOR_CHECK_PWM  C ADDR   07FCH   A 
GOVERNOR_ACTIVATE.  C ADDR   0733H   A 
PWM_AFET_DAMPED_D~  C ADDR   01A1H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
DEMAG_DETECTED_ME~  D ADDR   0036H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
SIGNATURE_001. . .  N NUMB   00F3h            
RTX_PORT . . . . .  N NUMB   0080h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
EMAX_NANO_20A_MUL~  N NUMB   00B4h            
PLATINUM_50AV3_MU~  N NUMB   00A2h            
POLARIS_THUNDER_6~  N NUMB   0092h            
H_KING_35A_MULTI .  N NUMB   0081h            
TURNIGY_AE_25A_MA~  N NUMB   0043h            
TURNIGY_AE_20A_TA~  N NUMB   0041h            
TURNIGY_PLUSH_10A~  N NUMB   001Fh            
XP_35A_SW_TAIL . .  N NUMB   0014h            
GETC . . . . . . .  C ADDR   1D7FH   A 
BIT_CNT. . . . . .  D ADDR   0026H   A 
BOOT_PAGES . . . .  N NUMB   0001h            
WRITE_EEPROM_SIGN~  C ADDR   180CH   A 
WAIT_FOR_POWER_ON.  C ADDR   1489H   A 
THROTTLE_LOW_CAL_~  C ADDR   140BH   A 
ERASE_AND_STORE_A~  C ADDR   179AH   A 
PROGRAM_BY_TX_CHE~  C ADDR   1457H   A 
ARMING_INITIAL_AR~  C ADDR   1391H   A 
FIND_THROTTLE_GAI~  C ADDR   1193H   A 
SET_DEFAULT_PARAM~  C ADDR   1079H   A 
COMM56_REV . . . .  C ADDR   0FDEH   A 
COMM23_NFET_OFF_R~  C ADDR   0EF3H   A 
COMP_READ_OK . . .  C ADDR   0DF5H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0BF8H   A 
CALC_NEXT_COMM_TI~  C ADDR   0AB1H   A 
COMM5COMM6 . . . .  C ADDR   0FCAH   A 
CALC_GOVERNOR_TAR~  C ADDR   0786H   A 
PCA_INT_STORE_DATA  C ADDR   04B8H   A 
T2_INT_RCP_UPDATE~  C ADDR   0248H   A 
PWM_BFET_DAMPED_D~  C ADDR   01B2H   A 
RESET. . . . . . .  C ADDR   19FDH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   00A4H   A 
PGM_ENABLE_TEMP_P~  I ADDR   00A0H   A 
_PGM_THROTTLE_RATE  I ADDR   009BH   A 
_PGM_STARTUP_RPM .  I ADDR   008FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   0062H   A 
RCP_PREPREV_EDGE_H  D ADDR   0056H   A 
WT_ZC_SCAN_START_L  D ADDR   004DH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0003h            
STARTUP_PHASE. . .  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
SIGNATURE_002. . .  N NUMB   0090h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C5h            
POLARIS_THUNDER_6~  N NUMB   0093h            
SKYWALKER_20A_MAIN  N NUMB   0058h            
TURNIGY_AE_30A_TA~  N NUMB   0047h            
TURNIGY_AE_20A_MU~  N NUMB   0042h            
XP_35A_SW_MULTI. .  N NUMB   0015h            
XP_7A_MAIN . . . .  N NUMB   0004h            
PRO3 . . . . . . .  C ADDR   1D01H   A 
BOOT_SIGN. . . . .  C ADDR   1DD6H   A 
BYTE_CNTL. . . . .  D ADDR   0027H   A 
BAUDH. . . . . . .  D ADDR   0025H   A 
CRCL . . . . . . .  D ADDR   0022H   A 
XL . . . . . . . .    REG    R0             
FUNCTION_NEXT. . .  C ADDR   1963H   A 
THROTTLE_HIGH_CAL.  C ADDR   13D5H   A 
COMM61_NFET_DONE .  C ADDR   1046H   A 
STORE_TIMES_INCRE~  C ADDR   0CC3H   A 
STARTUP_PWM_SET_P~  C ADDR   0A9FH   A 
PWM_CFET_DAMPED_D~  C ADDR   01C3H   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006EH   A 
RCP_EDGE_L . . . .  D ADDR   0057H   A 
COMM_DIFF. . . . .  D ADDR   003FH   A 
STALL_CNT. . . . .  D ADDR   0035H   A 
GOV_SPOOLRATE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
RTX_PIN. . . . . .  N NUMB   0005h            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C6h            
POLARIS_THUNDER_8~  N NUMB   0095h            
TURNIGY_KFORCE_12~  N NUMB   0053h            
TURNIGY_AE_45A_MA~  N NUMB   0049h            
TURNIGY_AE_30A_MU~  N NUMB   0048h            
TURNIGY_PLUSH_30A~  N NUMB   002Bh            
TURNIGY_PLUSH_12A~  N NUMB   0022h            
XP_3A_TAIL . . . .  N NUMB   0002h            
PRO4 . . . . . . .  C ADDR   1D0DH   A 
MAIN . . . . . . .  C ADDR   1C7CH   A 
PARAVAL_NEXT . . .  C ADDR   194EH   A 
WRITE_EEPROM_BYTE.  C ADDR   17E0H   A 
TEST_FOR_ONESHOT .  C ADDR   134CH   A 
MEASURE_PWM_FREQ_~  C ADDR   12F9H   A 
COMM61_NFET_OFF_R~  C ADDR   102BH   A 
COMM_EXIT. . . . .  C ADDR   1061H   A 
CALC_GOVERNOR_INT~  C ADDR   087FH   A 
PCA_INT_PPM_CHECK~  C ADDR   0531H   A 
PCA_INT_FALL_CHEC~  C ADDR   0508H   A 
PCA_INT_PWM_DIVIDE  C ADDR   057DH   A 
PCA_INT_LIMITED. .  C ADDR   05A0H   A 
T2H_INT_RCP_SET_L~  C ADDR   031BH   A 
T2H_INT_START. . .  C ADDR   0286H   A 
T2_INT_PWM_UPDATE.  C ADDR   0259H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0147H   A 
EEP_DUMMY. . . . .  C ADDR   1A27H   A 
EEP_PGM_ENABLE_PW~  C ADDR   1A25H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A13H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
CLOCK_SET_AT_48MHZ  D ADDR   007AH   A 
COMM_PERIOD4X_L. .  D ADDR   003DH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
RTX_MDIN . . . . .  N NUMB   00F1h            
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0000h            
POLARIS_THUNDER_8~  N NUMB   0096h            
SKYWALKER_40A_MAIN  N NUMB   005Bh            
TURNIGY_KFORCE_12~  N NUMB   0054h            
TURNIGY_PLUSH_40A~  N NUMB   002Eh            
SUPERMICRO_3P5A_M~  N NUMB   0019h            
XP_3A_MULTI. . . .  N NUMB   0003h            
WAIT1. . . . . . .  C ADDR   1DCFH   A 
PRO5 . . . . . . .  C ADDR   1D13H   A 
FUNC_PARAVAL_WAIT.  C ADDR   1917H   A 
WRITE_TAG. . . . .  C ADDR   1838H   A 
READ_EEPROM_STORE~  C ADDR   1772H   A 
RUN6_CHECK_DIR . .  C ADDR   16F8H   A 
RUN1 . . . . . . .  C ADDR   15BAH   A 
WAIT_FOR_POWER_ON~  C ADDR   14EAH   A 
MEASURE_PWM_FREQ_~  C ADDR   130AH   A 
CLEAR_RAM. . . . .  C ADDR   124FH   A 
SET_BEC_VOLTAGE. .  C ADDR   117FH   A 
DECODE_DEMAG_DONE.  C ADDR   1172H   A 
COMM45_NFET_DONE .  C ADDR   0FABH   A 
WAIT_FOR_COMM. . .  C ADDR   0E48H   A 
ADJUST_TIMING_TWO~  C ADDR   0CB6H   A 
MEASURE_LIPO_ADD_~  C ADDR   09BEH   A 
CALC_GOVERNOR_PRO~  C ADDR   07C2H   A 
DIV_U16_BY_U16_DI~  C ADDR   0660H   A 
WAIT100MS. . . . .  C ADDR   05F2H   A 
WAIT1MS. . . . . .  C ADDR   05DEH   A 
T0_INT_PWM_OFF_TI~  C ADDR   0127H   A 
T0_INT_PWM_OFF_SE~  C ADDR   0125H   A 
STARTUP_POWER_TAB~  C ADDR   008DH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
SKIP_T2_INT. . . .  D ADDR   0077H   A 
TX_PGM_BEEP_NO . .  D ADDR   0076H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   006AH   A 
WT_ZC_TOUT_START_H  D ADDR   0050H   A 
RCP_SKIP_RATE. . .  N NUMB   0020h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
RTX_MDOUT. . . . .  N NUMB   00A4h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D7h            
PLATINUM_PRO_30A_~  N NUMB   009Bh            
TURNIGY_KFORCE_12~  N NUMB   0055h            
RD1. . . . . . . .  C ADDR   1D2AH   A 
PRO6 . . . . . . .  C ADDR   1D20H   A 
ABD. . . . . . . .  C ADDR   1C2BH   A 
FUNCTION_PARAVAL_~  C ADDR   18E5H   A 
STORE_NEW_VALUE_I~  C ADDR   1841H   A 
RUN2 . . . . . . .  C ADDR   15D8H   A 
ARMING_PPM_CHECK .  C ADDR   139BH   A 
COMM45_NFET_OFF_R~  C ADDR   0F8FH   A 
COMM23_FETS_DONE .  C ADDR   0ED5H   A 
COMP_READ_WRONG_T~  C ADDR   0DD5H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CD1H   A 
STORE_TIMES_EXIT .  C ADDR   0C9CH   A 
MEASURE_LIPO_UPDA~  C ADDR   09C6H   A 
GOVERNOR_CORR_INT~  C ADDR   08C5H   A 
GOVERNOR_STORE_PR~  C ADDR   07BEH   A 
DIV_U16_BY_U16_DI~  C ADDR   066AH   A 
WAIT200MS. . . . .  C ADDR   05F7H   A 
T2_INT_CURRENT_PW~  C ADDR   025BH   A 
T2_INT_PULSES_ABS~  C ADDR   01F3H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_MAIN_SPOOLUP_~  I ADDR   009FH   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0055H   A 
GOV_ACTIVE . . . .  N NUMB   0005h            
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D8h            
PLATINUM_PRO_30A_~  N NUMB   009Ch            
TURNIGY_AE_25A_TA~  N NUMB   0044h            
TURNIGY_PLUSH_60A~  N NUMB   0031h            
TURNIGY_PLUSH_10A~  N NUMB   0020h            
MAI1 . . . . . . .  C ADDR   1C7EH   A 
IN1. . . . . . . .  C ADDR   1C74H   A 
BAUDL. . . . . . .  D ADDR   0024H   A 
RUN3 . . . . . . .  C ADDR   1605H   A 
CHECK_VOLTAGE_EXIT  C ADDR   0A7DH   A 
GOVERNOR_LIMIT_IN~  C ADDR   08ADH   A 
GOVERNOR_CHECK_IN~  C ADDR   07E4H   A 
DIV_U16_BY_U16_DI~  C ADDR   0681H   A 
WAIT3MS. . . . . .  C ADDR   05E3H   A 
T2_INT_PULSES_ABS~  C ADDR   0228H   A 
T0_INT_PWM_ON_TIM~  C ADDR   0107H   A 
T0_INT_PWM_ON_SET~  C ADDR   0105H   A 
REMAP_LOW_SLOPE. .  C ADDR   00C4H   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0045H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
RCP_PPM_ONESHOT125  N NUMB   0005h            
DIR_CHANGE_BRAKE .  N NUMB   0003h            
DEMAG_ENABLED. . .  N NUMB   0004h            
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
POLARIS_THUNDER_1~  N NUMB   0097h            
SKYWALKER_20A_TAIL  N NUMB   0059h            
TURNIGY_AE_25A_MU~  N NUMB   0045h            
TURNIGY_PLUSH_25A~  N NUMB   0028h            
TURNIGY_PLUSH_10A~  N NUMB   0021h            
XP_7A_TAIL . . . .  N NUMB   0005h            
PUTP . . . . . . .  C ADDR   1D40H   A 
SETBUF . . . . . .  C ADDR   1CBFH   A 
MAI2 . . . . . . .  C ADDR   1CA0H   A 
ERRORCOMMAND . . .  N NUMB   00C1h            
BEEP_NO_ENTRY. . .  C ADDR   1910H   A 
JMP_WAIT_FOR_POWE~  C ADDR   1757H   A 
DIRECT_START_CHEC~  C ADDR   16AEH   A 
RUN4 . . . . . . .  C ADDR   1626H   A 
COMM61_FETS_DONE .  C ADDR   100DH   A 
COMM23_NONDAMP_REV  C ADDR   0F17H   A 
COMP_READ_OK_JMP .  C ADDR   0E07H   A 
STORE_TIMES_UP_OR~  C ADDR   0C5AH   A 
STORE_TIMES_DECRE~  C ADDR   0C6DH   A 
CALC_NEXT_COMM_NE~  C ADDR   0B3DH   A 
TEMP_AVERAGE_INC .  C ADDR   0A09H   A 
GOVERNOR_CORR_INT~  C ADDR   08D6H   A 
MULT_S16_BY_U8_DI~  C ADDR   0690H   A 
PCA_INT_PPM_NEG_C~  C ADDR   0555H   A 
T2_INT_EXIT. . . .  C ADDR   026CH   A 
_EEP_PGM_DAMPING_~  C ADDR   1A16H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PWM_DITHER_EXCESS~  D ADDR   0067H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   005Ah            
TURNIGY_AE_45A_TA~  N NUMB   004Ah            
TURNIGY_PLUSH_80A~  N NUMB   0034h            
TURNIGY_PLUSH_30A~  N NUMB   002Ch            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
XP_7A_MULTI. . . .  N NUMB   0006h            
PUT1 . . . . . . .  C ADDR   1D46H   A 
READ_TAGS. . . . .  C ADDR   181DH   A 
RUN5 . . . . . . .  C ADDR   1647H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0BAFH   A 
SET_PWM_LIMIT_HIG~  C ADDR   0922H   A 
GOVERNOR_CORR_NEG~  C ADDR   08CAH   A 
GOVERNOR_LIMIT_PR~  C ADDR   07B3H   A 
GOVERNOR_TARGET_C~  C ADDR   0735H   A 
CALC_GOVERNOR_TAR~  C ADDR   06E7H   A 
PCA_INT_PWM_DIVID~  C ADDR   0584H   A 
PCA_INT_CHECK_12K~  C ADDR   0437H   A 
T2H_INT_RCP_BAILO~  C ADDR   034CH   A 
_EEP_PGM_MOTOR_GA~  C ADDR   1A07H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
CURRENT_PWM_LIMIT~  D ADDR   007CH   A 
BEEP_STRENGTH. . .  D ADDR   0073H   A 
RCP_PREV_PERIOD_H.  D ADDR   005AH   A 
WT_COMM_START_H. .  D ADDR   0052H   A 
WT_ZC_TOUT_START_L  D ADDR   004FH   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
F85_3A_MAIN. . . .  N NUMB   00D3h            
SKYWALKER_40A_TAIL  N NUMB   005Ch            
TURNIGY_AE_45A_MU~  N NUMB   004Bh            
TURNIGY_PLUSH_40A~  N NUMB   002Fh            
TURNIGY_PLUSH_30A~  N NUMB   002Dh            
TURNIGY_PLUSH_18A~  N NUMB   0025h            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
SUPERMICRO_3P5A_T~  N NUMB   001Ah            
PUT2 . . . . . . .  C ADDR   1D59H   A 
MAI4 . . . . . . .  C ADDR   1CD6H   A 
BAUDTIME . . . . .  N NUMB   0198h            
RUN6 . . . . . . .  C ADDR   1668H   A 
ARMING_START . . .  C ADDR   1383H   A 
MEASURE_PWM_FREQ_~  C ADDR   12FFH   A 
COMM61_NONDAMP_REV  C ADDR   104DH   A 
COMM45_FETS_DONE .  C ADDR   0F71H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CD9H   A 
GOVERNOR_DEACTIVA~  C ADDR   0714H   A 
PCA_INT_CHECK_LEG~  C ADDR   0595H   A 
PCA_INT_FALL_NOT_~  C ADDR   04E9H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
PREV_PREV_COMM_H .  D ADDR   003CH   A 
RCP_UPDATED. . . .  N NUMB   0000h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0040h            
MUX_A1 . . . . . .  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Ah            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
FLYCOLOR_FAIRY_30~  N NUMB   00C7h            
ROTORGEEKS_20A_MA~  N NUMB   00C1h            
ALIGN_RCE_BL15P_M~  N NUMB   006Dh            
SKYWALKER_40A_MUL~  N NUMB   005Dh            
TURNIGY_KFORCE_12~  N NUMB   0056h            
TURNIGY_PLUSH_40A~  N NUMB   0030h            
SUPERMICRO_3P5A_M~  N NUMB   001Bh            
DP_3A_MAIN . . . .  N NUMB   0016h            
PUT3 . . . . . . .  C ADDR   1D65H   A 
MAI5 . . . . . . .  C ADDR   1D25H   A 
WAIT_FOR_LOW . . .  C ADDR   1C42H   A 
PARAH. . . . . . .    REG    R3             
STORE_MAIN_FUNC_1.  C ADDR   1845H   A 
ARM_TARGET_UPDATED  C ADDR   1461H   A 
EVALUATE_COMPARAT~  C ADDR   0E0CH   A 
COMP_WAIT_READ_CO~  C ADDR   0D9CH   A 
TEMP_CHECK_EXIT. .  C ADDR   0A33H   A 
GOVERNOR_APPLY_PR~  C ADDR   0855H   A 
T2H_INT_RCP_GOV_B~  C ADDR   02D8H   A 
PWM_AFET_EXIT. . .  C ADDR   017EH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_PWM_IN~  I ADDR   00A2H   A 
_PGM_STARTUP_ACCEL  I ADDR   0090H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
CURRENT_PWM_LIM_D~  D ADDR   007DH   A 
GOV_INTEGRAL_L . .  D ADDR   0044H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0025h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
TURNIGY_KFORCE_12~  N NUMB   0057h            
TURNIGY_PLUSH_60A~  N NUMB   0032h            
PUT4 . . . . . . .  C ADDR   1D77H   A 
MAI6 . . . . . . .  C ADDR   1D36H   A 
CNTH . . . . . . .    REG    R7             
STORE_MAIN_FUNC_2.  C ADDR   184AH   A 
WRITE_EEPROM_BLOC~  C ADDR   17BDH   A 
NORMAL_RUN_CHECKS.  C ADDR   16BBH   A 
INIT_NO_SIGNAL . .  C ADDR   1284H   A 
COMM45_NONDAMP_REV  C ADDR   0FB3H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D34H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0BFDH   A 
CALC_NEW_WAIT_PER~  C ADDR   0B67H   A 
CALC_GOVERNOR_PRO~  C ADDR   0787H   A 
T2_INT_PPM_TIMEOU~  C ADDR   0234H   A 
PWM_BFET_EXIT. . .  C ADDR   0188H   A 
T0_INT_PWM_OFF_EX~  C ADDR   0134H   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
POLARIS_THUNDER_1~  N NUMB   0098h            
ALIGN_RCE_BL35P_M~  N NUMB   0073h            
TURNIGY_PLUSH_60A~  N NUMB   0033h            
TURNIGY_PLUSH_25A~  N NUMB   0029h            
POLYNOM. . . . . .  N NUMB   A001h            
STORE_MAIN_FUNC_3.  C ADDR   184FH   A 
WRITE_EEPROM_BLOC~  C ADDR   17CBH   A 
PROGRAM_BY_TX_ENT~  C ADDR   1448H   A 
READ_ALL_EEPROM_P~  C ADDR   1759H   A 
COMM23_NFET_DONE_~  C ADDR   0F26H   A 
CALC_NEXT_COMM_NE~  C ADDR   0B46H   A 
PWM_CFET_EXIT. . .  C ADDR   0192H   A 
T0_INT . . . . . .  C ADDR   00CFH   A 
_EEP_PGM_PWM_DITH~  C ADDR   1A26H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A18H   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
SKIP_T2H_INT . . .  D ADDR   0078H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006BH   A 
RCP_STOP_CNT . . .  D ADDR   005FH   A 
NEW_RCP. . . . . .  D ADDR   005CH   A 
RCP_PREV_PERIOD_L.  D ADDR   0059H   A 
WT_COMM_START_L. .  D ADDR   0051H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
INITIAL_RUN_PHASE.  N NUMB   0002h            
HIGH_RPM . . . . .  N NUMB   0007h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00D0h            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0003h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
POLARIS_THUNDER_1~  N NUMB   0099h            
TURNIGY_PLUSH_80A~  N NUMB   0035h            
TURNIGY_PLUSH_25A~  N NUMB   002Ah            
STORE_MAIN_FUNC_4.  C ADDR   1854H   A 
INIT_START_BIDIR_~  C ADDR   1589H   A 
EVAL_COMP_EXIT . .  C ADDR   0E2AH   A 
MEASURE_LIPO_ADJU~  C ADDR   098DH   A 
PCA_INT_SET_TIMEO~  C ADDR   05B8H   A 
PWM_NOFET. . . . .  C ADDR   0174H   A 
T0_INT_PWM_ON_EXE~  C ADDR   00F3H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
PREV_PREV_COMM_L .  D ADDR   003BH   A 
PREV_COMM_H. . . .  D ADDR   003AH   A 
RCP_DIR_REV. . . .  N NUMB   0006h            
RCP_TIMEOUT_CNT. .  D ADDR   002AH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0004h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
F85_3A_TAIL. . . .  N NUMB   00D4h            
FVT_LITTLEBEE_20A~  N NUMB   00CAh            
MDRX62H_MAIN . . .  N NUMB   00BEh            
TURNIGY_PLUSH_80A~  N NUMB   0036h            
TURNIGY_PLUSH_18A~  N NUMB   0026h            
XP_12A_MAIN. . . .  N NUMB   000Ah            
PUTW . . . . . . .  C ADDR   1D38H   A 
PARAL. . . . . . .    REG    R2             
STORE_MAIN_FUNC_5.  C ADDR   1859H   A 
BOOTLOADER_DONE. .  C ADDR   1294H   A 
AVERAGE_THROTTLE .  C ADDR   11B7H   A 
DECODE_PARAMS_DIR~  C ADDR   10F7H   A 
COMM61_NFET_DONE_~  C ADDR   105CH   A 
SETUP_COMM_WAIT. .  C ADDR   0E2BH   A 
CALC_NEXT_COMM_TI~  C ADDR   0BB0H   A 
CHECK_VOLTAGE_LIM.  C ADDR   0A63H   A 
CALC_GOVERNOR_INT~  C ADDR   0820H   A 
T2_INT . . . . . .  C ADDR   01C7H   A 
_PGM_DAMPING_FORCE  I ADDR   0093H   A 
AUTO_BAILOUT_ARMED  D ADDR   0060H   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
MOTOR_PPM_LOW_SLO~  N NUMB   002Bh            
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0002h            
CNFET. . . . . . .  N NUMB   0007h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
F85_3A_MULTI . . .  N NUMB   00D5h            
FVT_LITTLEBEE_30A~  N NUMB   00CDh            
FLYCOLOR_FAIRY_30~  N NUMB   00C8h            
ROTORGEEKS_20A_TA~  N NUMB   00C2h            
ALIGN_RCE_BL15P_T~  N NUMB   006Eh            
RCTIMER_6A_MAIN. .  N NUMB   0067h            
TURNIGY_PLUSH_NFE~  N NUMB   003Dh            
TURNIGY_PLUSH_18A~  N NUMB   0027h            
DP_3A_TAIL . . . .  N NUMB   0017h            
XP_7A_FAST_MAIN. .  N NUMB   0007h            
GET1 . . . . . . .  C ADDR   1D84H   A 
BYTE_REG . . . . .  D ADDR   0021H   A 
CNTL . . . . . . .    REG    R6             
STORE_MAIN_FUNC_6.  C ADDR   185EH   A 
ARM_END_BEEP . . .  C ADDR   1476H   A 
THROTTLE_HIGH_CAL~  C ADDR   13D3H   A 
PGM_START. . . . .  C ADDR   11E2H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D15H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0C0EH   A 
LOAD_MIN_TIME. . .  C ADDR   0BABH   A 
SET_STARTUP_PWM. .  C ADDR   0A8AH   A 
GOVERNOR_STORE_IN~  C ADDR   081AH   A 
T2H_INT_RCP_GOV_B~  C ADDR   02C5H   A 
T2H_INT_EXIT . . .  C ADDR   0357H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   0361H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0075H   A 
ADC_CONVERSION_CNT  D ADDR   0070H   A 
GOV_ARM_TARGET . .  D ADDR   004AH   A 
RCP_PPM. . . . . .  N NUMB   0004h            
RCP_OUTSIDE_RANGE~  D ADDR   0029H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0005h            
ADC_LIMIT_L. . . .  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
GRAUPNER_ULTRA_20~  N NUMB   00D0h            
FLYCOLOR_FAIRY_30~  N NUMB   00C9h            
ROTORGEEKS_20A_MU~  N NUMB   00C3h            
EMAX_20A_MAIN. . .  N NUMB   00ACh            
TAROT_30A_MAIN . .  N NUMB   00A6h            
ALIGN_RCE_BL15P_M~  N NUMB   006Fh            
DP_3A_MULTI. . . .  N NUMB   0018h            
GET2 . . . . . . .  C ADDR   1D99H   A 
FUNC_PARAVAL . . .  C ADDR   1913H   A 
WAIT1S_LOOP. . . .  C ADDR   1881H   A 
STORE_MAIN_FUNC_7.  C ADDR   1863H   A 
AVERAGE_THROTTLE_~  C ADDR   11D3H   A 
MEASURE_LIPO_DIVI~  C ADDR   09A3H   A 
CALC_GOVERNOR_PRO~  C ADDR   087EH   A 
GOVERNOR_INT_MIN_~  C ADDR   0815H   A 
GOVERNOR_LIMIT_PR~  C ADDR   07BAH   A 
BEEP_F1. . . . . .  C ADDR   0607H   A 
PCA_INT_PPM_OUTSI~  C ADDR   051FH   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   0071H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0064H   A 
PWM_LIMIT. . . . .  D ADDR   0061H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0006h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
ALIGN_RCE_BL35P_T~  N NUMB   0074h            
GET3 . . . . . . .  C ADDR   1DBDH   A 
STORE_MAIN_FUNC_8.  C ADDR   1868H   A 
INITIAL_RUN_PHASE~  C ADDR   16D9H   A 
TEST_THROTTLE_GAIN  C ADDR   11A8H   A 
COMM23_FETS_DONE_~  C ADDR   0EF5H   A 
CALC_NEXT_COMM_ST~  C ADDR   0B0EH   A 
GOVERNOR_STORE_PR~  C ADDR   087CH   A 
GOVERNOR_CHECK_PR~  C ADDR   0840H   A 
MULT_S16_BY_U8_PO~  C ADDR   06AAH   A 
DIV_U16_BY_U16 . .  C ADDR   0658H   A 
BEEP_ONOFF . . . .  C ADDR   0625H   A 
BEEP_F2. . . . . .  C ADDR   060EH   A 
PCA_INT_CHECK_DIFF  C ADDR   04ABH   A 
T2H_INT_RCP_INC_L~  C ADDR   0340H   A 
T2H_INT_RCP_GOV_P~  C ADDR   02E5H   A 
T2_INT_SKIP_START.  C ADDR   0238H   A 
PWM_AFET . . . . .  C ADDR   0176H   A 
T0_INT_PWM_OFF_FU~  C ADDR   0166H   A 
EEP_PGM_ENABLE_PO~  C ADDR   1A24H   A 
EEPROM_LAYOUT_REV~  N NUMB   0014h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
PREV_COMM_L. . . .  D ADDR   0039H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
XROTOR_10A_MAIN. .  N NUMB   00B5h            
EMAX_40A_MAIN. . .  N NUMB   00AFh            
ALIGN_RCE_BL35P_M~  N NUMB   0075h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ah            
TURNIGY_KFORCE_70~  N NUMB   004Fh            
TURNIGY_KFORCE_40~  N NUMB   004Ch            
XP_25A_MAIN. . . .  N NUMB   0010h            
INIT . . . . . . .  C ADDR   1C00H   A 
PARAVAL_NO_ENTRY .  C ADDR   190DH   A 
STORE_MAIN_FUNC_9.  C ADDR   186DH   A 
RUN6_BRAKE_DONE. .  C ADDR   1702H   A 
SUCCESS_BEEP_INVE~  C ADDR   18B6H   A 
SUCCESS_BEEP . . .  C ADDR   1887H   A 
FIND_THROTTLE_GAIN  C ADDR   1180H   A 
DECODE_SETTINGS. .  C ADDR   1115H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   170AH   A 
TEMP_AVERAGE_INC_~  C ADDR   09F9H   A 
GOVERNOR_INT_MAX_~  C ADDR   080DH   A 
GOVERNOR_LIMIT_IN~  C ADDR   07EDH   A 
BEEP_F3. . . . . .  C ADDR   0615H   A 
PCA_INT_FAIL_MINI~  C ADDR   03C4H   A 
PWM_BFET . . . . .  C ADDR   0180H   A 
T0_INT_PWM_OFF_EX~  C ADDR   0159H   A 
EEP_PGM_GOV_RANGE.  C ADDR   1A17H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0069H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
SKIP_DAMP_ON . . .  N NUMB   0006h            
P1_INIT. . . . . .  N NUMB   0002h            
RTX_SKIP . . . . .  N NUMB   00D4h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
FVT_LITTLEBEE_20A~  N NUMB   00CBh            
MDRX62H_TAIL . . .  N NUMB   00BFh            
XROTOR_20A_MAIN. .  N NUMB   00B8h            
PLATINUM_PRO_150A~  N NUMB   009Dh            
TURNIGY_PLUSH_NFE~  N NUMB   003Ah            
XP_12A_TAIL. . . .  N NUMB   000Bh            
UART_LOOP. . . . .  N NUMB   001Ah            
DAMPED_TRANSITION.  C ADDR   15AEH   A 
BEEP_DELAY_SET . .  C ADDR   14B1H   A 
PROGRAM_BY_TX_ENT~  C ADDR   13B9H   A 
LOCK_BYTE_OK . . .  C ADDR   1201H   A 
AVERAGE_THROTTLE_~  C ADDR   11C4H   A 
DECODE_PWM_FREQ_L~  C ADDR   110FH   A 
COMM61_FETS_DONE_~  C ADDR   102DH   A 
COMP_READ_WRONG_L~  C ADDR   0DDFH   A 
SET_PWM_LIMIT_LOW~  C ADDR   091FH   A 
GOVERNOR_ACT_LIM_~  C ADDR   070EH   A 
BEEP_F4. . . . . .  C ADDR   061CH   A 
PCA_INT_PPM_MAX_C~  C ADDR   0564H   A 
PCA_INT_RESTORE_E~  C ADDR   0495H   A 
PWM_CFET . . . . .  C ADDR   018AH   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A6H   A 
_PGM_STARTUP_METH~  I ADDR   0095H   A 
_PGM_VOLT_COMP . .  I ADDR   0091H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0006h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
FVT_LITTLEBEE_30A~  N NUMB   00CEh            
FVT_LITTLEBEE_20A~  N NUMB   00CCh            
MDRX62H_MULTI. . .  N NUMB   00C0h            
H_KING_10A_MAIN. .  N NUMB   0079h            
ALIGN_RCE_BL35X_M~  N NUMB   0070h            
RCTIMER_6A_TAIL. .  N NUMB   0068h            
TURNIGY_PLUSH_NFE~  N NUMB   003Eh            
XP_18A_MAIN. . . .  N NUMB   000Dh            
XP_12A_MULTI . . .  N NUMB   000Ch            
XP_7A_FAST_TAIL. .  N NUMB   0008h            
PROGRAM_BY_TX_EXIT  C ADDR   1972H   A 
READ_EEPROM_BYTE .  C ADDR   17DCH   A 
THROTTLE_LOW_CAL .  C ADDR   140DH   A 
COMP_READ_WRONG. .  C ADDR   0DA8H   A 
STORE_TIMES_UP_OR~  C ADDR   0CBDH   A 
STORE_TIMES_DECRE~  C ADDR   0CCAH   A 
TEMP_AVERAGE_UPDA~  C ADDR   0A11H   A 
SET_PWM_LIMIT_HIG~  C ADDR   0933H   A 
GOVERNOR_APPLY_IN~  C ADDR   08B1H   A 
GOVERNOR_LIMIT_PR~  C ADDR   084BH   A 
CALC_GOVERNOR_STO~  C ADDR   0782H   A 
BEEP_OFF . . . . .  C ADDR   064EH   A 
WAIT10MS . . . . .  C ADDR   05E8H   A 
T2H_INT_RCP_NO_LI~  C ADDR   034AH   A 
PWM_AFET_DAMPED_E~  C ADDR   01A3H   A 
T0_INT_PWM_ON_EXIT  C ADDR   00F5H   A 
TX_PGM_PARAMS_MAIN  C ADDR   009FH   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Eh            
PGM_PWM_DITHER . .  I ADDR   00A3H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0074H   A 
INITIAL_RUN_ROT_C~  D ADDR   0034H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
GRAUPNER_ULTRA_20~  N NUMB   00D1h            
FVT_LITTLEBEE_30A~  N NUMB   00CFh            
XROTOR_40A_MAIN. .  N NUMB   00BBh            
EMAX_20A_TAIL. . .  N NUMB   00ADh            
TAROT_30A_TAIL . .  N NUMB   00A7h            
H_KING_20A_MAIN. .  N NUMB   007Ch            
RCTIMER_6A_MULTI .  N NUMB   0069h            
HIMODEL_COOL_22A_~  N NUMB   005Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0037h            
XP_7A_FAST_MULTI .  N NUMB   0009h            
GETW . . . . . . .  C ADDR   1D7BH   A 
READ_TAG . . . . .  C ADDR   1826H   A 
RESET_CAL_DONE . .  C ADDR   1227H   A 
DECODE_PARAMETERS.  C ADDR   10E2H   A 
COMM45_FETS_DONE_~  C ADDR   0F91H   A 
COMM23_NFET_OFF. .  C ADDR   0ED3H   A 
STORE_TIMES_INCRE~  C ADDR   0C60H   A 
CHECK_VOLTAGE_GOOD  C ADDR   0A5CH   A 
MEASURE_LIPO_CELLS  C ADDR   0938H   A 
CALC_GOVERNOR_INT~  C ADDR   07C3H   A 
GOVERNOR_FIRST_DE~  C ADDR   0720H   A 
PCA_INT_PPM_CALCU~  C ADDR   053FH   A 
PCA_INT_EXIT . . .  C ADDR   05CCH   A 
T2H_INT_RCP_LIMIT~  C ADDR   030FH   A 
PWM_BFET_DAMPED_E~  C ADDR   01B4H   A 
RCP_PERIOD_DIFF_A~  D ADDR   005BH   A 
COMPARATOR_READ_C~  D ADDR   0041H   A 
STARTUP_CNT. . . .  D ADDR   0033H   A 
PWM_TIMER0_OVERFL~  N NUMB   0003h            
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
GRAUPNER_ULTRA_20~  N NUMB   00D2h            
EMAX_20A_MULTI . .  N NUMB   00AEh            
TAROT_30A_MULTI. .  N NUMB   00A8h            
HIMODEL_COOL_41A_~  N NUMB   0064h            
TURNIGY_PLUSH_6A_~  N NUMB   001Ch            
GETX . . . . . . .  C ADDR   1D89H   A 
WAIT_FOR_POWER_ON~  C ADDR   14DAH   A 
COMP_READ_WRONG_N~  C ADDR   0DBFH   A 
CALC_NEW_WAIT_PER~  C ADDR   0B83H   A 
SWITCH_POWER_OFF .  C ADDR   1064H   A 
CALC_GOVERNOR_TAR~  C ADDR   074EH   A 
WAIT30MS . . . . .  C ADDR   05EDH   A 
PCA_INT_CHECK_1KHZ  C ADDR   0484H   A 
T2H_INT. . . . . .  C ADDR   0279H   A 
PWM_CFET_DAMPED_E~  C ADDR   01C5H   A 
MOTOR_PWM_REMAP. .  C ADDR   00AAH   A 
GOV_INTEGRAL_X . .  D ADDR   0046H   A 
COMP_TIMED_OUT . .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   000Ch            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
XROTOR_10A_TAIL. .  N NUMB   00B6h            
EMAX_40A_TAIL. . .  N NUMB   00B0h            
EAZY_3AV2_MAIN . .  N NUMB   00A3h            
ALIGN_RCE_BL15X_T~  N NUMB   006Bh            
HIMODEL_COOL_33A_~  N NUMB   0061h            
TURNIGY_KFORCE_70~  N NUMB   0050h            
TURNIGY_KFORCE_40~  N NUMB   004Dh            
XP_25A_TAIL. . . .  N NUMB   0011h            
RST. . . . . . . .  C ADDR   1CBDH   A 
SUCCESS. . . . . .  N NUMB   0030h            
BOOT_VERSION . . .  N NUMB   0006h            
XTAL . . . . . . .  N NUMB   17D7840h            
FUNC_PARAVAL_CONT~  C ADDR   1941H   A 
WRITE_TAGS . . . .  C ADDR   1831H   A 
RUN_TO_NEXT_STATE~  C ADDR   174DH   A 
RUN6_CHECK_RCP_ST~  C ADDR   16E9H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   1712H   A 
WAIT1S . . . . . .  C ADDR   187FH   A 
COMM61_NFET_OFF. .  C ADDR   100BH   A 
EVAL_COMP_CHECK_T~  C ADDR   0E1AH   A 
COMP_WAIT_ON_COMP~  C ADDR   0D69H   A 
ADJUST_TIMING_TWO~  C ADDR   0C47H   A 
INITIALIZE_TIMING.  C ADDR   0AAAH   A 
CHECK_VOLTAGE_RET.  C ADDR   0A89H   A 
WAITXMS_M. . . . .  C ADDR   05FEH   A 
PCA_INT_CHECK_2KHZ  C ADDR   0473H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
WT_ADV_START_H . .  D ADDR   004CH   A 
GOV_TARGET_H . . .  D ADDR   0043H   A 
MOTOR_PPM_REMAP_T~  N NUMB   001Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
XROTOR_20A_TAIL. .  N NUMB   00B9h            
XROTOR_10A_MULTI .  N NUMB   00B7h            
EMAX_40A_MULTI . .  N NUMB   00B1h            
SKYIII_30A_MAIN. .  N NUMB   00A9h            
PLATINUM_PRO_150A~  N NUMB   009Eh            
POLARIS_THUNDER_2~  N NUMB   0088h            
H_KING_50A_MAIN. .  N NUMB   0082h            
GAUI_GE_183_18A_M~  N NUMB   0076h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ch            
TURNIGY_KFORCE_70~  N NUMB   0051h            
TURNIGY_KFORCE_40~  N NUMB   004Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Bh            
XP_25A_MULTI . . .  N NUMB   0012h            
EXIT . . . . . . .  C ADDR   1CB4H   A 
BOOT_MSG . . . . .  C ADDR   1DDCH   A 
READ_INITIAL_TEMP.  C ADDR   152AH   A 
WAIT_FOR_POWER_ON~  C ADDR   14CEH   A 
DECODE_PWM_FREQ_E~  C ADDR   1114H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0E81H   A 
START_ADC_CONVERS~  C ADDR   09CBH   A 
MULT_S16_BY_U8_EX~  C ADDR   06DEH   A 
PCA_INT_PPM_LIMIT~  C ADDR   0576H   A 
GET_RCP_END. . . .  C ADDR   039BH   A 
T2H_INT_RCP_GOV_P~  C ADDR   02B3H   A 
T2_INT_PWM_MIN_RUN  C ADDR   0259H   A 
PWM_DITHER_TABLE .  C ADDR   009AH   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
PGM_ENABLE_POWER_~  I ADDR   00A1H   A 
PWM_DITHER_DECODED  D ADDR   0066H   A 
PWM_LIMIT_BY_RPM .  D ADDR   0063H   A 
LOW_RPM_PWR_SLOPE.  D ADDR   0038H   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   000Ch            
HIGH_BEC_VOLTAGE .  N NUMB   0000h            
PSW. . . . . . . .  D ADDR   00D0H   A 
XROTOR_20A_MULTI .  N NUMB   00BAh            
PLATINUM_PRO_150A~  N NUMB   009Fh            
POLARIS_THUNDER_3~  N NUMB   008Bh            
POLARIS_THUNDER_1~  N NUMB   0085h            
H_KING_10A_TAIL. .  N NUMB   007Ah            
ALIGN_RCE_BL35X_T~  N NUMB   0071h            
TURNIGY_PLUSH_NFE~  N NUMB   003Ch            
XP_18A_TAIL. . . .  N NUMB   000Eh            
WAITF. . . . . . .  C ADDR   1DC9H   A 
BOOT_BAUDRATE. . .  N NUMB   4B00h            
STORE_IN_RAM_EXIT.  C ADDR   187CH   A 
VALIDATE_RCP_START  C ADDR   1360H   A 
LOCK_BYTE_TEST . .  C ADDR   11FAH   A 
COMM45_NFET_OFF. .  C ADDR   0F6FH   A 
COMM12_REV . . . .  C ADDR   0EA6H   A 
COMM1COMM2 . . . .  C ADDR   0E92H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CDBH   A 
TEMP_AVERAGE_UPDA~  C ADDR   0A0FH   A 
TEMP_AVERAGE_DEC .  C ADDR   0A05H   A 
CALC_GOVERNOR_PRO~  C ADDR   0821H   A 
CALC_GOVERNOR_TAR~  C ADDR   0767H   A 
WAITXMS_O. . . . .  C ADDR   05FCH   A 
PCA_INT_PPM_TIMEO~  C ADDR   05C1H   A 
PCA_INT_CHECK_4KHZ  C ADDR   0462H   A 
T0_INT_PWM_OFF . .  C ADDR   0116H   A 
T0_INT_START . . .  C ADDR   00DCH   A 
EEPROM_FW_SUB_REV~  N NUMB   0003h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0048H   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
XROTOR_40A_TAIL. .  N NUMB   00BCh            
POLARIS_THUNDER_4~  N NUMB   008Eh            
H_KING_20A_TAIL. .  N NUMB   007Dh            
H_KING_10A_MULTI .  N NUMB   007Bh            
ALIGN_RCE_BL35X_M~  N NUMB   0072h            
HIMODEL_COOL_22A_~  N NUMB   005Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0038h            
XP_18A_MULTI . . .  N NUMB   000Fh            
PUTC . . . . . . .  C ADDR   1D5CH   A 
BIT_REG. . . . . .  D ADDR   0020H   A 
CMDH . . . . . . .    REG    R5             
STORE_MAIN_FUNC_10  C ADDR   1872H   A 
READ_EEPROM_EXIT .  C ADDR   1799H   A 
WAIT_FOR_POWER_ON~  C ADDR   148EH   A 
INPUT_HIGH_CHECK_1  C ADDR   1288H   A 
CHECK_VOLTAGE_STA~  C ADDR   0A37H   A 
SET_PWM_LIMIT_LOW~  C ADDR   08DBH   A 
CALC_GOVERNOR_INT~  C ADDR   08DAH   A 
GOVERNOR_LIMIT_IN~  C ADDR   07F6H   A 
MULT_S16_BY_U8_DI~  C ADDR   06C3H   A 
BEEP . . . . . . .  C ADDR   0623H   A 
PCA_INT_FALL . . .  C ADDR   04C6H   A 
T2_INT_PWM_EXIT. .  C ADDR   0263H   A 
T2_INT_SKIP_END. .  C ADDR   0243H   A 
EEP_PGM_TEMP_PROT~  C ADDR   1A23H   A 
_EEP_PGM_THROTTLE~  C ADDR   1A1EH   A 
_EEP_PGM_STARTUP_~  C ADDR   1A12H   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A5H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006CH   A 
COMM_PHASE . . . .  D ADDR   0040H   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
XROTOR_40A_MULTI .  N NUMB   00BDh            
EMAX_NANO_20A_MAIN  N NUMB   00B2h            
PLATINUM_50AV3_MA~  N NUMB   00A0h            
H_KING_35A_MAIN. .  N NUMB   007Fh            
H_KING_20A_MULTI .  N NUMB   007Eh            
HIMODEL_COOL_41A_~  N NUMB   0065h            
HIMODEL_COOL_22A_~  N NUMB   0060h            
TURNIGY_PLUSH_NFE~  N NUMB   0039h            
TURNIGY_PLUSH_6A_~  N NUMB   001Dh            
WAITH. . . . . . .  C ADDR   1DCDH   A 
STORE_MAIN_FUNC_11  C ADDR   1877H   A 
ERASE_FLASH. . . .  C ADDR   17F5H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   1715H   A 
PROGRAM_BY_TX. . .  C ADDR   1904H   A 
INPUT_HIGH_CHECK_2  C ADDR   128AH   A 
COMM23_NONDAMP . .  C ADDR   0EFDH   A 
COMM2COMM3 . . . .  C ADDR   0EB7H   A 
CALC_NEXT_COMM_AV~  C ADDR   0B2AH   A 
MEASURE_LIPO_CELL~  C ADDR   0972H   A 
GOVERNOR_STORE_IN~  C ADDR   08D8H   A 
GOVERNOR_CHECK_IN~  C ADDR   089AH   A 
GOVERNOR_CORR_PRO~  C ADDR   0869H   A 
T2_INT_START . . .  C ADDR   01E3H   A 
PWM_AFET_DAMPED. .  C ADDR   0194H   A 
_EEP_PGM_PPM_CENT~  C ADDR   1A21H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
NEXT_WT_START_H. .  D ADDR   0054H   A 
WT_ADV_START_L . .  D ADDR   004BH   A 
GOV_TARGET_L . . .  D ADDR   0042H   A 
DEMAG_PWR_OFF_THR~  D ADDR   0037H   A 
FLAGS0 . . . . . .  D ADDR   002CH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
MOTOR_PPM_REMAP_T~  N NUMB   0099h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
EAZY_3AV2_TAIL . .  N NUMB   00A4h            
POLARIS_THUNDER_6~  N NUMB   0091h            
HIMODEL_COOL_41A_~  N NUMB   0066h            
HIMODEL_COOL_33A_~  N NUMB   0062h            
TURNIGY_AE_20A_MA~  N NUMB   0040h            
TURNIGY_PLUSH_6A_~  N NUMB   001Eh            
XP_35A_SW_MAIN . .  N NUMB   0013h            
ID1. . . . . . . .  C ADDR   1C47H   A 
FUNC_PARAVAL_STORE  C ADDR   1933H   A 
WRITE_EEPROM_BYTE~  C ADDR   17E1H   A 
READ_EEPROM_BLOCK1  C ADDR   1781H   A 
READ_EEPROM_READ .  C ADDR   177AH   A 
COMM23_DAMP_REV. .  C ADDR   0EDDH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0C9DH   A 
LOAD_MIN_TIME_FAST  C ADDR   0BF6H   A 
MEASURE_LIPO_EXIT.  C ADDR   09CAH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0851H   A 
GOVERNOR_CHECK_PR~  C ADDR   07A7H   A 
PCA_INT_SECOND_ME~  C ADDR   03EDH   A 
T2H_INT_RCP_STOP_~  C ADDR   0296H   A 
PWM_BFET_DAMPED. .  C ADDR   01A5H   A 
PCA_INT. . . . . .  C ADDR   037BH   A 
EEP_PGM_GOV_SETUP~  C ADDR   1A11H   A 
FLAGS1 . . . . . .  D ADDR   002DH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
MOTOR_PPM_HIGH_SL~  N NUMB   008Eh            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C4h            
SKYIII_30A_TAIL. .  N NUMB   00AAh            
EAZY_3AV2_MULTI. .  N NUMB   00A5h            
POLARIS_THUNDER_2~  N NUMB   0089h            
H_KING_50A_TAIL. .  N NUMB   0083h            
GAUI_GE_183_18A_T~  N NUMB   0077h            
HIMODEL_COOL_33A_~  N NUMB   0063h            
TURNIGY_AE_30A_MA~  N NUMB   0046h            
BOOT_INFO. . . . .  C ADDR   1DE0H   A 
ERRORVERIFY. . . .  N NUMB   00C0h            
READ_EEPROM_BLOCK2  C ADDR   178FH   A 
MEASURE_PWM_FREQ_~  C ADDR   12FDH   A 
COMM61_NONDAMP . .  C ADDR   1034H   A 
COMM6COMM1 . . . .  C ADDR   0FEFH   A 
COMM34_REV . . . .  C ADDR   0F42H   A 
COMM3COMM4 . . . .  C ADDR   0F2EH   A 
COMP_WAIT_NO_OF_R~  C ADDR   0D58H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D26H   A 
MEASURE_LIPO_LIMI~  C ADDR   09BAH   A 
GOVERNOR_CORR_PRO~  C ADDR   087AH   A 
GOVERNOR_SPEED_CH~  C ADDR   06EFH   A 
PCA_INT_CHECK_8KHZ  C ADDR   0451H   A 
T2H_INT_RCP_GOV_P~  C ADDR   02E7H   A 
PWM_CFET_DAMPED. .  C ADDR   01B6H   A 
DAMPINGFET . . . .  D ADDR   007BH   A 
WT_ZC_SCAN_START_H  D ADDR   004EH   A 
GOV_PROP_PWM . . .  D ADDR   0049H   A 
GOV_PROPORTIONAL_L  D ADDR   0047H   A 
FLAGS2 . . . . . .  D ADDR   002EH   A 
DEMAG_DETECTED . .  N NUMB   0005h            
RCP_SKIP_CNT . . .  D ADDR   002BH   A 
CURRENT_PWM_LIM_D~  D ADDR   0026H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
MCU_48MHZ. . . . .  N NUMB   0001h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
SKYIII_30A_MULTI .  N NUMB   00ABh            
POLARIS_THUNDER_8~  N NUMB   0094h            
POLARIS_THUNDER_3~  N NUMB   008Ch            
POLARIS_THUNDER_2~  N NUMB   008Ah            
POLARIS_THUNDER_1~  N NUMB   0086h            
H_KING_50A_MULTI .  N NUMB   0084h            
GAUI_GE_183_18A_M~  N NUMB   0078h            
TURNIGY_KFORCE_12~  N NUMB   0052h            
XP_3A_MAIN . . . .  N NUMB   0001h            



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6989    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =    103    ----
   IDATA SIZE       =     87    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
