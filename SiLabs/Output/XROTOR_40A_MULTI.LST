MACRO ASSEMBLER BLHELI                                      12/30/15 18:07:01 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\XROTOR_40A_REV14_3.OBJ
ASSEMBLER INVOKED BY: PRINT SET(BESCNO=189) OBJECT(OUTPUT\XROTOR_40A_REV14_3.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ;
                         4     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                         5     ;
                         6     ; Copyright 2011, 2012 Steffen Skaug
                         7     ; This program is distributed under the terms of the GNU General Public License
                         8     ;
                         9     ; This file is part of BLHeli.
                        10     ;
                        11     ; BLHeli is free software: you can redistribute it and/or modify
                        12     ; it under the terms of the GNU General Public License as published by
                        13     ; the Free Software Foundation, either version 3 of the License, or
                        14     ; (at your option) any later version.
                        15     ;
                        16     ; BLHeli is distributed in the hope that it will be useful,
                        17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        19     ; GNU General Public License for more details.
                        20     ;
                        21     ; You should have received a copy of the GNU General Public License
                        22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                        23     ;
                        24     ;**** **** **** **** ****
                        25     ;
                        26     ; The software was initially designed for use with Eflite mCP X, but is now adapted to copters/planes in general
                        27     ;
                        28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.versanet.de/~bkonze/blc_6a/blc_6a.htm
                        29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                        30     ;
                        31     ; This file is best viewed with tab width set to 5
                        32     ;
                        33     ; The input signal can be positive 1kHz, 2kHz, 4kHz, 8kHz or 12kHz PWM (e.g. taken from the "resistor tap" on mCPx)
                        34     ; And the input signal can be PPM (1-2ms) or OneShot125 (125-250us) at rates up to several hundred Hz.
                        35     ; The code autodetects the various input modes/frequencies
                        36     ; The code can also be programmed to accept inverted input signal.
                        37     ;
                        38     ; The first lines of the software must be modified according to the chosen environment:
                        39     ; Uncomment the selected ESC and main/tail/multi mode
                        40     ; BESCNO EQU "ESC"_"mode" 						
                        41     ; 
                        42     ;**** **** **** **** ****
                        43     ; Revision history:
                        44     ; - Rev1.0: Initial revision based upon BLHeli for AVR controllers
                        45     ; - Rev2.0: Changed "Eeprom" initialization, layout and defaults
                        46     ;           Various changes and improvements to comparator reading. Now using timer1 for time from pwm on/off
                        47     ;           Beeps are made louder
                        48     ;           Added programmable low voltage limit
                        49     ;           Added programmable damped tail mode (only for 1S ESCs)
                        50     ;           Added programmable motor rotation direction
                        51     ; - Rev2.1: (minor changes by 4712)
                        52     ;		  Added Disable TX Programming by PC Setup Application 
                        53     ;		  therfore changed EEPROM_LAYOUT_REVISION = 8					
                        54     ;		  Added Vdd Monitor as reset source when writing to "EEProm"
                        55     ;		  Changed for use of batch file to assemble, link and make hex files	
                        56     ; - Rev2.2: (minor changes by 4712)
                        57     ;           Added Disable Throttle Re-Arming every motor start by PC Setup Application 
                        58     ; - Rev2.3: (minor changes by 4712)
                        59     ;           Added bugfixed (2x CLR C before j(n)c operations)thx Steffen!			
                        60     ; - Rev2.4: Revisions 2.1 to 2.3 integrated
                        61     ; - Rev3.0: Added PPM (1050us-1866us) as accepted input signal
                        62     ;           Added startup rpm as a programming parameter
                        63     ;           Added startup acceleration as a programming parameter
                        64     ;           Added option for using voltage measurements to compensate motor power
                        65     ;           Added governor target by setup as a governor mode option
                        66     ;           Governor is kept active regardless of rpm
                        67     ;           Smooth governor spoolup/down in arm and setup modes
                        68     ;           Increased governor P and I gain programming ranges
                        69     ;           Increased and changed low voltage limit programming range
                        70     ;           Disabled tx programming entry for all but the first arming sequence after power on
                        71     ;           Made it possible to skip parameters in tx programming by setting throttle midstick
                        72     ;           Made it default not to rearm for every restart
                        73     ; - Rev3.1: Fixed bug that prevented chosen parameter to be set in tx programming
                        74     ; - Rev3.2: ...also updated the EEPROM revision parameter
                        75     ; - Rev3.3: Fixed negative number bug in voltage compensation
                        76     ;           Fixed bug in startup power calculation for non-default power
                        77     ;           Prevented possibility for voltage compensation fighting low voltage limiting
                        78     ;           Applied overall spoolup control to ensure soft spoolup in any mode
                        79     ;           Added a delay of 3 seconds from initiation of main motor stop until new startup is allowed
                        80     ;           Reduced beep power to reduce power consumption for very strong motors/ESCs
                        81     ; - Rev3.4: Fixed bug that prevented full power in governor arm and setup modes
                        82     ;           Increased NFETON_DELAY for XP_7A and XP_12A to allow for more powerful fets
                        83     ;           Increased initial spoolup power, and linked to startup power
                        84     ; - Rev4.0: Fixed bug that made tail tx program beeps very weak
                        85     ;           Added thermal protection feature
                        86     ;           Governor P and I gain ranges are extended up to 8.0x gain
                        87     ;           Startup sequence is aborted upon zero throttle
                        88     ;           Avoided voltage compensation function induced latency for tail when voltage compensation is not enabled
                        89     ;           Improved input signal frequency detection robustness
                        90     ; - Rev4.1: Increased thermal protection temperature limits
                        91     ; - Rev5.0: Added multi(copter) operating mode. TAIL define changed to MODE with three modes: MAIN, TAIL and MULTI
                        92     ;           Added programmable commutation timing
                        93     ;           Added a damped light mode that has less damping, but that can be used with all escs
                        94     ;           Added programmable damping force
                        95     ;           Added thermal protection for startup too
                        96     ;           Added wait beeps when waiting more than 30 sec for throttle above zero (after having been armed)
                        97     ;           Modified tail idling to provide option for very low speeds
                        98     ;           Changed PPM range to 1150-1830us
                        99     ;           Arming sequence is dropped for PPM input, unless it is governor arm mode
                       100     ;           Loss of input signal will immediately stop the motor for PPM input
                       101     ;           Bug corrected in Turnigy Plush 6A voltage measurement setup
                       102     ;           FET switching delays are set for original fets. Stronger/doubled/tripled etc fets may require faster pfet off switching
                       103     ;           Miscellaneous other changes
                       104     ; - Rev6.0: Reverted comparator reading routine to rev5.0 equivalent, in order to avoid tail motor stops
                       105     ;           Added governor range programmability
                       106     ;           Implemented startup retry sequence with varying startup power for multi mode
                       107     ;           In damped light mode, damping is now applied to the active nfet phase for fully damped capable ESCs
                       108     ; - Rev6.1: Added input signal qualification criteria for PPM, to avoid triggering on noise spikes (fix for plush hardware)
                       109     ;           Changed main and multi mode stop criteria. Will now be in run mode, even if RC pulse input is zero
                       110     ;           Fixed bug in commutation that caused rough running in damped light mode
                       111     ;           Miscellaneous other changes
                       112     ; - Rev7.0  Added direct startup mode programmability
                       113     ;           Added throttle calibration. Min>=1000us and Max<=2000us. Difference must be >520us, otherwise max is shifted so that difference=520us
                       114     ;           Added programmable throttle change rate
                       115     ;           Added programmable beep strength, beacon strength and beacon delay
                       116     ;           Reduced power step to full power significantly
                       117     ;           Miscellaneous other changes
                       118     ; - Rev8.0  Added a 2 second delay after power up, to wait for receiver initialization
                       119     ;           Added a programming option for disabling low voltage limit, and made it default for MULTI
                       120     ;           Added programable demag compensation, using the concept of SimonK
                       121     ;           Improved robustness against noisy input signal
                       122     ;           Refined direct startup
                       123     ;           Removed voltage compensation
                       124     ;           Miscellaneous other changes
                       125     ; - Rev9.0  Increased programming range for startup power, and made its default ESC dependent
                       126     ;           Made default startup method ESC dependent
                       127     ;           Even more smooth and gentle spoolup for MAIN, to suit larger helis
                       128     ;           Improved transition from stepped startup to run
                       129     ;           Refined direct startup
                       130     ; - Rev9.1  Fixed bug that changed FW revision after throttle calibration or TX programming
                       131     ; - Rev9.2  Altered timing of throttle calibration in order to work with MultiWii calibration firmware
                       132     ;           Reduced main spoolup time to around 5 seconds
                       133     ;           Changed default beacon delay to 3 minutes
                       134     ; - Rev9.3  Fixed bug in Plush 60/80A temperature reading, that caused failure in operation above 4S
                       135     ;           Corrected temperature limit for HiModel cool 22/33/41A, RCTimer 6A, Skywalker 20/40A, Turnigy AE45A, Plush 40/60/80A. Limit was previously set too high
                       136     ; - Rev9.4  Improved timing for increased maximum rpm limit
                       137     ; - Rev10.0 Added closed loop mode for multi
                       138     ;           Added high/low BEC voltage option (for the ESCs where HW supports it)
                       139     ;           Added method of resetting all programmed parameter values to defaults by TX programming
                       140     ;           Added Turnigy K-force 40A and Turnigy K-force 120A HV ESCs
                       141     ;           Enabled fully damped mode for several ESCs
                       142     ;           Extended startup power range downwards to enable very smooth start for large heli main motors
                       143     ;           Extended damping force with a highest setting
                       144     ;           Corrected temperature limits for F310 chips (Plush 40A and AE 45A)
                       145     ;           Implemented temperature reading average in order to avoid problems with ADC noise on Skywalkers
                       146     ;           Increased switching delays for XP 7A fast, in order to avoid cross conduction of N and P fets
                       147     ;           Miscellaneous other changes
                       148     ; - Rev10.1 Relaxed RC signal jitter requirement during frequency measurement
                       149     ;           Corrected bug that prevented using governor low
                       150     ;           Enabled vdd monitor always, in order to reduce likelihood of accidental overwriting of adjustments
                       151     ;           Fixed bug that caused stop for PPM input above 2048us, and moved upper accepted limit to 2160us
                       152     ; - Rev10.2 Corrected temperature limit for AE20-30/XP7-25, where limit was too high
                       153     ;           Corrected temperature limit for 120HV, where limit was too low
                       154     ;           Fixed bug that caused AE20/25/30A not to run in reverse
                       155     ; - Rev10.3 Removed vdd monitor for 1S capable ESCs, in order to avoid brownouts/resets
                       156     ;           Made auto bailout spoolup for main more smooth
                       157     ; - Rev10.4 Ensured that main spoolup and governor activation will always be smooth, regardless of throttle input
                       158     ;           Added capability to operate on 12kHz input signal too
                       159     ; - Rev11.0 Fixed bug of programming default values for governor in MULTI mode
                       160     ;           Disabled interrupts explicitly some places, to avoid possibilities for unintentional fet switching
                       161     ;           Changed interrupt disable strategy, to always allow pwm interrupts, to avoid noise when running at low rpms
                       162     ;           Added governor middle range for MAIN mode
                       163     ;           Added bidirectional mode for TAIL and MULTI mode with PPM input
                       164     ;           Changed and improved demag compensation
                       165     ;           Miscellaneous other changes
                       166     ; - Rev11.1 Fixed bug of slow acceleration response for MAIN mode running without governor
                       167     ;           Fixed bug with PWM input, where throttle remains high even when zeroing throttle (seen on V922 tail)
                       168     ;           Fixed bug in bidirectional operation, where direction change could cause reset
                       169     ;           Improved autorotation bailout for MAIN
                       170     ;           Reduced min speed back to 1220 erpm
                       171     ;           Misc code cleanups
                       172     ; - Rev11.2 Fixed throttle calibration bug
                       173     ;           Added high side driver precharge for all-nfet ESCs
                       174     ;           Optimized timing in general and for demag compensation in particular
                       175     ;           Auto bailout functionality modified
                       176     ;           Governor is deactivated for throttle inputs below 10%
                       177     ;           Increased beacon delay times
                       178     ; - Rev12.0 Added programmable main spoolup time
                       179     ;           Added programmable temperature protection enable
                       180     ;           Bidirectional mode stop/start improved. Motor is now stopped before starting
                       181     ;           Power is limited for very low rpms (when BEMF is low), in order to avoid sync loss 
                       182     ;           Damped light mode is made more smooth and quiet, particularly at low and high rpms
                       183     ;           Comparator signal qualification scheme is changed
                       184     ;           Demag compensation scheme is significantly changed
                       185     ;           Increased jitter tolerance for PPM frequency measurement
                       186     ;           Fully damped mode removed, and damped light only supported on damped capable ESCs
                       187     ;           Default tail mode changed to damped light
                       188     ;           Miscellaneous other changes
                       189     ; - Rev12.1 Fixed bug in tail code
                       190     ;           Improved startup for Atmel
                       191     ;           Added support for multiple high BEC voltages
                       192     ;           Added support for RPM output
                       193     ; - Rev12.2 Improved running smoothness, particularly for damped light
                       194     ;           Avoiding lockup at full throttle when input signal is noisy
                       195     ;           Avoiding detection of 1-wire programming signal as valid throttle signal
                       196     ; - Rev13.0 Removed stepped start
                       197     ;           Removed throttle change rate and damping force parameters
                       198     ;           Added support for OneShot125
                       199     ;           Improved commutation timing accuracy
                       200     ; - Rev13.1 Removed startup ramp for MULTI
                       201     ;           Improved startup for some odd ESCs
                       202     ; - Rev13.2 Still tweaking startup to make it more reliable and faster for all ESC/motor combos
                       203     ;           Increased deadband for bidirectional operation
                       204     ;           Relaxed signal detection criteria
                       205     ;           Added support for running 48MHz capable SiLabs MCUs at 48MHz
                       206     ;           Added bootlader to SiLabs code
                       207     ;           Miscellaneous other changes
                       208     ; - Rev14.0 Improved running at high timing
                       209     ;           Improved running at high RPMs and increased max RPM limit
                       210     ;           Avoid being locked in bootloader (implemented in Suite 13202)
                       211     ;           Improved reliability of 3D (bidirectional) mode and startup
                       212     ;           Smoother running and greatly reduced step to full power in damped light mode
                       213     ;           Removed low voltage limiting for MULTI
                       214     ;           Added pwm dither parameter
                       215     ;           Added setting for enable/disable of low RPM power protection
                       216     ;           Added setting for enable/disable of PWM input
                       217     ;           Better AFW and damping for some ESCs (that have a slow high side driver)
                       218     ;           Miscellaneous other changes
                       219     ; - Rev14.1 Fixed max throttle calibration bug (for non-oneshot)
                       220     ;           Fixed some closed loop mode bugs
                       221     ;           Relaxed signal jitter requirement for looptimes below 1000
                       222     ;           Added skipping of damping fet switching near max power, for improved high end throttle linearity, using the concept of SimonK
                       223     ;           Improved sync hold at high rpms
                       224     ; - Rev14.2 Added stalled motor shutoff after about 10 seconds (for tail and multi code with PPM input)
                       225     ;           Greatly increased maximum rpm limit, and added rpm limiting at 250k erpm (48MHz MCUs at 400k erpm)
                       226     ;           Improved bidirectional operation
                       227     ; - Rev14.3 Moved reset vector to be just before the settings segment, in order to better recover from partially failed flashing operation
                       228     ;           Added 100ms intialization delay for the Graupner Ultra 20A ESC
                       229     ;           Shortened stall detect time to about 5sec, and prevented going into tx programming after a stall
                       230     ;           Optimizations of software timing and running reliability
                       231     ;
                       232     ;           
                       233     ;
                       234     ;**** **** **** **** ****
                       235     ; Up to 8K Bytes of In-System Self-Programmable Flash
                       236     ; 768 Bytes Internal SRAM
                       237     ;
                       238     ;**** **** **** **** ****
                       239     ; Master clock is internal 24MHz oscillator
                       240     ; Timer 0 (167/500ns counts) always counts up and is used for
                       241     ; - PWM generation
                       242     ; Timer 1 (167/500ns counts) always counts up and is used for
                       243     ; - Time from pwm on/off event
                       244     ; Timer 2 (500ns counts) always counts up and is used for
                       245     ; - RC pulse timeout/skip counts and commutation times
                       246     ; Timer 3 (500ns counts) always counts up and is used for
                       247     ; - Commutation timeouts
                       248     ; PCA0 (500ns counts) always counts up and is used for
                       249     ; - RC pulse measurement
                       250     ;
                       251     ;**** **** **** **** ****
                       252     ; Interrupt handling
                       253     ; The F330 does not disable interrupts when entering an interrupt routine.
                       254     ; Also some interrupt flags need to be cleared by software
                       255     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                       256     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                       257     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                       258     ;
                       259     ;**** **** **** **** ****
                       260     ; Motor control:
                       261     ; - Brushless motor control with 6 states for each electrical 360 degrees
                       262     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                       263     ; - Timing advance in this implementation is set to 15deg nominally
                       264     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                       265     ; Motor sequence starting from zero crossing:
                       266     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                       267     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                       268     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                       269     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                       270     ;
                       271     ; Motor startup:
                       272     ; Startup is the only phase, before normal bemf commutation run begins.
                       273     ;
                       274     ;**** **** **** **** ****
                       275     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0001                 276     XP_3A_MAIN 					EQU 1
  0002                 277     XP_3A_TAIL 					EQU 2
  0003                 278     XP_3A_MULTI 					EQU 3
  0004                 279     XP_7A_MAIN 					EQU 4
  0005                 280     XP_7A_TAIL 					EQU 5
  0006                 281     XP_7A_MULTI 					EQU 6
  0007                 282     XP_7A_FAST_MAIN 				EQU 7
  0008                 283     XP_7A_FAST_TAIL 				EQU 8
  0009                 284     XP_7A_FAST_MULTI 				EQU 9
  000A                 285     XP_12A_MAIN 					EQU 10
  000B                 286     XP_12A_TAIL 					EQU 11
  000C                 287     XP_12A_MULTI 					EQU 12
  000D                 288     XP_18A_MAIN 					EQU 13
  000E                 289     XP_18A_TAIL 					EQU 14
  000F                 290     XP_18A_MULTI 					EQU 15
  0010                 291     XP_25A_MAIN 					EQU 16
  0011                 292     XP_25A_TAIL 					EQU 17
  0012                 293     XP_25A_MULTI 					EQU 18
  0013                 294     XP_35A_SW_MAIN 				EQU 19
  0014                 295     XP_35A_SW_TAIL 				EQU 20
  0015                 296     XP_35A_SW_MULTI 				EQU 21
  0016                 297     DP_3A_MAIN 					EQU 22
  0017                 298     DP_3A_TAIL  					EQU 23
  0018                 299     DP_3A_MULTI  					EQU 24
  0019                 300     SUPERMICRO_3P5A_MAIN 			EQU 25
  001A                 301     SUPERMICRO_3P5A_TAIL 			EQU 26   
  001B                 302     SUPERMICRO_3P5A_MULTI 			EQU 27   
  001C                 303     TURNIGY_PLUSH_6A_MAIN 			EQU 28
  001D                 304     TURNIGY_PLUSH_6A_TAIL 			EQU 29   
  001E                 305     TURNIGY_PLUSH_6A_MULTI 			EQU 30   
  001F                 306     TURNIGY_PLUSH_10A_MAIN 			EQU 31
  0020                 307     TURNIGY_PLUSH_10A_TAIL 			EQU 32   
  0021                 308     TURNIGY_PLUSH_10A_MULTI 			EQU 33   
  0022                 309     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                 310     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                 311     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  0025                 312     TURNIGY_PLUSH_18A_MAIN 			EQU 37
  0026                 313     TURNIGY_PLUSH_18A_TAIL 			EQU 38   
  0027                 314     TURNIGY_PLUSH_18A_MULTI 			EQU 39   
  0028                 315     TURNIGY_PLUSH_25A_MAIN 			EQU 40
  0029                 316     TURNIGY_PLUSH_25A_TAIL 			EQU 41   
  002A                 317     TURNIGY_PLUSH_25A_MULTI 			EQU 42   
  002B                 318     TURNIGY_PLUSH_30A_MAIN 			EQU 43
  002C                 319     TURNIGY_PLUSH_30A_TAIL 			EQU 44   
  002D                 320     TURNIGY_PLUSH_30A_MULTI 			EQU 45   
  002E                 321     TURNIGY_PLUSH_40A_MAIN 			EQU 46
  002F                 322     TURNIGY_PLUSH_40A_TAIL 			EQU 47   
  0030                 323     TURNIGY_PLUSH_40A_MULTI 			EQU 48   
  0031                 324     TURNIGY_PLUSH_60A_MAIN 			EQU 49
  0032                 325     TURNIGY_PLUSH_60A_TAIL 			EQU 50   
  0033                 326     TURNIGY_PLUSH_60A_MULTI 			EQU 51   
  0034                 327     TURNIGY_PLUSH_80A_MAIN 			EQU 52
  0035                 328     TURNIGY_PLUSH_80A_TAIL 			EQU 53   
  0036                 329     TURNIGY_PLUSH_80A_MULTI 			EQU 54   
  0037                 330     TURNIGY_PLUSH_NFET_18A_MAIN 		EQU 55
  0038                 331     TURNIGY_PLUSH_NFET_18A_TAIL 		EQU 56   
  0039                 332     TURNIGY_PLUSH_NFET_18A_MULTI 		EQU 57   
  003A                 333     TURNIGY_PLUSH_NFET_25A_MAIN 		EQU 58
  003B                 334     TURNIGY_PLUSH_NFET_25A_TAIL 		EQU 59   
  003C                 335     TURNIGY_PLUSH_NFET_25A_MULTI 		EQU 60   
  003D                 336     TURNIGY_PLUSH_NFET_30A_MAIN 		EQU 61
  003E                 337     TURNIGY_PLUSH_NFET_30A_TAIL 		EQU 62   
  003F                 338     TURNIGY_PLUSH_NFET_30A_MULTI 		EQU 63   
  0040                 339     TURNIGY_AE_20A_MAIN 			EQU 64
  0041                 340     TURNIGY_AE_20A_TAIL 			EQU 65   
  0042                 341     TURNIGY_AE_20A_MULTI 			EQU 66   
  0043                 342     TURNIGY_AE_25A_MAIN 			EQU 67
  0044                 343     TURNIGY_AE_25A_TAIL 			EQU 68   
  0045                 344     TURNIGY_AE_25A_MULTI 			EQU 69   
  0046                 345     TURNIGY_AE_30A_MAIN 			EQU 70
  0047                 346     TURNIGY_AE_30A_TAIL 			EQU 71   
  0048                 347     TURNIGY_AE_30A_MULTI 			EQU 72   
  0049                 348     TURNIGY_AE_45A_MAIN 			EQU 73
  004A                 349     TURNIGY_AE_45A_TAIL 			EQU 74   
  004B                 350     TURNIGY_AE_45A_MULTI 			EQU 75   
  004C                 351     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                 352     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                 353     TURNIGY_KFORCE_40A_MULTI 		EQU 78   
  004F                 354     TURNIGY_KFORCE_70A_HV_MAIN 		EQU 79   
  0050                 355     TURNIGY_KFORCE_70A_HV_TAIL 		EQU 80   
  0051                 356     TURNIGY_KFORCE_70A_HV_MULTI 		EQU 81   
  0052                 357     TURNIGY_KFORCE_120A_HV_MAIN 		EQU 82   
  0053                 358     TURNIGY_KFORCE_120A_HV_TAIL 		EQU 83   
  0054                 359     TURNIGY_KFORCE_120A_HV_MULTI 		EQU 84   
  0055                 360     TURNIGY_KFORCE_120A_HV_V2_MAIN	EQU 85   
  0056                 361     TURNIGY_KFORCE_120A_HV_V2_TAIL 	EQU 86   
  0057                 362     TURNIGY_KFORCE_120A_HV_V2_MULTI 	EQU 87   
  0058                 363     SKYWALKER_20A_MAIN 				EQU 88
  0059                 364     SKYWALKER_20A_TAIL 				EQU 89   
  005A                 365     SKYWALKER_20A_MULTI 			EQU 90   
  005B                 366     SKYWALKER_40A_MAIN 				EQU 91
  005C                 367     SKYWALKER_40A_TAIL 				EQU 92   
  005D                 368     SKYWALKER_40A_MULTI 			EQU 93   
  005E                 369     HIMODEL_COOL_22A_MAIN 			EQU 94
  005F                 370     HIMODEL_COOL_22A_TAIL 			EQU 95   
  0060                 371     HIMODEL_COOL_22A_MULTI 			EQU 96   
  0061                 372     HIMODEL_COOL_33A_MAIN 			EQU 97
  0062                 373     HIMODEL_COOL_33A_TAIL 			EQU 98   
  0063                 374     HIMODEL_COOL_33A_MULTI 			EQU 99  
  0064                 375     HIMODEL_COOL_41A_MAIN 			EQU 100
  0065                 376     HIMODEL_COOL_41A_TAIL 			EQU 101  
  0066                 377     HIMODEL_COOL_41A_MULTI 			EQU 102  
  0067                 378     RCTIMER_6A_MAIN 				EQU 103   
  0068                 379     RCTIMER_6A_TAIL 				EQU 104  
  0069                 380     RCTIMER_6A_MULTI 				EQU 105  
  006A                 381     ALIGN_RCE_BL15X_MAIN			EQU 106   
  006B                 382     ALIGN_RCE_BL15X_TAIL 			EQU 107  
  006C                 383     ALIGN_RCE_BL15X_MULTI 			EQU 108  
  006D                 384     ALIGN_RCE_BL15P_MAIN			EQU 109  
  006E                 385     ALIGN_RCE_BL15P_TAIL 			EQU 110  
  006F                 386     ALIGN_RCE_BL15P_MULTI 			EQU 111  
  0070                 387     ALIGN_RCE_BL35X_MAIN			EQU 112  
  0071                 388     ALIGN_RCE_BL35X_TAIL 			EQU 113  
  0072                 389     ALIGN_RCE_BL35X_MULTI 			EQU 114  
  0073                 390     ALIGN_RCE_BL35P_MAIN			EQU 115   
  0074                 391     ALIGN_RCE_BL35P_TAIL 			EQU 116  
  0075                 392     ALIGN_RCE_BL35P_MULTI 			EQU 117  
  0076                 393     GAUI_GE_183_18A_MAIN			EQU 118   
  0077                 394     GAUI_GE_183_18A_TAIL 			EQU 119  
  0078                 395     GAUI_GE_183_18A_MULTI 			EQU 120  
  0079                 396     H_KING_10A_MAIN				EQU 121   
  007A                 397     H_KING_10A_TAIL 				EQU 122  
  007B                 398     H_KING_10A_MULTI 				EQU 123  
  007C                 399     H_KING_20A_MAIN				EQU 124   
  007D                 400     H_KING_20A_TAIL 				EQU 125  
  007E                 401     H_KING_20A_MULTI 				EQU 126  
  007F                 402     H_KING_35A_MAIN				EQU 127   
  0080                 403     H_KING_35A_TAIL 				EQU 128 
  0081                 404     H_KING_35A_MULTI 				EQU 129  
  0082                 405     H_KING_50A_MAIN				EQU 130   
  0083                 406     H_KING_50A_TAIL 				EQU 131  
  0084                 407     H_KING_50A_MULTI 				EQU 132  
  0085                 408     POLARIS_THUNDER_12A_MAIN			EQU 133   
  0086                 409     POLARIS_THUNDER_12A_TAIL 		EQU 134  
  0087                 410     POLARIS_THUNDER_12A_MULTI 		EQU 135  
  0088                 411     POLARIS_THUNDER_20A_MAIN			EQU 136   
  0089                 412     POLARIS_THUNDER_20A_TAIL 		EQU 137  
  008A                 413     POLARIS_THUNDER_20A_MULTI 		EQU 138  
  008B                 414     POLARIS_THUNDER_30A_MAIN			EQU 139   
  008C                 415     POLARIS_THUNDER_30A_TAIL 		EQU 140  
  008D                 416     POLARIS_THUNDER_30A_MULTI 		EQU 141  
  008E                 417     POLARIS_THUNDER_40A_MAIN			EQU 142   
  008F                 418     POLARIS_THUNDER_40A_TAIL 		EQU 143  
  0090                 419     POLARIS_THUNDER_40A_MULTI 		EQU 144  
  0091                 420     POLARIS_THUNDER_60A_MAIN			EQU 145   
  0092                 421     POLARIS_THUNDER_60A_TAIL 		EQU 146  
  0093                 422     POLARIS_THUNDER_60A_MULTI 		EQU 147  
  0094                 423     POLARIS_THUNDER_80A_MAIN			EQU 148   
  0095                 424     POLARIS_THUNDER_80A_TAIL 		EQU 149  
  0096                 425     POLARIS_THUNDER_80A_MULTI 		EQU 150  
  0097                 426     POLARIS_THUNDER_100A_MAIN		EQU 151   
  0098                 427     POLARIS_THUNDER_100A_TAIL 		EQU 152  
  0099                 428     POLARIS_THUNDER_100A_MULTI 		EQU 153  
  009A                 429     PLATINUM_PRO_30A_MAIN			EQU 154   
  009B                 430     PLATINUM_PRO_30A_TAIL 			EQU 155  
  009C                 431     PLATINUM_PRO_30A_MULTI 			EQU 156  
  009D                 432     PLATINUM_PRO_150A_MAIN			EQU 157   
  009E                 433     PLATINUM_PRO_150A_TAIL 			EQU 158  
  009F                 434     PLATINUM_PRO_150A_MULTI 			EQU 159  
  00A0                 435     PLATINUM_50AV3_MAIN				EQU 160   
  00A1                 436     PLATINUM_50AV3_TAIL 			EQU 161  
  00A2                 437     PLATINUM_50AV3_MULTI 			EQU 162  
  00A3                 438     EAZY_3AV2_MAIN					EQU 163   
  00A4                 439     EAZY_3AV2_TAIL 				EQU 164  
  00A5                 440     EAZY_3AV2_MULTI 				EQU 165  
  00A6                 441     TAROT_30A_MAIN					EQU 166   
  00A7                 442     TAROT_30A_TAIL 				EQU 167  
  00A8                 443     TAROT_30A_MULTI 				EQU 168  
  00A9                 444     SKYIII_30A_MAIN				EQU 169   
  00AA                 445     SKYIII_30A_TAIL 				EQU 170  
  00AB                 446     SKYIII_30A_MULTI 				EQU 171  
  00AC                 447     EMAX_20A_MAIN					EQU 172   
  00AD                 448     EMAX_20A_TAIL 					EQU 173  
  00AE                 449     EMAX_20A_MULTI 				EQU 174  
  00AF                 450     EMAX_40A_MAIN					EQU 175   
  00B0                 451     EMAX_40A_TAIL 					EQU 176  
  00B1                 452     EMAX_40A_MULTI 				EQU 177  
  00B2                 453     EMAX_NANO_20A_MAIN				EQU 178   
  00B3                 454     EMAX_NANO_20A_TAIL 				EQU 179  
  00B4                 455     EMAX_NANO_20A_MULTI 			EQU 180  
  00B5                 456     XROTOR_10A_MAIN				EQU 181   
  00B6                 457     XROTOR_10A_TAIL 				EQU 182  
  00B7                 458     XROTOR_10A_MULTI 				EQU 183  
  00B8                 459     XROTOR_20A_MAIN				EQU 184   
  00B9                 460     XROTOR_20A_TAIL 				EQU 185  
  00BA                 461     XROTOR_20A_MULTI 				EQU 186  
  00BB                 462     XROTOR_40A_MAIN				EQU 187   
  00BC                 463     XROTOR_40A_TAIL 				EQU 188  
  00BD                 464     XROTOR_40A_MULTI 				EQU 189  
  00BE                 465     MDRX62H_MAIN					EQU 190   
  00BF                 466     MDRX62H_TAIL 					EQU 191  
  00C0                 467     MDRX62H_MULTI 					EQU 192  
  00C1                 468     ROTORGEEKS_20A_MAIN				EQU 193   
  00C2                 469     ROTORGEEKS_20A_TAIL 			EQU 194  
  00C3                 470     ROTORGEEKS_20A_MULTI 			EQU 195  
  00C4                 471     FLYCOLOR_FAIRY_6A_MAIN			EQU 196   
  00C5                 472     FLYCOLOR_FAIRY_6A_TAIL 			EQU 197  
  00C6                 473     FLYCOLOR_FAIRY_6A_MULTI 			EQU 198  
  00C7                 474     FLYCOLOR_FAIRY_30A_MAIN			EQU 199   
  00C8                 475     FLYCOLOR_FAIRY_30A_TAIL 			EQU 200  
  00C9                 476     FLYCOLOR_FAIRY_30A_MULTI 		EQU 201  
  00CA                 477     FVT_LITTLEBEE_20A_MAIN			EQU 202  
  00CB                 478     FVT_LITTLEBEE_20A_TAIL			EQU 203  
  00CC                 479     FVT_LITTLEBEE_20A_MULTI			EQU 204  
  00CD                 480     FVT_LITTLEBEE_30A_MAIN			EQU 205  
  00CE                 481     FVT_LITTLEBEE_30A_TAIL			EQU 206  
  00CF                 482     FVT_LITTLEBEE_30A_MULTI			EQU 207  
  00D0                 483     GRAUPNER_ULTRA_20A_MAIN			EQU 208  
  00D1                 484     GRAUPNER_ULTRA_20A_TAIL			EQU 209  
  00D2                 485     GRAUPNER_ULTRA_20A_MULTI			EQU 210  
  00D3                 486     F85_3A_MAIN					EQU 211  
  00D4                 487     F85_3A_TAIL					EQU 212  
  00D5                 488     F85_3A_MULTI					EQU 213  
  00D6                 489     ZTW_SPIDER_PRO_20A_MAIN			EQU 214  
  00D7                 490     ZTW_SPIDER_PRO_20A_TAIL			EQU 215  
  00D8                 491     ZTW_SPIDER_PRO_20A_MULTI			EQU 216  
                       492     
                       493     
                       494     ;**** **** **** **** ****
                       495     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                       496     ;BESCNO EQU XP_3A_Main 
                       497     ;BESCNO EQU XP_3A_Tail
                       498     ;BESCNO EQU XP_3A_Multi
                       499     ;BESCNO EQU XP_7A_Main
                       500     ;BESCNO EQU XP_7A_Tail
                       501     ;BESCNO EQU XP_7A_Multi
                       502     ;BESCNO EQU XP_7A_Fast_Main
                       503     ;BESCNO EQU XP_7A_Fast_Tail
                       504     ;BESCNO EQU XP_7A_Fast_Multi
                       505     ;BESCNO EQU XP_12A_Main
                       506     ;BESCNO EQU XP_12A_Tail 
                       507     ;BESCNO EQU XP_12A_Multi
                       508     ;BESCNO EQU XP_18A_Main 
                       509     ;BESCNO EQU XP_18A_Tail 
                       510     ;BESCNO EQU XP_18A_Multi
                       511     ;BESCNO EQU XP_25A_Main 
                       512     ;BESCNO EQU XP_25A_Tail 
                       513     ;BESCNO EQU XP_25A_Multi
                       514     ;BESCNO EQU XP_35A_SW_Main
                       515     ;BESCNO EQU XP_35A_SW_Tail 
                       516     ;BESCNO EQU XP_35A_SW_Multi
                       517     ;BESCNO EQU DP_3A_Main 						
                       518     ;BESCNO EQU DP_3A_Tail 
                       519     ;BESCNO EQU DP_3A_Multi 
                       520     ;BESCNO EQU Supermicro_3p5A_Main
                       521     ;BESCNO EQU Supermicro_3p5A_Tail 
                       522     ;BESCNO EQU Supermicro_3p5A_Multi
                       523     ;BESCNO EQU Turnigy_Plush_6A_Main 
                       524     ;BESCNO EQU Turnigy_Plush_6A_Tail 
                       525     ;BESCNO EQU Turnigy_Plush_6A_Multi
                       526     ;BESCNO EQU Turnigy_Plush_10A_Main 
                       527     ;BESCNO EQU Turnigy_Plush_10A_Tail 
                       528     ;BESCNO EQU Turnigy_Plush_10A_Multi
                       529     ;BESCNO EQU Turnigy_Plush_12A_Main 
                       530     ;BESCNO EQU Turnigy_Plush_12A_Tail 
                       531     ;BESCNO EQU Turnigy_Plush_12A_Multi 
                       532     ;BESCNO EQU Turnigy_Plush_18A_Main 
                       533     ;BESCNO EQU Turnigy_Plush_18A_Tail 
                       534     ;BESCNO EQU Turnigy_Plush_18A_Multi
                       535     ;BESCNO EQU Turnigy_Plush_25A_Main 
                       536     ;BESCNO EQU Turnigy_Plush_25A_Tail
                       537     ;BESCNO EQU Turnigy_Plush_25A_Multi
                       538     ;BESCNO EQU Turnigy_Plush_30A_Main 
                       539     ;BESCNO EQU Turnigy_Plush_30A_Tail 
                       540     ;BESCNO EQU Turnigy_Plush_30A_Multi
                       541     ;BESCNO EQU Turnigy_Plush_40A_Main 
                       542     ;BESCNO EQU Turnigy_Plush_40A_Tail 
                       543     ;BESCNO EQU Turnigy_Plush_40A_Multi 
                       544     ;BESCNO EQU Turnigy_Plush_60A_Main
                       545     ;BESCNO EQU Turnigy_Plush_60A_Tail 
                       546     ;BESCNO EQU Turnigy_Plush_60A_Multi
                       547     ;BESCNO EQU Turnigy_Plush_80A_Main
                       548     ;BESCNO EQU Turnigy_Plush_80A_Tail 
                       549     ;BESCNO EQU Turnigy_Plush_80A_Multi
                       550     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Main
                       551     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Tail 
                       552     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Multi 
                       553     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Main 
                       554     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Tail
                       555     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Multi
                       556     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Main  
                       557     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Tail 
                       558     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Multi
                       559     ;BESCNO EQU Turnigy_AE_20A_Main 
                       560     ;BESCNO EQU Turnigy_AE_20A_Tail 
                       561     ;BESCNO EQU Turnigy_AE_20A_Multi
                       562     ;BESCNO EQU Turnigy_AE_25A_Main 
                       563     ;BESCNO EQU Turnigy_AE_25A_Tail 
                       564     ;BESCNO EQU Turnigy_AE_25A_Multi
                       565     ;BESCNO EQU Turnigy_AE_30A_Main 
                       566     ;BESCNO EQU Turnigy_AE_30A_Tail 
                       567     ;BESCNO EQU Turnigy_AE_30A_Multi
                       568     ;BESCNO EQU Turnigy_AE_45A_Main
                       569     ;BESCNO EQU Turnigy_AE_45A_Tail 
                       570     ;BESCNO EQU Turnigy_AE_45A_Multi
                       571     ;BESCNO EQU Turnigy_KForce_40A_Main
                       572     ;BESCNO EQU Turnigy_KForce_40A_Tail 
                       573     ;BESCNO EQU Turnigy_KForce_40A_Multi 
                       574     ;BESCNO EQU Turnigy_KForce_70A_HV_Main
                       575     ;BESCNO EQU Turnigy_KForce_70A_HV_Tail 
                       576     ;BESCNO EQU Turnigy_KForce_70A_HV_Multi
                       577     ;BESCNO EQU Turnigy_KForce_120A_HV_Main
                       578     ;BESCNO EQU Turnigy_KForce_120A_HV_Tail 
                       579     ;BESCNO EQU Turnigy_KForce_120A_HV_Multi
                       580     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Main
                       581     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Tail 
                       582     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Multi
                       583     ;BESCNO EQU Skywalker_20A_Main
                       584     ;BESCNO EQU Skywalker_20A_Tail
                       585     ;BESCNO EQU Skywalker_20A_Multi 
                       586     ;BESCNO EQU Skywalker_40A_Main 
                       587     ;BESCNO EQU Skywalker_40A_Tail 
                       588     ;BESCNO EQU Skywalker_40A_Multi
                       589     ;BESCNO EQU HiModel_Cool_22A_Main
                       590     ;BESCNO EQU HiModel_Cool_22A_Tail
                       591     ;BESCNO EQU HiModel_Cool_22A_Multi
                       592     ;BESCNO EQU HiModel_Cool_33A_Main
                       593     ;BESCNO EQU HiModel_Cool_33A_Tail
                       594     ;BESCNO EQU HiModel_Cool_33A_Multi
                       595     ;BESCNO EQU HiModel_Cool_41A_Main
                       596     ;BESCNO EQU HiModel_Cool_41A_Tail
                       597     ;BESCNO EQU HiModel_Cool_41A_Multi
                       598     ;BESCNO EQU RCTimer_6A_Main
                       599     ;BESCNO EQU RCTimer_6A_Tail
                       600     ;BESCNO EQU RCTimer_6A_Multi
                       601     ;BESCNO EQU Align_RCE_BL15X_Main
                       602     ;BESCNO EQU Align_RCE_BL15X_Tail
                       603     ;BESCNO EQU Align_RCE_BL15X_Multi
                       604     ;BESCNO EQU Align_RCE_BL15P_Main
                       605     ;BESCNO EQU Align_RCE_BL15P_Tail
                       606     ;BESCNO EQU Align_RCE_BL15P_Multi 
                       607     ;BESCNO EQU Align_RCE_BL35X_Main 
                       608     ;BESCNO EQU Align_RCE_BL35X_Tail
                       609     ;BESCNO EQU Align_RCE_BL35X_Multi
                       610     ;BESCNO EQU Align_RCE_BL35P_Main
                       611     ;BESCNO EQU Align_RCE_BL35P_Tail
                       612     ;BESCNO EQU Align_RCE_BL35P_Multi
                       613     ;BESCNO EQU Gaui_GE_183_18A_Main
                       614     ;BESCNO EQU Gaui_GE_183_18A_Tail
                       615     ;BESCNO EQU Gaui_GE_183_18A_Multi
                       616     ;BESCNO EQU H_King_10A_Main 
                       617     ;BESCNO EQU H_King_10A_Tail 
                       618     ;BESCNO EQU H_King_10A_Multi
                       619     ;BESCNO EQU H_King_20A_Main
                       620     ;BESCNO EQU H_King_20A_Tail
                       621     ;BESCNO EQU H_King_20A_Multi
                       622     ;BESCNO EQU H_King_35A_Main
                       623     ;BESCNO EQU H_King_35A_Tail
                       624     ;BESCNO EQU H_King_35A_Multi
                       625     ;BESCNO EQU H_King_50A_Main
                       626     ;BESCNO EQU H_King_50A_Tail
                       627     ;BESCNO EQU H_King_50A_Multi
                       628     ;BESCNO EQU Polaris_Thunder_12A_Main
                       629     ;BESCNO EQU Polaris_Thunder_12A_Tail
                       630     ;BESCNO EQU Polaris_Thunder_12A_Multi
                       631     ;BESCNO EQU Polaris_Thunder_20A_Main
                       632     ;BESCNO EQU Polaris_Thunder_20A_Tail
                       633     ;BESCNO EQU Polaris_Thunder_20A_Multi
                       634     ;BESCNO EQU Polaris_Thunder_30A_Main
                       635     ;BESCNO EQU Polaris_Thunder_30A_Tail
                       636     ;BESCNO EQU Polaris_Thunder_30A_Multi
                       637     ;BESCNO EQU Polaris_Thunder_40A_Main
                       638     ;BESCNO EQU Polaris_Thunder_40A_Tail
                       639     ;BESCNO EQU Polaris_Thunder_40A_Multi
                       640     ;BESCNO EQU Polaris_Thunder_60A_Main
                       641     ;BESCNO EQU Polaris_Thunder_60A_Tail
                       642     ;BESCNO EQU Polaris_Thunder_60A_Multi
                       643     ;BESCNO EQU Polaris_Thunder_80A_Main
                       644     ;BESCNO EQU Polaris_Thunder_80A_Tail
                       645     ;BESCNO EQU Polaris_Thunder_80A_Multi
                       646     ;BESCNO EQU Polaris_Thunder_100A_Main
                       647     ;BESCNO EQU Polaris_Thunder_100A_Tail
                       648     ;BESCNO EQU Polaris_Thunder_100A_Multi
                       649     ;BESCNO EQU Platinum_Pro_30A_Main
                       650     ;BESCNO EQU Platinum_Pro_30A_Tail
                       651     ;BESCNO EQU Platinum_Pro_30A_Multi 
                       652     ;BESCNO EQU Platinum_Pro_150A_Main
                       653     ;BESCNO EQU Platinum_Pro_150A_Tail
                       654     ;BESCNO EQU Platinum_Pro_150A_Multi
                       655     ;BESCNO EQU Platinum_50Av3_Main
                       656     ;BESCNO EQU Platinum_50Av3_Tail
                       657     ;BESCNO EQU Platinum_50Av3_Multi 
                       658     ;BESCNO EQU EAZY_3Av2_Main
                       659     ;BESCNO EQU EAZY_3Av2_Tail
                       660     ;BESCNO EQU EAZY_3Av2_Multi
                       661     ;BESCNO EQU Tarot_30A_Main
                       662     ;BESCNO EQU Tarot_30A_Tail
                       663     ;BESCNO EQU Tarot_30A_Multi
                       664     ;BESCNO EQU SkyIII_30A_Main
                       665     ;BESCNO EQU SkyIII_30A_Tail
                       666     ;BESCNO EQU SkyIII_30A_Multi
                       667     ;BESCNO EQU EMAX_20A_Main
                       668     ;BESCNO EQU EMAX_20A_Tail
                       669     ;BESCNO EQU EMAX_20A_Multi 
                       670     ;BESCNO EQU EMAX_40A_Main
                       671     ;BESCNO EQU EMAX_40A_Tail
                       672     ;BESCNO EQU EMAX_40A_Multi 
                       673     ;BESCNO EQU EMAX_Nano_20A_Main
                       674     ;BESCNO EQU EMAX_Nano_20A_Tail
                       675     ;BESCNO EQU EMAX_Nano_20A_Multi 
                       676     ;BESCNO EQU XRotor_10A_Main 
                       677     ;BESCNO EQU XRotor_10A_Tail
                       678     ;BESCNO EQU XRotor_10A_Multi 
                       679     ;BESCNO EQU XRotor_20A_Main
                       680     ;BESCNO EQU XRotor_20A_Tail
                       681     ;BESCNO EQU XRotor_20A_Multi 
                       682     ;BESCNO EQU XRotor_40A_Main
                       683     ;BESCNO EQU XRotor_40A_Tail
                       684     ;BESCNO EQU XRotor_40A_Multi 
                       685     ;BESCNO EQU MDRX62H_Main
                       686     ;BESCNO EQU MDRX62H_Tail
                       687     ;BESCNO EQU MDRX62H_Multi 
                       688     ;BESCNO EQU RotorGeeks_20A_Main
                       689     ;BESCNO EQU RotorGeeks_20A_Tail
                       690     ;BESCNO EQU RotorGeeks_20A_Multi
                       691     ;BESCNO EQU Flycolor_Fairy_6A_Main
                       692     ;BESCNO EQU Flycolor_Fairy_6A_Tail
                       693     ;BESCNO EQU Flycolor_Fairy_6A_Multi
                       694     ;BESCNO EQU Flycolor_Fairy_30A_Main
                       695     ;BESCNO EQU Flycolor_Fairy_30A_Tail
                       696     ;BESCNO EQU Flycolor_Fairy_30A_Multi
                       697     ;BESCNO EQU FVT_Littlebee_20A_Main
                       698     ;BESCNO EQU FVT_Littlebee_20A_Tail
                       699     ;BESCNO EQU FVT_Littlebee_20A_Multi 
                       700     ;BESCNO EQU FVT_Littlebee_30A_Main
                       701     ;BESCNO EQU FVT_Littlebee_30A_Tail
                       702     ;BESCNO EQU FVT_Littlebee_30A_Multi 
                       703     ;BESCNO EQU Graupner_Ultra_20A_Main
                       704     ;BESCNO EQU Graupner_Ultra_20A_Tail
                       705     ;BESCNO EQU Graupner_Ultra_20A_Multi 
                       706     ;BESCNO EQU F85_3A_Main
                       707     ;BESCNO EQU F85_3A_Tail
                       708     ;BESCNO EQU F85_3A_Multi
                       709     ;BESCNO EQU ZTW_Spider_Pro_20A_Main
                       710     ;BESCNO EQU ZTW_Spider_Pro_20A_Tail
                       711     ;BESCNO EQU ZTW_Spider_Pro_20A_Multi
                       712     
                       713     
                       714     ;**** **** **** **** ****
                       715     ; ESC selection statements
                       716     IF BESCNO == XP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       720     
                       721     IF BESCNO == XP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       725     
                       726     IF BESCNO == XP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       730     
                       731     IF BESCNO == XP_7A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       735     
                       736     IF BESCNO == XP_7A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       740     
                       741     IF BESCNO == XP_7A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       745     
                       746     IF BESCNO == XP_7A_FAST_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       750     
                       751     IF BESCNO == XP_7A_FAST_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       755     
                       756     IF BESCNO == XP_7A_FAST_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       760     
                       761     IF BESCNO == XP_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       765     
                       766     IF BESCNO == XP_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       770     
                       771     IF BESCNO == XP_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       775     
                       776     IF BESCNO == XP_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       780     
                       781     IF BESCNO == XP_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       785     
                       786     IF BESCNO == XP_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       790     
                       791     IF BESCNO == XP_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       795     
                       796     IF BESCNO == XP_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       800     
                       801     IF BESCNO == XP_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       805     
                       806     IF BESCNO == XP_35A_SW_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       810     
                       811     IF BESCNO == XP_35A_SW_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       815     
                       816     IF BESCNO == XP_35A_SW_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       820     
                       821     IF BESCNO == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       825     
                       826     IF BESCNO == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       830     
                       831     IF BESCNO == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       835     
                       836     IF BESCNO == SUPERMICRO_3P5A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       840     
                       841     IF BESCNO == SUPERMICRO_3P5A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       845     
                       846     IF BESCNO == SUPERMICRO_3P5A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       850     
                       851     IF BESCNO == TURNIGY_PLUSH_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       855     
                       856     IF BESCNO == TURNIGY_PLUSH_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       860     
                       861     IF BESCNO == TURNIGY_PLUSH_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       865     
                       866     IF BESCNO == TURNIGY_PLUSH_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       870     
                       871     IF BESCNO == TURNIGY_PLUSH_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       875     
                       876     IF BESCNO == TURNIGY_PLUSH_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       880     
                       881     IF BESCNO == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       885     
                       886     IF BESCNO == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       890     
                       891     IF BESCNO == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       895     
                       896     IF BESCNO == TURNIGY_PLUSH_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       900     
                       901     IF BESCNO == TURNIGY_PLUSH_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       905     
                       906     IF BESCNO == TURNIGY_PLUSH_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       910     
                       911     IF BESCNO == TURNIGY_PLUSH_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       915     
                       916     IF BESCNO == TURNIGY_PLUSH_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       920     
                       921     IF BESCNO == TURNIGY_PLUSH_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       925     
                       926     IF BESCNO == TURNIGY_PLUSH_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       930     
                       931     IF BESCNO == TURNIGY_PLUSH_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       935     
                       936     IF BESCNO == TURNIGY_PLUSH_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       940     
                       941     IF BESCNO == TURNIGY_PLUSH_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       945     
                       946     IF BESCNO == TURNIGY_PLUSH_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       950     
                       951     IF BESCNO == TURNIGY_PLUSH_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       955     
                       956     IF BESCNO == TURNIGY_PLUSH_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       960     
                       961     IF BESCNO == TURNIGY_PLUSH_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       965     
                       966     IF BESCNO == TURNIGY_PLUSH_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       970     
                       971     IF BESCNO == TURNIGY_PLUSH_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       975     
                       976     IF BESCNO == TURNIGY_PLUSH_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       980     
                       981     IF BESCNO == TURNIGY_PLUSH_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       985     
                       986     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       990     
                       991     IF BESCNO == TURNIGY_PLUSH_NFET_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       995     
                       996     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                      1000     
                      1001     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1005     
                      1006     IF BESCNO == TURNIGY_PLUSH_NFET_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1010     
                      1011     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                      1015     
                      1016     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1020     
                      1021     IF BESCNO == TURNIGY_PLUSH_NFET_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1025     
                      1026     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                      1030     
                      1031     IF BESCNO == TURNIGY_AE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1035     
                      1036     IF BESCNO == TURNIGY_AE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1040     
                      1041     IF BESCNO == TURNIGY_AE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                      1045     
                      1046     IF BESCNO == TURNIGY_AE_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1050     
                      1051     IF BESCNO == TURNIGY_AE_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1055     
                      1056     IF BESCNO == TURNIGY_AE_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                      1060     
                      1061     IF BESCNO == TURNIGY_AE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1065     
                      1066     IF BESCNO == TURNIGY_AE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1070     
                      1071     IF BESCNO == TURNIGY_AE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                      1075     
                      1076     IF BESCNO == TURNIGY_AE_45A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1080     
                      1081     IF BESCNO == TURNIGY_AE_45A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1085     
                      1086     IF BESCNO == TURNIGY_AE_45A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1090     
                      1091     IF BESCNO == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1095     
                      1096     IF BESCNO == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1100     
                      1101     IF BESCNO == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1105     
                      1106     IF BESCNO == TURNIGY_KFORCE_70A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1110     
                      1111     IF BESCNO == TURNIGY_KFORCE_70A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1115     
                      1116     IF BESCNO == TURNIGY_KFORCE_70A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1120     
                      1121     IF BESCNO == TURNIGY_KFORCE_120A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1125     
                      1126     IF BESCNO == TURNIGY_KFORCE_120A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1130     
                      1131     IF BESCNO == TURNIGY_KFORCE_120A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1135     
                      1136     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1140     
                      1141     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1145     
                      1146     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1150     
                      1151     IF BESCNO == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1155     
                      1156     IF BESCNO == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1160     
                      1161     IF BESCNO == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1165     
                      1166     IF BESCNO == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1170     
                      1171     IF BESCNO == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1175     
                      1176     IF BESCNO == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1180     
                      1181     IF BESCNO == HIMODEL_COOL_22A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1185     
                      1186     IF BESCNO == HIMODEL_COOL_22A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1190     
                      1191     IF BESCNO == HIMODEL_COOL_22A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1195     
                      1196     IF BESCNO == HIMODEL_COOL_33A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1200     
                      1201     IF BESCNO == HIMODEL_COOL_33A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1205     
                      1206     IF BESCNO == HIMODEL_COOL_33A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1210     
                      1211     IF BESCNO == HIMODEL_COOL_41A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1215     
                      1216     IF BESCNO == HIMODEL_COOL_41A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1220     
                      1221     IF BESCNO == HIMODEL_COOL_41A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1225     
                      1226     IF BESCNO == RCTIMER_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1230     
                      1231     IF BESCNO == RCTIMER_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1235     
                      1236     IF BESCNO == RCTIMER_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1240     
                      1241     IF BESCNO == ALIGN_RCE_BL15X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1245     
                      1246     IF BESCNO == ALIGN_RCE_BL15X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1250     
                      1251     IF BESCNO == ALIGN_RCE_BL15X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1255     
                      1256     IF BESCNO == ALIGN_RCE_BL15P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1260     
                      1261     IF BESCNO == ALIGN_RCE_BL15P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1265     
                      1266     IF BESCNO == ALIGN_RCE_BL15P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1270     
                      1271     IF BESCNO == ALIGN_RCE_BL35X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1275     
                      1276     IF BESCNO == ALIGN_RCE_BL35X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1280     
                      1281     IF BESCNO == ALIGN_RCE_BL35X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1285     
                      1286     IF BESCNO == ALIGN_RCE_BL35P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1290     
                      1291     IF BESCNO == ALIGN_RCE_BL35P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1295     
                      1296     IF BESCNO == ALIGN_RCE_BL35P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1300     
                      1301     IF BESCNO == GAUI_GE_183_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1305     
                      1306     IF BESCNO == GAUI_GE_183_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1310     
                      1311     IF BESCNO == GAUI_GE_183_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1315     
                      1316     IF BESCNO == H_KING_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1320     
                      1321     IF BESCNO == H_KING_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1325     
                      1326     IF BESCNO == H_KING_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1330     
                      1331     IF BESCNO == H_KING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1335     
                      1336     IF BESCNO == H_KING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1340     
                      1341     IF BESCNO == H_KING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1345     
                      1346     IF BESCNO == H_KING_35A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1350     
                      1351     IF BESCNO == H_KING_35A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1355     
                      1356     IF BESCNO == H_KING_35A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1360     
                      1361     IF BESCNO == H_KING_50A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1365     
                      1366     IF BESCNO == H_KING_50A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1370     
                      1371     IF BESCNO == H_KING_50A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1375     
                      1376     IF BESCNO == POLARIS_THUNDER_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1380     
                      1381     IF BESCNO == POLARIS_THUNDER_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1385     
                      1386     IF BESCNO == POLARIS_THUNDER_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1390     
                      1391     IF BESCNO == POLARIS_THUNDER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1395     
                      1396     IF BESCNO == POLARIS_THUNDER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1400     
                      1401     IF BESCNO == POLARIS_THUNDER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1405     
                      1406     IF BESCNO == POLARIS_THUNDER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1410     
                      1411     IF BESCNO == POLARIS_THUNDER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1415     
                      1416     IF BESCNO == POLARIS_THUNDER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1420     
                      1421     IF BESCNO == POLARIS_THUNDER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1425     
                      1426     IF BESCNO == POLARIS_THUNDER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1430     
                      1431     IF BESCNO == POLARIS_THUNDER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1435     
                      1436     IF BESCNO == POLARIS_THUNDER_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1440     
                      1441     IF BESCNO == POLARIS_THUNDER_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1445     
                      1446     IF BESCNO == POLARIS_THUNDER_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1450     
                      1451     IF BESCNO == POLARIS_THUNDER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1455     
                      1456     IF BESCNO == POLARIS_THUNDER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1460     
                      1461     IF BESCNO == POLARIS_THUNDER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1465     
                      1466     IF BESCNO == POLARIS_THUNDER_100A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1470     
                      1471     IF BESCNO == POLARIS_THUNDER_100A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1475     
                      1476     IF BESCNO == POLARIS_THUNDER_100A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1480     
                      1481     IF BESCNO == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1485     
                      1486     IF BESCNO == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1490     
                      1491     IF BESCNO == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1495     
                      1496     IF BESCNO == PLATINUM_PRO_150A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1500     
                      1501     IF BESCNO == PLATINUM_PRO_150A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1505     
                      1506     IF BESCNO == PLATINUM_PRO_150A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1510     
                      1511     IF BESCNO == PLATINUM_50AV3_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1515     
                      1516     IF BESCNO == PLATINUM_50AV3_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1520     
                      1521     IF BESCNO == PLATINUM_50AV3_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1525     
                      1526     IF BESCNO == EAZY_3AV2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1530     
                      1531     IF BESCNO == EAZY_3AV2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1535     
                      1536     IF BESCNO == EAZY_3AV2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1540     
                      1541     IF BESCNO == TAROT_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1545     
                      1546     IF BESCNO == TAROT_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1550     
                      1551     IF BESCNO == TAROT_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1555     
                      1556     IF BESCNO == SKYIII_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1560     
                      1561     IF BESCNO == SKYIII_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1565     
                      1566     IF BESCNO == SKYIII_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1570     
                      1571     IF BESCNO == EMAX_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1575     
                      1576     IF BESCNO == EMAX_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1580     
                      1581     IF BESCNO == EMAX_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1585     
                      1586     IF BESCNO == EMAX_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1590     
                      1591     IF BESCNO == EMAX_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1595     
                      1596     IF BESCNO == EMAX_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1600     
                      1601     IF BESCNO == EMAX_NANO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1605     
                      1606     IF BESCNO == EMAX_NANO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1610     
                      1611     IF BESCNO == EMAX_NANO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_NANO_20A.INC)		; Select EMAX Nano 20A pinout
                               ENDIF
                      1615     
                      1616     IF BESCNO == XROTOR_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1620     
                      1621     IF BESCNO == XROTOR_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1625     
                      1626     IF BESCNO == XROTOR_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1630     
                      1631     IF BESCNO == XROTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1635     
                      1636     IF BESCNO == XROTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1640     
                      1641     IF BESCNO == XROTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1645     
                      1646     IF BESCNO == XROTOR_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1650     
                      1651     IF BESCNO == XROTOR_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1655     
                      1656     IF BESCNO == XROTOR_40A_MULTI
  0002                1657     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                      1658     $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                      2272     ENDIF
                      2273     
                      2274     IF BESCNO == MDRX62H_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2278     
                      2279     IF BESCNO == MDRX62H_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2283     
                      2284     IF BESCNO == MDRX62H_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (MDRX62H.INC)			; Select MDRX62H pinout
                               ENDIF
                      2288     
                      2289     IF BESCNO == ROTORGEEKS_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2293     
                      2294     IF BESCNO == ROTORGEEKS_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2298     
                      2299     IF BESCNO == ROTORGEEKS_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ROTORGEEKS_20A.INC)		; Select RotorGeeks 20A pinout
                               ENDIF
                      2303     
                      2304     IF BESCNO == FLYCOLOR_FAIRY_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2308     
                      2309     IF BESCNO == FLYCOLOR_FAIRY_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2313     
                      2314     IF BESCNO == FLYCOLOR_FAIRY_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_6A.INC)	; Select Flycolor Fairy 6A pinout
                               ENDIF
                      2318     
                      2319     IF BESCNO == FLYCOLOR_FAIRY_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2323     
                      2324     IF BESCNO == FLYCOLOR_FAIRY_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2328     
                      2329     IF BESCNO == FLYCOLOR_FAIRY_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FLYCOLOR_FAIRY_30A.INC)	; Select Flycolor Fairy 30A pinout
                               ENDIF
                      2333     
                      2334     IF BESCNO == FVT_LITTLEBEE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2338     
                      2339     IF BESCNO == FVT_LITTLEBEE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2343     
                      2344     IF BESCNO == FVT_LITTLEBEE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_20A.INC)	; Select Favourite Littlebee 20A pinout
                               ENDIF
                      2348     
                      2349     IF BESCNO == FVT_LITTLEBEE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2353     
                      2354     IF BESCNO == FVT_LITTLEBEE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2358     
                      2359     IF BESCNO == FVT_LITTLEBEE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (FVT_LITTLEBEE_30A.INC)	; Select Favourite Littlebee 30A pinout
                               ENDIF
                      2363     
                      2364     IF BESCNO == GRAUPNER_ULTRA_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2368     
                      2369     IF BESCNO == GRAUPNER_ULTRA_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2373     
                      2374     IF BESCNO == GRAUPNER_ULTRA_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GRAUPNER_ULTRA_20A.INC)	; Select Graupner Ultra 20A pinout
                               ENDIF
                      2378     
                      2379     IF BESCNO == F85_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2383     
                      2384     IF BESCNO == F85_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2388     
                      2389     IF BESCNO == F85_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (F85_3A.INC)			; Select F85 3A pinout
                               ENDIF
                      2393     
                      2394     IF BESCNO == ZTW_SPIDER_PRO_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2398     
                      2399     IF BESCNO == ZTW_SPIDER_PRO_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2403     
                      2404     IF BESCNO == ZTW_SPIDER_PRO_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ZTW_SPIDER_PRO_20A.INC)	; Select ZTW Spider Pro 20A pinout
                               ENDIF
                      2408     
                      2409     
                      2410     ;**** **** **** **** ****
                      2411     ; TX programming defaults
                      2412     ;
                      2413     ; Parameter dependencies:
                      2414     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                      2415     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                      2416     ;
                      2417     ; MAIN
  0007                2418     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                2419     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                2420     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                2421     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                2422     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                2423     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2424     IF DAMPED_MODE_ENABLE == 1
  0002                2425     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
                      2426     ELSE
                               DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low	
                               ENDIF
  0001                2429     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2430     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                2431     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                2432     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                2433     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                2434     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                2435     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                2436     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                      2437     
                      2438     ; TAIL
  0003                2439     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                2440     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                2441     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2442     IF DAMPED_MODE_ENABLE == 1
  0003                2443     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                      2444     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		
                               ENDIF
  0001                2447     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2448     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2449     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                2450     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                2451     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                2452     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2453     DEFAULT_PGM_TAIL_PWM_DITHER		EQU 3 	; 1=Off		2=7			3=15			4=31			5=63
                      2454     
                      2455     ; MULTI
  0009                2456     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                2457     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                2458     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                2459     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0003                2460     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2461     IF DAMPED_MODE_ENABLE == 1
  0001                2462     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight 
                      2463     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low
                               ENDIF
  0002                2466     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                2467     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2468     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0028                2469     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0050                2470     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0004                2471     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
  0003                2472     DEFAULT_PGM_MULTI_PWM_DITHER		EQU 3 	; 1=Off		2=7			3=15			4=31			5=63
                      2473     
                      2474     ; COMMON
  0001                2475     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 1 	; 1=Enabled 	0=Disabled
  0025                2476     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 37	; 4*37+1000=1148
  00D0                2477     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 208	; 4*208+1000=1832
  007A                2478     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 122	; 4*122+1000=1488 (used in bidirectional mode)
  0000                2479     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0=Low		1+= High or higher	
  0001                2480     DEFAULT_PGM_ENABLE_TEMP_PROT	 	EQU 1 	; 1=Enabled 	0=Disabled
  0001                2481     DEFAULT_PGM_ENABLE_POWER_PROT 	EQU 1 	; 1=Enabled 	0=Disabled
  0000                2482     DEFAULT_PGM_ENABLE_PWM_INPUT	 	EQU 0 	; 1=Enabled 	0=Disabled
                      2483     
                      2484     ; PATRICK'S CHANGES
  002B                2485     MOTOR_PPM_LOW_SLOPE				EQU 43   ;256/6 = 43 -Patrick
                      2486     
                      2487     ;**** **** **** **** ****
                      2488     ; Constant definitions for main
                      2489     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2508     ; Constant definitions for tail
                      2509     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2528     ; Constant definitions for multi
                      2529     IF MODE == 2
                      2530     
  0001                2531     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
  000A                2532     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                2533     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                2534     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                2535     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                2536     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                2537     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                2538     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                2539     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                      2540     
  0032                2541     PWM_START			EQU	50 	; PWM used as max power during start
                      2542     
  0001                2543     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                      2544     
  0008                2545     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                      2546     
                      2547     ENDIF
                      2548     
                      2549     ;**** **** **** **** ****
                      2550     ; Temporary register definitions
  REG                 2551     TEMP1		EQU	R0
  REG                 2552     TEMP2		EQU	R1
  REG                 2553     TEMP3		EQU	R2
  REG                 2554     TEMP4		EQU	R3
  REG                 2555     TEMP5		EQU	R4
  REG                 2556     TEMP6		EQU	R5
  REG                 2557     TEMP7		EQU	R6
  REG                 2558     TEMP8		EQU	R7
                      2559     
                      2560     ;**** **** **** **** ****
                      2561     ; Register definitions
------                2562     DSEG AT 20H					; Variables segment 
                      2563     
0020                  2564     BIT_ACCESS: 				DS	1		; MUST BE AT THIS ADDRESS. Variable at bit accessible address (for non interrupt routines)
0021                  2565     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                      2566     
0022                  2567     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                  2568     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                  2569     CURRENT_PWM: 				DS	1		; Current pwm
0025                  2570     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited
0026                  2571     CURRENT_PWM_LIM_DITH: 		DS	1		; Current pwm that is limited and dithered (applied to the motor output)
0027                  2572     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0028                  2573     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0029                  2574     RCP_OUTSIDE_RANGE_CNT: 		DS	1		; RC pulse outside range counter (incrementing) 
002A                  2575     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
002B                  2576     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
                      2577     
002C                  2578     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                2579     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                2580     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                2581     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                2582     PWM_TIMER0_OVERFLOW			EQU	3		; Set for 48MHz MCUs when PWM timer 0 overflows
  0004                2583     DEMAG_ENABLED				EQU 	4		; Set when demag compensation is enabled (above a min speed and throttle)
  0005                2584     DEMAG_DETECTED				EQU 	5		; Set when excessive demag time is detected
  0006                2585     DEMAG_CUT_POWER			EQU 	6		; Set when demag compensation cuts power
  0007                2586     HIGH_RPM					EQU 	7		; Set when motor rpm is high (Comm_Period4x_H less than 2)
                      2587     
002D                  2588     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                2589     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                2590     STARTUP_PHASE				EQU 	1		; Set when in startup phase
  0002                2591     INITIAL_RUN_PHASE			EQU	2		; Set when in initial run phase, before synchronized run is achieved
  0003                2592     DIR_CHANGE_BRAKE			EQU 	3		; Set when braking before direction change
  0004                2593     COMP_TIMED_OUT				EQU 	4		; Set when comparator reading timed out
  0005                2594     GOV_ACTIVE				EQU 	5		; Set when governor is active (enabled when speed is above minimum)
  0006                2595     SKIP_DAMP_ON				EQU 	6 		; Set when turning damping fet on is skipped
                      2596     ;						EQU 	7 		
                      2597     
002E                  2598     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                2599     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                2600     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                2601     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode
  0003                2602     PGM_PWM_HIGH_FREQ			EQU	3		; Progremmed pwm high frequency
  0004                2603     RCP_PPM					EQU 	4		; RC pulse ppm type input (set also when oneshot is set)
  0005                2604     RCP_PPM_ONESHOT125			EQU 	5		; RC pulse ppm type input is OneShot125
  0006                2605     RCP_DIR_REV				EQU 	6		; RC pulse direction in bidirectional mode
                      2606     ;						EQU 	7	
                      2607     
002F                  2608     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                2609     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                2610     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                2611     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                2612     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                2613     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                2614     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                2615     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                2616     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                      2617     
                      2618     
                      2619     ;**** **** **** **** ****
                      2620     ; RAM definitions
------                2621     DSEG AT 30H						; Ram data segment, direct addressing
                      2622     
0030                  2623     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                      2624     
0031                  2625     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                  2626     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                      2627     
0033                  2628     STARTUP_CNT: 				DS	1		; Startup phase commutations counter (incrementing)
0034                  2629     INITIAL_RUN_ROT_CNT: 		DS	1		; Initial run rotations counter (incrementing)
0035                  2630     STALL_CNT: 				DS	1		; Counts start/run attempts that resulted in stall. Reset upon a proper stop
0036                  2631     DEMAG_DETECTED_METRIC: 		DS	1		; Metric used to gauge demag event frequency
0037                  2632     DEMAG_PWR_OFF_THRESH: 		DS	1		; Metric threshold above which power is cut
0038                  2633     LOW_RPM_PWR_SLOPE: 			DS	1		; Sets the slope of power increase for low rpms
                      2634     
0039                  2635     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003A                  2636     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003B                  2637     PREV_PREV_COMM_L: 			DS	1		; Pre-previous commutation timer3 timestamp (lo byte)
003C                  2638     PREV_PREV_COMM_H: 			DS	1		; Pre-previous commutation timer3 timestamp (hi byte)
003D                  2639     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003E                  2640     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003F                  2641     COMM_DIFF: 				DS	1		; Timer3 count difference between the last two commutations
0040                  2642     COMM_PHASE: 				DS	1		; Current commutation phase
0041                  2643     COMPARATOR_READ_CNT:  		DS	1		; Number of comparator reads done
                      2644     
0042                  2645     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0043                  2646     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0044                  2647     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0045                  2648     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0046                  2649     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0047                  2650     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0048                  2651     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0049                  2652     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
004A                  2653     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
                      2654     
004B                  2655     WT_ADV_START_L: 			DS	1		; Timer3 start point for commutation advance timing (lo byte)
004C                  2656     WT_ADV_START_H: 			DS	1		; Timer3 start point for commutation advance timing (hi byte)
004D                  2657     WT_ZC_SCAN_START_L: 			DS	1		; Timer3 start point from commutation to zero cross scan (lo byte)
004E                  2658     WT_ZC_SCAN_START_H: 			DS	1		; Timer3 start point from commutation to zero cross scan (hi byte)
004F                  2659     WT_ZC_TOUT_START_L: 			DS	1		; Timer3 start point for zero cross scan timeout (lo byte)
0050                  2660     WT_ZC_TOUT_START_H: 			DS	1		; Timer3 start point for zero cross scan timeout (hi byte)
0051                  2661     WT_COMM_START_L: 			DS	1		; Timer3 start point from zero cross to commutation (lo byte)
0052                  2662     WT_COMM_START_H: 			DS	1		; Timer3 start point from zero cross to commutation (hi byte)
0053                  2663     NEXT_WT_START_L: 			DS	1		; Timer3 start point for next wait period (lo byte)
0054                  2664     NEXT_WT_START_H: 			DS	1		; Timer3 start point for next wait period (hi byte)
                      2665     
0055                  2666     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0056                  2667     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0057                  2668     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0058                  2669     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0059                  2670     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
005A                  2671     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
005B                  2672     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
005C                  2673     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005D                  2674     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005E                  2675     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005F                  2676     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
0060                  2677     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      2678     
0061                  2679     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
0062                  2680     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup
0063                  2681     PWM_LIMIT_BY_RPM: 			DS	1		; Maximum allowed pwm for low or high rpms
0064                  2682     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0065                  2683     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0066                  2684     PWM_DITHER_DECODED: 			DS	1		; Decoded pwm dither value
0067                  2685     PWM_DITHER_EXCESS_POWER: 		DS	1		; Excess power (above max) from pwm dither
0068                  2686     RANDOM: 					DS	1		; Random number from LFSR 
                      2687     
0069                  2688     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
006A                  2689     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
006B                  2690     MAIN_SPOOLUP_TIME_3X: 		DS	1		; Main spoolup time x3
006C                  2691     MAIN_SPOOLUP_TIME_10X: 		DS	1		; Main spoolup time x10
006D                  2692     MAIN_SPOOLUP_TIME_15X: 		DS	1		; Main spoolup time x15
                      2693     
006E                  2694     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006F                  2695     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
0070                  2696     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      2697     
0071                  2698     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      2699     
0072                  2700     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
0073                  2701     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      2702     
0074                  2703     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0075                  2704     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0076                  2705     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      2706     
0077                  2707     SKIP_T2_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 interrupt shall be ignored 
0078                  2708     SKIP_T2H_INT: 				DS	1		; Set for 48MHz MCUs when timer 2 high interrupt shall be ignored 
0079                  2709     TIMER0_OVERFLOW_VALUE: 		DS	1		; Remaining timer 0 wait time used with 48MHz MCUs
007A                  2710     CLOCK_SET_AT_48MHZ: 			DS	1		; Variable set if 48MHz MCUs run at 48MHz
007B                  2711     DAMPINGFET: 				DS	1		; Port position of fet used for damping
007C                  2712     CURRENT_PWM_LIMITED_REMAPPED: 	DS	1
007D                  2713     CURRENT_PWM_LIM_DITH_REMAPPED:  DS	1
                      2714     
                      2715     ; Indirect addressing data segment. The variables below must be in this sequence
------                2716     ISEG AT 080H					
0080                  2717     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  2718     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  2719     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  2720     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  2721     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  2722     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  2723     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  2724     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  2725     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  2726     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  2727     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  2728     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  2729     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  2730     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  2731     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  2732     _PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm (unused - place holder)
0090                  2733     _PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration (unused - place holder)
0091                  2734     _PGM_VOLT_COMP: 			DS	1		; Place holder
0092                  2735     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  2736     _PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force (unused - place holder)
0094                  2737     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  2738     _PGM_STARTUP_METHOD: 		DS	1		; Programmed startup method (unused - place holder)
0096                  2739     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  2740     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  2741     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  2742     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  2743     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  2744     _PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate (unused - place holder)
009C                  2745     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  2746     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  2747     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
009F                  2748     PGM_MAIN_SPOOLUP_TIME: 		DS	1		; Programmed main spoolup time
00A0                  2749     PGM_ENABLE_TEMP_PROT: 		DS	1		; Programmed temperature protection enable
00A1                  2750     PGM_ENABLE_POWER_PROT: 		DS	1		; Programmed low rpm power protection enable
00A2                  2751     PGM_ENABLE_PWM_INPUT: 		DS	1		; Programmed PWM input signal enable
00A3                  2752     PGM_PWM_DITHER: 			DS	1		; Programmed output PWM dither
                      2753     
                      2754     ; The sequence of the variables below is no longer of importance
00A4                  2755     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A5                  2756     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A6                  2757     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
                      2758     
                      2759     
                      2760     ; Indirect addressing data segment
------                2761     ISEG AT 0D0H					
00D0                  2762     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      2763     
                      2764     
                      2765     ;**** **** **** **** ****
------                2766     CSEG AT 1A00H            ; "Eeprom" segment
  000E                2767     EEPROM_FW_MAIN_REVISION		EQU	14		; Main revision of the firmware
  0003                2768     EEPROM_FW_SUB_REVISION		EQU	3		; Sub revision of the firmware
  0014                2769     EEPROM_LAYOUT_REVISION		EQU	20		; Revision of the EEPROM layout
                      2770     
1A00    0E            2771     EEP_FW_MAIN_REVISION:  DB 14 
1A01    03            2772     EEP_FW_SUB_REVISION:  DB 3 
1A02    14            2773     EEP_LAYOUT_REVISION:  DB 20 
                      2774     
                      2775     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH	
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH	
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH						
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH	
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH	
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							
                               EEP_PGM_MAIN_SPOOLUP_TIME:	DB	DEFAULT_PGM_MAIN_SPOOLUP_TIME		; EEPROM copy of programmed main spoolup time
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               _EEP_PGM_PWM_DITHER:		DB	0FFH	
                               ENDIF 
                      2813     
                      2814     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               EEP_PGM_ENABLE_POWER_PROT:	DB	DEFAULT_PGM_ENABLE_POWER_PROT		; EEPROM copy of programmed low rpm power protection enable
                               EEP_PGM_ENABLE_PWM_INPUT:	DB	DEFAULT_PGM_ENABLE_PWM_INPUT		; EEPROM copy of programmed PWM input signal enable
                               EEP_PGM_PWM_DITHER:			DB	DEFAULT_PGM_TAIL_PWM_DITHER		; EEPROM copy of programmed output PWM dither
                               ENDIF
                      2852     
                      2853     IF MODE == 2
1A03    09            2854     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            2855     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            2856     EEP_PGM_GOV_MODE:  DB 4 
1A06    FF            2857     _EEP_PGM_LOW_VOLTAGE_LIM: 	DB	0FFH							
1A07    03            2858     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            2859     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            2860     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            2861     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            2862     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            2863     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            2864     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            2865     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    01            2866     EEP_ENABLE_TX_PROGRAM:  DB 1 
1A10    FF            2867     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            2868     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    FF            2869     _EEP_PGM_STARTUP_RPM: 		DB	0FFH
1A13    FF            2870     _EEP_PGM_STARTUP_ACCEL: 		DB	0FFH
1A14    FF            2871     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            2872     EEP_PGM_COMM_TIMING:  DB 3 
1A16    FF            2873     _EEP_PGM_DAMPING_FORCE: 		DB	0FFH
1A17    FF            2874     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    FF            2875     _EEP_PGM_STARTUP_METHOD: 		DB	0FFH
1A19    25            2876     EEP_PGM_PPM_MIN_THROTTLE:  DB 37 
1A1A    D0            2877     EEP_PGM_PPM_MAX_THROTTLE:  DB 208 
1A1B    28            2878     EEP_PGM_BEEP_STRENGTH:  DB 40 
1A1C    50            2879     EEP_PGM_BEACON_STRENGTH:  DB 80 
1A1D    04            2880     EEP_PGM_BEACON_DELAY:  DB 4 
1A1E    FF            2881     _EEP_PGM_THROTTLE_RATE: 		DB	0FFH
1A1F    02            2882     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            2883     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7A            2884     EEP_PGM_PPM_CENTER_THROTTLE:  DB 122 
1A22    FF            2885     _EEP_PGM_MAIN_SPOOLUP_TIME: 	DB	0FFH
1A23    01            2886     EEP_PGM_TEMP_PROT_ENABLE:  DB 1 
1A24    01            2887     EEP_PGM_ENABLE_POWER_PROT:  DB 1 
1A25    00            2888     EEP_PGM_ENABLE_PWM_INPUT:  DB 0 
1A26    03            2889     EEP_PGM_PWM_DITHER:  DB 3 
                      2890     ENDIF
                      2891     
1A27    FF            2892     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      2893     
------                2894     CSEG AT 1A60H
1A60    20202020      2895     EEP_NAME: 					DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      2896     
                      2897     ;**** **** **** **** ****
                      2898     INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                2898+1   CSEG AT 0  ; CODE SEGMENT START
0000    0219FD        2898+1   JMP RESET 
------                2898+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200B5        2898+1   JMP T0_INT 
------                2898+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0201AD        2898+1   JMP T2_INT 
------                2898+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    02035C        2898+1   JMP PCA_INT 
------                2898+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    020342        2898+1   JMP T3_INT 
------                2899     CSEG AT 80H			; Code segment after interrupt vectors 
                      2900     
                      2901     ;**** **** **** **** ****
                      2902     
                      2903     ; Table definitions
0080    02030406      2904     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    0406080C      2905     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
0091    10182030
0095    406080A0
0099    C0
009A    00070F1F      2906     PWM_DITHER_TABLE:   		DB 	00H, 07H, 0FH, 1FH, 3FH
009E    3F
                      2907     IF MODE == 0
                                 IF DAMPED_MODE_ENABLE == 1
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 3, 3, 2, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 2, 3, 2, 2
                                 ENDIF
                               ENDIF
                      2915     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 3, 5, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF
                               ENDIF
                      2923     IF MODE == 2
                      2924       IF DAMPED_MODE_ENABLE == 1
009F    0D0D0405      2925     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 13, 5, 3, 5, 3, 3, 2
00A3    0D050305
00A7    030302
                      2926       ENDIF
                      2927       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 13, 5, 2, 5, 3, 3, 2
                                 ENDIF 
                      2930     ENDIF
                      2931     
                      2932     ; Subroutine remaps pwm value (implements throttle curve)
                      2933     ; Input: A holds value to be remapped and ranges from 0 to 255
                      2934     ; Output: A holds remapped value
                      2935     ; -Patrick
                      2936     MOTOR_PWM_REMAP: 
00AA    C0F0          2937         PUSH B
00AC    75F02B        2938     MOV B , # 43 
00AF    A4            2939         MUL  AB
00B0    E5F0          2940         MOV  A, B
00B2    D0F0          2941         POP  B
00B4    22            2942         RET
                      2943     
                      2944     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2945     ;
                      2946     ; Timer0 interrupt routine
                      2947     ;
                      2948     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      2949     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      2950     ;
                      2951     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2952     T0_INT: 	; Used for pwm control
00B5    C2AF          2953     	CLR 	EA			; Disable all interrupts
                      2954     IF MCU_48MHZ == 1
                      2955     	; Check overflow flag
00B7    306308        2956     JNB FLAGS0 . 3 , T0_INT_START 
                      2957     
00BA    C263          2958     CLR FLAGS0 . 3 
00BC    85798A        2959     	MOV	TL0, TIMER0_OVERFLOW_VALUE	; Set timer 
00BF    D2AF          2960     	SETB	EA			; Enable all interrupts
00C1    32            2961     	RETI
                      2962     
                      2963     T0_INT_START: 
                      2964     ENDIF
00C2    C0D0          2965     	PUSH	PSW			; Preserve registers through interrupt
00C4    C0E0          2966     	PUSH	ACC	
                      2967     	
                      2968     	; Scale Current_Pwm_Limited and Current_Pwm_Lim_Dith by MOTOR_PPM_LOW_SLOPE -Patrick
                      2969     
                      2970     	; Scale Current_Pwm_Limited -Patrick
00C6    E525          2971     	MOV	A, CURRENT_PWM_LIMITED
00C8    11AA          2972     	CALL MOTOR_PWM_REMAP
00CA    F57C          2973     	MOV  CURRENT_PWM_LIMITED_REMAPPED, A
                      2974     
                      2975     	; Scale Current_Pwm_Lim_Dith -Patrick
00CC    E526          2976     	MOV	A, CURRENT_PWM_LIM_DITH
00CE    11AA          2977     	CALL MOTOR_PWM_REMAP
00D0    F57D          2978     	MOV  CURRENT_PWM_LIM_DITH_REMAPPED, A
                      2979     
                      2980     	; Check if pwm is on
00D2    206227        2981     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      2982     
                      2983     	; Pwm on cycle
00D5    E57C          2984     	MOV	A, CURRENT_PWM_LIMITED_REMAPPED ; Replace with remapped value -Patrick
00D7    6002          2985     	JZ	T0_INT_PWM_ON_EXIT
                      2986     
                      2987     T0_INT_PWM_ON_EXECUTE: 
00D9    E4            2988     	CLR	A					
00DA    73            2989     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      2990     
                      2991     T0_INT_PWM_ON_EXIT: 
                      2992     	; Set timer for coming on cycle length
00DB    E57C          2993     	MOV 	A, CURRENT_PWM_LIMITED_REMAPPED		; Load current pwm and replace with remapped value -Patrick
00DD    F4            2994     	CPL	A						; cpl is 255-x
                      2995     IF MCU_48MHZ == 0
                               	MOV	TL0, A					; Write start point for timer
                               ELSE
00DE    C3            2998     	CLR	C
00DF    33            2999     	RLC	A
00E0    4009          3000     	JC	T0_INT_PWM_ON_SET_TIMER
                      3001     
00E2    758A00        3002     	MOV	TL0, #0
00E5    D263          3003     SETB FLAGS0 . 3 
00E7    F579          3004     	MOV	TIMER0_OVERFLOW_VALUE, A
00E9    01ED          3005     	AJMP	T0_INT_PWM_ON_TIMER_SET
                      3006     
                      3007     T0_INT_PWM_ON_SET_TIMER: 
00EB    F58A          3008     	MOV	TL0, A
                      3009     T0_INT_PWM_ON_TIMER_SET: 
                      3010     ENDIF
                      3011     	; Set other variables
00ED    758B00        3012     	MOV	TL1, #0					; Reset timer1	
                      3013     IF MCU_48MHZ == 1
00F0    758D00        3014     	MOV	TH1, #0		
                      3015     ENDIF
00F3    D262          3016     SETB FLAGS0 . 2 
                      3017     	; Exit interrupt
00F5    D0E0          3018     	POP	ACC			; Restore preserved registers
00F7    D0D0          3019     	POP	PSW
00F9    D2AF          3020     	SETB	EA			; Enable all interrupts
00FB    32            3021     	RETI
                      3022     
                      3023     
                      3024     	; Pwm off cycle
                      3025     T0_INT_PWM_OFF: 
                      3026     IF MCU_48MHZ == 0
                               	MOV	TL0, CURRENT_PWM_LIM_DITH_REMAPPED	; Load new timer setting and replace with remapped value -Patrick
                               ELSE
00FC    C3            3029     	CLR	C
00FD    E57D          3030     	MOV	A, CURRENT_PWM_LIM_DITH_REMAPPED ; Replace with remapped value -Patrick
00FF    33            3031     	RLC	A
0100    4009          3032     	JC	T0_INT_PWM_OFF_SET_TIMER 
                      3033     
0102    758A00        3034     	MOV	TL0, #0
0105    D263          3035     SETB FLAGS0 . 3 
0107    F579          3036     	MOV	TIMER0_OVERFLOW_VALUE, A
0109    210D          3037     	AJMP	T0_INT_PWM_OFF_TIMER_SET
                      3038     
                      3039     T0_INT_PWM_OFF_SET_TIMER: 
010B    F58A          3040     	MOV	TL0, A
                      3041     T0_INT_PWM_OFF_TIMER_SET: 
                      3042     ENDIF
                      3043     	; Clear pwm on flag
010D    C262          3044     CLR FLAGS0 . 2 
                      3045     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
010F    E57D          3046     	MOV	A, CURRENT_PWM_LIM_DITH_REMAPPED		; Load current pwm and replace with remapped value -Patrick
0111    F4            3047     	CPL	A						; Full pwm?
0112    6038          3048     	JZ	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      3049     
                      3050     IF DAMPED_MODE_ENABLE == 1
                      3051     	; Do not execute damped pwm when stopped
0114    306803        3052     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_EXIT_NFETS_OFF 
                      3053     
                      3054     	; If damped operation, set pFETs on in pwm_off
0117    207213        3055     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      3056     ENDIF
                      3057     
                      3058     T0_INT_PWM_OFF_EXIT_NFETS_OFF: 	
                      3059     	; Separate exit commands here for minimum delay
011A    758B00        3060     	MOV	TL1, #0		; Reset timer1	
                      3061     IF MCU_48MHZ == 1
011D    758D00        3062     	MOV	TH1, #0		
                      3063     ENDIF
0120    D0E0          3064     	POP	ACC			; Restore preserved registers
0122    D0D0          3065     	POP	PSW
                      3066     	ALL_NFETS_OFF 		; Switch off all nfets
0124    C293          3066+1   CLR P1 . 3 
0126    C297          3066+1   CLR P1 . 7 
0128    C294          3066+1   CLR P1 . 4 
012A    D2AF          3067     	SETB	EA			; Enable all interrupts
012C    32            3068     	RETI
                      3069     
                      3070     T0_INT_PWM_OFF_DAMPED: 
                      3071     IF PFETON_DELAY < 128
                      3072     	ALL_NFETS_OFF 				; Switch off all nfets
012D    C293          3072+1   CLR P1 . 3 
012F    C297          3072+1   CLR P1 . 7 
0131    C294          3072+1   CLR P1 . 4 
0133    206E09        3073     JB FLAGS1 . 6 , T0_INT_PWM_OFF_DAMP_DONE 
                      3074     IF PFETON_DELAY NE 0
0136    740C          3075     MOV A , # 12 
0138    D5E0FD        3076     	DJNZ	ACC, $	
                      3077     ENDIF
                      3078     	DAMPING_FET_ON
013B    E57B          3078+1   MOV A , DAMPINGFET 
013D    4290          3078+1   ORL P1 , A 
                      3079     T0_INT_PWM_OFF_DAMP_DONE: 
                      3080     ENDIF
                      3081     IF PFETON_DELAY >= 128			; "Negative", 1's complement
                               	JB	FLAGS1.SKIP_DAMP_ON, T0_INT_PWM_OFF_DAMP_DONE
                               	DAMPING_FET_ON				; Damping fet on
                               	MOV	A, #PFETON_DELAY
                               	CPL	A
                               T0_INT_PWM_OFF_DAMP_DONE:
                               	ALL_NFETS_OFF 				; Switch off all nfets
                               ENDIF
                      3089     T0_INT_PWM_OFF_EXIT: 	
013F    758B00        3090     	MOV	TL1, #0		; Reset timer1	
                      3091     IF MCU_48MHZ == 1
0142    758D00        3092     	MOV	TH1, #0		
                      3093     ENDIF
0145    D0E0          3094     	POP	ACC			; Restore preserved registers
0147    D0D0          3095     	POP	PSW
0149    D2AF          3096     	SETB	EA			; Enable all interrupts
014B    32            3097     	RETI
                      3098     
                      3099     T0_INT_PWM_OFF_FULLPOWER_EXIT: 
014C    758A00        3100     	MOV	TL0, #0		; Set long time till next interrupt
                      3101     IF MCU_48MHZ == 1
014F    D263          3102     SETB FLAGS0 . 3 
0151    757900        3103     	MOV	TIMER0_OVERFLOW_VALUE, #0
                      3104     ENDIF
0154    C28D          3105     	CLR	TF0			; Clear interrupt flag
0156    D262          3106     SETB FLAGS0 . 2 
0158    213F          3107     	AJMP	T0_INT_PWM_OFF_EXIT
                      3108     
                      3109     
                      3110     PWM_NOFET: 	; Dummy pwm on cycle
015A    01DB          3111     	AJMP	T0_INT_PWM_ON_EXIT
                      3112     
                      3113     PWM_AFET: 		; Pwm on cycle afet on
015C    306805        3114     JNB FLAGS1 . 0 , PWM_AFET_EXIT 
015F    206602        3115     JB FLAGS0 . 6 , PWM_AFET_EXIT 
                      3116     	ANFET_ON	
0162    D293          3116+1   SETB P1 . 3 
                      3117     PWM_AFET_EXIT: 
0164    01DB          3118     	AJMP	T0_INT_PWM_ON_EXIT
                      3119     
                      3120     PWM_BFET: 		; Pwm on cycle bfet on
0166    306805        3121     JNB FLAGS1 . 0 , PWM_BFET_EXIT 
0169    206602        3122     JB FLAGS0 . 6 , PWM_BFET_EXIT 
                      3123     	BNFET_ON
016C    D294          3123+1   SETB P1 . 4 
                      3124     PWM_BFET_EXIT: 
016E    01DB          3125     	AJMP	T0_INT_PWM_ON_EXIT
                      3126     
                      3127     PWM_CFET: 		; Pwm on cycle cfet on
0170    306805        3128     JNB FLAGS1 . 0 , PWM_CFET_EXIT 
0173    206602        3129     JB FLAGS0 . 6 , PWM_CFET_EXIT 
                      3130     	CNFET_ON
0176    D297          3130+1   SETB P1 . 7 
                      3131     PWM_CFET_EXIT: 
0178    01DB          3132     	AJMP	T0_INT_PWM_ON_EXIT
                      3133     
                      3134     PWM_AFET_DAMPED: 	
                      3135     	APFET_OFF
017A    C292          3135+1   CLR P1 . 2 
017C    30680A        3136     JNB FLAGS1 . 0 , PWM_AFET_DAMPED_EXIT 
017F    206607        3137     JB FLAGS0 . 6 , PWM_AFET_DAMPED_EXIT 
                      3138     IF NFETON_DELAY NE 0
0182    740C          3139     MOV A , # 12 
0184    D5E0FD        3140     	DJNZ ACC,	$
                      3141     ENDIF
                      3142     PWM_AFET_DAMPED_DONE: 
                      3143     	ANFET_ON								; Switch nFET
0187    D293          3143+1   SETB P1 . 3 
                      3144     PWM_AFET_DAMPED_EXIT: 
0189    01DB          3145     	AJMP	T0_INT_PWM_ON_EXIT
                      3146     
                      3147     PWM_BFET_DAMPED: 
                      3148     	BPFET_OFF
018B    C295          3148+1   CLR P1 . 5 
018D    30680A        3149     JNB FLAGS1 . 0 , PWM_BFET_DAMPED_EXIT 
0190    206607        3150     JB FLAGS0 . 6 , PWM_BFET_DAMPED_EXIT 
                      3151     IF NFETON_DELAY NE 0
0193    740C          3152     MOV A , # 12 
0195    D5E0FD        3153     	DJNZ ACC,	$
                      3154     ENDIF
                      3155     PWM_BFET_DAMPED_DONE: 
                      3156     	BNFET_ON								; Switch nFET
0198    D294          3156+1   SETB P1 . 4 
                      3157     PWM_BFET_DAMPED_EXIT: 
019A    01DB          3158     	AJMP	T0_INT_PWM_ON_EXIT
                      3159     
                      3160     PWM_CFET_DAMPED: 	
                      3161     	CPFET_OFF
019C    C296          3161+1   CLR P1 . 6 
019E    30680A        3162     JNB FLAGS1 . 0 , PWM_CFET_DAMPED_EXIT 
01A1    206607        3163     JB FLAGS0 . 6 , PWM_CFET_DAMPED_EXIT 
                      3164     IF NFETON_DELAY NE 0
01A4    740C          3165     MOV A , # 12 
01A6    D5E0FD        3166     	DJNZ ACC,	$
                      3167     ENDIF
                      3168     PWM_CFET_DAMPED_DONE: 
                      3169     	CNFET_ON								; Switch nFET
01A9    D297          3169+1   SETB P1 . 7 
                      3170     PWM_CFET_DAMPED_EXIT:  
01AB    01DB          3171     	AJMP	T0_INT_PWM_ON_EXIT
                      3172     
                      3173     
                      3174     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3175     ;
                      3176     ; Timer2 interrupt routine
                      3177     ;
                      3178     ; No assumptions
                      3179     ;
                      3180     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3181     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
01AD    C2AF          3182     	CLR	EA
01AF    C2AD          3183     	CLR	ET2			; Disable timer2 interrupts
01B1    53E6EF        3184     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
01B4    C0D0          3185     	PUSH	PSW			; Preserve registers through interrupt
01B6    C0E0          3186     	PUSH	ACC
01B8    D2D3          3187     	SETB	PSW.3		; Select register bank 1 for interrupt routines
01BA    D2AF          3188     	SETB	EA
                      3189     IF MCU_48MHZ == 1
01BC    E57A          3190     	MOV	A, CLOCK_SET_AT_48MHZ
01BE    6009          3191     	JZ 	T2_INT_START
                      3192     
                      3193     	; Check skip variable
01C0    E577          3194     	MOV	A, SKIP_T2_INT
01C2    6005          3195     	JZ	T2_INT_START				; Execute this interrupt
                      3196     
01C4    757700        3197     	MOV	SKIP_T2_INT, #0
01C7    41F1          3198     	AJMP	T2_INT_EXIT
                      3199     
                      3200     T2_INT_START: 
01C9    757701        3201     	MOV	SKIP_T2_INT, #1			; Skip next interrupt
                      3202     ENDIF
                      3203     	; Clear low byte interrupt flag
01CC    C2CE          3204     	CLR	TF2L						; Clear interrupt flag
                      3205     	; Check RC pulse timeout counter
01CE    E52A          3206     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
01D0    6007          3207     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      3208     
                      3209     	; Decrement timeout counter (if PWM)
01D2    207449        3210     JB FLAGS2 . 4 , T2_INT_SKIP_START 
                      3211     
01D5    152A          3212     	DEC	RCP_TIMEOUT_CNT			; No - decrement
01D7    411E          3213     	AJMP	T2_INT_SKIP_START
                      3214     
                      3215     T2_INT_PULSES_ABSENT: 
                      3216     	; Timeout counter has reached zero, pulses are absent
01D9    7800          3217     MOV R0 , # 0 
01DB    7900          3218     MOV R1 , # 0 
01DD    20742E        3219     JB FLAGS2 . 4 , T2_INT_PULSES_ABSENT_NO_MAX 
                      3220     
                      3221     	READ_RCP_INT 					; Look at value of Rcp_In
01E0    E580          3221+1   MOV A , P0 
01E2    307E01        3221+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
01E5    F4            3221+1   CPL A  ; YES - INVERT
01E6    30E502        3222     JNB ACC . 5 , ( $+5 ) 
01E9    78FF          3223     MOV R0 , # 255 
                      3224     	RCP_INT_FIRST 					; Set interrupt trig to first again
01EB    53DACF        3224+1   ANL PCA0CPM0 , # 0CFH 
01EE    207E03        3224+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
01F1    43DA20        3224+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
01F4    307E03        3224+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
01F7    43DA10        3224+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3225     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
01FA    C2D8          3225+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
01FC    C271          3226     CLR FLAGS2 . 1 
                      3227     	READ_RCP_INT 					; Look once more at value of Rcp_In
01FE    E580          3227+1   MOV A , P0 
0200    307E01        3227+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0203    F4            3227+1   CPL A  ; YES - INVERT
0204    30E502        3228     JNB ACC . 5 , ( $+5 ) 
0207    79FF          3229     MOV R1 , # 255 
0209    C3            3230     	CLR	C
020A    E8            3231     MOV A , R0 
020B    99            3232     SUBB A , R1 
020C    70CB          3233     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      3234     
                      3235     T2_INT_PULSES_ABSENT_NO_MAX: 
020E    306103        3236     JNB FLAGS0 . 1 , ( $+6 ) 
                      3237     
0211    752A18        3238     MOV RCP_TIMEOUT_CNT , # 24 
                      3239     
0214    207403        3240     JB FLAGS2 . 4 , T2_INT_PPM_TIMEOUT_SET 
                      3241     
0217    752A18        3242     MOV RCP_TIMEOUT_CNT , # 24 
                      3243     
                      3244     T2_INT_PPM_TIMEOUT_SET: 
021A    885C          3245     MOV NEW_RCP , R0 
021C    D270          3246     SETB FLAGS2 . 0 
                      3247     
                      3248     T2_INT_SKIP_START: 
021E    20740D        3249     JB FLAGS2 . 4 , T2_INT_RCP_UPDATE_START 
                      3250     
                      3251     	; Check RC pulse skip counter
0221    E52B          3252     	MOV	A, RCP_SKIP_CNT			
0223    6004          3253     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      3254     	
                      3255     	; Decrement skip counter (only if edge counter is zero)
0225    152B          3256     	DEC	RCP_SKIP_CNT				; Decrement
0227    412E          3257     	AJMP	T2_INT_RCP_UPDATE_START
                      3258     
                      3259     T2_INT_SKIP_END: 
                      3260     	; Skip counter has reached zero, start looking for RC pulses again
                      3261     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0229    43DA01        3261+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      3262     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
022C    C2D8          3262+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3263     	
                      3264     T2_INT_RCP_UPDATE_START: 
                      3265     	; Process updated RC pulse
022E    207002        3266     JB FLAGS2 . 0 , ( $+5 ) 
0231    418A          3267     	AJMP	T2_INT_CURRENT_PWM_UPDATE	; No - update pwm limits and exit
                      3268     
0233    A85C          3269     MOV R0 , NEW_RCP 
0235    206102        3270     JB FLAGS0 . 1 , ( $+5 ) 
                      3271     
0238    C270          3272     CLR FLAGS2 . 0 
                      3273     
                      3274     	; Use a gain of 1.0625x for pwm input if not governor mode
023A    207436        3275     JB FLAGS2 . 4 , T2_INT_PWM_MIN_RUN 
                      3276     
                      3277     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ELSE
                      3280     
                      3281     IF MODE == 2	; Multi 
023D    7982          3282     MOV R1 , # PGM_GOV_MODE 
023F    B70431        3283     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      3284     ENDIF
                      3285     
                      3286     	; Limit the maximum value to avoid wrap when scaled to pwm range
0242    C3            3287     	CLR	C
0243    E8            3288     MOV A , R0 
0244    94F0          3289     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0246    4003          3290     	JC	T2_INT_RCP_UPDATE_MULT
                      3291     
0248    74F0          3292     	MOV	A, #240			; Set requested pwm to max
024A    F8            3293     MOV R0 , A 
                      3294     
                      3295     T2_INT_RCP_UPDATE_MULT: 	
                      3296     	; Multiply by 1.0625 (optional adjustment gyro gain)
024B    E8            3297     MOV A , R0 
024C    C4            3298     	SWAP	A			; After this "0.0625"
024D    540F          3299     	ANL	A, #0FH
024F    28            3300     ADD A , R0 
0250    F8            3301     MOV R0 , A 
                      3302     	; Adjust tail gain
0251    7984          3303     MOV R1 , # PGM_MOTOR_GAIN 
0253    B70302        3304     CJNE @ R1 , # 3 , ( $+5 ) 
0256    4173          3305     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      3306     
0258    C3            3307     	CLR	C
0259    13            3308     	RRC	A			; After this "0.5"
025A    C3            3309     	CLR	C
025B    13            3310     	RRC	A			; After this "0.25"
025C    8721          3311     MOV BIT_ACCESS_INT , @ R1 
025E    200802        3312     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      3313     
0261    C3            3314     	CLR	C
0262    13            3315     	RRC	A			; After this "0.125"
                      3316     
                      3317     T2_INT_RCP_GAIN_CORR: 
0263    200A06        3318     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      3319     
0266    C3            3320     	CLR	C
0267    C8            3321     XCH A , R0 
0268    98            3322     SUBB A , R0 
0269    F8            3323     MOV R0 , A 
026A    4173          3324     	AJMP	T2_INT_PWM_MIN_RUN
                      3325     
                      3326     T2_INT_RCP_GAIN_POS: 
026C    28            3327     ADD A , R0 
026D    F8            3328     MOV R0 , A 
026E    5003          3329     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      3330     
0270    74FF          3331     	MOV	A, #0FFH					; Yes - limit
0272    F8            3332     MOV R0 , A 
                      3333     ENDIF
                      3334     
                      3335     T2_INT_PWM_MIN_RUN:  
                      3336     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      3346     
                      3347     T2_INT_PWM_UPDATE:  
                      3348     	; Update requested_pwm
0273    8822          3349     MOV REQUESTED_PWM , R0 
                      3350     IF MODE >= 1	; Tail or multi
                      3351     	; Boost pwm during direct start
0275    E52D          3352     	MOV	A, FLAGS1
0277    5406          3353     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0279    600F          3354     	JZ	T2_INT_CURRENT_PWM_UPDATE
                      3355     
027B    E533          3356     	MOV	A, STARTUP_CNT				; Add an extra power boost during start
027D    C3            3357     	CLR	C
027E    13            3358     	RRC	A
027F    C3            3359     	CLR	C
0280    13            3360     	RRC	A
0281    2522          3361     	ADD	A, REQUESTED_PWM			
0283    F522          3362     	MOV	REQUESTED_PWM, A
0285    5003          3363     	JNC	($+5)
                      3364     
0287    7522FF        3365     	MOV	REQUESTED_PWM, #0FFH
                      3366     
                      3367     ENDIF
                      3368     T2_INT_CURRENT_PWM_UPDATE:  
                      3369     IF MODE == 0 OR MODE == 2	; Main or multi
028A    7882          3370     MOV R0 , # PGM_GOV_MODE 
028C    B60459        3371     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      3372     ENDIF
                      3373     
028F    852224        3374     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      3375     IF MODE >= 1	; Tail or multi
                      3376     	; Set current_pwm_limited
0292    A824          3377     MOV R0 , CURRENT_PWM 
0294    C3            3378     	CLR	C
0295    E524          3379     	MOV	A, CURRENT_PWM				; Check against limit
0297    9561          3380     	SUBB	A, PWM_LIMIT
0299    4002          3381     	JC	($+4)					; If current pwm below limit - branch
                      3382     
029B    A861          3383     MOV R0 , PWM_LIMIT 
                      3384     
                      3385     IF MODE == 2	; Multi
                      3386     	; Limit pwm for low rpms
029D    C3            3387     	CLR	C
029E    E8            3388     MOV A , R0 
029F    9563          3389     	SUBB	A, PWM_LIMIT_BY_RPM
02A1    4002          3390     	JC	($+4)					; If current pwm below limit - branch
                      3391     
02A3    A863          3392     MOV R0 , PWM_LIMIT_BY_RPM 
                      3393     
                      3394     ENDIF
02A5    8825          3395     MOV CURRENT_PWM_LIMITED , R0 
                      3396     	; Dither
02A7    E566          3397     	MOV	A, PWM_DITHER_DECODED		; Load pwm dither
02A9    7002          3398     	JNZ	($+4)					; If active - branch
02AB    41DB          3399     	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                      3400     
02AD    C3            3401     	CLR	C
02AE    E8            3402     MOV A , R0 
02AF    AA66          3403     MOV R2 , PWM_DITHER_DECODED 
02B1    9A            3404     SUBB A , R2 
02B2    5003          3405     	JNC	T2_INT_CURRENT_PWM_FULL_DITHER; If pwm more than dither value, then do full dither
                      3406     
02B4    E8            3407     MOV A , R0 
02B5    FA            3408     MOV R2 , A 
02B6    E4            3409     	CLR	A						; Set pwm minus dither
                      3410     
                      3411     T2_INT_CURRENT_PWM_FULL_DITHER: 
02B7    F9            3412     MOV R1 , A 
02B8    EA            3413     MOV A , R2 
02B9    C3            3414     	CLR	C
02BA    33            3415     	RLC	A						; Shift left once
02BB    FB            3416     MOV R3 , A 
02BC    E568          3417     	MOV	A, RANDOM					; Load random number
02BE    F4            3418     	CPL	A						; Invert to create proper DC bias in random code
02BF    5B            3419     ANL A , R3 
02C0    29            3420     ADD A , R1 
02C1    400D          3421     	JC	T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER	; If dither cause power above max - branch and increase excess 
                      3422     
02C3    2567          3423     	ADD	A, PWM_DITHER_EXCESS_POWER	; Add excess power from previous cycles
02C5    F8            3424     MOV R0 , A 
02C6    E567          3425     	MOV	A, PWM_DITHER_EXCESS_POWER	; Decrement excess power
02C8    6002          3426     	JZ	($+4)
02CA    1567          3427     	DEC	PWM_DITHER_EXCESS_POWER
02CC    400B          3428     	JC	T2_INT_CURRENT_PWM_DITHER_MAX_POWER; If dither cause power above max - branch
                      3429     
02CE    41DB          3430     	AJMP	T2_INT_CURRENT_PWM_NO_DITHER
                      3431     
                      3432     T2_INT_CURRENT_PWM_DITHER_MAX_EXCESS_POWER: 
02D0    0A            3433     INC R2 
02D1    C3            3434     	CLR	C
02D2    E567          3435     	MOV	A, PWM_DITHER_EXCESS_POWER
02D4    9A            3436     SUBB A , R2 
02D5    5002          3437     	JNC	($+4)
02D7    0567          3438     	INC	PWM_DITHER_EXCESS_POWER
                      3439     
                      3440     T2_INT_CURRENT_PWM_DITHER_MAX_POWER: 
02D9    78FF          3441     MOV R0 , # 255 
                      3442     
                      3443     T2_INT_CURRENT_PWM_NO_DITHER: 
02DB    8826          3444     MOV CURRENT_PWM_LIM_DITH , R0 
                      3445     IF DAMPED_MODE_ENABLE == 1
                      3446     	; Skip damping fet switching for high throttle
02DD    C26E          3447     CLR FLAGS1 . 6 
02DF    C3            3448     	CLR	C
02E0    E526          3449     	MOV	A, CURRENT_PWM_LIM_DITH
02E2    94F8          3450     	SUBB	A, #248
02E4    4002          3451     	JC	T2_INT_PWM_EXIT
02E6    D26E          3452     SETB FLAGS1 . 6 
                      3453     ENDIF
                      3454     ENDIF
                      3455     T2_INT_PWM_EXIT: 	
                      3456     	; Set demag enabled if pwm is above limit
02E8    C3            3457     	CLR	C
02E9    E525          3458     	MOV	A, CURRENT_PWM_LIMITED	
02EB    9440          3459     	SUBB	A, #40H					; Set if above 25%
02ED    4002          3460     	JC	($+4)
                      3461     
02EF    D264          3462     SETB FLAGS0 . 4 
                      3463     
                      3464     T2_INT_EXIT: 	
                      3465     	; Check if high byte flag is set
02F1    20CF0A        3466     	JB	TF2H, T2H_INT		
02F4    D0E0          3467     	POP	ACC			; Restore preserved registers
02F6    D0D0          3468     	POP	PSW
02F8    43E610        3469     	ORL	EIE1, #10H	; Enable PCA0 interrupts
02FB    D2AD          3470     	SETB	ET2			; Enable timer2 interrupts
02FD    32            3471     	RETI
                      3472     
                      3473     T2H_INT: 
                      3474     IF MCU_48MHZ == 1
02FE    E57A          3475     	MOV	A, CLOCK_SET_AT_48MHZ
0300    6009          3476     	JZ 	T2H_INT_START
                      3477     
                      3478     	; Check skip variable
0302    E578          3479     	MOV	A, SKIP_T2H_INT
0304    6005          3480     	JZ	T2H_INT_START				; Execute this interrupt
                      3481     
0306    757800        3482     	MOV	SKIP_T2H_INT, #0
0309    6138          3483     	AJMP	T2H_INT_EXIT
                      3484     
                      3485     T2H_INT_START: 
030B    757801        3486     	MOV	SKIP_T2H_INT, #1			; Skip next interrupt
                      3487     ENDIF
                      3488     	; High byte interrupt (happens every 32ms)
030E    C2CF          3489     	CLR	TF2H					; Clear interrupt flag
0310    7801          3490     MOV R0 , # 1 
                      3491     	; Check RC pulse timeout counter (used here for PPM only)
0312    E52A          3492     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
0314    6005          3493     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      3494     
                      3495     	; Decrement timeout counter (if PPM)
0316    307402        3496     JNB FLAGS2 . 4 , T2H_INT_RCP_STOP_CHECK 
                      3497     
0319    152A          3498     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      3499     
                      3500     T2H_INT_RCP_STOP_CHECK: 
                      3501     	; Check RC pulse against stop value
031B    C3            3502     	CLR	C
031C    E55C          3503     	MOV	A, NEW_RCP				; Load new pulse value
031E    9401          3504     SUBB A , # 1 
0320    4005          3505     	JC	T2H_INT_RCP_STOP
                      3506     
                      3507     	; RC pulse higher than stop value, reset stop counter
0322    755F00        3508     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0325    6138          3509     	AJMP	T2H_INT_RCP_GOV_PWM
                      3510     
                      3511     T2H_INT_RCP_STOP: 	
                      3512     	; RC pulse less than stop value
0327    756000        3513     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
032A    756900        3514     	MOV	SPOOLUP_LIMIT_CNT, #0
032D    E55F          3515     	MOV	A, RCP_STOP_CNT			; Increment stop counter
032F    2401          3516     	ADD	A, #1
0331    F55F          3517     	MOV	RCP_STOP_CNT, A
0333    5003          3518     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      3519     
0335    755FFF        3520     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      3521     
                      3522     T2H_INT_RCP_GOV_PWM: 
                      3523     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	JNB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_GOV_BY_TX; If governor not active - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	JNB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_GOV_BY_TX; If governor not active - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_3X			; No spoolup until 3*N*32ms
                               
                               	JC	T2H_INT_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_10X			; Slow spoolup until "100"*N*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_15X			; Faster spoolup until "150"*N*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	JB	FLAGS1.GOV_ACTIVE, T2H_INT_RCP_INC_LIMIT	; If governor active - branch 
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, MAIN_SPOOLUP_TIME_3X	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_EXIT					; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      3649     T2H_INT_EXIT: 
0338    D0E0          3650     	POP	ACC			; Restore preserved registers
033A    D0D0          3651     	POP	PSW
033C    43E610        3652     	ORL	EIE1, #10H	; Enable PCA0 interrupts
033F    D2AD          3653     	SETB	ET2			; Enable timer2 interrupts
0341    32            3654     	RETI
                      3655     
                      3656     
                      3657     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3658     ;
                      3659     ; Timer3 interrupt routine
                      3660     ;
                      3661     ; No assumptions
                      3662     ;
                      3663     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3664     T3_INT: 	; Used for commutation timing
0342    C2AF          3665     	CLR 	EA				; Disable all interrupts
0344    C0D0          3666     	PUSH	PSW				; Preserve registers through interrupt
0346    53E67F        3667     	ANL	EIE1, #7FH		; Disable timer3 interrupts
0349    C260          3668     CLR FLAGS0 . 0 
                      3669     	; Set up next wait
034B    759100        3670     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
034E    855394        3671     	MOV	TMR3L, NEXT_WT_START_L	; Set wait value	
0351    855495        3672     	MOV	TMR3H, NEXT_WT_START_H
0354    759104        3673     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
0357    D0D0          3674     	POP	PSW
0359    D2AF          3675     	SETB	EA				; Enable all interrupts
035B    32            3676     	RETI
                      3677     
                      3678     
                      3679     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3680     ;
                      3681     ; PCA interrupt routine
                      3682     ;
                      3683     ; No assumptions
                      3684     ;
                      3685     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3686     PCA_INT: 	; Used for RC pulse timing
035C    C2AF          3687     	CLR	EA
035E    53E6EF        3688     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
0361    C2AD          3689     	CLR	ET2			; Disable timer2 interrupts
0363    C0D0          3690     	PUSH	PSW			; Preserve registers through interrupt
0365    C0E0          3691     	PUSH	ACC
0367    C0F0          3692     	PUSH	B
0369    D2D3          3693     	SETB	PSW.3		; Select register bank 1 for interrupt routines
036B    D2AF          3694     	SETB	EA
                      3695     	; Get the PCA counter values
                      3696     	GET_RCP_CAPTURE_VALUES
036D    A8FB          3696+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
036F    A9FC          3696+1   MOV R1 , PCA0CPH0 
                      3696+1   IF 1 ==1 
0371    E57A          3696+1   MOV A , CLOCK_SET_AT_48MHZ 
0373    6007          3696+1   JZ GET_RCP_END 
0375    C3            3696+1   CLR C 
0376    E9            3696+1   MOV A , R1 
0377    13            3696+1   RRC A 
0378    F9            3696+1   MOV R1 , A 
0379    E8            3696+1   MOV A , R0 
037A    13            3696+1   RRC A 
037B    F8            3696+1   MOV R0 , A 
                      3696+1   GET_RCP_END:  
                      3696+1   ENDIF 
                      3697     	; Clear interrupt flag
                      3698     	RCP_CLEAR_INT_FLAG 				
037C    C2D8          3698+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3699     	; Check which edge it is
037E    307102        3700     JNB FLAGS2 . 1 , ( $+5 ) 
0381    61CE          3701     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      3702     
                      3703     	RCP_INT_SECOND					; Yes - set second edge trig
0383    53DACF        3703+1   ANL PCA0CPM0 , # 0CFH 
0386    207E03        3703+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0389    43DA10        3703+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
038C    307E03        3703+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
038F    43DA20        3703+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0392    D271          3704     SETB FLAGS2 . 1 
                      3705     	; Read RC signal level
                      3706     	READ_RCP_INT			
0394    E580          3706+1   MOV A , P0 
0396    307E01        3706+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0399    F4            3706+1   CPL A  ; YES - INVERT
                      3707     	; Test RC signal level
039A    20E502        3708     JB ACC . 5 , ( $+5 ) 
039D    61A5          3709     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      3710     
                      3711     	; RC pulse was high, store RC pulse start timestamp
039F    8827          3712     MOV RCP_PREV_EDGE_L , R0 
03A1    8928          3713     MOV RCP_PREV_EDGE_H , R1 
03A3    A1F5          3714     	AJMP	PCA_INT_EXIT				; Exit
                      3715     
                      3716     PCA_INT_FAIL_MINIMUM: 
                      3717     	; Prepare for next interrupt
                      3718     	RCP_INT_FIRST					; Set interrupt trig to first again
03A5    53DACF        3718+1   ANL PCA0CPM0 , # 0CFH 
03A8    207E03        3718+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03AB    43DA20        3718+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03AE    307E03        3718+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03B1    43DA10        3718+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3719     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03B4    C2D8          3719+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03B6    C271          3720     CLR FLAGS2 . 1 
03B8    307402        3721     JNB FLAGS2 . 4 , ( $+5 ) 
                      3722     
03BB    A1E1          3723     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      3724     
03BD    7800          3725     MOV R0 , # 0 
                      3726     	READ_RCP_INT 					; Test RC signal level again
03BF    E580          3726+1   MOV A , P0 
03C1    307E01        3726+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
03C4    F4            3726+1   CPL A  ; YES - INVERT
03C5    30E502        3727     JNB ACC . 5 , ( $+5 ) 
                      3728     
03C8    A1E1          3729     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      3730     
03CA    885C          3731     MOV NEW_RCP , R0 
03CC    A1C9          3732     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      3733     
                      3734     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      3735     	; Prepare for next interrupt
                      3736     	RCP_INT_FIRST 					; Set first edge trig
03CE    53DACF        3736+1   ANL PCA0CPM0 , # 0CFH 
03D1    207E03        3736+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03D4    43DA20        3736+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03D7    307E03        3736+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03DA    43DA10        3736+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03DD    C271          3737     CLR FLAGS2 . 1 
                      3738     	; Check if pwm frequency shall be measured
03DF    206102        3739     JB FLAGS0 . 1 , ( $+5 ) 
03E2    81A7          3740     	AJMP	PCA_INT_FALL				; No - skip measurements
                      3741     
                      3742     	; Set second edge trig only during pwm frequency measurement
                      3743     	RCP_INT_SECOND 				; Set second edge trig
03E4    53DACF        3743+1   ANL PCA0CPM0 , # 0CFH 
03E7    207E03        3743+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03EA    43DA10        3743+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
03ED    307E03        3743+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03F0    43DA20        3743+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      3744     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03F3    C2D8          3744+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03F5    D271          3745     SETB FLAGS2 . 1 
                      3746     	; Store edge data to RAM
03F7    8857          3747     MOV RCP_EDGE_L , R0 
03F9    8958          3748     MOV RCP_EDGE_H , R1 
                      3749     	; Calculate pwm frequency
03FB    C3            3750     	CLR	C
03FC    E8            3751     MOV A , R0 
03FD    9555          3752     	SUBB	A, RCP_PREPREV_EDGE_L	
03FF    F8            3753     MOV R0 , A 
0400    E9            3754     MOV A , R1 
0401    9556          3755     	SUBB	A, RCP_PREPREV_EDGE_H
0403    F9            3756     MOV R1 , A 
0404    7B00          3757     MOV R3 , # 0 
0406    7E08          3758     MOV R6 , # 8 
0408    7A00          3759     MOV R2 , # 0 
                      3760     	; Check if pulse is too short
040A    C3            3761     	CLR	C
040B    E8            3762     MOV A , R0 
040C    948C          3763     	SUBB	A, #LOW(140)				; If pulse below 70us, not accepted
040E    E9            3764     MOV A , R1 
040F    9400          3765     	SUBB	A, #HIGH(140)
0411    5005          3766     	JNC	PCA_INT_CHECK_12KHZ
                      3767     
0413    755B00        3768     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0	; Set not accepted 
0416    8199          3769     	AJMP	PCA_INT_STORE_DATA
                      3770     
                      3771     PCA_INT_CHECK_12KHZ: 
0418    8821          3772     MOV BIT_ACCESS_INT , R0 
041A    78A2          3773     MOV R0 , # PGM_ENABLE_PWM_INPUT 
041C    E6            3774     MOV A , @ R0 
041D    A821          3775     MOV R0 , BIT_ACCESS_INT 
041F    6055          3776     	JZ	PCA_INT_RESTORE_EDGE		; If it is not - branch
                      3777     
                      3778     	; Check if pwm frequency is 12kHz
0421    C3            3779     	CLR	C
0422    E8            3780     MOV A , R0 
0423    94C8          3781     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
0425    E9            3782     MOV A , R1 
0426    9400          3783     	SUBB	A, #HIGH(200)
0428    5008          3784     	JNC	PCA_INT_CHECK_8KHZ
                      3785     
042A    E4            3786     	CLR	A
042B    D2E4          3787     SETB ACC . 4 
042D    FB            3788     MOV R3 , A 
042E    7A0A          3789     MOV R2 , # 10 
0430    8174          3790     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3791     
                      3792     PCA_INT_CHECK_8KHZ: 
                      3793     	; Check if pwm frequency is 8kHz
0432    C3            3794     	CLR	C
0433    E8            3795     MOV A , R0 
0434    9468          3796     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0436    E9            3797     MOV A , R1 
0437    9401          3798     	SUBB	A, #HIGH(360)
0439    5008          3799     	JNC	PCA_INT_CHECK_4KHZ
                      3800     
043B    E4            3801     	CLR	A
043C    D2E3          3802     SETB ACC . 3 
043E    FB            3803     MOV R3 , A 
043F    7A0F          3804     MOV R2 , # 15 
0441    8174          3805     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3806     
                      3807     PCA_INT_CHECK_4KHZ: 
                      3808     	; Check if pwm frequency is 4kHz
0443    C3            3809     	CLR	C
0444    E8            3810     MOV A , R0 
0445    94D0          3811     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0447    E9            3812     MOV A , R1 
0448    9402          3813     	SUBB	A, #HIGH(720)
044A    5008          3814     	JNC	PCA_INT_CHECK_2KHZ
                      3815     
044C    E4            3816     	CLR	A
044D    D2E2          3817     SETB ACC . 2 
044F    FB            3818     MOV R3 , A 
0450    7A1E          3819     MOV R2 , # 30 
0452    8174          3820     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3821     
                      3822     PCA_INT_CHECK_2KHZ: 
                      3823     	; Check if pwm frequency is 2kHz
0454    C3            3824     	CLR	C
0455    E8            3825     MOV A , R0 
0456    94A0          3826     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0458    E9            3827     MOV A , R1 
0459    9405          3828     	SUBB	A, #HIGH(1440)
045B    5008          3829     	JNC	PCA_INT_CHECK_1KHZ
                      3830     
045D    E4            3831     	CLR	A
045E    D2E1          3832     SETB ACC . 1 
0460    FB            3833     MOV R3 , A 
0461    7A3C          3834     MOV R2 , # 60 
0463    8174          3835     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3836     
                      3837     PCA_INT_CHECK_1KHZ: 
                      3838     	; Check if pwm frequency is 1kHz
0465    C3            3839     	CLR	C
0466    E8            3840     MOV A , R0 
0467    9498          3841     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0469    E9            3842     MOV A , R1 
046A    9408          3843     	SUBB	A, #HIGH(2200)
046C    5008          3844     	JNC	PCA_INT_RESTORE_EDGE
                      3845     
046E    E4            3846     	CLR	A
046F    D2E0          3847     SETB ACC . 0 
0471    FB            3848     MOV R3 , A 
0472    7A78          3849     MOV R2 , # 120 
                      3850     
                      3851     PCA_INT_RESTORE_EDGE_SET_MSB: 
0474    7E00          3852     MOV R6 , # 0 
                      3853     PCA_INT_RESTORE_EDGE: 
                      3854     	; Calculate difference between this period and previous period
0476    C3            3855     	CLR	C
0477    E8            3856     MOV A , R0 
0478    9559          3857     	SUBB	A, RCP_PREV_PERIOD_L
047A    FC            3858     MOV R4 , A 
047B    E9            3859     MOV A , R1 
047C    955A          3860     	SUBB	A, RCP_PREV_PERIOD_H
047E    FD            3861     MOV R5 , A 
                      3862     	; Make positive
047F    30E70A        3863     	JNB	ACC.7, PCA_INT_CHECK_DIFF
0482    EC            3864     MOV A , R4 
0483    F4            3865     	CPL	A
0484    2401          3866     	ADD	A, #1
0486    FC            3867     MOV R4 , A 
0487    ED            3868     MOV A , R5 
0488    F4            3869     	CPL	A
0489    3400          3870     	ADDC	A, #0
048B    FD            3871     MOV R5 , A 
                      3872     
                      3873     PCA_INT_CHECK_DIFF: 
                      3874     	; Check difference
048C    755B00        3875     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
048F    C3            3876     	CLR	C
0490    EC            3877     MOV A , R4 
0491    9A            3878     SUBB A , R2 
0492    ED            3879     MOV A , R5 
0493    9E            3880     SUBB A , R6 
0494    5003          3881     	JNC	PCA_INT_STORE_DATA
                      3882     
0496    755B01        3883     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      3884     
                      3885     PCA_INT_STORE_DATA: 
                      3886     	; Store previous period
0499    8859          3887     MOV RCP_PREV_PERIOD_L , R0 
049B    895A          3888     MOV RCP_PREV_PERIOD_H , R1 
                      3889     	; Store pre previous edge
049D    855755        3890     	MOV	RCP_PREPREV_EDGE_L, RCP_EDGE_L
04A0    855856        3891     	MOV	RCP_PREPREV_EDGE_H, RCP_EDGE_H
04A3    7802          3892     MOV R0 , # 2 
04A5    A1C9          3893     	AJMP	PCA_INT_LIMITED
                      3894     
                      3895     PCA_INT_FALL: 
                      3896     	; RC pulse edge was second, calculate new pulse length
04A7    C3            3897     	CLR	C
04A8    E8            3898     MOV A , R0 
04A9    9527          3899     	SUBB	A, RCP_PREV_EDGE_L	
04AB    F8            3900     MOV R0 , A 
04AC    E9            3901     MOV A , R1 
04AD    9528          3902     	SUBB	A, RCP_PREV_EDGE_H
04AF    F9            3903     MOV R1 , A 
04B0    307C02        3904     JNB FLAGS3 . 4 , ( $+5 ) 
04B3    A1AD          3905     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3906     
04B5    307B02        3907     JNB FLAGS3 . 3 , ( $+5 ) 
04B8    A1AD          3908     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3909     
04BA    307A02        3910     JNB FLAGS3 . 2 , ( $+5 ) 
04BD    A1A6          3911     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3912     
04BF    207502        3913     JB FLAGS2 . 5 , ( $+5 ) 
04C2    81CA          3914     	AJMP	PCA_INT_FALL_NOT_ONESHOT
                      3915     
04C4    E9            3916     MOV A , R1 
04C5    FD            3917     MOV R5 , A 
04C6    E8            3918     MOV A , R0 
04C7    FC            3919     MOV R4 , A 
04C8    81E9          3920     	AJMP	PCA_INT_FALL_CHECK_RANGE
                      3921     
                      3922     PCA_INT_FALL_NOT_ONESHOT: 
04CA    E9            3923     MOV A , R1 
04CB    C3            3924     	CLR	C
04CC    13            3925     	RRC	A
04CD    F9            3926     MOV R1 , A 
04CE    E8            3927     MOV A , R0 
04CF    13            3928     	RRC	A
04D0    F8            3929     MOV R0 , A 
                      3930     
04D1    307902        3931     JNB FLAGS3 . 1 , ( $+5 ) 
04D4    A1A6          3932     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3933     
04D6    E9            3934     MOV A , R1 
04D7    C3            3935     	CLR	C
04D8    13            3936     	RRC	A
04D9    F9            3937     MOV R1 , A 
04DA    E8            3938     MOV A , R0 
04DB    13            3939     	RRC	A
04DC    F8            3940     MOV R0 , A 
                      3941     
04DD    307802        3942     JNB FLAGS3 . 0 , ( $+5 ) 
04E0    A1A6          3943     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3944     
04E2    E9            3945     MOV A , R1 
04E3    C3            3946     	CLR	C
04E4    13            3947     	RRC	A
04E5    FD            3948     MOV R5 , A 
04E6    E8            3949     MOV A , R0 
04E7    13            3950     	RRC	A
04E8    FC            3951     MOV R4 , A 
                      3952     PCA_INT_FALL_CHECK_RANGE: 
                      3953     	; Skip range limitation if pwm frequency measurement
04E9    206126        3954     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      3955     
                      3956     	; Check if 2160us or above (in order to ignore false pulses)
04EC    C3            3957     	CLR	C
04ED    EC            3958     MOV A , R4 
04EE    941C          3959     	SUBB	A, #28
04F0    ED            3960     MOV A , R5 
04F1    9402          3961     	SUBB A, #2
04F3    4002          3962     	JC	($+4)						; No - proceed
                      3963     
04F5    A100          3964     	AJMP	PCA_INT_PPM_OUTSIDE_RANGE		; Yes - ignore pulse
                      3965     
                      3966     PCA_INT_PPM_BELOW_FULL_RANGE: 
                      3967     	; Check if below 800us (in order to ignore false pulses)
04F7    ED            3968     MOV A , R5 
04F8    7018          3969     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      3970     
04FA    C3            3971     	CLR	C
04FB    EC            3972     MOV A , R4 
04FC    94C8          3973     	SUBB	A, #200
04FE    5012          3974     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      3975     
                      3976     PCA_INT_PPM_OUTSIDE_RANGE: 
0500    0529          3977     	INC	RCP_OUTSIDE_RANGE_CNT
0502    C3            3978     	CLR	C
0503    E529          3979     	MOV	A, RCP_OUTSIDE_RANGE_CNT
0505    940A          3980     	SUBB	A, #10						; Allow a given number of outside pulses
0507    5002          3981     	JNC	($+4)			
0509    A1E1          3982     	AJMP	PCA_INT_SET_TIMEOUT				; If below limit - ignore pulse
                      3983     
050B    755C00        3984     	MOV	NEW_RCP, #0					; Set pulse length to zero
050E    D270          3985     SETB FLAGS2 . 0 
0510    A1E1          3986     	AJMP	PCA_INT_SET_TIMEOUT			
                      3987     
                      3988     PCA_INT_PPM_CHECK_FULL_RANGE: 
0512    E529          3989     	MOV	A, RCP_OUTSIDE_RANGE_CNT
0514    6002          3990     	JZ	($+4)
                      3991     
0516    1529          3992     	DEC	RCP_OUTSIDE_RANGE_CNT
                      3993     
                      3994     	; Calculate "1000us" plus throttle minimum
                      3995     IF MODE >= 1	; Tail or multi
0518    7888          3996     MOV R0 , # PGM_DIRECTION 
051A    E6            3997     MOV A , @ R0 
051B    F9            3998     MOV R1 , A 
                      3999     ENDIF
051C    7400          4000     	MOV	A, #0						; Set 1000us as default minimum
051E    207F08        4001     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      4002     
0521    7896          4003     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      4004     IF MODE >= 1	; Tail or multi
0523    B90302        4005     CJNE R1 , # 3 , ( $+5 ) 
                      4006     
0526    789E          4007     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      4008     ENDIF
0528    E6            4009     MOV A , @ R0 
                      4010     
                      4011     PCA_INT_PPM_CALCULATE: 
0529    24FA          4012     	ADD	A, #250						; Add 1000us to minimum
052B    FE            4013     MOV R6 , A 
052C    E4            4014     	CLR	A
052D    3400          4015     	ADDC	A, #0
052F    FF            4016     MOV R7 , A 
                      4017     
0530    C3            4018     	CLR	C
0531    EC            4019     MOV A , R4 
0532    9E            4020     SUBB A , R6 
0533    FC            4021     MOV R4 , A 
0534    ED            4022     MOV A , R5 
0535    9F            4023     SUBB A , R7 
0536    FD            4024     MOV R5 , A 
                      4025     IF MODE >= 1	; Tail or multi
0537    9208          4026     	MOV	BIT_ACCESS_INT.0, C
0539    B90310        4027     CJNE R1 , # 3 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4028     
053C    A208          4029     	MOV	C, BIT_ACCESS_INT.0
053E    5007          4030     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      4031     
                      4032     PCA_INT_PPM_BIDIR_REV: 
0540    207609        4033     JB FLAGS2 . 6 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4034     
0543    D276          4035     SETB FLAGS2 . 6 
0545    A14C          4036     	AJMP	PCA_INT_PPM_BIDIR_DIR_SET
                      4037     
                      4038     PCA_INT_PPM_BIDIR_FWD: 
0547    307602        4039     JNB FLAGS2 . 6 , PCA_INT_PPM_BIDIR_DIR_SET 
                      4040     
054A    C276          4041     CLR FLAGS2 . 6 
                      4042     
                      4043     PCA_INT_PPM_BIDIR_DIR_SET: 
054C    A208          4044     	MOV	C, BIT_ACCESS_INT.0
                      4045     ENDIF
054E    5016          4046     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      4047     
                      4048     IF MODE >= 1	; Tail or multi
0550    B9030D        4049     CJNE R1 , # 3 , PCA_INT_PPM_UNIDIR_NEG 
                      4050     
0553    EC            4051     MOV A , R4 
0554    F4            4052     	CPL	A
0555    2401          4053     	ADD	A, #1
0557    FC            4054     MOV R4 , A 
0558    ED            4055     MOV A , R5 
0559    F4            4056     	CPL	A
055A    3400          4057     	ADDC	A, #0
055C    FD            4058     MOV R5 , A 
055D    020566        4059     	JMP	PCA_INT_PPM_NEG_CHECKED
                      4060     
                      4061     PCA_INT_PPM_UNIDIR_NEG: 
                      4062     ENDIF
0560    7800          4063     MOV R0 , # 0 
0562    7900          4064     MOV R1 , # 0 
0564    A1AD          4065     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4066     
                      4067     PCA_INT_PPM_NEG_CHECKED: 
                      4068     IF MODE >= 1	; Tail or multi
0566    B90315        4069     CJNE R1 , # 3 , PCA_INT_PPM_BIDIR_DONE 
                      4070     
0569    EC            4071     MOV A , R4 
056A    33            4072     	RLC	A
056B    FC            4073     MOV R4 A 
056C    ED            4074     MOV A , R5 
056D    33            4075     	RLC	A
056E    FD            4076     MOV R5 A 
056F    C3            4077     	CLR	C							; Subtract deadband
0570    EC            4078     MOV A , R4 
0571    940A          4079     	SUBB	A, #10		
0573    FC            4080     MOV R4 , A 
0574    ED            4081     MOV A , R5 
0575    9400          4082     	SUBB	A, #0
0577    FD            4083     MOV R5 , A 
0578    5004          4084     	JNC	PCA_INT_PPM_BIDIR_DONE
                      4085     
057A    7C00          4086     MOV R4 , # 0 
057C    7D00          4087     MOV R5 , # 0 
                      4088     
                      4089     PCA_INT_PPM_BIDIR_DONE: 
                      4090     ENDIF
057E    C3            4091     	CLR	C							; Check that RC pulse is within legal range (max 255)
057F    EC            4092     MOV A , R4 
0580    94FF          4093     SUBB A , # 255 
0582    ED            4094     MOV A , R5 
0583    9400          4095     	SUBB	A, #0
0585    4006          4096     	JC	PCA_INT_PPM_MAX_CHECKED
                      4097     
0587    78FF          4098     MOV R0 , # 255 
0589    7900          4099     MOV R1 , # 0 
058B    A1AD          4100     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      4101     
                      4102     PCA_INT_PPM_MAX_CHECKED: 
058D    EC            4103     MOV A , R4 
058E    8572F0        4104     	MOV	B, PPM_THROTTLE_GAIN
0591    A4            4105     	MUL	AB
0592    C5F0          4106     	XCH	A, B
0594    A2F7          4107     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0596    33            4108     	RLC	A
0597    F8            4109     MOV R0 , A 
0598    7900          4110     MOV R1 , # 0 
059A    4003          4111     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      4112     	
059C    0205C9        4113     	JMP	PCA_INT_LIMITED			
                      4114     
                      4115     PCA_INT_PPM_LIMIT_AFTER_MULT: 
059F    78FF          4116     MOV R0 , # 255 
05A1    7900          4117     MOV R1 , # 0 
05A3    0205C9        4118     	JMP	PCA_INT_LIMITED			
                      4119     
                      4120     PCA_INT_PWM_DIVIDE: 
05A6    E9            4121     MOV A , R1 
05A7    C3            4122     	CLR	C
05A8    13            4123     	RRC	A
05A9    F9            4124     MOV R1 , A 
05AA    E8            4125     MOV A , R0 
05AB    13            4126     	RRC	A
05AC    F8            4127     MOV R0 , A 
                      4128     
                      4129     PCA_INT_PWM_DIVIDE_DONE: 
05AD    307C0E        4130     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
05B0    E9            4131     MOV A , R1 
05B1    6002          4132     	JZ	($+4)
                      4133     
05B3    78FF          4134     MOV R0 , # 255 
                      4135     
05B5    C3            4136     	CLR	C
05B6    E8            4137     MOV A , R0 
05B7    13            4138     	RRC	A
05B8    38            4139     ADDC A , R0 
05B9    F8            4140     MOV R0 , A 
05BA    E4            4141     	CLR	A
05BB    3400          4142     	ADDC	A, #0
05BD    F9            4143     MOV R1 , A 
                      4144     
                      4145     PCA_INT_CHECK_LEGAL_RANGE: 
                      4146     	; Check that RC pulse is within legal range
05BE    C3            4147     	CLR	C
05BF    E8            4148     MOV A , R0 
05C0    94FF          4149     SUBB A , # 255 
05C2    E9            4150     MOV A , R1 
05C3    9400          4151     	SUBB	A, #0
05C5    4002          4152     	JC	PCA_INT_LIMITED
                      4153     
05C7    78FF          4154     MOV R0 , # 255 
                      4155     
                      4156     PCA_INT_LIMITED: 
                      4157     	; RC pulse value accepted
05C9    885C          4158     MOV NEW_RCP , R0 
05CB    D270          4159     SETB FLAGS2 . 0 
05CD    206102        4160     JB FLAGS0 . 1 , ( $+5 ) 
                      4161     
05D0    A1E1          4162     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      4163     
05D2    741F          4164     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
05D4    F4            4165     	CPL	A
05D5    552F          4166     	ANL	A, FLAGS3					; Clear all pwm frequency flags
05D7    4B            4167     ORL A , R3 
05D8    F52F          4168     	MOV	FLAGS3, A
05DA    C274          4169     CLR FLAGS2 . 4 
05DC    EB            4170     MOV A , R3 
05DD    7002          4171     	JNZ	PCA_INT_SET_TIMEOUT
                      4172     
05DF    D274          4173     SETB FLAGS2 . 4 
                      4174     
                      4175     PCA_INT_SET_TIMEOUT: 
05E1    752A18        4176     MOV RCP_TIMEOUT_CNT , # 24 
05E4    307403        4177     JNB FLAGS2 . 4 , PCA_INT_PPM_TIMEOUT_SET 
                      4178     
05E7    752A0A        4179     MOV RCP_TIMEOUT_CNT , # 10 
                      4180     
                      4181     PCA_INT_PPM_TIMEOUT_SET: 
05EA    306102        4182     JNB FLAGS0 . 1 , ( $+5 ) 
                      4183     
05ED    A1F5          4184     	AJMP PCA_INT_EXIT				; Yes - exit
                      4185     
05EF    207403        4186     JB FLAGS2 . 4 , PCA_INT_EXIT 
                      4187     
                      4188     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
05F2    53DAFE        4188+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      4189     
                      4190     PCA_INT_EXIT: 	; Exit interrupt routine	
05F5    207403        4191     JB FLAGS2 . 4 , ( $+6 ) 
                      4192     
05F8    752B06        4193     MOV RCP_SKIP_CNT , # 6 
                      4194     
05FB    D0F0          4195     	POP	B			; Restore preserved registers
05FD    D0E0          4196     	POP	ACC			
05FF    D0D0          4197     	POP	PSW
0601    D2AD          4198     	SETB	ET2			; Enable timer2 interrupts
0603    43E610        4199     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0606    32            4200     	RETI
                      4201     
                      4202     
                      4203     
                      4204     
                      4205     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4206     ;
                      4207     ; Wait xms ~(x*4*250)  (Different entry points)	
                      4208     ;
                      4209     ; No assumptions
                      4210     ;
                      4211     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4212     WAIT1MS: 	
0607    7901          4213     MOV R1 , # 1 
0609    020625        4214     	JMP	WAITXMS_O
                      4215     
                      4216     WAIT3MS: 	
060C    7903          4217     MOV R1 , # 3 
060E    020625        4218     	JMP	WAITXMS_O
                      4219     
                      4220     WAIT10MS: 	
0611    790A          4221     MOV R1 , # 10 
0613    020625        4222     	JMP	WAITXMS_O
                      4223     
                      4224     WAIT30MS: 	
0616    791E          4225     MOV R1 , # 30 
0618    020625        4226     	JMP	WAITXMS_O
                      4227     
                      4228     WAIT100MS: 	
061B    7964          4229     MOV R1 , # 100 
061D    020625        4230     	JMP	WAITXMS_O
                      4231     
                      4232     WAIT200MS: 	
0620    79C8          4233     MOV R1 , # 200 
0622    020625        4234     	JMP	WAITXMS_O
                      4235     
                      4236     WAITXMS_O: 	; Outer loop
0625    7817          4237     MOV R0 , # 23 
                      4238     WAITXMS_M: 	; Middle loop
0627    E4            4239     	CLR	A
0628    D5E0FD        4240      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
062B    D8FA          4241     DJNZ R0 , WAITXMS_M 
062D    D9F6          4242     DJNZ R1 , WAITXMS_O 
062F    22            4243     	RET
                      4244     
                      4245     
                      4246     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4247     ;
                      4248     ; Beeper routines (4 different entry points) 
                      4249     ;
                      4250     ; No assumptions
                      4251     ;
                      4252     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4253     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
0630    7A14          4254     MOV R2 , # 20 
0632    7B78          4255     MOV R3 , # 120 
0634    02064C        4256     	JMP	BEEP
                      4257     
                      4258     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
0637    7A10          4259     MOV R2 , # 16 
0639    7B8C          4260     MOV R3 , # 140 
063B    02064C        4261     	JMP	BEEP
                      4262     
                      4263     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
063E    7A0D          4264     MOV R2 , # 13 
0640    7BB4          4265     MOV R3 , # 180 
0642    02064C        4266     	JMP	BEEP
                      4267     
                      4268     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0645    7A0B          4269     MOV R2 , # 11 
0647    7BC8          4270     MOV R3 , # 200 
0649    02064C        4271     	JMP	BEEP
                      4272     
                      4273     BEEP: 	; Beep loop start
064C    7902          4274     MOV R1 , # 2 
                      4275     BEEP_ONOFF: 
064E    B27D          4276     CPL FLAGS3 . 5 
0650    E4            4277     	CLR	A
                      4278     	BPFET_OFF			; BpFET off
0651    C295          4278+1   CLR P1 . 5 
0653    D5E0FD        4279     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      4280     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
0656    D294          4280+1   SETB P1 . 4 
0658    D5E0FD        4281     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      4282     	BNFET_OFF			; BnFET off again
065B    C294          4282+1   CLR P1 . 4 
065D    D5E0FD        4283     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      4284     	BPFET_ON			; BpFET on
0660    D295          4284+1   SETB P1 . 5 
0662    D5E0FD        4285     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      4286     	; Turn on nfet
                      4287     	ANFET_ON			; AnFET on
0665    D293          4287+1   SETB P1 . 3 
0667    E573          4288     	MOV	A, BEEP_STRENGTH
0669    D5E0FD        4289     	DJNZ	ACC, $		
                      4290     	; Turn off nfet
                      4291     	ANFET_OFF			; AnFET off
066C    C293          4291+1   CLR P1 . 3 
066E    7496          4292     	MOV	A, #150		; 25s off
0670    D5E0FD        4293     	DJNZ	ACC, $		
0673    D9D9          4294     DJNZ R1 , BEEP_ONOFF 
                      4295     	; Copy variable
0675    EA            4296     MOV A , R2 
0676    F8            4297     MOV R0 , A 
                      4298     BEEP_OFF: 		; Fets off loop
0677    D5E0FD        4299     	DJNZ	ACC, $
067A    D8FB          4300     DJNZ R0 , BEEP_OFF 
067C    DBCE          4301     DJNZ R3 , BEEP 
                      4302     	BPFET_OFF			; BpFET off
067E    C295          4302+1   CLR P1 . 5 
0680    22            4303     	RET
                      4304     
                      4305     
                      4306     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4307     ;
                      4308     ; Division 16bit unsigned by 16bit unsigned
                      4309     ;
                      4310     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      4311     ; Result will be in Temp2/Temp1
                      4312     ;
                      4313     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4314     DIV_U16_BY_U16: 	
0681    C3            4315     	CLR	C       
0682    7C00          4316     MOV R4 , # 0 
0684    7D00          4317     MOV R5 , # 0 
0686    75F000        4318     	MOV	B, #0
                      4319     DIV_U16_BY_U16_DIV1: 
0689    05F0          4320     	INC	B      			; Increment counter for each left shift
068B    EA            4321     MOV A , R2 
068C    33            4322     	RLC	A      		
068D    FA            4323     MOV R2 , A 
068E    EB            4324     MOV A , R3 
068F    33            4325     	RLC	A      	  	
0690    FB            4326     MOV R3 , A 
0691    50F6          4327     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      4328     DIV_U16_BY_U16_DIV2:         
0693    EB            4329     MOV A , R3 
0694    13            4330     	RRC	A      
0695    FB            4331     MOV R3 , A 
0696    EA            4332     MOV A , R2 
0697    13            4333     	RRC	A      
0698    FA            4334     MOV R2 , A 
0699    C3            4335     	CLR	C      
069A    E9            4336     MOV A , R1 
069B    FF            4337     MOV R7 , A 
069C    E8            4338     MOV A , R0 
069D    FE            4339     MOV R6 , A 
069E    E8            4340     MOV A , R0 
069F    9A            4341     SUBB A , R2 
06A0    F8            4342     MOV R0 , A 
06A1    E9            4343     MOV A , R1 
06A2    9B            4344     SUBB A , R3 
06A3    F9            4345     MOV R1 , A 
06A4    5004          4346     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
06A6    EF            4347     MOV A , R7 
06A7    F9            4348     MOV R1 , A 
06A8    EE            4349     MOV A , R6 
06A9    F8            4350     MOV R0 , A 
                      4351     DIV_U16_BY_U16_DIV3: 
06AA    B3            4352     	CPL	C      			; Invert carry, so it can be directly copied into result
06AB    EC            4353     MOV A , R4 
06AC    33            4354     	RLC	A      			; Shift carry flag into temporary result
06AD    FC            4355     MOV R4 , A 
06AE    ED            4356     MOV A , R5 
06AF    33            4357     	RLC	A
06B0    FD            4358     MOV R5 , A 
06B1    D5F0DF        4359     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
06B4    ED            4360     MOV A , R5 
06B5    F9            4361     MOV R1 , A 
06B6    EC            4362     MOV A , R4 
06B7    F8            4363     MOV R0 , A 
06B8    22            4364     	RET
                      4365     
                      4366     
                      4367     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4368     ;
                      4369     ; Multiplication 16bit signed by 8bit unsigned
                      4370     ;
                      4371     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      4372     ; Result will be in Temp2/Temp1. Result will divided by 16
                      4373     ;
                      4374     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4375     MULT_S16_BY_U8_DIV_16: 
06B9    E8            4376     MOV A , R0 
06BA    89F0          4377     MOV B , R1 
06BC    8A20          4378     MOV BIT_ACCESS , R2 
06BE    D2D4          4379     	SETB	PSW.4		; Select register bank 2 for math routines
06C0    F8            4380     MOV R0 , A 
06C1    A9F0          4381     MOV R1 , B 
06C3    7B00          4382     MOV R3 , # 0 
06C5    30F70B        4383     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      4384     
06C8    7BFF          4385     MOV R3 , # 0FFH 
06CA    F4            4386     	CPL	A
06CB    2401          4387     	ADD	A, #1
06CD    F8            4388     MOV R0 , A 
06CE    E9            4389     MOV A , R1 
06CF    F4            4390     	CPL	A
06D0    3400          4391     	ADDC	A, #0
06D2    F9            4392     MOV R1 , A 
                      4393     MULT_S16_BY_U8_POSITIVE: 
06D3    E8            4394     MOV A , R0 
06D4    8520F0        4395     	MOV	B, BIT_ACCESS
06D7    A4            4396     	MUL	AB
06D8    ADF0          4397     MOV R5 , B 
06DA    F8            4398     MOV R0 , A 
06DB    E9            4399     MOV A , R1 
06DC    8520F0        4400     	MOV	B, BIT_ACCESS
06DF    A4            4401     	MUL	AB
06E0    AFF0          4402     MOV R7 , B 
06E2    FE            4403     MOV R6 , A 
06E3    ED            4404     MOV A , R5 
06E4    2E            4405     ADD A , R6 
06E5    F9            4406     MOV R1 , A 
06E6    7400          4407     	MOV	A, #0
06E8    3F            4408     ADDC A , R7 
06E9    FA            4409     MOV R2 , A 
06EA    7C04          4410     MOV R4 , # 4 
                      4411     MULT_S16_BY_U8_DIV_LOOP: 
06EC    C3            4412     	CLR	C			; Rotate right 
06ED    EA            4413     MOV A , R2 
06EE    13            4414     	RRC	A
06EF    FA            4415     MOV R2 , A 
06F0    E9            4416     MOV A , R1 
06F1    13            4417     	RRC	A
06F2    F9            4418     MOV R1 , A 
06F3    E8            4419     MOV A , R0 
06F4    13            4420     	RRC	A
06F5    F8            4421     MOV R0 , A 
06F6    DCF4          4422     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      4423     
06F8    8BF0          4424     MOV B , R3 
06FA    30F70A        4425     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      4426     
06FD    E8            4427     MOV A , R0 
06FE    F4            4428     	CPL	A
06FF    2401          4429     	ADD	A, #1
0701    F8            4430     MOV R0 , A 
0702    E9            4431     MOV A , R1 
0703    F4            4432     	CPL	A
0704    3400          4433     	ADDC	A, #0
0706    F9            4434     MOV R1 , A 
                      4435     
                      4436     MULT_S16_BY_U8_EXIT: 
0707    E8            4437     MOV A , R0 
0708    89F0          4438     MOV B , R1 
070A    C2D4          4439     	CLR	PSW.4		; Select normal register bank
070C    F8            4440     MOV R0 , A 
070D    A9F0          4441     MOV R1 , B 
070F    22            4442     	RET
                      4443     
                      4444     
                      4445     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4446     ;
                      4447     ; Calculate governor routines
                      4448     ;
                      4449     ; No assumptions
                      4450     ;
                      4451     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      4452     ; The governor task is split into several routines in order to distribute processing time
                      4453     ;
                      4454     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4455     ; First governor routine - calculate governor target
                      4456     IF MODE == 0	; Main
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	JB	FLAGS1.GOV_ACTIVE, GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	JNB	FLAGS1.GOV_ACTIVE, GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                                
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	CLR	FLAGS1.GOV_ACTIVE
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	SETB	FLAGS1.GOV_ACTIVE
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      4594     IF MODE == 1	; Tail
                               CALC_GOVERNOR_TARGET:
                               	RET						
                               ENDIF
                      4598     IF MODE == 2	; Multi
                      4599     CALC_GOVERNOR_TARGET: 
0710    7882          4600     MOV R0 , # PGM_GOV_MODE 
0712    B60403        4601     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0715    02076B        4602     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      4603     
                      4604     GOVERNOR_TARGET_CALC: 
                      4605     	; Stop governor for stop RC pulse	
0718    C3            4606     	CLR	C
0719    E55C          4607     	MOV	A, NEW_RCP				; Check RC pulse against stop value
071B    9401          4608     SUBB A , # 1 
071D    4003          4609     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      4610     
071F    020735        4611     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      4612     
                      4613     GOVERNOR_DEACTIVATE: 
0722    852224        4614     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0725    E4            4615     	CLR	A
0726    F542          4616     	MOV	GOV_TARGET_L, A			; Set target to zero
0728    F543          4617     	MOV	GOV_TARGET_H, A
072A    F544          4618     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
072C    F545          4619     	MOV	GOV_INTEGRAL_H, A
072E    F546          4620     	MOV	GOV_INTEGRAL_X, A
0730    C26D          4621     CLR FLAGS1 . 5 
0732    02076B        4622     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      4623     
                      4624     GOVERNOR_ACTIVATE: 
0735    7882          4625     MOV R0 , # PGM_GOV_MODE 
0737    E6            4626     MOV A , @ R0 
0738    FC            4627     MOV R4 , A 
0739    D26D          4628     SETB FLAGS1 . 5 
073B    E522          4629     	MOV	A, REQUESTED_PWM			; Load requested pwm
073D    F523          4630     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      4631     	; Calculate comm period target 2*(51000/Requested_Pwm)
073F    7838          4632     MOV R0 , # 38H 
0741    79C7          4633     MOV R1 , # 0C7H 
0743    AA3D          4634     MOV R2 , COMM_PERIOD4X_L 
0745    AB3E          4635     MOV R3 , COMM_PERIOD4X_H 
                      4636     	; Set speed range 
0747    C3            4637     	CLR	C
0748    EB            4638     MOV A , R3 
0749    13            4639     	RRC	A
074A    FB            4640     MOV R3 , A 
074B    EA            4641     MOV A , R2 
074C    13            4642     	RRC	A
074D    FA            4643     MOV R2 , A 
                      4644     	; Check range
074E    EC            4645     MOV A , R4 
074F    14            4646     	DEC	A
0750    6013          4647     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      4648     GOVERNOR_ACTIVATE_100K: 
0752    C3            4649     	CLR	C
0753    EB            4650     MOV A , R3 
0754    13            4651     	RRC	A
0755    FB            4652     MOV R3 , A 
0756    EA            4653     MOV A , R2 
0757    13            4654     	RRC	A
0758    FA            4655     MOV R2 , A 
0759    EC            4656     MOV A , R4 
075A    14            4657     	DEC	A
075B    14            4658     	DEC	A
075C    6007          4659     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      4660     GOVERNOR_ACTIVATE_50K: 
075E    C3            4661     	CLR	C
075F    EB            4662     MOV A , R3 
0760    13            4663     	RRC	A
0761    FB            4664     MOV R3 , A 
0762    EA            4665     MOV A , R2 
0763    13            4666     	RRC	A
0764    FA            4667     MOV R2 , A 
                      4668     GOVERNOR_ACTIVATE_RANGE_SET: 
0765    D181          4669     	CALL	DIV_U16_BY_U16
                      4670     	; Store governor target
0767    8842          4671     MOV GOV_TARGET_L , R0 
0769    8943          4672     MOV GOV_TARGET_H , R1 
                      4673     CALC_GOVERNOR_TARGET_EXIT: 
076B    22            4674     	RET						
                      4675     ENDIF
                      4676     
                      4677     
                      4678     ; Second governor routine - calculate governor proportional error
                      4679     CALC_GOVERNOR_PROP_ERROR: 
                      4680     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      4698     IF MODE == 2	; Multi
                      4699     	; Calculate error
076C    C3            4700     	CLR	C
076D    E542          4701     	MOV	A, GOV_TARGET_L
076F    9523          4702     	SUBB	A, GOVERNOR_REQ_PWM
0771    F8            4703     MOV R0 , A 
0772    E543          4704     	MOV	A, GOV_TARGET_H
0774    9400          4705     	SUBB	A, #0
0776    F9            4706     MOV R1 , A 
                      4707     ENDIF
                      4708     	; Check error and limit
0777    500C          4709     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      4710     
0779    C3            4711     	CLR	C
077A    E8            4712     MOV A , R0 
077B    9480          4713     	SUBB	A, #80H					; Is error too negative?
077D    E9            4714     MOV A , R1 
077E    94FF          4715     	SUBB	A, #0FFH
0780    4016          4716     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
0782    02079C        4717     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4718     
                      4719     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0785    C3            4720     	CLR	C
0786    E8            4721     MOV A , R0 
0787    947F          4722     	SUBB	A, #7FH					; Is error too positive?
0789    E9            4723     MOV A , R1 
078A    9400          4724     	SUBB	A, #00H
078C    5003          4725     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
078E    02079C        4726     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4727     
                      4728     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0791    787F          4729     MOV R0 , # 7FH 
0793    7900          4730     MOV R1 , # 00H 
0795    02079C        4731     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4732     
                      4733     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
0798    7880          4734     MOV R0 , # 80H 
079A    79FF          4735     MOV R1 , # 0FFH 
                      4736     
                      4737     GOVERNOR_STORE_PROP_ERROR: 
                      4738     	; Store proportional
079C    8847          4739     MOV GOV_PROPORTIONAL_L , R0 
079E    8948          4740     MOV GOV_PROPORTIONAL_H , R1 
                      4741     CALC_GOVERNOR_PROP_ERROR_EXIT: 
07A0    22            4742     	RET						
                      4743     
                      4744     
                      4745     ; Third governor routine - calculate governor integral error
                      4746     CALC_GOVERNOR_INT_ERROR: 
                      4747     	; Add proportional to integral
07A1    E547          4748     	MOV	A, GOV_PROPORTIONAL_L
07A3    2544          4749     	ADD	A, GOV_INTEGRAL_L
07A5    F8            4750     MOV R0 , A 
07A6    E548          4751     	MOV	A, GOV_PROPORTIONAL_H
07A8    3545          4752     	ADDC	A, GOV_INTEGRAL_H
07AA    F9            4753     MOV R1 , A 
07AB    854820        4754     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
07AE    E4            4755     	CLR	A
07AF    300701        4756     	JNB	BIT_ACCESS.7, ($+4)			
07B2    F4            4757     	CPL	A
07B3    3546          4758     	ADDC	A, GOV_INTEGRAL_X
07B5    FA            4759     MOV R2 , A 
                      4760     	; Check integral and limit
07B6    30E709        4761     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      4762     
07B9    C3            4763     	CLR	C
07BA    EA            4764     MOV A , R2 
07BB    94F0          4765     	SUBB	A, #0F0H					; Is error too negative?
07BD    4015          4766     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
07BF    0207DA        4767     	JMP	GOVERNOR_CHECK_PWM
                      4768     
                      4769     GOVERNOR_CHECK_INT_LIMIT_POS: 
07C2    C3            4770     	CLR	C
07C3    EA            4771     MOV A , R2 
07C4    940F          4772     	SUBB	A, #0FH					; Is error too positive?
07C6    5003          4773     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
07C8    0207DA        4774     	JMP	GOVERNOR_CHECK_PWM
                      4775     
                      4776     GOVERNOR_LIMIT_INT_ERROR_POS: 
07CB    78FF          4777     MOV R0 , # 0FFH 
07CD    79FF          4778     MOV R1 , # 0FFH 
07CF    7A0F          4779     MOV R2 , # 0FH 
07D1    0207DA        4780     	JMP	GOVERNOR_CHECK_PWM
                      4781     
                      4782     GOVERNOR_LIMIT_INT_ERROR_NEG: 
07D4    7800          4783     MOV R0 , # 00H 
07D6    7900          4784     MOV R1 , # 00H 
07D8    7AF0          4785     MOV R2 , # 0F0H 
                      4786     
                      4787     GOVERNOR_CHECK_PWM: 
                      4788     	; Check current pwm
07DA    C3            4789     	CLR	C
07DB    E524          4790     	MOV	A, CURRENT_PWM
07DD    9561          4791     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
07DF    500A          4792     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      4793     
07E1    C3            4794     	CLR	C
07E2    7401          4795     	MOV	A, #1
07E4    9524          4796     	SUBB	A, CURRENT_PWM				; Is current pwm at minimum?
07E6    500B          4797     	JNC	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      4798     
07E8    0207F8        4799     	JMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      4800     
                      4801     GOVERNOR_INT_MAX_PWM: 
07EB    E548          4802     	MOV	A, GOV_PROPORTIONAL_H
07ED    20E70E        4803     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      4804     
07F0    0207F8        4805     	JMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      4806     
                      4807     GOVERNOR_INT_MIN_PWM: 
07F3    E548          4808     	MOV	A, GOV_PROPORTIONAL_H
07F5    30E706        4809     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      4810     
                      4811     GOVERNOR_STORE_INT_ERROR: 
                      4812     	; Store integral
07F8    8844          4813     MOV GOV_INTEGRAL_L , R0 
07FA    8945          4814     MOV GOV_INTEGRAL_H , R1 
07FC    8A46          4815     MOV GOV_INTEGRAL_X , R2 
                      4816     CALC_GOVERNOR_INT_ERROR_EXIT: 
07FE    22            4817     	RET						
                      4818     
                      4819     
                      4820     ; Fourth governor routine - calculate governor proportional correction
                      4821     CALC_GOVERNOR_PROP_CORRECTION: 
                      4822     	; Load proportional gain
07FF    78A4          4823     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0801    E6            4824     MOV A , @ R0 
0802    FA            4825     MOV R2 , A 
                      4826     	; Load proportional
0803    C3            4827     	CLR	C
0804    E547          4828     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0806    33            4829     	RLC	A
0807    F8            4830     MOV R0 , A 
0808    E548          4831     	MOV	A, GOV_PROPORTIONAL_H
080A    33            4832     	RLC	A
080B    F9            4833     MOV R1 , A 
                      4834     	; Apply gain
080C    1206B9        4835     	CALL	MULT_S16_BY_U8_DIV_16
                      4836     	; Check error and limit (to low byte)
080F    E9            4837     MOV A , R1 
0810    30E70B        4838     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      4839     
0813    C3            4840     	CLR	C
0814    E8            4841     MOV A , R0 
0815    9480          4842     	SUBB	A, #80H					; Is error too negative?
0817    E9            4843     MOV A , R1 
0818    94FF          4844     	SUBB	A, #0FFH
081A    4013          4845     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
081C    0133          4846     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4847     
                      4848     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
081E    C3            4849     	CLR	C
081F    E8            4850     MOV A , R0 
0820    947F          4851     	SUBB	A, #7FH					; Is error too positive?
0822    E9            4852     MOV A , R1 
0823    9400          4853     	SUBB	A, #00H
0825    5002          4854     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0827    0133          4855     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4856     
                      4857     GOVERNOR_LIMIT_PROP_CORR_POS: 
0829    787F          4858     MOV R0 , # 7FH 
082B    7900          4859     MOV R1 , # 00H 
082D    0133          4860     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4861     
                      4862     GOVERNOR_LIMIT_PROP_CORR_NEG: 
082F    7880          4863     MOV R0 , # 80H 
0831    79FF          4864     MOV R1 , # 0FFH 
                      4865     
                      4866     GOVERNOR_APPLY_PROP_CORR: 
                      4867     	; Test proportional sign
0833    E8            4868     MOV A , R0 
0834    20E715        4869     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      4870     
                      4871     	; Subtract positive proportional
0837    C3            4872     	CLR	C
0838    E523          4873     	MOV	A, GOVERNOR_REQ_PWM
083A    98            4874     SUBB A , R0 
083B    F8            4875     MOV R0 , A 
                      4876     	; Check result
083C    4009          4877     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      4878     
083E    C3            4879     	CLR	C
083F    E8            4880     MOV A , R0 
0840    9401          4881     	SUBB	A, #1
0842    4003          4882     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0844    02085A        4883     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4884     
                      4885     GOVERNOR_CORR_PROP_MIN_PWM: 
0847    7801          4886     MOV R0 , # 1 
0849    02085A        4887     	JMP	GOVERNOR_STORE_PROP_CORR
                      4888     
                      4889     GOVERNOR_CORR_NEG_PROP: 
                      4890     	; Add negative proportional
084C    E8            4891     MOV A , R0 
084D    F4            4892     	CPL	A
084E    2401          4893     	ADD	A, #1
0850    2523          4894     	ADD	A, GOVERNOR_REQ_PWM
0852    F8            4895     MOV R0 , A 
                      4896     	; Check result
0853    4003          4897     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0855    02085A        4898     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4899     
                      4900     GOVERNOR_CORR_PROP_MAX_PWM: 
0858    78FF          4901     MOV R0 , # 255 
                      4902     GOVERNOR_STORE_PROP_CORR: 
                      4903     	; Store proportional pwm
085A    8849          4904     MOV GOV_PROP_PWM , R0 
                      4905     CALC_GOVERNOR_PROP_CORR_EXIT: 
085C    22            4906     	RET
                      4907     
                      4908     
                      4909     ; Fifth governor routine - calculate governor integral correction
                      4910     CALC_GOVERNOR_INT_CORRECTION: 
                      4911     	; Load integral gain
085D    78A5          4912     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
085F    E6            4913     MOV A , @ R0 
0860    FA            4914     MOV R2 , A 
                      4915     	; Load integral
0861    A845          4916     MOV R0 , GOV_INTEGRAL_H 
0863    A946          4917     MOV R1 , GOV_INTEGRAL_X 
                      4918     	; Apply gain
0865    1206B9        4919     	CALL	MULT_S16_BY_U8_DIV_16
                      4920     	; Check integral and limit
0868    E9            4921     MOV A , R1 
0869    30E70C        4922     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      4923     
086C    C3            4924     	CLR	C
086D    E8            4925     MOV A , R0 
086E    9401          4926     	SUBB	A, #01H					; Is integral too negative?
0870    E9            4927     MOV A , R1 
0871    94FF          4928     	SUBB	A, #0FFH
0873    4016          4929     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0875    02088F        4930     	JMP	GOVERNOR_APPLY_INT_CORR
                      4931     
                      4932     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0878    C3            4933     	CLR	C
0879    E8            4934     MOV A , R0 
087A    94FF          4935     	SUBB	A, #0FFH					; Is integral too positive?
087C    E9            4936     MOV A , R1 
087D    9400          4937     	SUBB	A, #00H
087F    5003          4938     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0881    02088F        4939     	JMP	GOVERNOR_APPLY_INT_CORR
                      4940     
                      4941     GOVERNOR_LIMIT_INT_CORR_POS: 
0884    78FF          4942     MOV R0 , # 0FFH 
0886    7900          4943     MOV R1 , # 00H 
0888    02088F        4944     	JMP	GOVERNOR_APPLY_INT_CORR
                      4945     
                      4946     GOVERNOR_LIMIT_INT_CORR_NEG: 
088B    7801          4947     MOV R0 , # 01H 
088D    79FF          4948     MOV R1 , # 0FFH 
                      4949     
                      4950     GOVERNOR_APPLY_INT_CORR: 
                      4951     	; Test integral sign
088F    E9            4952     MOV A , R1 
0890    20E715        4953     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      4954     
                      4955     	; Subtract positive integral
0893    C3            4956     	CLR	C
0894    E549          4957     	MOV	A, GOV_PROP_PWM
0896    98            4958     SUBB A , R0 
0897    F8            4959     MOV R0 , A 
                      4960     	; Check result
0898    4009          4961     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      4962     
089A    C3            4963     	CLR	C
089B    E8            4964     MOV A , R0 
089C    9401          4965     	SUBB	A, #1
089E    4003          4966     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
08A0    0208B6        4967     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4968     
                      4969     GOVERNOR_CORR_INT_MIN_PWM: 
08A3    7801          4970     MOV R0 , # 1 
08A5    0208B6        4971     	JMP	GOVERNOR_STORE_INT_CORR
                      4972     
                      4973     GOVERNOR_CORR_NEG_INT: 
                      4974     	; Add negative integral
08A8    E8            4975     MOV A , R0 
08A9    F4            4976     	CPL	A
08AA    2401          4977     	ADD	A, #1
08AC    2549          4978     	ADD	A, GOV_PROP_PWM
08AE    F8            4979     MOV R0 , A 
                      4980     	; Check result
08AF    4003          4981     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
08B1    0208B6        4982     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4983     
                      4984     GOVERNOR_CORR_INT_MAX_PWM: 
08B4    78FF          4985     MOV R0 , # 255 
                      4986     GOVERNOR_STORE_INT_CORR: 
                      4987     	; Store current pwm
08B6    8824          4988     MOV CURRENT_PWM , R0 
                      4989     CALC_GOVERNOR_INT_CORR_EXIT: 
08B8    22            4990     	RET
                      4991     
                      4992     
                      4993     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4994     ;
                      4995     ; Set pwm limit low rpm
                      4996     ;
                      4997     ; No assumptions
                      4998     ;
                      4999     ; Sets power limit for low rpms and disables demag for low rpms
                      5000     ;
                      5001     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5002     SET_PWM_LIMIT_LOW_RPM: 
                      5003     	; Set pwm limit and demag disable for low rpms
08B9    78FF          5004     MOV R0 , # 0FFH 
08BB    C264          5005     CLR FLAGS0 . 4 
08BD    20693D        5006     JB FLAGS1 . 1 , SET_PWM_LIMIT_LOW_RPM_EXIT 
08C0    206A12        5007     JB FLAGS1 . 2 , SET_PWM_DEMAG_DONE 
                      5008     
08C3    D264          5009     SETB FLAGS0 . 4 
08C5    C3            5010     	CLR	C
08C6    E53E          5011     	MOV	A, COMM_PERIOD4X_H
08C8    940A          5012     	SUBB	A, #0AH						; ~31250 eRPM
08CA    4009          5013     	JC	SET_PWM_DEMAG_DONE				; If speed above - branch
                      5014     
08CC    C3            5015     	CLR	C
08CD    E525          5016     	MOV	A, CURRENT_PWM_LIMITED	
08CF    9440          5017     	SUBB	A, #40H						; Do not disable if pwm above 25%
08D1    5002          5018     	JNC	SET_PWM_DEMAG_DONE
                      5019     
08D3    C264          5020     CLR FLAGS0 . 4 
                      5021     
                      5022     SET_PWM_DEMAG_DONE: 
08D5    79A1          5023     MOV R1 , # PGM_ENABLE_POWER_PROT 
08D7    E7            5024     MOV A , @ R1 
08D8    6023          5025     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Exit if disabled
                      5026     
08DA    E53E          5027     	MOV	A, COMM_PERIOD4X_H
08DC    601F          5028     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Avoid divide by zero
                      5029     
08DE    74FF          5030     	MOV	A, #255						; Divide 255 by Comm_Period4x_H
08E0    853EF0        5031     	MOV	B, COMM_PERIOD4X_H
08E3    84            5032     	DIV	AB
08E4    8538F0        5033     	MOV	B, LOW_RPM_PWR_SLOPE			; Multiply by slope
08E7    306A03        5034     JNB FLAGS1 . 2 , ( $+6 ) 
08EA    75F005        5035     	MOV	B, #5
08ED    A4            5036     	MUL	AB
08EE    F8            5037     MOV R0 , A 
08EF    C5F0          5038     	XCH	A, B
08F1    6002          5039     	JZ	($+4)						; Limit to max
                      5040     	
08F3    78FF          5041     MOV R0 , # 0FFH 
                      5042     
08F5    C3            5043     	CLR	C
08F6    E8            5044     MOV A , R0 
08F7    9564          5045     	SUBB	A, PWM_SPOOLUP_BEG
08F9    5002          5046     	JNC	SET_PWM_LIMIT_LOW_RPM_EXIT
                      5047     
08FB    A864          5048     MOV R0 , PWM_SPOOLUP_BEG 
                      5049     
                      5050     SET_PWM_LIMIT_LOW_RPM_EXIT: 
08FD    8863          5051     MOV PWM_LIMIT_BY_RPM , R0 
08FF    22            5052     	RET
                      5053     	
                      5054     
                      5055     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5056     ;
                      5057     ; Set pwm limit high rpm
                      5058     ;
                      5059     ; No assumptions
                      5060     ;
                      5061     ; Sets power limit for high rpms
                      5062     ;
                      5063     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5064     SET_PWM_LIMIT_HIGH_RPM: 
                      5065     IF MCU_48MHZ == 1
0900    C3            5066     	CLR	C
0901    E53D          5067     	MOV	A, COMM_PERIOD4X_L
0903    94C8          5068     	SUBB	A, #0C8H				; Limit Comm_Period to 200, which is 400k erpm
0905    E53E          5069     	MOV	A, COMM_PERIOD4X_H
0907    9400          5070     	SUBB	A, #00H
                      5071     ELSE
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_L
                               	SUBB	A, #40H				; Limit Comm_Period to 320, which is 250k erpm
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, #01H
                               ENDIF
0909    E563          5078     	MOV	A, PWM_LIMIT_BY_RPM
090B    5003          5079     	JNC	SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT
                      5080     	
090D    14            5081     	DEC	A
090E    2111          5082     	AJMP	SET_PWM_LIMIT_HIGH_RPM_STORE
                      5083     	
                      5084     SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT: 
0910    04            5085     	INC	A
                      5086     SET_PWM_LIMIT_HIGH_RPM_STORE: 
0911    6002          5087     	JZ	($+4)
                      5088     
0913    F563          5089     	MOV	PWM_LIMIT_BY_RPM, A
                      5090     
0915    22            5091     	RET
                      5092     
                      5093     
                      5094     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5095     ;
                      5096     ; Measure lipo cells
                      5097     ;
                      5098     ; No assumptions
                      5099     ;
                      5100     ; Measure voltage and calculate lipo cells
                      5101     ;
                      5102     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5103     MEASURE_LIPO_CELLS: 
                      5104     IF MODE >= 1	; Tail or multi
                      5105     	; If not supported, then exit
0916    020919        5106     	JMP	MEASURE_LIPO_EXIT
                      5107     ENDIF
                      5108     IF MODE == 0	; Main
                               	; Load programmed low voltage limit
                               	MOV	TEMP1, #PGM_LOW_VOLTAGE_LIM	; Load limit
                               	MOV	A, @TEMP1				
                               	MOV	BIT_ACCESS, A				; Store in Bit_Access
                               	; Set commutation to BpFET on
                               	CALL	COMM5COMM6			
                               	; Start adc
                               	START_ADC 
                               	; Wait for ADC reference to settle, and then start again
                               	CALL	WAIT1MS
                               	START_ADC
                               	; Wait for ADC conversion to complete
                               MEASURE_LIPO_WAIT_ADC:
                               	GET_ADC_STATUS 
                               	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                               	; Read ADC result
                               	READ_ADC_RESULT
                               	; Stop ADC
                               	STOP_ADC
                               	; Switch power off
                               	CALL	SWITCH_POWER_OFF		
                               	; Set limit step
                               	MOV	LIPO_ADC_LIMIT_L, #ADC_LIMIT_L
                               	MOV	LIPO_ADC_LIMIT_H, #ADC_LIMIT_H
                               	CLR	C
                               	MOV	A, #ADC_LIMIT_H		; Divide 3.0V value by 2
                               	RRC	A
                               	MOV	TEMP6, A
                               	MOV	A, #ADC_LIMIT_L
                               	JZ	MEASURE_LIPO_EXIT		; Exit if disabled
                               
                               	RRC	A
                               	MOV	TEMP5, A
                               	MOV	A, #ADC_LIMIT_L		; Calculate 1.5*3.0V=4.5V value
                               	ADD	A, TEMP5
                               	MOV	TEMP5, A
                               	MOV	A, #ADC_LIMIT_H		
                               	ADDC	A, TEMP6
                               	MOV	TEMP6, A
                               	MOV	A, TEMP5				; Copy step
                               	MOV	TEMP3, A
                               	MOV	A, TEMP6	
                               	MOV	TEMP4, A
                               MEASURE_LIPO_CELL_LOOP:
                               	; Check voltage against xS lower limit
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, TEMP3				; Voltage above limit?
                               	MOV	A, TEMP2
                               	SUBB A, TEMP4
                               	JC	MEASURE_LIPO_ADJUST		; No - branch
                               
                               	; Set xS voltage limit
                               	MOV	A, LIPO_ADC_LIMIT_L		
                               	ADD	A, #ADC_LIMIT_L
                               	MOV	LIPO_ADC_LIMIT_L, A
                               	MOV	A, LIPO_ADC_LIMIT_H		
                               	ADDC	A, #ADC_LIMIT_H
                               	MOV	LIPO_ADC_LIMIT_H, A
                               	; Set (x+1)S lower limit
                               	MOV	A, TEMP3
                               	ADD	A, TEMP5				; Add step
                               	MOV	TEMP3, A
                               	MOV	A, TEMP4
                               	ADDC	A, TEMP6
                               	MOV	TEMP4, A
                               	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                               
                               MEASURE_LIPO_ADJUST:
                               	MOV	TEMP7, LIPO_ADC_LIMIT_L
                               	MOV	TEMP8, LIPO_ADC_LIMIT_H
                               	; Calculate 3.125%
                               	CLR	C
                               	MOV	A, LIPO_ADC_LIMIT_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, LIPO_ADC_LIMIT_L	
                               	RRC	A
                               	MOV	TEMP1, A			; After this 50%
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1	
                               	RRC	A
                               	MOV	TEMP1, A			; After this 25%
                               	; Divide three times to get to 3.125%
                               	MOV	TEMP3, #3
                               MEASURE_LIPO_DIVIDE_LOOP:
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1	
                               	RRC	A
                               	MOV	TEMP1, A			
                               	DJNZ	TEMP3, MEASURE_LIPO_DIVIDE_LOOP
                               
                               	; Add the programmed number of 0.1V (or 3.125% increments)
                               	MOV	TEMP3, BIT_ACCESS		; Load programmed limit (Bit_Access has Pgm_Low_Voltage_Lim)
                               	DEC	TEMP3
                               	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                               
                               	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
                               	MOV	LIPO_ADC_LIMIT_H, #0
                               	JMP	MEASURE_LIPO_EXIT	
                               
                               MEASURE_LIPO_LIMIT_ON:
                               	DEC	TEMP3
                               	MOV	A, TEMP3
                               	JZ	MEASURE_LIPO_UPDATE
                               
                               MEASURE_LIPO_ADD_LOOP:
                               	MOV	A, TEMP7			; Add 3.125%
                               	ADD	A, TEMP1
                               	MOV	TEMP7, A
                               	MOV	A, TEMP8
                               	ADDC	A, TEMP2
                               	MOV	TEMP8, A
                               	DJNZ	TEMP3, MEASURE_LIPO_ADD_LOOP
                               
                               MEASURE_LIPO_UPDATE:
                               	; Set ADC limit
                               	MOV	LIPO_ADC_LIMIT_L, TEMP7
                               	MOV	LIPO_ADC_LIMIT_H, TEMP8
                               ENDIF
                      5235     MEASURE_LIPO_EXIT: 
0919    22            5236     	RET
                      5237     
                      5238     
                      5239     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5240     ;
                      5241     ; Start ADC conversion
                      5242     ;
                      5243     ; No assumptions
                      5244     ;
                      5245     ; Start conversion used for measuring power supply voltage
                      5246     ;
                      5247     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5248     START_ADC_CONVERSION: 
                      5249     	; Start adc
                      5250     	START_ADC 
091A    75E890        5250+1   MOV ADC0CN , # 90H  ; ADC START
091D    22            5251     	RET
                      5252     
                      5253     
                      5254     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5255     ;
                      5256     ; Check temperature, power supply voltage and limit power
                      5257     ;
                      5258     ; No assumptions
                      5259     ;
                      5260     ; Used to limit main motor power in order to maintain the required voltage
                      5261     ;
                      5262     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5263     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      5264     	; Load programmed low voltage limit
091E    7883          5265     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0920    E6            5266     MOV A , @ R0 
0921    FF            5267     MOV R7 , A 
                      5268     	; Wait for ADC conversion to complete
                      5269     	GET_ADC_STATUS 
0922    E5E8          5269+1   MOV A , ADC0CN 
0924    20ECF7        5270     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      5271     	; Read ADC result
                      5272     	READ_ADC_RESULT
0927    A8BD          5272+1   MOV R0 , ADC0L 
0929    A9BE          5272+1   MOV R1 , ADC0H 
                      5273     	; Stop ADC
                      5274     	STOP_ADC
                      5275     
092B    0570          5276     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
092D    C3            5277     	CLR	C
092E    E570          5278     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0930    9408          5279     SUBB A , # 8 
0932    4052          5280     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      5281     
0934    757000        5282     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0937    E9            5283     MOV A , R1 
0938    FA            5284     MOV R2 , A 
0939    79A0          5285     MOV R1 , # PGM_ENABLE_TEMP_PROT 
093B    E7            5286     MOV A , @ R1 
093C    6044          5287     	JZ	TEMP_CHECK_EXIT			; No - branch
                      5288     
093E    EA            5289     MOV A , R2 
093F    7007          5290     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      5291     
0941    E571          5292     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0943    601B          5293     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0945    020954        5294     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      5295     
                      5296     TEMP_AVERAGE_INC_DEC: 
0948    C3            5297     	CLR	C
0949    E8            5298     MOV A , R0 
094A    9571          5299     	SUBB	A, CURRENT_AVERAGE_TEMP
094C    6010          5300     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      5301     
094E    E571          5302     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0950    5006          5303     	JNC	TEMP_AVERAGE_INC				
                      5304     
0952    600C          5305     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      5306     TEMP_AVERAGE_DEC: 
0954    14            5307     	DEC	A						; Decrement average
0955    020960        5308     	JMP	TEMP_AVERAGE_UPDATED
                      5309     
                      5310     TEMP_AVERAGE_INC: 
0958    04            5311     	INC	A						; Increment average
0959    60F9          5312     	JZ	TEMP_AVERAGE_DEC
095B    020960        5313     	JMP	TEMP_AVERAGE_UPDATED
                      5314     
                      5315     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
095E    E571          5316     	MOV	A, CURRENT_AVERAGE_TEMP
                      5317     TEMP_AVERAGE_UPDATED: 
0960    F571          5318     	MOV	CURRENT_AVERAGE_TEMP, A
0962    C3            5319     	CLR	C
0963    9472          5320     SUBB A , # 114 
0965    401B          5321     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5322     
0967    7561C0        5323     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      5324     
096A    C3            5325     	CLR	C
096B    9404          5326     SUBB A , # 4 
096D    4013          5327     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5328     
096F    756180        5329     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      5330     
0972    C3            5331     	CLR	C
0973    9404          5332     SUBB A , # 4 
0975    400B          5333     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5334     
0977    756140        5335     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      5336     
097A    C3            5337     	CLR	C
097B    9404          5338     SUBB A , # 4 
097D    4003          5339     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5340     
097F    756100        5341     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      5342     
                      5343     TEMP_CHECK_EXIT: 
                      5344     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0982    75BB09        5344+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0985    22            5345     	RET
                      5346     
                      5347     CHECK_VOLTAGE_START: 
                      5348     IF MODE == 0	; Main 
                               	; Check if low voltage limiting is enabled
                               	MOV	A, TEMP8
                               	CLR	C
                               	SUBB	A, #1					; Is low voltage limit disabled?
                               	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                               
                               	MOV	A, #ADC_LIMIT_L			; Is low voltage limit zero (ESC does not support it)?
                               	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                               
                               	; Check if ADC is saturated
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #0FFH
                               	MOV	A, TEMP2
                               	SUBB	A, #03H
                               	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                               
                               	; Check voltage against limit
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, LIPO_ADC_LIMIT_L
                               	MOV	A, TEMP2
                               	SUBB	A, LIPO_ADC_LIMIT_H
                               	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                               
                               	; Decrease pwm limit
                               	MOV  A, PWM_LIMIT
                               	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                               
                               	DEC	PWM_LIMIT					; Decrement limit
                               	JMP	CHECK_VOLTAGE_LIM
                               
                               CHECK_VOLTAGE_GOOD:
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               	MOV	TEMP1, PWM_LIMIT			; Set limit
                               	CLR	C
                               	MOV	A, CURRENT_PWM
                               	SUBB	A, TEMP1
                               	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                               
                               	MOV	TEMP1, CURRENT_PWM			; Set current pwm (no limiting)
                               
                               CHECK_VOLTAGE_SPOOLUP_LIM:
                               	; Slow spoolup
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_LIMIT_SPOOLUP
                               	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                               
                               	MOV	TEMP1, PWM_LIMIT_SPOOLUP
                               	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
                               	CPL	A
                               	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                                
                               	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                               
                               CHECK_VOLTAGE_EXIT:
                               	MOV  CURRENT_PWM_LIMITED, TEMP1
                               	MOV	CURRENT_PWM_LIM_DITH, TEMP1
                               ENDIF
                      5416     IF MODE == 1	; Tail
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               ENDIF
                      5426     IF MODE == 2	; Multi
                      5427     	; Increase pwm limit
0986    E561          5428     	MOV  A, PWM_LIMIT
0988    2410          5429     	ADD	A, #16			
098A    5002          5430     	JNC	($+4)					; If not max - branch
                      5431     
098C    74FF          5432     	MOV	A, #255
                      5433     
098E    F561          5434     	MOV	PWM_LIMIT, A				; Increment limit 
                      5435     	; Set current pwm limited if closed loop mode
0990    7982          5436     MOV R1 , # PGM_GOV_MODE 
0992    B70402        5437     CJNE @ R1 , # 4 , ( $+5 ) 
0995    21AD          5438     	AJMP	CHECK_VOLTAGE_PWM_DONE		; No - branch
                      5439     
0997    C3            5440     	CLR	C
0998    A861          5441     MOV R0 , PWM_LIMIT 
099A    E524          5442     	MOV	A, CURRENT_PWM
099C    98            5443     SUBB A , R0 
099D    5002          5444     	JNC	CHECK_VOLTAGE_LOW_RPM		; If current pwm above limit - branch and limit	
                      5445     
099F    A824          5446     MOV R0 , CURRENT_PWM 
                      5447     
                      5448     CHECK_VOLTAGE_LOW_RPM: 
                      5449     	; Limit pwm for low rpms
09A1    C3            5450     	CLR	C
09A2    E8            5451     MOV A , R0 
09A3    9563          5452     	SUBB	A, PWM_LIMIT_BY_RPM
09A5    4002          5453     	JC	($+4)					; If current pwm below limit - branch
                      5454     
09A7    A863          5455     MOV R0 , PWM_LIMIT_BY_RPM 
                      5456     
09A9    8825          5457     MOV CURRENT_PWM_LIMITED , R0 
09AB    8826          5458     MOV CURRENT_PWM_LIM_DITH , R0 
                      5459     CHECK_VOLTAGE_PWM_DONE: 
                      5460     ENDIF
                      5461     	; Set adc mux for next conversion
09AD    E570          5462     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
09AF    B40703        5463     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      5464     
                      5465     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
09B2    75BB10        5465+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5466     
                      5467     CHECK_VOLTAGE_RET: 
09B5    22            5468     	RET
                      5469     
                      5470     
                      5471     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5472     ;
                      5473     ; Set startup PWM routine
                      5474     ;
                      5475     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      5476     ;
                      5477     ; Used for pwm control during startup
                      5478     ;
                      5479     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5480     SET_STARTUP_PWM: 	
                      5481     	; Adjust startup power
09B6    7432          5482     MOV A , # 50 
09B8    79A6          5483     MOV R1 , # PGM_STARTUP_PWR_DECODED 
09BA    87F0          5484     MOV B , @ R1 
09BC    A4            5485     	MUL	AB
09BD    C5F0          5486     	XCH	A, B
09BF    A2F7          5487     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
09C1    33            5488     	RLC	A
09C2    F8            5489     MOV R0 , A 
09C3    C3            5490     	CLR	C
09C4    E8            5491     MOV A , R0 
09C5    9561          5492     	SUBB	A, PWM_LIMIT	
09C7    4002          5493     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      5494     
09C9    A861          5495     MOV R0 , PWM_LIMIT 
                      5496     
                      5497     STARTUP_PWM_SET_PWM: 
                      5498     	; Set pwm variables
09CB    8822          5499     MOV REQUESTED_PWM , R0 
09CD    8824          5500     MOV CURRENT_PWM , R0 
09CF    8825          5501     MOV CURRENT_PWM_LIMITED , R0 
09D1    8826          5502     MOV CURRENT_PWM_LIM_DITH , R0 
09D3    8864          5503     MOV PWM_SPOOLUP_BEG , R0 
09D5    22            5504     	RET
                      5505     
                      5506     
                      5507     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5508     ;
                      5509     ; Initialize timing routine
                      5510     ;
                      5511     ; No assumptions
                      5512     ;
                      5513     ; Part of initialization before motor start
                      5514     ;
                      5515     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5516     INITIALIZE_TIMING:  
09D6    753D00        5517     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
09D9    753EF0        5518     	MOV	COMM_PERIOD4X_H, #0F0H
09DC    22            5519     	RET
                      5520     
                      5521     
                      5522     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5523     ;
                      5524     ; Calculate next commutation timing routine
                      5525     ;
                      5526     ; No assumptions
                      5527     ;
                      5528     ; Called immediately after each commutation
                      5529     ; Also sets up timer 3 to wait advance timing
                      5530     ; Two entry points are used
                      5531     ;
                      5532     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5533     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
                      5534     	; Read commutation time
09DD    75C820        5535     	MOV	TMR2CN, #20H		; Timer2 disabled
09E0    A8CC          5536     MOV R0 , TMR2L 
09E2    A9CD          5537     MOV R1 , TMR2H 
09E4    75C824        5538     	MOV	TMR2CN, #24H		; Timer2 enabled
                      5539     IF MCU_48MHZ == 1
09E7    C3            5540     	CLR	C
09E8    E9            5541     MOV A , R1 
09E9    13            5542     	RRC	A
09EA    F9            5543     MOV R1 , A 
09EB    E8            5544     MOV A , R0 
09EC    13            5545     	RRC	A
09ED    F8            5546     MOV R0 , A 
                      5547     ENDIF
                      5548     	; Calculate this commutation time
09EE    AA39          5549     MOV R2 , PREV_COMM_L 
09F0    AB3A          5550     MOV R3 , PREV_COMM_H 
09F2    8839          5551     MOV PREV_COMM_L , R0 
09F4    893A          5552     MOV PREV_COMM_H , R1 
09F6    C3            5553     	CLR	C
09F7    E8            5554     MOV A , R0 
09F8    9A            5555     SUBB A , R2 
09F9    F8            5556     MOV R0 , A 
09FA    E9            5557     MOV A , R1 
09FB    9B            5558     SUBB A , R3 
                      5559     IF MCU_48MHZ == 1
09FC    547F          5560     	ANL	A, #7FH
                      5561     ENDIF
09FE    F9            5562     MOV R1 , A 
09FF    306702        5563     JNB FLAGS0 . 7 , ( $+5 ) 
0A02    41DC          5564     	AJMP	CALC_NEXT_COMM_TIMING_FAST
                      5565     
0A04    306933        5566     JNB FLAGS1 . 1 , CALC_NEXT_COMM_STARTUP_DONE 
                      5567     
0A07    AC3B          5568     MOV R4 , PREV_PREV_COMM_L 
0A09    AD3C          5569     MOV R5 , PREV_PREV_COMM_H 
0A0B    8A3B          5570     MOV PREV_PREV_COMM_L , R2 
0A0D    8B3C          5571     MOV PREV_PREV_COMM_H , R3 
0A0F    C3            5572     	CLR	C
0A10    EB            5573     MOV A , R3 
0A11    9D            5574     SUBB A , R5 
                      5575     IF MCU_48MHZ == 1
0A12    547F          5576     	ANL	A, #7FH
                      5577     ENDIF
0A14    FB            5578     MOV R3 , A 
0A15    C3            5579     	CLR	C
0A16    E9            5580     MOV A , R1 
0A17    9B            5581     SUBB A , R3 
0A18    F53F          5582     	MOV	COMM_DIFF, A
0A1A    A839          5583     MOV R0 , PREV_COMM_L 
0A1C    A93A          5584     MOV R1 , PREV_COMM_H 
0A1E    C3            5585     	CLR	C
0A1F    E8            5586     MOV A , R0 
0A20    9C            5587     SUBB A , R4 
0A21    F8            5588     MOV R0 , A 
0A22    E9            5589     MOV A , R1 
0A23    9D            5590     SUBB A , R5 
                      5591     IF MCU_48MHZ == 1
0A24    547F          5592     	ANL	A, #7FH
                      5593     ENDIF
0A26    F9            5594     MOV R1 , A 
                      5595     
0A27    C3            5596     	CLR	C
0A28    E53E          5597     	MOV	A, COMM_PERIOD4X_H		; Average with previous and save
0A2A    13            5598     	RRC	A
0A2B    FB            5599     MOV R3 , A 
0A2C    E53D          5600     	MOV	A, COMM_PERIOD4X_L
0A2E    13            5601     	RRC	A
0A2F    FA            5602     MOV R2 , A 
0A30    E8            5603     MOV A , R0 
0A31    2A            5604     ADD A , R2 
0A32    F53D          5605     	MOV	COMM_PERIOD4X_L, A
0A34    E9            5606     MOV A , R1 
0A35    3B            5607     ADDC A , R3 
0A36    F53E          5608     	MOV	COMM_PERIOD4X_H, A
0A38    4184          5609     	AJMP	CALC_NEW_WAIT_TIMES_SETUP
                      5610     
                      5611     CALC_NEXT_COMM_STARTUP_DONE: 
                      5612     	; Calculate new commutation time 
0A3A    AA3D          5613     MOV R2 , COMM_PERIOD4X_L 
0A3C    AB3E          5614     MOV R3 , COMM_PERIOD4X_H 
0A3E    AC3D          5615     MOV R4 , COMM_PERIOD4X_L 
0A40    AD3E          5616     MOV R5 , COMM_PERIOD4X_H 
0A42    7E04          5617     MOV R6 , # 4 
0A44    7F02          5618     MOV R7 , # 2 
0A46    C3            5619     	CLR	C
0A47    EB            5620     MOV A , R3 
0A48    9404          5621     	SUBB	A, #04H
0A4A    4002          5622     	JC	($+4)
                      5623     
0A4C    1E            5624     DEC R6 
0A4D    1F            5625     DEC R7 
                      5626     
0A4E    C3            5627     	CLR	C
0A4F    EB            5628     MOV A , R3 
0A50    9408          5629     	SUBB	A, #08H
0A52    4002          5630     	JC	($+4)
                      5631     
0A54    1E            5632     DEC R6 
0A55    1F            5633     DEC R7 
                      5634     
                      5635     CALC_NEXT_COMM_AVG_PERIOD_DIV: 
0A56    C3            5636     	CLR	C
0A57    ED            5637     MOV A , R5 
0A58    13            5638     	RRC	A					; Divide by 2
0A59    FD            5639     MOV R5 , A 
0A5A    EC            5640     MOV A , R4 
0A5B    13            5641     	RRC	A
0A5C    FC            5642     MOV R4 , A 
0A5D    DEF7          5643     DJNZ R6 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      5644     
0A5F    C3            5645     	CLR	C
0A60    EA            5646     MOV A , R2 
0A61    9C            5647     SUBB A , R4 
0A62    FA            5648     MOV R2 , A 
0A63    EB            5649     MOV A , R3 
0A64    9D            5650     SUBB A , R5 
0A65    FB            5651     MOV R3 , A 
0A66    EF            5652     MOV A , R7 
0A67    6009          5653     	JZ	CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE
                      5654     
                      5655     CALC_NEXT_COMM_NEW_PERIOD_DIV: 
0A69    C3            5656     	CLR	C
0A6A    E9            5657     MOV A , R1 
0A6B    13            5658     	RRC	A					; Divide by 2
0A6C    F9            5659     MOV R1 , A 
0A6D    E8            5660     MOV A , R0 
0A6E    13            5661     	RRC	A
0A6F    F8            5662     MOV R0 , A 
0A70    DFF7          5663     DJNZ R7 , CALC_NEXT_COMM_NEW_PERIOD_DIV 
                      5664     
                      5665     CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE: 
0A72    EA            5666     MOV A , R2 
0A73    28            5667     ADD A , R0 
0A74    FA            5668     MOV R2 , A 
0A75    EB            5669     MOV A , R3 
0A76    39            5670     ADDC A , R1 
0A77    FB            5671     MOV R3 , A 
0A78    8A3D          5672     MOV COMM_PERIOD4X_L , R2 
0A7A    8B3E          5673     MOV COMM_PERIOD4X_H , R3 
0A7C    5006          5674     	JNC	CALC_NEW_WAIT_TIMES_SETUP; If period larger than 0xffff - go to slow case
                      5675     
0A7E    7BFF          5676     MOV R3 , # 0FFH 
0A80    8B3D          5677     MOV COMM_PERIOD4X_L , R3 
0A82    8B3E          5678     MOV COMM_PERIOD4X_H , R3 
                      5679     
                      5680     CALC_NEW_WAIT_TIMES_SETUP: 	
                      5681     	; Set high rpm bit (if above 156k erpm)
0A84    C3            5682     	CLR	C
0A85    EB            5683     MOV A , R3 
0A86    9402          5684     	SUBB	A, #2
0A88    5002          5685     	JNC	($+4)
                      5686     
0A8A    D267          5687     SETB FLAGS0 . 7 
                      5688     	
                      5689     	; Load programmed commutation timing
0A8C    306904        5690     JNB FLAGS1 . 1 , CALC_NEW_WAIT_PER_STARTUP_DONE 
                      5691     
0A8F    7F03          5692     MOV R7 , # 3 
0A91    41AF          5693     	AJMP	CALC_NEW_WAIT_PER_DEMAG_DONE
                      5694     
                      5695     CALC_NEW_WAIT_PER_STARTUP_DONE: 
0A93    7892          5696     MOV R0 , # PGM_COMM_TIMING 
0A95    E6            5697     MOV A , @ R0 
0A96    FF            5698     MOV R7 , A 
0A97    C3            5699     	CLR	C
0A98    E536          5700     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0A9A    9482          5701     	SUBB	A, #130
0A9C    4011          5702     	JC	CALC_NEW_WAIT_PER_DEMAG_DONE
                      5703     
0A9E    0F            5704     INC R7 
                      5705     
0A9F    C3            5706     	CLR	C
0AA0    E536          5707     	MOV	A, DEMAG_DETECTED_METRIC
0AA2    94A0          5708     	SUBB	A, #160
0AA4    4001          5709     	JC	($+3)
                      5710     
0AA6    0F            5711     INC R7 
                      5712     
0AA7    C3            5713     	CLR	C
0AA8    EF            5714     MOV A , R7 
0AA9    9406          5715     	SUBB	A, #6
0AAB    4002          5716     	JC	($+4)
                      5717     
0AAD    7F05          5718     MOV R7 , # 5 
                      5719     
                      5720     CALC_NEW_WAIT_PER_DEMAG_DONE: 
                      5721     	; Set timing reduction
                      5722     IF MCU_48MHZ == 0
                               	MOV	TEMP7, #4
                               ELSE
0AAF    7E01          5725     MOV R6 , # 1 
                      5726     ENDIF
                      5727     	; Load current commutation timing
0AB1    E53E          5728     	MOV	A, COMM_PERIOD4X_H		; Divide 4 times
0AB3    C4            5729     	SWAP	A
0AB4    540F          5730     	ANL	A, #00FH
0AB6    F9            5731     MOV R1 , A 
0AB7    E53E          5732     	MOV	A, COMM_PERIOD4X_H
0AB9    C4            5733     	SWAP	A
0ABA    54F0          5734     	ANL	A, #0F0H
0ABC    F8            5735     MOV R0 , A 
0ABD    E53D          5736     	MOV	A, COMM_PERIOD4X_L
0ABF    C4            5737     	SWAP	A
0AC0    540F          5738     	ANL	A, #00FH
0AC2    28            5739     ADD A , R0 
0AC3    F8            5740     MOV R0 , A 
                      5741     
0AC4    C3            5742     	CLR	C
0AC5    E8            5743     MOV A , R0 
0AC6    9E            5744     SUBB A , R6 
0AC7    FA            5745     MOV R2 , A 
0AC8    E9            5746     MOV A , R1 
0AC9    9400          5747     	SUBB	A, #0
0ACB    FB            5748     MOV R3 , A 
0ACC    4009          5749     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      5750     
0ACE    C3            5751     	CLR	C
0ACF    EA            5752     MOV A , R2 
0AD0    9402          5753     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0AD2    EB            5754     MOV A , R3 
0AD3    9400          5755     	SUBB	A, #0
0AD5    5004          5756     	JNC	CALC_NEW_WAIT_TIMES_EXIT	; Check that result is still above minumum
                      5757     
                      5758     LOAD_MIN_TIME: 
0AD7    7A02          5759     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0AD9    E4            5760     	CLR	A
0ADA    FB            5761     MOV R3 , A 
                      5762     
                      5763     CALC_NEW_WAIT_TIMES_EXIT: 	
0ADB    22            5764     	RET
                      5765     
                      5766     
                      5767     ; Fast calculation (Comm_Period4x_H less than 2)
                      5768     CALC_NEXT_COMM_TIMING_FAST: 			
                      5769     	; Calculate new commutation time
0ADC    AA3D          5770     MOV R2 , COMM_PERIOD4X_L 
0ADE    AB3E          5771     MOV R3 , COMM_PERIOD4X_H 
0AE0    EB            5772     MOV A , R3 
0AE1    C4            5773     	SWAP	A
0AE2    FE            5774     MOV R6 , A 
0AE3    EA            5775     MOV A , R2 
0AE4    C4            5776     	SWAP A
0AE5    540F          5777     	ANL	A, #0FH
0AE7    4E            5778     ORL A , R6 
0AE8    FC            5779     MOV R4 , A 
0AE9    C3            5780     	CLR	C
0AEA    EA            5781     MOV A , R2 
0AEB    9C            5782     SUBB A , R4 
0AEC    FA            5783     MOV R2 , A 
0AED    EB            5784     MOV A , R3 
0AEE    9400          5785     	SUBB	A, #0
0AF0    FB            5786     MOV R3 , A 
0AF1    C3            5787     	CLR	C
0AF2    E8            5788     MOV A , R0 
0AF3    13            5789     	RRC	A					; Divide by 2 2 times
0AF4    C3            5790     	CLR	C
0AF5    13            5791     	RRC	A
0AF6    F8            5792     MOV R0 , A 
0AF7    EA            5793     MOV A , R2 
0AF8    28            5794     ADD A , R0 
0AF9    FA            5795     MOV R2 , A 
0AFA    EB            5796     MOV A , R3 
0AFB    3400          5797     	ADDC	A, #0
0AFD    FB            5798     MOV R3 , A 
0AFE    8A3D          5799     MOV COMM_PERIOD4X_L , R2 
0B00    8B3E          5800     MOV COMM_PERIOD4X_H , R3 
0B02    C3            5801     	CLR	C
0B03    EB            5802     MOV A , R3 
0B04    9402          5803     	SUBB	A, #2
0B06    4002          5804     	JC	($+4)
                      5805     
0B08    C267          5806     CLR FLAGS0 . 7 
                      5807     	
                      5808     IF MCU_48MHZ == 0
                               	MOV	TEMP1, #4				; Set timing reduction
                               ELSE
0B0A    7801          5811     MOV R0 , # 1 
                      5812     ENDIF
0B0C    EB            5813     MOV A , R3 
0B0D    C4            5814     	SWAP	A
0B0E    FE            5815     MOV R6 , A 
0B0F    7B00          5816     MOV R3 , # 0 
0B11    EA            5817     MOV A , R2 
0B12    C4            5818     	SWAP A
0B13    540F          5819     	ANL	A, #0FH
0B15    4E            5820     ORL A , R6 
0B16    FA            5821     MOV R2 , A 
0B17    C3            5822     	CLR	C
0B18    EA            5823     MOV A , R2 
0B19    98            5824     SUBB A , R0 
0B1A    FA            5825     MOV R2 , A 
0B1B    4005          5826     	JC	LOAD_MIN_TIME_FAST		; Check that result is still positive
                      5827     
0B1D    C3            5828     	CLR	C
0B1E    9402          5829     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0B20    5002          5830     	JNC	CALC_NEW_WAIT_TIMES_FAST_DONE	; Check that result is still above minumum
                      5831     
                      5832     LOAD_MIN_TIME_FAST: 
0B22    7A02          5833     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
                      5834     
                      5835     CALC_NEW_WAIT_TIMES_FAST_DONE: 	
0B24    7892          5836     MOV R0 , # PGM_COMM_TIMING 
0B26    E6            5837     MOV A , @ R0 
0B27    FF            5838     MOV R7 , A 
0B28    22            5839     	RET
                      5840     
                      5841     
                      5842     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5843     ;
                      5844     ; Wait advance timing routine
                      5845     ;
                      5846     ; No assumptions
                      5847     ; NOTE: Be VERY careful if using temp registers. They are passed over this routine
                      5848     ;
                      5849     ; Waits for the advance timing to elapse and sets up the next zero cross wait
                      5850     ;
                      5851     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5852     WAIT_ADVANCE_TIMING: 	
0B29    306002        5853     JNB FLAGS0 . 0 , ( $+5 ) 
0B2C    6129          5854     	AJMP	WAIT_ADVANCE_TIMING
                      5855     
                      5856     	; Setup next wait time
0B2E    854F53        5857     	MOV	NEXT_WT_START_L, WT_ZC_TOUT_START_L
0B31    855054        5858     	MOV	NEXT_WT_START_H, WT_ZC_TOUT_START_H
0B34    D260          5859     SETB FLAGS0 . 0 
0B36    43E680        5860     	ORL	EIE1, #80H	; Enable timer3 interrupts
0B39    22            5861     	RET
                      5862     
                      5863     
                      5864     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5865     ;
                      5866     ; Calculate new wait times routine
                      5867     ;
                      5868     ; No assumptions
                      5869     ;
                      5870     ; Calculates new wait times
                      5871     ;
                      5872     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5873     CALC_NEW_WAIT_TIMES: 	
0B3A    C3            5874     	CLR	C
0B3B    E4            5875     	CLR	A
0B3C    9A            5876     SUBB A , R2 
0B3D    F8            5877     MOV R0 , A 
0B3E    E4            5878     	CLR	A
0B3F    9B            5879     SUBB A , R3 
0B40    F9            5880     MOV R1 , A 
                      5881     IF MCU_48MHZ == 1
0B41    C3            5882     	CLR	C
0B42    E8            5883     MOV A , R0 
0B43    33            5884     	RLC	A
0B44    F8            5885     MOV R0 , A 
0B45    E9            5886     MOV A , R1 
0B46    33            5887     	RLC	A
0B47    F9            5888     MOV R1 , A 
                      5889     ENDIF
0B48    306702        5890     JNB FLAGS0 . 7 , ( $+5 ) 
0B4B    61C9          5891     	AJMP	CALC_NEW_WAIT_TIMES_FAST
                      5892     
0B4D    E8            5893     MOV A , R0 
0B4E    FA            5894     MOV R2 , A 
0B4F    E9            5895     MOV A , R1 
0B50    FB            5896     MOV R3 , A 
0B51    D3            5897     	SETB	C					; Negative numbers - set carry
0B52    E9            5898     MOV A , R1 
0B53    13            5899     	RRC	A					; Divide by 2
0B54    FD            5900     MOV R5 , A 
0B55    E8            5901     MOV A , R0 
0B56    13            5902     	RRC	A
0B57    FC            5903     MOV R4 , A 
0B58    884F          5904     MOV WT_ZC_TOUT_START_L , R0 
0B5A    8950          5905     MOV WT_ZC_TOUT_START_H , R1 
0B5C    C3            5906     	CLR	C
0B5D    EF            5907     MOV A , R7 
0B5E    9403          5908     	SUBB	A, #3				; Is timing normal?
0B60    6037          5909     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      5910     
0B62    EF            5911     MOV A , R7 
0B63    20E00D        5912     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      5913     
0B66    E8            5914     MOV A , R0 
0B67    2C            5915     ADD A , R4 
0B68    F8            5916     MOV R0 , A 
0B69    E9            5917     MOV A , R1 
0B6A    3D            5918     ADDC A , R5 
0B6B    F9            5919     MOV R1 , A 
0B6C    EC            5920     MOV A , R4 
0B6D    FA            5921     MOV R2 , A 
0B6E    ED            5922     MOV A , R5 
0B6F    FB            5923     MOV R3 , A 
0B70    020B86        5924     	JMP	STORE_TIMES_UP_OR_DOWN
                      5925     
                      5926     ADJUST_TIMING_TWO_STEPS: 
0B73    E8            5927     MOV A , R0 
0B74    28            5928     ADD A , R0 
0B75    F8            5929     MOV R0 , A 
0B76    E9            5930     MOV A , R1 
0B77    39            5931     ADDC A , R1 
0B78    F9            5932     MOV R1 , A 
0B79    C3            5933     	CLR	C
0B7A    E8            5934     MOV A , R0 
0B7B    2402          5935     	ADD	A, #(COMM_TIME_MIN SHL 1)
0B7D    F8            5936     MOV R0 , A 
0B7E    E9            5937     MOV A , R1 
0B7F    3400          5938     	ADDC	A, #0
0B81    F9            5939     MOV R1 , A 
0B82    7AFE          5940     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
0B84    7BFF          5941     MOV R3 , # 0FFH 
                      5942     
                      5943     STORE_TIMES_UP_OR_DOWN: 
0B86    C3            5944     	CLR	C
0B87    EF            5945     MOV A , R7 
0B88    9403          5946     	SUBB	A, #3					; Is timing higher than normal?
0B8A    400D          5947     	JC	STORE_TIMES_DECREASE		; No - branch
                      5948     
                      5949     STORE_TIMES_INCREASE: 
0B8C    8A51          5950     MOV WT_COMM_START_L , R2 
0B8E    8B52          5951     MOV WT_COMM_START_H , R3 
0B90    884B          5952     MOV WT_ADV_START_L , R0 
0B92    894C          5953     MOV WT_ADV_START_H , R1 
0B94    8C4D          5954     MOV WT_ZC_SCAN_START_L , R4 
0B96    8D4E          5955     MOV WT_ZC_SCAN_START_H , R5 
0B98    22            5956     	RET
                      5957     
                      5958     STORE_TIMES_DECREASE: 
0B99    8851          5959     MOV WT_COMM_START_L , R0 
0B9B    8952          5960     MOV WT_COMM_START_H , R1 
0B9D    8A4B          5961     MOV WT_ADV_START_L , R2 
0B9F    8B4C          5962     MOV WT_ADV_START_H , R3 
0BA1    8C4D          5963     MOV WT_ZC_SCAN_START_L , R4 
0BA3    8D4E          5964     MOV WT_ZC_SCAN_START_H , R5 
0BA5    306920        5965     JNB FLAGS1 . 1 , STORE_TIMES_EXIT 
                      5966     
0BA8    C3            5967     	CLR	C
0BA9    E533          5968     	MOV	A, STARTUP_CNT			
0BAB    9403          5969     	SUBB	A, #3
0BAD    4019          5970     	JC	STORE_TIMES_EXIT
                      5971     
0BAF    E53F          5972     	MOV	A, COMM_DIFF			; Compensate commutation wait for comparator offset
0BB1    A2E7          5973     	MOV	C, ACC.7
0BB3    13            5974     	RRC	A
0BB4    F8            5975     MOV R0 , A 
0BB5    E552          5976     	MOV	A, WT_COMM_START_H
0BB7    F4            5977     	CPL	A
0BB8    2401          5978     	ADD	A, #1
0BBA    38            5979     ADDC A , R0 
0BBB    400B          5980     	JC	STORE_TIMES_EXIT
0BBD    20E708        5981     	JB	ACC.7, STORE_TIMES_EXIT
                      5982     
0BC0    7551FF        5983     	MOV	WT_COMM_START_L, #0FFH
0BC3    F4            5984     	CPL	A
0BC4    2401          5985     	ADD	A, #1
0BC6    F552          5986     	MOV	WT_COMM_START_H, A 
                      5987     
                      5988     STORE_TIMES_EXIT: 
0BC8    22            5989     	RET
                      5990     
                      5991     
                      5992     CALC_NEW_WAIT_TIMES_FAST: 	
0BC9    E8            5993     MOV A , R0 
0BCA    FA            5994     MOV R2 , A 
0BCB    D3            5995     	SETB	C					; Negative numbers - set carry
0BCC    E8            5996     MOV A , R0 
0BCD    13            5997     	RRC	A
0BCE    FC            5998     MOV R4 , A 
0BCF    884F          5999     MOV WT_ZC_TOUT_START_L , R0 
0BD1    C3            6000     	CLR	C
0BD2    EF            6001     MOV A , R7 
0BD3    9403          6002     	SUBB	A, #3				; Is timing normal?
0BD5    601F          6003     	JZ	STORE_TIMES_DECREASE_FAST; Yes - branch
                      6004     
0BD7    EF            6005     MOV A , R7 
0BD8    20E007        6006     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS_FAST	; If an odd number - branch
                      6007     
0BDB    E8            6008     MOV A , R0 
0BDC    2C            6009     ADD A , R4 
0BDD    F8            6010     MOV R0 , A 
0BDE    EC            6011     MOV A , R4 
0BDF    FA            6012     MOV R2 , A 
0BE0    61E9          6013     	AJMP	STORE_TIMES_UP_OR_DOWN_FAST
                      6014     
                      6015     ADJUST_TIMING_TWO_STEPS_FAST: 
0BE2    E8            6016     MOV A , R0 
0BE3    28            6017     ADD A , R0 
0BE4    2402          6018     	ADD	A, #(COMM_TIME_MIN SHL 1)
0BE6    F8            6019     MOV R0 , A 
0BE7    7AFE          6020     MOV R2 , # - ( COMM_TIME_MIN SHL 1 ) 
                      6021     
                      6022     STORE_TIMES_UP_OR_DOWN_FAST: 
0BE9    C3            6023     	CLR	C
0BEA    EF            6024     MOV A , R7 
0BEB    9403          6025     	SUBB	A, #3				; Is timing higher than normal?
0BED    4007          6026     	JC	STORE_TIMES_DECREASE_FAST; No - branch
                      6027     
                      6028     STORE_TIMES_INCREASE_FAST: 
0BEF    8A51          6029     MOV WT_COMM_START_L , R2 
0BF1    884B          6030     MOV WT_ADV_START_L , R0 
0BF3    8C4D          6031     MOV WT_ZC_SCAN_START_L , R4 
0BF5    22            6032     	RET
                      6033     
                      6034     STORE_TIMES_DECREASE_FAST: 
0BF6    8851          6035     MOV WT_COMM_START_L , R0 
0BF8    8A4B          6036     MOV WT_ADV_START_L , R2 
0BFA    8C4D          6037     MOV WT_ZC_SCAN_START_L , R4 
0BFC    22            6038     	RET
                      6039     
                      6040     
                      6041     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6042     ;
                      6043     ; Wait before zero cross scan routine
                      6044     ;
                      6045     ; No assumptions
                      6046     ;
                      6047     ; Waits for the zero cross scan wait time to elapse
                      6048     ; Also sets up timer 3 for the zero cross scan timeout time
                      6049     ;
                      6050     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6051     WAIT_BEFORE_ZC_SCAN: 	
                      6052     	; Calculate random number
0BFD    E568          6053     	MOV	A, RANDOM
0BFF    C3            6054     	CLR	C
0C00    33            6055     	RLC	A
0C01    5002          6056     	JNC	WAIT_BEFORE_ZC_SCAN_RAND
                      6057     
0C03    646B          6058     	XRL	A, #06BH		; Sequence length of 35, when initialized to 1
                      6059     
                      6060     WAIT_BEFORE_ZC_SCAN_RAND:           
0C05    F568          6061     	MOV	RANDOM, A
                      6062     
                      6063     WAIT_BEFORE_ZC_SCAN_WAIT:           
0C07    306002        6064     JNB FLAGS0 . 0 , ( $+5 ) 
0C0A    8107          6065     	AJMP	WAIT_BEFORE_ZC_SCAN_WAIT
                      6066     
0C0C    D260          6067     SETB FLAGS0 . 0 
0C0E    43E680        6068     	ORL	EIE1, #80H			; Enable timer3 interrupts
0C11    E52D          6069     	MOV	A, FLAGS1
0C13    5406          6070     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0C15    6029          6071     	JZ	WAIT_BEFORE_ZC_SCAN_EXIT		
                      6072     
0C17    A83D          6073     MOV R0 , COMM_PERIOD4X_L 
0C19    A93E          6074     MOV R1 , COMM_PERIOD4X_H 
0C1B    C3            6075     	CLR	C
0C1C    E9            6076     MOV A , R1 
0C1D    13            6077     	RRC	A
0C1E    F9            6078     MOV R1 , A 
0C1F    E8            6079     MOV A , R0 
0C20    13            6080     	RRC	A
0C21    F8            6081     MOV R0 , A 
                      6082     IF MCU_48MHZ == 1
0C22    C3            6083     	CLR	C
0C23    E8            6084     MOV A , R0 
0C24    33            6085     	RLC	A
0C25    F8            6086     MOV R0 , A 
0C26    E9            6087     MOV A , R1 
0C27    33            6088     	RLC	A
0C28    F9            6089     MOV R1 , A 
                      6090     ENDIF
0C29    53E67F        6091     	ANL	EIE1, #7FH			; Disable timer3 interrupts
0C2C    759100        6092     	MOV	TMR3CN, #00H			; Timer3 disabled and interrupt flag cleared
0C2F    C3            6093     	CLR	C
0C30    E4            6094     	CLR	A
0C31    98            6095     SUBB A , R0 
0C32    F594          6096     	MOV	TMR3L, A
0C34    E4            6097     	CLR	A
0C35    99            6098     SUBB A , R1 
0C36    F595          6099     	MOV	TMR3H, A
0C38    759104        6100     	MOV	TMR3CN, #04H			; Timer3 enabled and interrupt flag cleared
                      6101     
0C3B    D260          6102     SETB FLAGS0 . 0 
0C3D    43E680        6103     	ORL	EIE1, #80H			; Enable timer3 interrupts
                      6104     
                      6105     WAIT_BEFORE_ZC_SCAN_EXIT:           
0C40    22            6106     	RET
                      6107     
                      6108     
                      6109     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6110     ;
                      6111     ; Wait for comparator to go low/high routines
                      6112     ;
                      6113     ; No assumptions
                      6114     ;
                      6115     ; Waits for the zero cross scan wait time to elapse
                      6116     ; Then scans for comparator going low/high
                      6117     ;
                      6118     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6119     WAIT_FOR_COMP_OUT_LOW: 
0C41    D265          6120     SETB FLAGS0 . 5 
0C43    754100        6121     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0C46    752000        6122     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0C49    306B03        6123     JNB FLAGS1 . 3 , ( $+6 ) 
0C4C    752040        6124     	MOV	BIT_ACCESS, #40H		
0C4F    020C60        6125     	JMP	WAIT_FOR_COMP_OUT_START
                      6126     
                      6127     WAIT_FOR_COMP_OUT_HIGH: 
0C52    D265          6128     SETB FLAGS0 . 5 
0C54    754100        6129     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0C57    752040        6130     	MOV	BIT_ACCESS, #40H			; Desired comparator output
0C5A    306B03        6131     JNB FLAGS1 . 3 , ( $+6 ) 
0C5D    752000        6132     	MOV	BIT_ACCESS, #00H		
                      6133     
                      6134     WAIT_FOR_COMP_OUT_START: 
0C60    D2AF          6135     	SETB	EA						; Enable interrupts
                      6136     	; Set number of comparator readings
0C62    7801          6137     MOV R0 , # 1 
0C64    206722        6138     JB FLAGS0 . 7 , COMP_WAIT_ON_COMP_ABLE 
                      6139     
0C67    E52D          6140     	MOV	A, FLAGS1					; Clear demag detected flag if start phases
0C69    5406          6141     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0C6B    6002          6142     	JZ	($+4)
                      6143     		
0C6D    C265          6144     CLR FLAGS0 . 5 
                      6145     
0C6F    C3            6146     	CLR	C						; Set number of readings higher for lower speeds
0C70    E53E          6147     	MOV 	A, COMM_PERIOD4X_H			
0C72    9405          6148     	SUBB	A, #05H
0C74    4013          6149     	JC	COMP_WAIT_ON_COMP_ABLE
                      6150     
0C76    7802          6151     MOV R0 , # 2 
                      6152     
0C78    9405          6153     	SUBB	A, #05H
0C7A    4008          6154     	JC	COMP_WAIT_NO_OF_READINGS
                      6155     
0C7C    7803          6156     MOV R0 , # 3 
                      6157     
0C7E    9405          6158     	SUBB	A, #05H					; Set number of consecutive readings higher for lower speeds
0C80    4002          6159     	JC	COMP_WAIT_NO_OF_READINGS
                      6160     
0C82    7806          6161     MOV R0 , # 6 
                      6162     
                      6163     COMP_WAIT_NO_OF_READINGS: 
0C84    306902        6164     JNB FLAGS1 . 1 , ( $+5 ) 
0C87    780A          6165     MOV R0 , # 10 
                      6166     
                      6167     COMP_WAIT_ON_COMP_ABLE: 
0C89    206009        6168     JB FLAGS0 . 0 , COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT 
                      6169     
0C8C    E541          6170     	MOV	A, COMPARATOR_READ_CNT			; Check that comparator has been read
0C8E    6005          6171     	JZ	COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT	; If not read - branch
                      6172     
0C90    D2AF          6173     	SETB	EA							; Enable interrupts
0C92    D26C          6174     SETB FLAGS1 . 4 
0C94    22            6175     	RET								; Yes - return
                      6176     
                      6177     
                      6178     COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT: 
0C95    D2AF          6179     	SETB	EA							; Enable interrupts
0C97    00            6180     	NOP								; Allocate only just enough time to capture interrupt
0C98    00            6181     	NOP
0C99    C2AF          6182     	CLR	EA							; Disable interrupts
0C9B    20672A        6183     JB FLAGS0 . 7 , COMP_WAIT_READ_COMP 
                      6184     
0C9E    E53E          6185     	MOV	A, COMM_PERIOD4X_H				; Reduce required distance to pwm transition for higher speeds
0CA0    C3            6186     	CLR	C
0CA1    FB            6187     MOV R3 , A 
0CA2    940F          6188     	SUBB	A, #0FH
0CA4    4002          6189     	JC	($+4)
                      6190     
0CA6    7B0F          6191     MOV R3 , # 0FH 
                      6192     
0CA8    EB            6193     MOV A , R3 
0CA9    2405          6194     	ADD	A, #5
0CAB    307301        6195     JNB FLAGS2 . 3 , ( $+4 ) 
                      6196     
0CAE    23            6197     	RL	A
                      6198     
0CAF    306A02        6199     JNB FLAGS1 . 2 , ( $+5 ) 
0CB2    7428          6200     	MOV	A, #40
                      6201     
0CB4    206201        6202     JB FLAGS0 . 2 , ( $+4 ) 
                      6203     
0CB7    23            6204     	RL	A
                      6205     
0CB8    F9            6206     MOV R1 , A 
0CB9    306902        6207     JNB FLAGS1 . 1 , ( $+5 ) 
0CBC    7982          6208     MOV R1 , # 130 
                      6209     
                      6210     IF MCU_48MHZ == 0
                               	MOV	A, TL1
                               ELSE
0CBE    E58D          6213     	MOV	A, TH1
0CC0    13            6214     	RRC	A
0CC1    E58B          6215     	MOV	A, TL1
0CC3    13            6216     	RRC	A
                      6217     ENDIF
0CC4    C3            6218     	CLR	C
0CC5    99            6219     SUBB A , R1 
0CC6    40C1          6220     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle
                      6221     
                      6222     COMP_WAIT_READ_COMP: 
0CC8    0541          6223     	INC	COMPARATOR_READ_CNT			; Increment comparator read count
                      6224     	READ_COMP_OUT					; Read comparator output
0CCA    E59B          6224+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0CCC    F4            6224+1   CPL A 
0CCD    5440          6225     	ANL	A, #40H
0CCF    B52002        6226     	CJNE	A, BIT_ACCESS, COMP_READ_WRONG
0CD2    A121          6227     	AJMP	COMP_READ_OK
                      6228     	
                      6229     COMP_READ_WRONG: 
0CD4    306914        6230     JNB FLAGS1 . 1 , COMP_READ_WRONG_NOT_STARTUP 
                      6231     
0CD7    08            6232     INC R0 
0CD8    C3            6233     	CLR	C
0CD9    E8            6234     MOV A , R0 
0CDA    940A          6235     	SUBB	A, #10					; If above initial requirement - go back and restart
0CDC    4002          6236     	JC	($+4)
0CDE    8160          6237     	AJMP	WAIT_FOR_COMP_OUT_START
                      6238     
0CE0    C3            6239     	CLR	C
0CE1    E533          6240     	MOV	A, STARTUP_CNT				; For the first commutations - go back and restart
0CE3    9406          6241     	SUBB	A, #6
0CE5    5002          6242     	JNC	($+4)
0CE7    8160          6243     	AJMP	WAIT_FOR_COMP_OUT_START
                      6244     
0CE9    8189          6245     	AJMP	COMP_WAIT_ON_COMP_ABLE		; If below initial requirement - continue to look for good ones
                      6246     
                      6247     COMP_READ_WRONG_NOT_STARTUP: 
0CEB    206502        6248     JB FLAGS0 . 5 , ( $+5 ) 
0CEE    8160          6249     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct, and timeout already extended - go back and restart
                      6250     
0CF0    C265          6251     CLR FLAGS0 . 5 
0CF2    53E67F        6252     	ANL	EIE1, #7FH				; Disable timer3 interrupts
0CF5    759100        6253     	MOV	TMR3CN, #00H				; Timer3 disabled and interrupt flag cleared
0CF8    306710        6254     JNB FLAGS0 . 7 , COMP_READ_WRONG_LOW_RPM 
                      6255     
0CFB    759400        6256     	MOV	TMR3L, #00H				; Set timeout to 256us
                      6257     IF MCU_48MHZ == 1
0CFE    7595FC        6258     	MOV	TMR3H, #0FCH
                      6259     ELSE
                               	MOV	TMR3H, #0FEH
                               ENDIF
                      6262     COMP_READ_WRONG_TIMEOUT_SET: 
0D01    759104        6263     	MOV	TMR3CN, #04H				; Timer3 enabled and interrupt flag cleared
0D04    D260          6264     SETB FLAGS0 . 0 
0D06    43E680        6265     	ORL	EIE1, #80H				; Enable timer3 interrupts
0D09    8160          6266     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      6267     
                      6268     COMP_READ_WRONG_LOW_RPM: 
0D0B    AE3D          6269     MOV R6 , COMM_PERIOD4X_L 
0D0D    AF3E          6270     MOV R7 , COMM_PERIOD4X_H 
                      6271     IF MCU_48MHZ == 1
0D0F    C3            6272     	CLR	C
0D10    EE            6273     MOV A , R6 
0D11    33            6274     	RLC	A
0D12    FE            6275     MOV R6 , A 
0D13    EF            6276     MOV A , R7 
0D14    33            6277     	RLC	A
0D15    FF            6278     MOV R7 , A 
                      6279     ENDIF
0D16    C3            6280     	CLR	C
0D17    E4            6281     	CLR	A
0D18    9E            6282     SUBB A , R6 
0D19    F594          6283     	MOV	TMR3L, A
0D1B    E4            6284     	CLR	A
0D1C    9F            6285     SUBB A , R7 
0D1D    F595          6286     	MOV	TMR3H, A
0D1F    A101          6287     	AJMP	COMP_READ_WRONG_TIMEOUT_SET
                      6288     
                      6289     COMP_READ_OK: 
0D21    C3            6290     	CLR	C
0D22    E533          6291     	MOV	A, STARTUP_CNT				; Force a timeout for the first commutations			
0D24    9402          6292     	SUBB	A, #2
0D26    5002          6293     	JNC	($+4)
0D28    8160          6294     	AJMP	WAIT_FOR_COMP_OUT_START
                      6295     
0D2A    306502        6296     JNB FLAGS0 . 5 , ( $+5 ) 
0D2D    8160          6297     	AJMP	WAIT_FOR_COMP_OUT_START
                      6298     
0D2F    D802          6299     DJNZ R0 , COMP_READ_OK_JMP 
0D31    A135          6300     	AJMP	($+4)
                      6301     
                      6302     COMP_READ_OK_JMP: 
0D33    8189          6303     	AJMP	COMP_WAIT_ON_COMP_ABLE	
                      6304     
0D35    C26C          6305     CLR FLAGS1 . 4 
0D37    22            6306     	RET							
                      6307     
                      6308     
                      6309     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6310     ;
                      6311     ; Evaluate comparator integrity
                      6312     ;
                      6313     ; No assumptions
                      6314     ;
                      6315     ; Checks comparator signal behaviour versus expected behaviour
                      6316     ;
                      6317     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6318     EVALUATE_COMPARATOR_INTEGRITY: 
0D38    E52D          6319     	MOV	A, FLAGS1
0D3A    5406          6320     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0D3C    6008          6321     	JZ	EVAL_COMP_CHECK_TIMEOUT
                      6322     
0D3E    206A02        6323     JB FLAGS1 . 2 , ( $+5 ) 
0D41    0533          6324     	INC	STARTUP_CNT					; Increment counter
0D43    020D56        6325     	JMP	EVAL_COMP_EXIT
                      6326     
                      6327     EVAL_COMP_CHECK_TIMEOUT: 
0D46    306C0D        6328     JNB FLAGS1 . 4 , EVAL_COMP_EXIT 
0D49    206B0A        6329     JB FLAGS1 . 3 , EVAL_COMP_EXIT 
0D4C    206507        6330     JB FLAGS0 . 5 , EVAL_COMP_EXIT 
0D4F    1581          6331     	DEC	SP								; Routine exit without "ret" command
0D51    1581          6332     	DEC	SP
0D53    02164D        6333     	LJMP	RUN_TO_WAIT_FOR_POWER_ON_FAIL			; Yes - exit run mode
                      6334     
                      6335     EVAL_COMP_EXIT: 
0D56    22            6336     	RET
                      6337     
                      6338     
                      6339     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6340     ;
                      6341     ; Setup commutation timing routine
                      6342     ;
                      6343     ; No assumptions
                      6344     ;
                      6345     ; Sets up and starts wait from commutation to zero cross
                      6346     ;
                      6347     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6348     SETUP_COMM_WAIT:  
0D57    53E67F        6349     	ANL	EIE1, #7FH		; Disable timer3 interrupts
0D5A    759100        6350     	MOV	TMR3CN, #00H		; Timer3 disabled and interrupt flag cleared
0D5D    855194        6351     	MOV	TMR3L, WT_COMM_START_L
0D60    855295        6352     	MOV	TMR3H, WT_COMM_START_H
0D63    759104        6353     	MOV	TMR3CN, #04H		; Timer3 enabled and interrupt flag cleared
                      6354     	; Setup next wait time
0D66    854B53        6355     	MOV	NEXT_WT_START_L, WT_ADV_START_L
0D69    854C54        6356     	MOV	NEXT_WT_START_H, WT_ADV_START_H
0D6C    D260          6357     SETB FLAGS0 . 0 
0D6E    43E680        6358     	ORL	EIE1, #80H		; Enable timer3 interrupts
0D71    D2AF          6359     	SETB	EA				; Enable interrupts again
0D73    22            6360     	RET
                      6361     
                      6362     
                      6363     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6364     ;
                      6365     ; Wait for commutation routine
                      6366     ;
                      6367     ; No assumptions
                      6368     ;
                      6369     ; Waits from zero cross to commutation 
                      6370     ;
                      6371     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6372     WAIT_FOR_COMM:  
                      6373     	; Update demag metric
0D74    7800          6374     MOV R0 , # 0 
0D76    306405        6375     JNB FLAGS0 . 4 , ( $+8 ) 
0D79    306502        6376     JNB FLAGS0 . 5 , ( $+5 ) 
                      6377     
0D7C    7801          6378     MOV R0 , # 1 
                      6379     
0D7E    E536          6380     	MOV	A, DEMAG_DETECTED_METRIC	; Sliding average of 8, 256 when demag and 0 when not. Limited to minimum 120
0D80    75F007        6381     	MOV	B, #7
0D83    A4            6382     	MUL	AB					; Multiply by 7
0D84    F9            6383     MOV R1 , A 
0D85    E5F0          6384     	MOV	A, B					; Add new value for current demag status
0D87    28            6385     ADD A , R0 
0D88    F5F0          6386     	MOV	B, A
0D8A    E9            6387     MOV A , R1 
0D8B    A2F0          6388     	MOV	C, B.0				; Divide by 8
0D8D    13            6389     	RRC	A					
0D8E    A2F1          6390     	MOV	C, B.1
0D90    13            6391     	RRC	A
0D91    A2F2          6392     	MOV	C, B.2
0D93    13            6393     	RRC	A
0D94    F536          6394     	MOV	DEMAG_DETECTED_METRIC, A
0D96    C3            6395     	CLR	C
0D97    9478          6396     	SUBB	A, #120				; Limit to minimum 120
0D99    5003          6397     	JNC	($+5)
                      6398     
0D9B    753678        6399     	MOV	DEMAG_DETECTED_METRIC, #120
                      6400     
0D9E    C3            6401     	CLR	C
0D9F    E536          6402     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0DA1    9537          6403     	SUBB	A, DEMAG_PWR_OFF_THRESH
0DA3    4008          6404     	JC	WAIT_FOR_COMM_WAIT		; Cut power if many consecutive demags. This will help retain sync during hard accelerations
                      6405     
0DA5    D266          6406     SETB FLAGS0 . 6 
                      6407     	ALL_NFETS_OFF
0DA7    C293          6407+1   CLR P1 . 3 
0DA9    C297          6407+1   CLR P1 . 7 
0DAB    C294          6407+1   CLR P1 . 4 
                      6408     
                      6409     WAIT_FOR_COMM_WAIT: 
0DAD    306002        6410     JNB FLAGS0 . 0 , ( $+5 ) 
0DB0    A1AD          6411     	AJMP	WAIT_FOR_COMM_WAIT					
                      6412     
                      6413     	; Setup next wait time
0DB2    854D53        6414     	MOV	NEXT_WT_START_L, WT_ZC_SCAN_START_L
0DB5    854E54        6415     	MOV	NEXT_WT_START_H, WT_ZC_SCAN_START_H
0DB8    D260          6416     SETB FLAGS0 . 0 
0DBA    43E680        6417     	ORL	EIE1, #80H			; Enable timer3 interrupts
0DBD    22            6418     	RET
                      6419     
                      6420     
                      6421     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6422     ;
                      6423     ; Commutation routines
                      6424     ;
                      6425     ; No assumptions
                      6426     ;
                      6427     ; Performs commutation switching 
                      6428     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      6429     ;
                      6430     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6431     ; Comm phase 1 to comm phase 2
                      6432     COMM1COMM2: 	
                      6433     	SET_RPM_OUT
0DBE    207D11        6434     JB FLAGS3 . 5 , COMM12_REV 
                      6435     
0DC1    C2AF          6436     	CLR 	EA					; Disable all interrupts
0DC3    754002        6437     	MOV	COMM_PHASE, #2
                      6438     	BPFET_OFF 				; Turn off pfet
0DC6    C295          6438+1   CLR P1 . 5 
                      6439     	APFET_ON					; Turn on pfet
0DC8    D292          6439+1   SETB P1 . 2 
0DCA    D2AF          6440     	SETB	EA
                      6441     	SET_COMP_PHASE_B 			; Set comparator phase
0DCC    759F80        6441+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0DCF    020F8D        6442     	JMP	COMM_EXIT
                      6443     
                      6444     COMM12_REV: 	
0DD2    C2AF          6445     	CLR 	EA					; Disable all interrupts
0DD4    754002        6446     	MOV	COMM_PHASE, #2
                      6447     	BPFET_OFF 				; Turn off pfet
0DD7    C295          6447+1   CLR P1 . 5 
                      6448     	CPFET_ON					; Turn on pfet (reverse)
0DD9    D296          6448+1   SETB P1 . 6 
0DDB    D2AF          6449     	SETB	EA
                      6450     	SET_COMP_PHASE_B 			; Set comparator phase
0DDD    759F80        6450+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0DE0    020F8D        6451     	JMP	COMM_EXIT
                      6452     
                      6453     
                      6454     ; Comm phase 2 to comm phase 3
                      6455     COMM2COMM3: 	
                      6456     	CLEAR_RPM_OUT
0DE3    307243        6457     JNB FLAGS2 . 2 , COMM23_NONDAMP 
                      6458     
                      6459     	; Comm2Comm3 Damped
0DE6    207D20        6460     JB FLAGS3 . 5 , COMM23_DAMP_REV 
                      6461     
0DE9    C2AF          6462     	CLR 	EA					; Disable all interrupts
0DEB    754003        6463     	MOV	COMM_PHASE, #3
0DEE    90018B        6464     	MOV	DPTR, #PWM_BFET_DAMPED	
0DF1    757B20        6465     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6466     	CNFET_OFF					; Turn off fets
0DF4    C297          6466+1   CLR P1 . 7 
                      6467     	CPFET_OFF						
0DF6    C296          6467+1   CLR P1 . 6 
0DF8    306204        6468     JNB FLAGS0 . 2 , COMM23_NFET_OFF 
                      6469     	BNFET_ON					; Pwm on - turn on nfet
0DFB    D294          6469+1   SETB P1 . 4 
0DFD    C101          6470     	AJMP	COMM23_FETS_DONE
                      6471     COMM23_NFET_OFF: 
                      6472     	BPFET_ON					; Pwm off - switch damping fets	
0DFF    D295          6472+1   SETB P1 . 5 
                      6473     COMM23_FETS_DONE: 
0E01    D2AF          6474     	SETB	EA
                      6475     	SET_COMP_PHASE_C 			; Set comparator phase
0E03    759F89        6475+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0E06    020F8D        6476     	LJMP	COMM_EXIT
                      6477     
                      6478     	; Comm2Comm3 Damped reverse
                      6479     COMM23_DAMP_REV: 
0E09    C2AF          6480     	CLR 	EA					; Disable all interrupts
0E0B    754003        6481     	MOV	COMM_PHASE, #3
0E0E    90018B        6482     	MOV	DPTR, #PWM_BFET_DAMPED	
0E11    757B20        6483     	MOV	DAMPINGFET, #(1 SHL BPFET)
                      6484     	ANFET_OFF					; Turn off fets (reverse)
0E14    C293          6484+1   CLR P1 . 3 
                      6485     	APFET_OFF						
0E16    C292          6485+1   CLR P1 . 2 
0E18    306204        6486     JNB FLAGS0 . 2 , COMM23_NFET_OFF_REV 
                      6487     	BNFET_ON					; Pwm on - turn on nfet
0E1B    D294          6487+1   SETB P1 . 4 
0E1D    C121          6488     	AJMP	COMM23_FETS_DONE_REV
                      6489     COMM23_NFET_OFF_REV: 
                      6490     	BPFET_ON					; Pwm off - switch damping fets	
0E1F    D295          6490+1   SETB P1 . 5 
                      6491     COMM23_FETS_DONE_REV: 
0E21    D2AF          6492     	SETB	EA
                      6493     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0E23    759F81        6493+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0E26    020F8D        6494     	LJMP	COMM_EXIT
                      6495     
                      6496     	; Comm2Comm3 Non-damped
                      6497     COMM23_NONDAMP: 
0E29    207D17        6498     JB FLAGS3 . 5 , COMM23_NONDAMP_REV 
                      6499     
0E2C    C2AF          6500     	CLR 	EA					; Disable all interrupts
0E2E    754003        6501     	MOV	COMM_PHASE, #3
0E31    900166        6502     	MOV	DPTR, #PWM_BFET	
                      6503     	CNFET_OFF					; Turn off nfet
0E34    C297          6503+1   CLR P1 . 7 
0E36    306202        6504     JNB FLAGS0 . 2 , COMM23_NFET_DONE 
                      6505     	BNFET_ON					; Yes - turn on nfet
0E39    D294          6505+1   SETB P1 . 4 
                      6506     COMM23_NFET_DONE: 
0E3B    D2AF          6507     	SETB	EA
                      6508     	SET_COMP_PHASE_C 			; Set comparator phase
0E3D    759F89        6508+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0E40    020F8D        6509     	LJMP	COMM_EXIT
                      6510     
                      6511     	; Comm2Comm3 Non-damped reverse
                      6512     COMM23_NONDAMP_REV: 
0E43    C2AF          6513     	CLR 	EA					; Disable all interrupts
0E45    754003        6514     	MOV	COMM_PHASE, #3
0E48    900166        6515     	MOV	DPTR, #PWM_BFET	
                      6516     	ANFET_OFF					; Turn off nfet (reverse)
0E4B    C293          6516+1   CLR P1 . 3 
0E4D    306202        6517     JNB FLAGS0 . 2 , COMM23_NFET_DONE_REV 
                      6518     	BNFET_ON					; Yes - turn on nfet
0E50    D294          6518+1   SETB P1 . 4 
                      6519     COMM23_NFET_DONE_REV: 
0E52    D2AF          6520     	SETB	EA
                      6521     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0E54    759F81        6521+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0E57    020F8D        6522     	LJMP	COMM_EXIT
                      6523     
                      6524     
                      6525     ; Comm phase 3 to comm phase 4
                      6526     COMM3COMM4: 	
                      6527     	SET_RPM_OUT
0E5A    207D11        6528     JB FLAGS3 . 5 , COMM34_REV 
                      6529     
0E5D    C2AF          6530     	CLR 	EA					; Disable all interrupts
0E5F    754004        6531     	MOV	COMM_PHASE, #4
                      6532     	APFET_OFF 				; Turn off pfet
0E62    C292          6532+1   CLR P1 . 2 
                      6533     	CPFET_ON					; Turn on pfet
0E64    D296          6533+1   SETB P1 . 6 
0E66    D2AF          6534     	SETB	EA
                      6535     	SET_COMP_PHASE_A 			; Set comparator phase
0E68    759F81        6535+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0E6B    020F8D        6536     	JMP	COMM_EXIT
                      6537     
                      6538     COMM34_REV: 	
0E6E    C2AF          6539     	CLR 	EA					; Disable all interrupts
0E70    754004        6540     	MOV	COMM_PHASE, #4
                      6541     	CPFET_OFF 				; Turn off pfet (reverse)
0E73    C296          6541+1   CLR P1 . 6 
                      6542     	APFET_ON					; Turn on pfet (reverse)
0E75    D292          6542+1   SETB P1 . 2 
0E77    D2AF          6543     	SETB	EA
                      6544     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0E79    759F89        6544+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0E7C    020F8D        6545     	JMP	COMM_EXIT
                      6546     
                      6547     
                      6548     ; Comm phase 4 to comm phase 5
                      6549     COMM4COMM5: 	
                      6550     	CLEAR_RPM_OUT
0E7F    307243        6551     JNB FLAGS2 . 2 , COMM45_NONDAMP 
                      6552     
                      6553     	; Comm4Comm5 Damped
0E82    207D20        6554     JB FLAGS3 . 5 , COMM45_DAMP_REV 
                      6555     
0E85    C2AF          6556     	CLR 	EA					; Disable all interrupts
0E87    754005        6557     	MOV	COMM_PHASE, #5
0E8A    90017A        6558     	MOV	DPTR, #PWM_AFET_DAMPED	
0E8D    757B04        6559     	MOV	DAMPINGFET, #(1 SHL APFET)
                      6560     	BNFET_OFF					; Turn off fets
0E90    C294          6560+1   CLR P1 . 4 
                      6561     	BPFET_OFF						
0E92    C295          6561+1   CLR P1 . 5 
0E94    306204        6562     JNB FLAGS0 . 2 , COMM45_NFET_OFF 
                      6563     	ANFET_ON					; Pwm on - turn on nfet
0E97    D293          6563+1   SETB P1 . 3 
0E99    C19D          6564     	AJMP	COMM45_FETS_DONE
                      6565     COMM45_NFET_OFF: 
                      6566     	APFET_ON					; Pwm off - switch damping fets	
0E9B    D292          6566+1   SETB P1 . 2 
                      6567     COMM45_FETS_DONE: 
0E9D    D2AF          6568     	SETB	EA
                      6569     	SET_COMP_PHASE_B 			; Set comparator phase
0E9F    759F80        6569+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EA2    020F8D        6570     	LJMP	COMM_EXIT
                      6571     
                      6572     	; Comm4Comm5 Damped reverse
                      6573     COMM45_DAMP_REV: 
0EA5    C2AF          6574     	CLR 	EA					; Disable all interrupts
0EA7    754005        6575     	MOV	COMM_PHASE, #5
0EAA    90019C        6576     	MOV	DPTR, #PWM_CFET_DAMPED	; (reverse)
0EAD    757B40        6577     	MOV	DAMPINGFET, #(1 SHL CPFET)	; (reverse)
                      6578     	BNFET_OFF					; Turn off fets
0EB0    C294          6578+1   CLR P1 . 4 
                      6579     	BPFET_OFF						
0EB2    C295          6579+1   CLR P1 . 5 
0EB4    306204        6580     JNB FLAGS0 . 2 , COMM45_NFET_OFF_REV 
                      6581     	CNFET_ON					; Pwm on - turn on nfet (reverse)
0EB7    D297          6581+1   SETB P1 . 7 
0EB9    C1BD          6582     	AJMP	COMM45_FETS_DONE_REV
                      6583     COMM45_NFET_OFF_REV: 
                      6584     	CPFET_ON					; Pwm off - switch damping fets (reverse)	
0EBB    D296          6584+1   SETB P1 . 6 
                      6585     COMM45_FETS_DONE_REV: 
0EBD    D2AF          6586     	SETB	EA
                      6587     	SET_COMP_PHASE_B 			; Set comparator phase
0EBF    759F80        6587+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EC2    020F8D        6588     	LJMP	COMM_EXIT
                      6589     
                      6590     	; Comm4Comm5 Non-damped
                      6591     COMM45_NONDAMP: 
0EC5    207D17        6592     JB FLAGS3 . 5 , COMM45_NONDAMP_REV 
                      6593     
0EC8    C2AF          6594     	CLR 	EA					; Disable all interrupts
0ECA    754005        6595     	MOV	COMM_PHASE, #5
0ECD    90015C        6596     	MOV	DPTR, #PWM_AFET	
                      6597     	BNFET_OFF					; Turn off nfet
0ED0    C294          6597+1   CLR P1 . 4 
0ED2    306202        6598     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      6599     	ANFET_ON					; Yes - turn on nfet
0ED5    D293          6599+1   SETB P1 . 3 
                      6600     COMM45_NFET_DONE: 
0ED7    D2AF          6601     	SETB	EA
                      6602     	SET_COMP_PHASE_B 			; Set comparator phase
0ED9    759F80        6602+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EDC    020F8D        6603     	LJMP	COMM_EXIT
                      6604     
                      6605     	; Comm4Comm5 Non-damped reverse
                      6606     COMM45_NONDAMP_REV: 
0EDF    C2AF          6607     	CLR 	EA					; Disable all interrupts
0EE1    754005        6608     	MOV	COMM_PHASE, #5
0EE4    900170        6609     	MOV	DPTR, #PWM_CFET		;  (reverse)
                      6610     	BNFET_OFF					; Turn off nfet
0EE7    C294          6610+1   CLR P1 . 4 
0EE9    3062EB        6611     JNB FLAGS0 . 2 , COMM45_NFET_DONE 
                      6612     	CNFET_ON					; Yes - turn on nfet (reverse)
0EEC    D297          6612+1   SETB P1 . 7 
0EEE    D2AF          6613     	SETB	EA
                      6614     	SET_COMP_PHASE_B 			; Set comparator phase
0EF0    759F80        6614+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EF3    020F8D        6615     	LJMP	COMM_EXIT
                      6616     
                      6617     
                      6618     ; Comm phase 5 to comm phase 6
                      6619     COMM5COMM6: 	
                      6620     	SET_RPM_OUT
0EF6    207D11        6621     JB FLAGS3 . 5 , COMM56_REV 
                      6622     
0EF9    C2AF          6623     	CLR 	EA					; Disable all interrupts
0EFB    754006        6624     	MOV	COMM_PHASE, #6
                      6625     	CPFET_OFF 				; Turn off pfet
0EFE    C296          6625+1   CLR P1 . 6 
                      6626     	BPFET_ON					; Turn on pfet
0F00    D295          6626+1   SETB P1 . 5 
0F02    D2AF          6627     	SETB	EA
                      6628     	SET_COMP_PHASE_C 			; Set comparator phase
0F04    759F89        6628+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F07    020F8D        6629     	JMP	COMM_EXIT
                      6630     
                      6631     COMM56_REV: 
0F0A    C2AF          6632     	CLR 	EA					; Disable all interrupts
0F0C    754006        6633     	MOV	COMM_PHASE, #6
                      6634     	APFET_OFF 				; Turn off pfet (reverse)
0F0F    C292          6634+1   CLR P1 . 2 
                      6635     	BPFET_ON					; Turn on pfet
0F11    D295          6635+1   SETB P1 . 5 
0F13    D2AF          6636     	SETB	EA
                      6637     	SET_COMP_PHASE_A 			; Set comparator phase (reverse)
0F15    759F81        6637+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F18    020F8D        6638     	JMP	COMM_EXIT
                      6639     
                      6640     
                      6641     ; Comm phase 6 to comm phase 1
                      6642     COMM6COMM1: 	
                      6643     	CLEAR_RPM_OUT
0F1B    307242        6644     JNB FLAGS2 . 2 , COMM61_NONDAMP 
                      6645     
                      6646     	; Comm6Comm1 Damped
0F1E    207D20        6647     JB FLAGS3 . 5 , COMM61_DAMP_REV 
                      6648     
0F21    C2AF          6649     	CLR 	EA					; Disable all interrupts
0F23    754001        6650     	MOV	COMM_PHASE, #1
0F26    90019C        6651     	MOV	DPTR, #PWM_CFET_DAMPED	
0F29    757B40        6652     	MOV	DAMPINGFET, #(1 SHL CPFET)
                      6653     	ANFET_OFF					; Turn off fets
0F2C    C293          6653+1   CLR P1 . 3 
                      6654     	APFET_OFF						
0F2E    C292          6654+1   CLR P1 . 2 
0F30    306204        6655     JNB FLAGS0 . 2 , COMM61_NFET_OFF 
                      6656     	CNFET_ON					; Pwm on - turn on nfet
0F33    D297          6656+1   SETB P1 . 7 
0F35    E139          6657     	AJMP	COMM61_FETS_DONE
                      6658     COMM61_NFET_OFF: 
                      6659     	CPFET_ON					; Pwm off - switch damping fets	
0F37    D296          6659+1   SETB P1 . 6 
                      6660     COMM61_FETS_DONE: 
0F39    D2AF          6661     	SETB	EA
                      6662     	SET_COMP_PHASE_A 			; Set comparator phase
0F3B    759F81        6662+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F3E    020F8D        6663     	LJMP	COMM_EXIT
                      6664     
                      6665     	; Comm6Comm1 Damped reverse
                      6666     COMM61_DAMP_REV: 
0F41    C2AF          6667     	CLR 	EA					; Disable all interrupts
0F43    754001        6668     	MOV	COMM_PHASE, #1
0F46    90017A        6669     	MOV	DPTR, #PWM_AFET_DAMPED	; (reverse)	
0F49    757B04        6670     	MOV	DAMPINGFET, #(1 SHL APFET)	; (reverse)
                      6671     	CNFET_OFF					; Turn off fets (reverse)
0F4C    C297          6671+1   CLR P1 . 7 
                      6672     	CPFET_OFF						
0F4E    C296          6672+1   CLR P1 . 6 
0F50    306204        6673     JNB FLAGS0 . 2 , COMM61_NFET_OFF_REV 
                      6674     	ANFET_ON					; Pwm on - turn on nfet
0F53    D293          6674+1   SETB P1 . 3 
0F55    E159          6675     	AJMP	COMM61_FETS_DONE_REV
                      6676     COMM61_NFET_OFF_REV: 
                      6677     	APFET_ON					; Pwm off - switch damping fets (reverse)	
0F57    D292          6677+1   SETB P1 . 2 
                      6678     COMM61_FETS_DONE_REV: 
0F59    D2AF          6679     	SETB	EA
                      6680     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0F5B    759F89        6680+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F5E    E18D          6681     	AJMP	COMM_EXIT
                      6682     
                      6683     	; Comm6Comm1 Non-damped
                      6684     COMM61_NONDAMP: 
0F60    207D16        6685     JB FLAGS3 . 5 , COMM61_NONDAMP_REV 
                      6686     
0F63    C2AF          6687     	CLR 	EA					; Disable all interrupts
0F65    754001        6688     	MOV	COMM_PHASE, #1
0F68    900170        6689     	MOV	DPTR, #PWM_CFET	
                      6690     	ANFET_OFF					; Turn off nfet
0F6B    C293          6690+1   CLR P1 . 3 
0F6D    306202        6691     JNB FLAGS0 . 2 , COMM61_NFET_DONE 
                      6692     	CNFET_ON					; Yes - turn on nfet
0F70    D297          6692+1   SETB P1 . 7 
                      6693     COMM61_NFET_DONE: 
0F72    D2AF          6694     	SETB	EA
                      6695     	SET_COMP_PHASE_A 			; Set comparator phase
0F74    759F81        6695+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F77    E18D          6696     	AJMP	COMM_EXIT
                      6697     
                      6698     	; Comm6Comm1 Non-damped reverse
                      6699     COMM61_NONDAMP_REV: 
0F79    C2AF          6700     	CLR 	EA					; Disable all interrupts
0F7B    754001        6701     	MOV	COMM_PHASE, #1
0F7E    90015C        6702     	MOV	DPTR, #PWM_AFET		; (reverse)
                      6703     	CNFET_OFF					; Turn off nfet (reverse)
0F81    C297          6703+1   CLR P1 . 7 
0F83    306202        6704     JNB FLAGS0 . 2 , COMM61_NFET_DONE_REV 
                      6705     	ANFET_ON					; Yes - turn on nfet (reverse)
0F86    D293          6705+1   SETB P1 . 3 
                      6706     COMM61_NFET_DONE_REV: 
0F88    D2AF          6707     	SETB	EA
                      6708     	SET_COMP_PHASE_C 			; Set comparator phase (reverse)
0F8A    759F89        6708+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
                      6709     
                      6710     COMM_EXIT: 
0F8D    C266          6711     CLR FLAGS0 . 6 
0F8F    22            6712     	RET
                      6713     
                      6714     
                      6715     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6716     ;
                      6717     ; Switch power off routine
                      6718     ;
                      6719     ; No assumptions
                      6720     ;
                      6721     ; Switches all fets off 
                      6722     ;
                      6723     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6724     SWITCH_POWER_OFF: 
0F90    90015A        6725     	MOV	DPTR, #PWM_NOFET	; Set DPTR register to pwm_nofet		
0F93    757B00        6726     	MOV	DAMPINGFET, #0
                      6727     	ALL_NFETS_OFF			; Turn off all nfets
0F96    C293          6727+1   CLR P1 . 3 
0F98    C297          6727+1   CLR P1 . 7 
0F9A    C294          6727+1   CLR P1 . 4 
                      6728     	ALL_PFETS_OFF			; Turn off all pfets
0F9C    C292          6728+1   CLR P1 . 2 
0F9E    C296          6728+1   CLR P1 . 6 
0FA0    C295          6728+1   CLR P1 . 5 
0FA2    C262          6729     CLR FLAGS0 . 2 
0FA4    22            6730     	RET			
                      6731     
                      6732     
                      6733     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6734     ;
                      6735     ; Set default parameters
                      6736     ;
                      6737     ; No assumptions
                      6738     ;
                      6739     ; Sets default programming parameters
                      6740     ;
                      6741     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6742     SET_DEFAULT_PARAMETERS: 
                      6743     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_SPOOLUP_TIME
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Pwm dither
                               ENDIF
                      6814     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_POWER_PROT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_DITHER
                               ENDIF
                      6885     IF MODE == 2	; Multi
0FA5    7880          6886     MOV R0 , # PGM_GOV_P_GAIN 
0FA7    7609          6887     MOV @ R0 , # 9 
0FA9    08            6888     INC R0 
0FAA    7609          6889     MOV @ R0 , # 9 
0FAC    08            6890     INC R0 
0FAD    7604          6891     MOV @ R0 , # 4 
0FAF    08            6892     INC R0 
0FB0    76FF          6893     MOV @ R0 , # 0FFH 
0FB2    08            6894     INC R0 
0FB3    7603          6895     MOV @ R0 , # 3 
0FB5    08            6896     INC R0 
0FB6    76FF          6897     MOV @ R0 , # 0FFH 
0FB8    08            6898     INC R0 
0FB9    7609          6899     MOV @ R0 , # 9 
0FBB    08            6900     INC R0 
0FBC    7601          6901     MOV @ R0 , # 1 
0FBE    08            6902     INC R0 
0FBF    7601          6903     MOV @ R0 , # 1 
0FC1    08            6904     INC R0 
0FC2    7601          6905     MOV @ R0 , # 1 
                      6906     
0FC4    788C          6907     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
0FC6    7601          6908     MOV @ R0 , # 1 
0FC8    08            6909     INC R0 
0FC9    76FF          6910     MOV @ R0 , # 0FFH 
0FCB    08            6911     INC R0 
0FCC    76FF          6912     MOV @ R0 , # 0FFH 
0FCE    08            6913     INC R0 
0FCF    76FF          6914     MOV @ R0 , # 0FFH 
0FD1    08            6915     INC R0 
0FD2    76FF          6916     MOV @ R0 , # 0FFH 
0FD4    08            6917     INC R0 
0FD5    76FF          6918     MOV @ R0 , # 0FFH 
0FD7    08            6919     INC R0 
0FD8    7603          6920     MOV @ R0 , # 3 
0FDA    08            6921     INC R0 
0FDB    76FF          6922     MOV @ R0 , # 0FFH 
0FDD    08            6923     INC R0 
0FDE    76FF          6924     MOV @ R0 , # 0FFH 
0FE0    08            6925     INC R0 
0FE1    76FF          6926     MOV @ R0 , # 0FFH 
0FE3    08            6927     INC R0 
0FE4    7625          6928     MOV @ R0 , # 37 
0FE6    08            6929     INC R0 
0FE7    76D0          6930     MOV @ R0 , # 208 
0FE9    08            6931     INC R0 
0FEA    7628          6932     MOV @ R0 , # 40 
0FEC    08            6933     INC R0 
0FED    7650          6934     MOV @ R0 , # 80 
0FEF    08            6935     INC R0 
0FF0    7604          6936     MOV @ R0 , # 4 
0FF2    08            6937     INC R0 
0FF3    76FF          6938     MOV @ R0 , # 0FFH 
0FF5    08            6939     INC R0 
0FF6    7602          6940     MOV @ R0 , # 2 
0FF8    08            6941     INC R0 
0FF9    7600          6942     MOV @ R0 , # 0 
0FFB    08            6943     INC R0 
0FFC    767A          6944     MOV @ R0 , # 122 
0FFE    08            6945     INC R0 
0FFF    76FF          6946     MOV @ R0 , # 0FFH 
1001    08            6947     INC R0 
1002    7601          6948     MOV @ R0 , # 1 
1004    08            6949     INC R0 
1005    7601          6950     MOV @ R0 , # 1 
1007    08            6951     INC R0 
1008    7600          6952     MOV @ R0 , # 0 
100A    08            6953     INC R0 
100B    7603          6954     MOV @ R0 , # 3 
                      6955     ENDIF
100D    22            6956     	RET
                      6957     
                      6958     
                      6959     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6960     ;
                      6961     ; Decode parameters
                      6962     ;
                      6963     ; No assumptions
                      6964     ;
                      6965     ; Decodes programming parameters
                      6966     ;
                      6967     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6968     DECODE_PARAMETERS: 
                      6969     	; Load programmed pwm frequency
100E    7887          6970     MOV R0 , # PGM_PWM_FREQ 
1010    E6            6971     MOV A , @ R0 
1011    FF            6972     MOV R7 , A 
1012    C272          6973     CLR FLAGS2 . 2 
                      6974     IF DAMPED_MODE_ENABLE == 1
1014    BF0302        6975     CJNE R7 , # 3 , ( $+5 ) 
1017    D272          6976     SETB FLAGS2 . 2 
                      6977     ENDIF
                      6978     	; Load programmed direction
1019    7888          6979     MOV R0 , # PGM_DIRECTION 
                      6980     IF MODE >= 1	; Tail or multi
101B    E6            6981     MOV A , @ R0 
101C    C3            6982     	CLR	C
101D    9403          6983     	SUBB	A, #3
101F    6008          6984     	JZ	DECODE_PARAMS_DIR_SET
                      6985     ENDIF
                      6986     
1021    C27D          6987     CLR FLAGS3 . 5 
1023    E6            6988     MOV A , @ R0 
1024    30E102        6989     	JNB	ACC.1, ($+5)
1027    D27D          6990     SETB FLAGS3 . 5 
                      6991     DECODE_PARAMS_DIR_SET: 
1029    C27E          6992     CLR FLAGS3 . 6 
102B    7889          6993     MOV R0 , # PGM_INPUT_POL 
102D    E6            6994     MOV A , @ R0 
102E    30E102        6995     	JNB	ACC.1, ($+5)
1031    D27E          6996     SETB FLAGS3 . 6 
1033    C3            6997     	CLR	C
1034    EF            6998     MOV A , R7 
1035    9402          6999     	SUBB	A, #2
1037    6008          7000     	JZ	DECODE_PWM_FREQ_LOW
                      7001     
1039    758E01        7002     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
103C    D273          7003     SETB FLAGS2 . 3 
103E    021046        7004     	JMP	DECODE_PWM_FREQ_END
                      7005     
                      7006     DECODE_PWM_FREQ_LOW: 
1041    758E00        7007     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
1044    C273          7008     CLR FLAGS2 . 3 
                      7009     
                      7010     DECODE_PWM_FREQ_END: 
1046    22            7011     	RET
                      7012     
                      7013     
                      7014     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7015     ;
                      7016     ; Decode settings
                      7017     ;
                      7018     ; No assumptions
                      7019     ;
                      7020     ; Decodes various settings
                      7021     ;
                      7022     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7023     DECODE_SETTINGS: 
                      7024     	; Decode governor gains
1047    7880          7025     MOV R0 , # PGM_GOV_P_GAIN 
1049    E6            7026     MOV A , @ R0 
104A    14            7027     	DEC	A	
104B    900080        7028     	MOV	DPTR, #GOV_GAIN_TABLE
104E    93            7029     	MOVC A, @A+DPTR	
104F    78A4          7030     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
1051    F6            7031     MOV @ R0 , A 
1052    7881          7032     MOV R0 , # PGM_GOV_I_GAIN 
1054    E6            7033     MOV A , @ R0 
1055    14            7034     	DEC	A	
1056    900080        7035     	MOV	DPTR, #GOV_GAIN_TABLE
1059    93            7036     	MOVC A, @A+DPTR	
105A    78A5          7037     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
105C    F6            7038     MOV @ R0 , A 
                      7039     	; Decode startup power
105D    7886          7040     MOV R0 , # PGM_STARTUP_PWR 
105F    E6            7041     MOV A , @ R0 
1060    14            7042     	DEC	A	
1061    90008D        7043     	MOV	DPTR, #STARTUP_POWER_TABLE
1064    93            7044     	MOVC A, @A+DPTR	
1065    78A6          7045     MOV R0 , # PGM_STARTUP_PWR_DECODED 
1067    F6            7046     MOV @ R0 , A 
                      7047     IF MODE == 0	; Main
                               	; Decode spoolup time
                               	MOV	TEMP1, #PGM_MAIN_SPOOLUP_TIME		
                               	MOV	A, @TEMP1
                               	MOV	TEMP1, A		; Store
                               	JNZ	($+3)		; If not zero - branch
                               	
                               	INC	TEMP1
                               
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #17		; Limit to 17 max
                               	JC	($+4)
                               
                               	MOV	TEMP1, #17
                               
                               	MOV	A, TEMP1
                               	ADD	A, TEMP1
                               	ADD	A, TEMP1		; Now 3x
                               	MOV	MAIN_SPOOLUP_TIME_3X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		; Now 10x
                               	MOV	MAIN_SPOOLUP_TIME_10X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		
                               	ADD	A, TEMP1		; Now 15x
                               	MOV	MAIN_SPOOLUP_TIME_15X, A
                               ENDIF
                      7076     	; Decode demag compensation
1068    789C          7077     MOV R0 , # PGM_DEMAG_COMP 
106A    E6            7078     MOV A , @ R0 
106B    7537FF        7079     	MOV	DEMAG_PWR_OFF_THRESH, #255	; Set default
106E    75380C        7080     	MOV	LOW_RPM_PWR_SLOPE, #12		; Set default
                      7081     
1071    B40206        7082     	CJNE	A, #2, DECODE_DEMAG_HIGH
                      7083     
1074    7537A0        7084     	MOV	DEMAG_PWR_OFF_THRESH, #160	; Settings for demag comp low
1077    75380A        7085     	MOV	LOW_RPM_PWR_SLOPE, #10		
                      7086     
                      7087     DECODE_DEMAG_HIGH: 
107A    B40306        7088     	CJNE	A, #3, DECODE_DEMAG_DONE
                      7089     
107D    753782        7090     	MOV	DEMAG_PWR_OFF_THRESH, #130	; Settings for demag comp high
1080    753805        7091     	MOV	LOW_RPM_PWR_SLOPE, #5		
                      7092     
                      7093     DECODE_DEMAG_DONE: 
                      7094     	; Decode pwm dither
1083    78A3          7095     MOV R0 , # PGM_PWM_DITHER 
1085    E6            7096     MOV A , @ R0 
1086    14            7097     	DEC	A	
1087    90009A        7098     	MOV	DPTR, #PWM_DITHER_TABLE
108A    93            7099     	MOVC A, @A+DPTR	
108B    F566          7100     	MOV	PWM_DITHER_DECODED, A
108D    120F90        7101     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1090    22            7102     	RET
                      7103     
                      7104     
                      7105     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7106     ;
                      7107     ; Set BEC voltage
                      7108     ;
                      7109     ; No assumptions
                      7110     ;
                      7111     ; Sets the BEC output voltage low or high
                      7112     ;
                      7113     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7114     SET_BEC_VOLTAGE: 
                      7115     	; Set bec voltage
                      7116     IF HIGH_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
                      7126     IF HIGH_BEC_VOLTAGE == 2
                               	SET_BEC_0				; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	CJNE	A, #1, SET_BEC_VOLTAGE_2	
                               
                               	SET_BEC_1				; Set to level 1
                               
                               SET_BEC_VOLTAGE_2:
                               	CJNE	A, #2, SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_2				; Set to level 2
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
1091    22            7141     	RET
                      7142     
                      7143     
                      7144     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7145     ;
                      7146     ; Find throttle gain
                      7147     ;
                      7148     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      7149     ;
                      7150     ; Finds throttle gain from throttle calibration values
                      7151     ;
                      7152     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7153     FIND_THROTTLE_GAIN: 
                      7154     	; Load programmed minimum and maximum throttle
1092    7896          7155     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1094    E6            7156     MOV A , @ R0 
1095    FA            7157     MOV R2 , A 
1096    7897          7158     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1098    E6            7159     MOV A , @ R0 
1099    FB            7160     MOV R3 , A 
109A    7888          7161     MOV R0 , # PGM_DIRECTION 
109C    E6            7162     MOV A , @ R0 
109D    B40305        7163     	CJNE	A, #3, FIND_THROTTLE_GAIN_CHECK_FULL
                      7164     
10A0    C3            7165     	CLR	C
10A1    EB            7166     MOV A , R3 
10A2    940E          7167     	SUBB	A, #14				; Compensate for higher deadband in bidirectional
10A4    FB            7168     MOV R3 , A 
                      7169     
                      7170     FIND_THROTTLE_GAIN_CHECK_FULL: 
                      7171     	; Check if full range is chosen
10A5    307F04        7172     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      7173     
10A8    7A00          7174     MOV R2 , # 0 
10AA    7BFF          7175     MOV R3 , # 255 
                      7176     
                      7177     FIND_THROTTLE_GAIN_CALCULATE: 
                      7178     	; Calculate difference
10AC    C3            7179     	CLR	C
10AD    EB            7180     MOV A , R3 
10AE    9A            7181     SUBB A , R2 
10AF    FC            7182     MOV R4 , A 
                      7183     	; Check that difference is minimum 130
10B0    C3            7184     	CLR	C
10B1    9482          7185     	SUBB	A, #130
10B3    5002          7186     	JNC	($+4)
                      7187     
10B5    7C82          7188     MOV R4 , # 130 
                      7189     
                      7190     	; Find gain
10B7    757200        7191     	MOV	PPM_THROTTLE_GAIN, #0
                      7192     TEST_THROTTLE_GAIN: 
10BA    0572          7193     	INC	PPM_THROTTLE_GAIN
10BC    EC            7194     MOV A , R4 
10BD    8572F0        7195     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
10C0    A4            7196     	MUL	AB
10C1    C3            7197     	CLR	C
10C2    E5F0          7198     	MOV	A, B
10C4    947D          7199     	SUBB	A, #125
10C6    40F2          7200     	JC	TEST_THROTTLE_GAIN
10C8    22            7201     	RET
                      7202     
                      7203     
                      7204     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7205     ;
                      7206     ; Average throttle 
                      7207     ;
                      7208     ; Outputs result in Temp3
                      7209     ;
                      7210     ; Averages throttle calibration readings
                      7211     ;
                      7212     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7213     AVERAGE_THROTTLE: 
10C9    D27F          7214     SETB FLAGS3 . 7 
10CB    1192          7215     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
10CD    120616        7216     	CALL WAIT30MS		
10D0    7A00          7217     MOV R2 , # 0 
10D2    7B00          7218     MOV R3 , # 0 
10D4    7C10          7219     MOV R4 , # 16 
                      7220     AVERAGE_THROTTLE_MEAS: 
10D6    12060C        7221     	CALL	WAIT3MS			; Wait for new RC pulse value
10D9    E55C          7222     	MOV	A, NEW_RCP		; Get new RC pulse value
10DB    2A            7223     ADD A , R2 
10DC    FA            7224     MOV R2 , A 
10DD    7400          7225     	MOV	A, #0
10DF    3B            7226     ADDC A , R3 
10E0    FB            7227     MOV R3 , A 
10E1    DCF3          7228     DJNZ R4 , AVERAGE_THROTTLE_MEAS 
                      7229     
10E3    7C04          7230     MOV R4 , # 4 
                      7231     AVERAGE_THROTTLE_DIV: 
10E5    C3            7232     	CLR	C
10E6    EB            7233     MOV A , R3 
10E7    13            7234     	RRC	A      
10E8    FB            7235     MOV R3 , A 
10E9    EA            7236     MOV A , R2 
10EA    13            7237     	RRC	A      
10EB    FA            7238     MOV R2 , A 
10EC    DCF7          7239     DJNZ R4 , AVERAGE_THROTTLE_DIV 
                      7240     
10EE    FE            7241     MOV R6 , A 
10EF    C27F          7242     CLR FLAGS3 . 7 
10F1    1192          7243     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
10F3    22            7244     	RET
                      7245     
                      7246     
                      7247     
                      7248     
                      7249     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7250     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7251     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7252     ;
                      7253     ; Main program start
                      7254     ;
                      7255     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7256     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7257     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7258     PGM_START: 
                      7259     	; Check flash lock byte
10F4    E5EF          7260     	MOV	A, RSTSRC			
10F6    20E603        7261     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      7262     
10F9    752000        7263     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      7264     
10FC    0520          7265     	INC	BIT_ACCESS
10FE    903FFF        7266     MOV DPTR , # 16383 
1101    E520          7267     	MOV	A, BIT_ACCESS
1103    14            7268     	DEC	A
1104    6006          7269     	JZ	LOCK_BYTE_TEST
                      7270     
1106    901FFF        7271     MOV DPTR , # 8191 
1109    14            7272     	DEC	A
110A    6000          7273     	JZ	LOCK_BYTE_TEST
                      7274     
                      7275     LOCK_BYTE_TEST: 
110C    93            7276     	MOVC A, @A+DPTR		; Read lock byte
110D    04            7277     	INC	A				
110E    6003          7278     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      7279     
                      7280     IF ONE_S_CAPABLE == 0		
1110    75EF12        7281     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      7282     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      7285     
                      7286     LOCK_BYTE_OK: 
                      7287     	; Disable the WDT.
                      7288     IF SIGNATURE_001 == 0F3H		
1113    53D9BF        7289     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      7290     ENDIF
                      7291     IF SIGNATURE_001 == 0F8H		
                               	MOV	WDTCN, #0DEH		; Disable watchdog
                               	MOV	WDTCN, #0ADH		
                               ENDIF
                      7295     	; Initialize stack
1116    7581C0        7296     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      7297     	; Initialize VDD monitor
1119    43FF80        7298     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
111C    120607        7299     	CALL	WAIT1MS			; Wait at least 100us
                      7300     IF ONE_S_CAPABLE == 0		
111F    75EF02        7301     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      7302     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      7305     	; Set clock frequency
                      7306     IF SIGNATURE_001 == 0F3H		
1122    43B203        7307     	ORL	OSCICN, #03H		; Set clock divider to 1 (not supported on 'f850)
                      7308     ENDIF
                      7309     IF SIGNATURE_001 == 0F8H		
                               	MOV	CLKSEL, #00H		; Set clock divider to 1 (not supported on 'f3xx)
                               ENDIF
1125    E5B3          7312     	MOV	A, OSCICL				
1127    2404          7313     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
1129    20E70D        7314     	JB	ACC.7, RESET_CAL_DONE	; Is carry (7bit) set? - branch
                      7315     
112C    F521          7316     	MOV	BIT_ACCESS_INT, A
                      7317     IF SIGNATURE_002 <> 010H		
112E    E5E3          7318     	MOV	A, OSCLCN
                      7319     ELSE
                               	MOV	A, OSCXCN
                               ENDIF
1130    20E006        7322     	JB	ACC.0, RESET_CAL_DONE	; Set if cal aleady done
                      7323     
1133    8521B3        7324     	MOV	OSCICL, BIT_ACCESS_INT
                      7325     IF SIGNATURE_002 <> 010H		
1136    43E301        7326     	ORL	OSCLCN, #01H			; Tag that cal is done
                      7327     ELSE
                               	ORL	OSCXCN, #01H			; Tag that cal is done
                               ENDIF
                      7330     
                      7331     RESET_CAL_DONE: 
                      7332     	; Switch power off
1139    120F90        7333     	CALL	SWITCH_POWER_OFF
                      7334     	; Ports initialization
113C    7580FF        7335     MOV P0 , # 255 
113F    75A400        7336     MOV P0MDOUT , # 0 
1142    75F1F0        7337     MOV P0MDIN , # -16 
1145    75D4DF        7338     MOV P0SKIP , # -33 
1148    759002        7339     MOV P1 , # 2 
114B    75A5FC        7340     MOV P1MDOUT , # 252 
114E    75F2FD        7341     MOV P1MDIN , # -3 
1151    75D502        7342     MOV P1SKIP , # 2 
                      7343     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
1154    75A610        7346     MOV P2MDOUT , # 16 
                      7347     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      7354     	; Initialize the XBAR and related functionality
                      7355     	INITIALIZE_XBAR
1157    75A0FF        7355+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
115A    75F3F1        7355+1   MOV P2MDIN , # -15 
115D    75E241        7355+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      7356     	; Clear RAM
1160    E4            7357     	CLR	A				; Clear accumulator
1161    F8            7358     MOV R0 , A 
                      7359     CLEAR_RAM: 	
1162    F6            7360     MOV @ R0 , A 
1163    D8FD          7361     DJNZ R0 , CLEAR_RAM 
                      7362     	; Initialize LFSR
1165    756801        7363     	MOV	RANDOM, #1
                      7364     	; Set default programmed parameters
1168    120FA5        7365     	CALL	SET_DEFAULT_PARAMETERS
                      7366     	; Read all programmed parameters
116B    121697        7367     	CALL READ_ALL_EEPROM_PARAMETERS
                      7368     	; Set beep strength
116E    7898          7369     MOV R0 , # PGM_BEEP_STRENGTH 
1170    8673          7370     MOV BEEP_STRENGTH , @ R0 
                      7371     	; Set initial arm variable
1172    753001        7372     	MOV	INITIAL_ARM, #1
                      7373     	; Initializing beep
1175    C2AF          7374     	CLR	EA				; Disable interrupts explicitly
1177    120620        7375     	CALL WAIT200MS	
117A    120630        7376     	CALL BEEP_F1
117D    120616        7377     	CALL WAIT30MS
1180    120637        7378     	CALL BEEP_F2
1183    120616        7379     	CALL WAIT30MS
1186    12063E        7380     	CALL BEEP_F3
1189    120616        7381     	CALL WAIT30MS
                      7382     IF MODE <= 1	; Main or tail
                               	; Wait for receiver to initialize
                               	CALL	WAIT1S
                               	CALL	WAIT200MS
                               	CALL	WAIT200MS
                               	CALL	WAIT100MS
                               ENDIF
                      7389     
                      7390     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7391     ;
                      7392     ; No signal entry point
                      7393     ;
                      7394     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7395     INIT_NO_SIGNAL: 
                      7396     	; Disable interrupts explicitly
118C    C2AF          7397     	CLR	EA				
                      7398     	; Check if input signal is high for more than 15ms
118E    78FA          7399     MOV R0 , # 250 
                      7400     INPUT_HIGH_CHECK_1: 
1190    79FA          7401     MOV R1 , # 250 
                      7402     INPUT_HIGH_CHECK_2: 
1192    308507        7403     JNB 128 . 5 , BOOTLOADER_DONE 
1195    D9FB          7404     DJNZ R1 , INPUT_HIGH_CHECK_2 
1197    D8F7          7405     DJNZ R0 , INPUT_HIGH_CHECK_1 
                      7406     
1199    021C00        7407     	LJMP	1C00H			; Jump to bootloader
                      7408     
                      7409     BOOTLOADER_DONE: 
                      7410     	; Decode parameters
119C    110E          7411     	CALL	DECODE_PARAMETERS
                      7412     	; Decode settings
119E    1147          7413     	CALL	DECODE_SETTINGS
                      7414     	; Set BEC voltage
11A0    1191          7415     	CALL	SET_BEC_VOLTAGE
                      7416     	; Find throttle gain from stored min and max settings
11A2    1192          7417     	CALL	FIND_THROTTLE_GAIN
                      7418     	; Set beep strength
11A4    7898          7419     MOV R0 , # PGM_BEEP_STRENGTH 
11A6    8673          7420     MOV BEEP_STRENGTH , @ R0 
                      7421     	; Switch power off
11A8    120F90        7422     	CALL	SWITCH_POWER_OFF
                      7423     	; Set clock frequency
                      7424     IF MCU_48MHZ == 1
                      7425     	SET_MCU_CLK_24MHZ
11AB    75B680        7425+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
11AE    75A900        7425+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
11B1    757A00        7425+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      7426     ENDIF
                      7427     	; Timer control
11B4    758850        7428     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      7429     	; Timer mode
11B7    758912        7430     	MOV	TMOD, #12H		; Timer0 as 8bit, timer1 as 16bit
                      7431     	; Timer2: clk/12 for 128us and 32ms interrupts
11BA    75C824        7432     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      7433     	; Timer3: clk/12 for commutation timing
11BD    759104        7434     	MOV	TMR3CN, #04H		; Timer3 enabled
                      7435     	; PCA
11C0    75D840        7436     	MOV	PCA0CN, #40H		; PCA enabled
                      7437     	; Enable interrupts
11C3    75A822        7438     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
11C6    75B802        7439     	MOV	IP, #02H			; High priority to timer0 interrupts
11C9    75E690        7440     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      7441     	; Initialize comparator
11CC    759B80        7442     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
11CF    759D00        7443     	MOV	CPT0MD, #00H		; Comparator response time 100ns
                      7444     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #00H		; Comparator response time 100ns
                               ENDIF
                      7448     	; Initialize ADC
                      7449     	INITIALIZE_ADC			; Initialize ADC operation
11D2    75D10E        7449+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
                      7449+1   IF MCU_50MHZ ==0 
11D5    75BC58        7449+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
                      7449+1   ELSE 
                               MOV ADC0CF , # 0C0H  ; ADC CLOCK 2MHZ
                               ENDIF 
11D8    75BB09        7449+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
11DB    75BA11        7449+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
11DE    75E880        7449+1   MOV ADC0CN , # 80H  ; ADC ENABLED
11E1    120607        7450     	CALL	WAIT1MS
11E4    D2AF          7451     	SETB	EA				; Enable all interrupts
                      7452     	; Measure number of lipo cells
11E6    120916        7453     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      7454     	; Initialize RC pulse
                      7455     	RCP_INT_FIRST 					; Enable interrupt and set to first edge
11E9    53DACF        7455+1   ANL PCA0CPM0 , # 0CFH 
11EC    207E03        7455+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
11EF    43DA20        7455+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
11F2    307E03        7455+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
11F5    43DA10        7455+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7456     	RCP_INT_ENABLE		 			; Enable interrupt
11F8    43DA01        7456+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      7457     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
11FB    C2D8          7457+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
11FD    C271          7458     CLR FLAGS2 . 1 
11FF    120620        7459     	CALL WAIT200MS
                      7460     
                      7461     	; Measure PWM frequency
                      7462     MEASURE_PWM_FREQ_INIT: 	
1202    D261          7463     SETB FLAGS0 . 1 
1204    7B03          7464     MOV R3 , # 3 
                      7465     MEASURE_PWM_FREQ_START: 	
1206    7A0C          7466     MOV R2 , # 12 
                      7467     MEASURE_PWM_FREQ_LOOP: 	
                      7468     	; Check if period diff was accepted
1208    E55B          7469     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
120A    7007          7470     	JNZ	MEASURE_PWM_FREQ_WAIT
                      7471     
120C    7A0C          7472     MOV R2 , # 12 
120E    DB03          7473     DJNZ R3 , ( $+5 ) 
1210    02118C        7474     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      7475     
                      7476     MEASURE_PWM_FREQ_WAIT: 
1213    120616        7477     	CALL	WAIT30MS						; Wait 30ms for new pulse
1216    207003        7478     JB FLAGS2 . 0 , ( $+6 ) 
1219    02118C        7479     	LJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      7480     
121C    C270          7481     CLR FLAGS2 . 0 
121E    E55C          7482     	MOV	A, NEW_RCP					; Load value
1220    C3            7483     	CLR	C
1221    9402          7484     SUBB A , # 2 
1223    40E1          7485     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      7486     
1225    E52F          7487     	MOV	A, FLAGS3						; Check pwm frequency flags
1227    541F          7488     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1229    855E5D        7489     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
122C    F55E          7490     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
122E    B55DD5        7491     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      7492     
1231    DAD5          7493     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      7494     
                      7495     	; Clear measure pwm frequency flag
1233    C261          7496     CLR FLAGS0 . 1 
                      7497     	; Set up RC pulse interrupts after pwm frequency measurement
                      7498     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
1235    53DACF        7498+1   ANL PCA0CPM0 , # 0CFH 
1238    207E03        7498+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
123B    43DA20        7498+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
123E    307E03        7498+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1241    43DA10        7498+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      7499     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
1244    C2D8          7499+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1246    C271          7500     CLR FLAGS2 . 1 
1248    78A2          7501     MOV R0 , # PGM_ENABLE_PWM_INPUT 
124A    E6            7502     MOV A , @ R0 
124B    7008          7503     	JNZ	TEST_FOR_ONESHOT				; If it is - proceed
                      7504     
124D    D274          7505     SETB FLAGS2 . 4 
124F    E52F          7506     	MOV	A, FLAGS3						; Clear pwm frequency flags
1251    54E0          7507     	ANL	A, #NOT((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1253    F52F          7508     	MOV	FLAGS3, A
                      7509     
                      7510     TEST_FOR_ONESHOT: 	
                      7511     	; Test whether signal is OneShot125
1255    C275          7512     CLR FLAGS2 . 5 
1257    752900        7513     	MOV	RCP_OUTSIDE_RANGE_CNT, #0		; Reset out of range counter
125A    12061B        7514     	CALL WAIT100MS						; Wait for new RC pulse
125D    307409        7515     JNB FLAGS2 . 4 , VALIDATE_RCP_START 
                      7516     
1260    C3            7517     	CLR	C
1261    E529          7518     	MOV	A, RCP_OUTSIDE_RANGE_CNT			; Check how many pulses were outside normal PPM range (800-2160us)
1263    940A          7519     	SUBB	A, #10						
1265    4002          7520     	JC	VALIDATE_RCP_START
                      7521     
1267    D275          7522     SETB FLAGS2 . 5 
                      7523     
                      7524     	; Validate RC pulse
                      7525     VALIDATE_RCP_START: 	
1269    12060C        7526     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
126C    7802          7527     MOV R0 , # 2 
126E    307402        7528     JNB FLAGS2 . 4 , ( $+5 ) 
                      7529     
1271    7800          7530     MOV R0 , # 0 
                      7531     
1273    C3            7532     	CLR	C
1274    E55C          7533     	MOV	A, NEW_RCP					; Load value
1276    98            7534     SUBB A , R0 
1277    40F0          7535     	JC	VALIDATE_RCP_START				; No - start over
                      7536     
                      7537     	; Beep arm sequence start signal
1279    C2AF          7538     	CLR 	EA							; Disable all interrupts
127B    120630        7539     	CALL BEEP_F1						; Signal that RC pulse is ready
127E    120630        7540     	CALL BEEP_F1
1281    120630        7541     	CALL BEEP_F1
1284    D2AF          7542     	SETB	EA							; Enable all interrupts
1286    120620        7543     	CALL WAIT200MS	
                      7544     
                      7545     	; Arming sequence start
1289    754A00        7546     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      7547     ARMING_START: 
                      7548     IF MODE >= 1	; Tail or multi
128C    7888          7549     MOV R0 , # PGM_DIRECTION 
128E    E6            7550     MOV A , @ R0 
128F    B40302        7551     	CJNE	A, #3, ($+5)
                      7552     
1292    6168          7553     	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                      7554     ENDIF
                      7555     
1294    12060C        7556     	CALL WAIT3MS
1297    788C          7557     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1299    E6            7558     MOV A , @ R0 
129A    C3            7559     	CLR	C
129B    9401          7560     	SUBB	A, #1				; Is TX programming enabled?
129D    5003          7561     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      7562     
129F    021368        7563     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7564     
                      7565     ARMING_INITIAL_ARM_CHECK: 
12A2    E530          7566     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
12A4    C3            7567     	CLR	C
12A5    9401          7568     	SUBB	A, #1				; Is it the initial arm sequence?
12A7    5003          7569     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      7570     
12A9    021368        7571     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      7572     
                      7573     ARMING_PPM_CHECK: 
12AC    207435        7574     JB FLAGS2 . 4 , THROTTLE_HIGH_CAL_START 
                      7575     
                      7576     	; PWM tx program entry
12AF    C3            7577     	CLR	C
12B0    E55C          7578     	MOV	A, NEW_RCP			; Load new RC pulse value
12B2    94FF          7579     SUBB A , # 255 
12B4    5003          7580     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      7581     
12B6    021368        7582     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7583     
                      7584     PROGRAM_BY_TX_ENTRY_PWM: 	
12B9    C2AF          7585     	CLR	EA					; Disable all interrupts
12BB    120645        7586     	CALL BEEP_F4
12BE    D2AF          7587     	SETB	EA					; Enable all interrupts
12C0    12061B        7588     	CALL WAIT100MS
12C3    C3            7589     	CLR	C
12C4    E55C          7590     	MOV	A, NEW_RCP			; Load new RC pulse value
12C6    9401          7591     SUBB A , # 1 
12C8    50EF          7592     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      7593     
                      7594     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
12CA    C2AF          7595     	CLR	EA					; Disable all interrupts
12CC    120630        7596     	CALL BEEP_F1
12CF    120611        7597     	CALL WAIT10MS
12D2    120630        7598     	CALL BEEP_F1
12D5    D2AF          7599     	SETB	EA					; Enable all interrupts
12D7    12061B        7600     	CALL WAIT100MS
12DA    C3            7601     	CLR	C
12DB    E55C          7602     	MOV	A, NEW_RCP			; Load new RC pulse value
12DD    94FF          7603     SUBB A , # 255 
12DF    40E9          7604     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      7605     
12E1    02183F        7606     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7607     
                      7608     	; PPM throttle calibration and tx program entry
                      7609     THROTTLE_HIGH_CAL_START: 
                      7610     IF MODE <= 1	; Main or tail
                               	MOV	TEMP8, #5				; Set 3 seconds wait time
                               ELSE
12E4    7F02          7613     MOV R7 , # 2 
                      7614     ENDIF
                      7615     THROTTLE_HIGH_CAL: 			
12E6    D27F          7616     SETB FLAGS3 . 7 
12E8    1192          7617     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
12EA    12061B        7618     	CALL WAIT100MS				; Wait for new throttle value
12ED    C2AF          7619     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
12EF    C27F          7620     CLR FLAGS3 . 7 
12F1    1192          7621     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
12F3    AE5C          7622     MOV R6 , NEW_RCP 
12F5    C3            7623     	CLR	C
12F6    E55C          7624     	MOV	A, NEW_RCP			; Load new RC pulse value
12F8    947F          7625     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
12FA    D2AF          7626     	SETB	EA					; Enable interrupts
12FC    4074          7627     	JC	ARM_TARGET_UPDATED		; No - branch
                      7628     
12FE    120607        7629     	CALL WAIT1MS		
1301    C2AF          7630     	CLR	EA					; Disable all interrupts
1303    120645        7631     	CALL BEEP_F4
1306    D2AF          7632     	SETB	EA					; Enable all interrupts
1308    DFDC          7633     DJNZ R7 , THROTTLE_HIGH_CAL 
                      7634     
130A    11C9          7635     	CALL	AVERAGE_THROTTLE
130C    C3            7636     	CLR	C
130D    EE            7637     MOV A , R6 
130E    9405          7638     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
1310    7897          7639     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1312    F6            7640     MOV @ R0 , A 
1313    120620        7641     	CALL WAIT200MS				
1316    1216D9        7642     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
1319    1217C2        7643     	CALL	SUCCESS_BEEP
                      7644     
                      7645     THROTTLE_LOW_CAL_START: 
131C    7F0A          7646     MOV R7 , # 10 
                      7647     THROTTLE_LOW_CAL: 			
131E    D27F          7648     SETB FLAGS3 . 7 
1320    1192          7649     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1322    12061B        7650     	CALL WAIT100MS
1325    C2AF          7651     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
1327    C27F          7652     CLR FLAGS3 . 7 
1329    1192          7653     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
132B    AE5C          7654     MOV R6 , NEW_RCP 
132D    C3            7655     	CLR	C
132E    E55C          7656     	MOV	A, NEW_RCP			; Load new RC pulse value
1330    947F          7657     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
1332    D2AF          7658     	SETB	EA					; Enable interrupts
1334    50E6          7659     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      7660     
1336    120607        7661     	CALL WAIT1MS		
1339    C2AF          7662     	CLR	EA					; Disable all interrupts
133B    120630        7663     	CALL BEEP_F1
133E    120611        7664     	CALL WAIT10MS
1341    120630        7665     	CALL BEEP_F1
1344    D2AF          7666     	SETB	EA					; Enable all interrupts
1346    DFD6          7667     DJNZ R7 , THROTTLE_LOW_CAL 
                      7668     
1348    11C9          7669     	CALL	AVERAGE_THROTTLE
134A    EE            7670     MOV A , R6 
134B    2405          7671     	ADD	A, #5				; Add about 2%
134D    7896          7672     MOV R0 , # PGM_PPM_MIN_THROTTLE 
134F    F6            7673     MOV @ R0 , A 
1350    120620        7674     	CALL WAIT200MS				
1353    1216D9        7675     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
1356    1217F1        7676     	CALL	SUCCESS_BEEP_INVERTED
                      7677     
                      7678     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
1359    12061B        7679     	CALL WAIT100MS
135C    1192          7680     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
135E    C3            7681     	CLR	C
135F    E55C          7682     	MOV	A, NEW_RCP			; Load new RC pulse value
1361    94FF          7683     SUBB A , # 255 
1363    40F4          7684     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      7685     
1365    02183F        7686     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7687     
                      7688     PROGRAM_BY_TX_CHECKED: 
1368    C3            7689     	CLR	C
1369    E55C          7690     	MOV	A, NEW_RCP			; Load new RC pulse value
136B    954A          7691     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
136D    4003          7692     	JC	ARM_TARGET_UPDATED		; No - do not update
                      7693     
136F    855C4A        7694     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      7695     
                      7696     ARM_TARGET_UPDATED: 
1372    12061B        7697     	CALL WAIT100MS				; Wait for new throttle value
1375    7801          7698     MOV R0 , # 1 
1377    7988          7699     MOV R1 , # PGM_DIRECTION 
1379    E7            7700     MOV A , @ R1 
137A    B40302        7701     	CJNE	A, #3, ($+5)			; No - branch
                      7702     
137D    7805          7703     MOV R0 , # ( RCP_STOP+4 ) 
                      7704     
137F    C3            7705     	CLR	C
1380    E55C          7706     	MOV	A, NEW_RCP			; Load new RC pulse value
1382    98            7707     SUBB A , R0 
1383    4002          7708     	JC	ARM_END_BEEP			; Yes - proceed
                      7709     
1385    418C          7710     	JMP	ARMING_START			; No - start over
                      7711     
                      7712     ARM_END_BEEP: 
                      7713     	; Beep arm sequence end signal
1387    C2AF          7714     	CLR 	EA					; Disable all interrupts
1389    120645        7715     	CALL BEEP_F4				; Signal that rcpulse is ready
138C    120645        7716     	CALL BEEP_F4
138F    120645        7717     	CALL BEEP_F4
1392    D2AF          7718     	SETB	EA					; Enable all interrupts
1394    120620        7719     	CALL WAIT200MS
                      7720     
                      7721     	; Clear initial arm variable
1397    753000        7722     	MOV	INITIAL_ARM, #0
                      7723     
                      7724     	; Armed and waiting for power on
                      7725     WAIT_FOR_POWER_ON: 
139A    E4            7726     	CLR	A
139B    F531          7727     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
139D    F532          7728     	MOV	POWER_ON_WAIT_CNT_H, A	
                      7729     WAIT_FOR_POWER_ON_LOOP: 
139F    0531          7730     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
13A1    E531          7731     	MOV	A, POWER_ON_WAIT_CNT_L
13A3    F4            7732     	CPL	A
13A4    7039          7733     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      7734     
13A6    0532          7735     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
13A8    789A          7736     MOV R0 , # PGM_BEACON_DELAY 
13AA    E6            7737     MOV A , @ R0 
13AB    7819          7738     MOV R0 , # 25 
13AD    14            7739     	DEC	A
13AE    6012          7740     	JZ	BEEP_DELAY_SET
                      7741     
13B0    7832          7742     MOV R0 , # 50 
13B2    14            7743     	DEC	A
13B3    600D          7744     	JZ	BEEP_DELAY_SET
                      7745     
13B5    787D          7746     MOV R0 , # 125 
13B7    14            7747     	DEC	A
13B8    6008          7748     	JZ	BEEP_DELAY_SET
                      7749     
13BA    78FA          7750     MOV R0 , # 250 
13BC    14            7751     	DEC	A
13BD    6003          7752     	JZ	BEEP_DELAY_SET
                      7753     
13BF    753200        7754     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      7755     
                      7756     BEEP_DELAY_SET: 
13C2    C3            7757     	CLR	C
13C3    E532          7758     	MOV	A, POWER_ON_WAIT_CNT_H
13C5    98            7759     SUBB A , R0 
13C6    4017          7760     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      7761     
13C8    1532          7762     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
13CA    7531B4        7763     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
13CD    7899          7764     MOV R0 , # PGM_BEACON_STRENGTH 
13CF    8673          7765     MOV BEEP_STRENGTH , @ R0 
13D1    C2AF          7766     	CLR 	EA					; Disable all interrupts
13D3    120645        7767     	CALL BEEP_F4				; Signal that there is no signal
13D6    D2AF          7768     	SETB	EA					; Enable all interrupts
13D8    7898          7769     MOV R0 , # PGM_BEEP_STRENGTH 
13DA    8673          7770     MOV BEEP_STRENGTH , @ R0 
13DC    12061B        7771     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      7772     
                      7773     WAIT_FOR_POWER_ON_NO_BEEP: 
13DF    120611        7774     	CALL WAIT10MS
13E2    E52A          7775     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
13E4    7005          7776     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      7777     
13E6    307402        7778     JNB FLAGS2 . 4 , WAIT_FOR_POWER_ON_PPM_NOT_MISSING 
                      7779     
13E9    218C          7780     	JMP	INIT_NO_SIGNAL					; If ppm and pulses missing - go back to detect input signal
                      7781     
                      7782     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
13EB    7801          7783     MOV R0 , # 1 
13ED    207402        7784     JB FLAGS2 . 4 , ( $+5 ) 
                      7785     
13F0    7806          7786     MOV R0 , # ( RCP_STOP+5 ) 
                      7787     
13F2    C3            7788     	CLR	C
13F3    E55C          7789     	MOV	A, NEW_RCP			; Load new RC pulse value
13F5    98            7790     SUBB A , R0 
13F6    40A7          7791     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      7792     
                      7793     IF MODE >= 1	; Tail or multi
13F8    7888          7794     MOV R0 , # PGM_DIRECTION 
13FA    E6            7795     MOV A , @ R0 
13FB    C3            7796     	CLR	C
13FC    9403          7797     	SUBB	A, #3
13FE    6003          7798     	JZ 	WAIT_FOR_POWER_ON_CHECK_TIMEOUT	; Do not wait if bidirectional operation
                      7799     ENDIF
                      7800     
1400    12061B        7801     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      7802     
                      7803     WAIT_FOR_POWER_ON_CHECK_TIMEOUT: 
1403    E52A          7804     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
1405    7003          7805     	JNZ	($+5)				; If it is not zero - proceed
                      7806     
1407    02118C        7807     	LJMP	INIT_NO_SIGNAL			; If it is zero (pulses missing) - go back to detect input signal
                      7808     
                      7809     
                      7810     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7811     ;
                      7812     ; Start entry point
                      7813     ;
                      7814     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7815     INIT_START: 
140A    C2AF          7816     	CLR	EA
140C    120F90        7817     	CALL SWITCH_POWER_OFF
140F    E4            7818     	CLR	A
1410    F522          7819     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1412    F523          7820     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1414    F524          7821     	MOV	CURRENT_PWM, A			; Set current pwm to zero
1416    F525          7822     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
1418    F526          7823     	MOV	CURRENT_PWM_LIM_DITH, A
141A    F567          7824     	MOV	PWM_DITHER_EXCESS_POWER, A
141C    D2AF          7825     	SETB	EA
141E    7885          7826     MOV R0 , # PGM_MOTOR_IDLE 
1420    E6            7827     MOV A , @ R0 
1421    C3            7828     	CLR	C
1422    33            7829     	RLC	A
1423    F565          7830     	MOV	PWM_MOTOR_IDLE, A
1425    E4            7831     	CLR	A
1426    F542          7832     	MOV	GOV_TARGET_L, A		; Set target to zero
1428    F543          7833     	MOV	GOV_TARGET_H, A
142A    F544          7834     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
142C    F545          7835     	MOV	GOV_INTEGRAL_H, A
142E    F546          7836     	MOV	GOV_INTEGRAL_X, A
1430    F570          7837     	MOV	ADC_CONVERSION_CNT, A
1432    F52C          7838     	MOV	FLAGS0, A				; Clear flags0
1434    F52D          7839     	MOV	FLAGS1, A				; Clear flags1
1436    F536          7840     	MOV	DEMAG_DETECTED_METRIC, A	; Clear demag metric
                      7841     	;**** **** **** **** ****
                      7842     	; Motor start beginning
                      7843     	;**** **** **** **** **** 
1438    757008        7844     MOV ADC_CONVERSION_CNT , # 8 
                      7845     	SET_ADC_IP_TEMP
143B    75BB10        7845+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
143E    120607        7846     	CALL WAIT1MS
1441    12091A        7847     	CALL START_ADC_CONVERSION
                      7848     READ_INITIAL_TEMP: 
                      7849     	GET_ADC_STATUS 
1444    E5E8          7849+1   MOV A , ADC0CN 
1446    20ECFB        7850     	JB	AD0BUSY, READ_INITIAL_TEMP
                      7851     	READ_ADC_RESULT						; Read initial temperature
1449    A8BD          7851+1   MOV R0 , ADC0L 
144B    A9BE          7851+1   MOV R1 , ADC0H 
144D    E9            7852     MOV A , R1 
144E    7001          7853     	JNZ	($+3)							; Is reading below 256?
                      7854     
1450    F8            7855     MOV R0 , A 
                      7856     
1451    8871          7857     MOV CURRENT_AVERAGE_TEMP , R0 
1453    12091E        7858     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1456    757008        7859     MOV ADC_CONVERSION_CNT , # 8 
                      7860     	SET_ADC_IP_TEMP
1459    75BB10        7860+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      7861     	; Set up start operating conditions
145C    7887          7862     MOV R0 , # PGM_PWM_FREQ 
145E    E6            7863     MOV A , @ R0 
145F    FE            7864     MOV R6 , A 
1460    7602          7865     MOV @ R0 , # 2 
1462    110E          7866     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1464    7887          7867     MOV R0 , # PGM_PWM_FREQ 
1466    EE            7868     MOV A , R6 
1467    F6            7869     MOV @ R0 , A 
                      7870     	; Set max allowed power
1468    C2AF          7871     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
146A    7561FF        7872     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
146D    1209B6        7873     	CALL SET_STARTUP_PWM
1470    852261        7874     	MOV	PWM_LIMIT, REQUESTED_PWM
1473    852262        7875     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
1476    852263        7876     	MOV	PWM_LIMIT_BY_RPM, REQUESTED_PWM
1479    D2AF          7877     	SETB	EA
147B    752201        7878     	MOV	REQUESTED_PWM, #1			; Set low pwm again after calling set_startup_pwm
147E    752401        7879     	MOV	CURRENT_PWM, #1
1481    752501        7880     	MOV	CURRENT_PWM_LIMITED, #1	
1484    752601        7881     	MOV	CURRENT_PWM_LIM_DITH, #1
1487    856069        7882     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
148A    756A01        7883     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      7884     	; Begin startup sequence
                      7885     IF MCU_48MHZ == 1
                      7886     	SET_MCU_CLK_48MHZ
148D    75B690        7886+1   MOV FLSCL , # 90H  ; SET FLASH TIMING FOR 48MHZ
1490    75A903        7886+1   MOV CLKSEL , # 3  ; SET CLOCK TO 48MHZ
1493    757A01        7886+1   MOV CLOCK_SET_AT_48MHZ , # 1 
                      7887     ENDIF
1496    7888          7888     MOV R0 , # PGM_DIRECTION 
1498    E6            7889     MOV A , @ R0 
1499    B40307        7890     	CJNE	A, #3, INIT_START_BIDIR_DONE
                      7891     
149C    C27D          7892     CLR FLAGS3 . 5 
149E    307602        7893     JNB FLAGS2 . 6 , ( $+5 ) 
14A1    D27D          7894     SETB FLAGS3 . 5 
                      7895     
                      7896     INIT_START_BIDIR_DONE: 
14A3    D268          7897     SETB FLAGS1 . 0 
14A5    D269          7898     SETB FLAGS1 . 1 
14A7    753300        7899     	MOV	STARTUP_CNT, #0			; Reset counter
14AA    120EF6        7900     	CALL COMM5COMM6				; Initialize commutation
14AD    120F1B        7901     	CALL COMM6COMM1				
14B0    1209DD        7902     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
14B3    1209DD        7903     	CALL	CALC_NEXT_COMM_TIMING		
14B6    1209D6        7904     	CALL INITIALIZE_TIMING			; Initialize timing
14B9    1209DD        7905     	CALL	CALC_NEXT_COMM_TIMING		
14BC    120B3A        7906     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
14BF    1209D6        7907     	CALL	INITIALIZE_TIMING			; Initialize timing
14C2    120BFD        7908     	CALL	WAIT_BEFORE_ZC_SCAN			; Set up comparator timeout
14C5    0214D4        7909     	JMP	RUN1
                      7910     
                      7911     
                      7912     
                      7913     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7914     ;
                      7915     ; Run entry point
                      7916     ;
                      7917     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7918     DAMPED_TRANSITION: 
                      7919     	; Transition from nondamped to damped if applicable
14C8    C2AF          7920     	CLR	EA
14CA    110E          7921     	CALL	DECODE_PARAMETERS		; Set programmed parameters
14CC    D2AF          7922     	SETB	EA
14CE    757000        7923     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      7924     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
14D1    75BB09        7924+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      7925     
                      7926     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      7927     ; Out_cA changes from low to high
                      7928     RUN1: 
14D4    120C52        7929     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
14D7    120D57        7930     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
14DA    120D38        7931     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
14DD    120710        7932     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
14E0    120D74        7933     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
14E3    120DBE        7934     	CALL COMM1COMM2			; Commutate
14E6    1209DD        7935     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
14E9    120B29        7936     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
14EC    120B3A        7937     	CALL CALC_NEW_WAIT_TIMES
14EF    120BFD        7938     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      7939     
                      7940     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      7941     ; Out_cB changes from high to low
                      7942     RUN2: 
14F2    120C41        7943     	CALL WAIT_FOR_COMP_OUT_LOW
14F5    120D57        7944     	CALL SETUP_COMM_WAIT	
14F8    120D38        7945     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
14FB    306D03        7946     JNB FLAGS1 . 5 , ( $+6 ) 
14FE    12076C        7947     	LCALL CALC_GOVERNOR_PROP_ERROR
1501    206703        7948     JB FLAGS0 . 7 , ( $+6 ) 
1504    1208B9        7949     	LCALL SET_PWM_LIMIT_LOW_RPM
1507    306703        7950     JNB FLAGS0 . 7 , ( $+6 ) 
150A    120900        7951     	LCALL SET_PWM_LIMIT_HIGH_RPM
150D    120D74        7952     	CALL WAIT_FOR_COMM
1510    120DE3        7953     	CALL COMM2COMM3
1513    1209DD        7954     	CALL CALC_NEXT_COMM_TIMING
1516    120B29        7955     	CALL WAIT_ADVANCE_TIMING
1519    120B3A        7956     	CALL CALC_NEW_WAIT_TIMES
151C    120BFD        7957     	CALL WAIT_BEFORE_ZC_SCAN	
                      7958     
                      7959     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      7960     ; Out_cC changes from low to high
                      7961     RUN3: 
151F    120C52        7962     	CALL WAIT_FOR_COMP_OUT_HIGH
1522    120D57        7963     	CALL SETUP_COMM_WAIT	
1525    120D38        7964     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
1528    306D03        7965     JNB FLAGS1 . 5 , ( $+6 ) 
152B    1207A1        7966     	LCALL CALC_GOVERNOR_INT_ERROR
152E    120D74        7967     	CALL WAIT_FOR_COMM
1531    120E5A        7968     	CALL COMM3COMM4
1534    1209DD        7969     	CALL CALC_NEXT_COMM_TIMING
1537    120B29        7970     	CALL WAIT_ADVANCE_TIMING
153A    120B3A        7971     	CALL CALC_NEW_WAIT_TIMES
153D    120BFD        7972     	CALL WAIT_BEFORE_ZC_SCAN	
                      7973     
                      7974     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      7975     ; Out_cA changes from high to low
                      7976     RUN4: 
1540    120C41        7977     	CALL WAIT_FOR_COMP_OUT_LOW
1543    120D57        7978     	CALL SETUP_COMM_WAIT	
1546    120D38        7979     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
1549    306D03        7980     JNB FLAGS1 . 5 , ( $+6 ) 
154C    1207FF        7981     	LCALL CALC_GOVERNOR_PROP_CORRECTION
154F    120D74        7982     	CALL WAIT_FOR_COMM
1552    120E7F        7983     	CALL COMM4COMM5
1555    1209DD        7984     	CALL CALC_NEXT_COMM_TIMING
1558    120B29        7985     	CALL WAIT_ADVANCE_TIMING
155B    120B3A        7986     	CALL CALC_NEW_WAIT_TIMES
155E    120BFD        7987     	CALL WAIT_BEFORE_ZC_SCAN	
                      7988     
                      7989     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      7990     ; Out_cB changes from low to high
                      7991     RUN5: 
1561    120C52        7992     	CALL WAIT_FOR_COMP_OUT_HIGH
1564    120D57        7993     	CALL SETUP_COMM_WAIT	
1567    120D38        7994     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
156A    306D03        7995     JNB FLAGS1 . 5 , ( $+6 ) 
156D    12085D        7996     	LCALL CALC_GOVERNOR_INT_CORRECTION
1570    120D74        7997     	CALL WAIT_FOR_COMM
1573    120EF6        7998     	CALL COMM5COMM6
1576    1209DD        7999     	CALL CALC_NEXT_COMM_TIMING
1579    120B29        8000     	CALL WAIT_ADVANCE_TIMING
157C    120B3A        8001     	CALL CALC_NEW_WAIT_TIMES
157F    120BFD        8002     	CALL WAIT_BEFORE_ZC_SCAN	
                      8003     
                      8004     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      8005     ; Out_cC changes from high to low
                      8006     RUN6: 
1582    12091A        8007     	CALL START_ADC_CONVERSION
1585    120C41        8008     	CALL WAIT_FOR_COMP_OUT_LOW
1588    120D57        8009     	CALL SETUP_COMM_WAIT	
158B    120D38        8010     	CALL	EVALUATE_COMPARATOR_INTEGRITY	
158E    120D74        8011     	CALL WAIT_FOR_COMM
1591    120F1B        8012     	CALL COMM6COMM1
1594    12091E        8013     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1597    1209DD        8014     	CALL CALC_NEXT_COMM_TIMING
159A    120B29        8015     	CALL WAIT_ADVANCE_TIMING
159D    120B3A        8016     	CALL CALC_NEW_WAIT_TIMES
15A0    120BFD        8017     	CALL WAIT_BEFORE_ZC_SCAN	
                      8018     
                      8019     	; Check if it is direct startup
15A3    306935        8020     JNB FLAGS1 . 1 , NORMAL_RUN_CHECKS 
15A6    206B32        8021     JB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      8022     
                      8023     	; Set spoolup power variables
15A9    856461        8024     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
15AC    856462        8025     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
15AF    856069        8026     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
15B2    756A01        8027     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      8028     	; Check startup counter
15B5    7918          8029     MOV R1 , # 24 
15B7    7A0C          8030     MOV R2 , # 12 
15B9    C3            8031     	CLR	C
15BA    E533          8032     	MOV	A, STARTUP_CNT				; Load counter
15BC    99            8033     SUBB A , R1 
15BD    400F          8034     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      8035     
15BF    C269          8036     CLR FLAGS1 . 1 
15C1    D26A          8037     SETB FLAGS1 . 2 
15C3    8A34          8038     MOV INITIAL_RUN_ROT_CNT , R2 
                      8039     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               ENDIF
                      8042     IF MODE == 2	; Multi
15C5    856461        8043     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG
15C8    856463        8044     	MOV	PWM_LIMIT_BY_RPM, PWM_SPOOLUP_BEG
                      8045     ENDIF
15CB    0215DB        8046     	JMP	NORMAL_RUN_CHECKS
                      8047     
                      8048     DIRECT_START_CHECK_RCP: 
15CE    C3            8049     	CLR	C
15CF    E55C          8050     	MOV	A, NEW_RCP				; Load new pulse value
15D1    9401          8051     SUBB A , # 1 
15D3    4003          8052     	JC	($+5)
                      8053     
15D5    0214D4        8054     	LJMP	RUN1						; Continue to run 
                      8055     
15D8    021655        8056     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8057     
                      8058     
                      8059     NORMAL_RUN_CHECKS: 
                      8060     	; Check if it is initial run phase
15DB    306A1B        8061     JNB FLAGS1 . 2 , INITIAL_RUN_PHASE_DONE 
15DE    206B18        8062     JB FLAGS1 . 3 , INITIAL_RUN_PHASE_DONE 
                      8063     
                      8064     	; Decrement startup rotaton count
15E1    E534          8065     	MOV	A, INITIAL_RUN_ROT_CNT
15E3    14            8066     	DEC	A
                      8067     	; Check number of nondamped rotations
15E4    7004          8068     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      8069     
15E6    C26A          8070     CLR FLAGS1 . 2 
15E8    81C8          8071     	JMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      8072     
                      8073     NORMAL_RUN_CHECK_STARTUP_ROT: 
15EA    F534          8074     	MOV	INITIAL_RUN_ROT_CNT, A		; Not zero - store counter
                      8075     
15EC    C3            8076     	CLR	C
15ED    E55C          8077     	MOV	A, NEW_RCP				; Load new pulse value
15EF    9401          8078     SUBB A , # 1 
15F1    4003          8079     	JC	($+5)
                      8080     
15F3    0214D4        8081     	LJMP	RUN1						; Continue to run 
                      8082     
15F6    021655        8083     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      8084     
                      8085     INITIAL_RUN_PHASE_DONE: 
                      8086     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      8099     	; Exit run loop after a given time
15F9    C3            8100     	CLR	C
15FA    E55F          8101     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
15FC    78FA          8102     MOV R0 , # 250 
15FE    98            8103     SUBB A , R0 
15FF    5054          8104     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      8105     
1601    307404        8106     JNB FLAGS2 . 4 , RUN6_CHECK_DIR 
                      8107     
1604    E52A          8108     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1606    604D          8109     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      8110     
                      8111     RUN6_CHECK_DIR: 
                      8112     IF MODE >= 1	; Tail or multi
1608    7888          8113     MOV R0 , # PGM_DIRECTION 
160A    E6            8114     MOV A , @ R0 
160B    B40317        8115     	CJNE	A, #3, RUN6_CHECK_SPEED
                      8116     
160E    207D05        8117     JB FLAGS3 . 5 , RUN6_CHECK_DIR_REV 
1611    207607        8118     JB FLAGS2 . 6 , RUN6_CHECK_DIR_CHANGE 
1614    C125          8119     	AJMP	RUN6_CHECK_SPEED
                      8120     
                      8121     RUN6_CHECK_DIR_REV: 
1616    307602        8122     JNB FLAGS2 . 6 , RUN6_CHECK_DIR_CHANGE 
1619    C125          8123     	AJMP	RUN6_CHECK_SPEED
                      8124     
                      8125     RUN6_CHECK_DIR_CHANGE: 
161B    206B07        8126     JB FLAGS1 . 3 , RUN6_CHECK_SPEED 
                      8127     
161E    D26B          8128     SETB FLAGS1 . 3 
1620    856461        8129     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set max power while braking
1623    A140          8130     	JMP	RUN4						; Go back to run 4, thereby changing force direction
                      8131     
                      8132     RUN6_CHECK_SPEED: 
                      8133     ENDIF
1625    78F0          8134     MOV R0 , # 0F0H 
1627    306B05        8135     JNB FLAGS1 . 3 , RUN6_BRAKE_DONE 
                      8136     
162A    856461        8137     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG 	; Set max power while braking
162D    7820          8138     MOV R0 , # 20H 
                      8139     
                      8140     RUN6_BRAKE_DONE: 
162F    C3            8141     	CLR	C
1630    E53E          8142     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1632    98            8143     SUBB A , R0 
1633    5002          8144     	JNC	($+4)					; Yes - stop or turn direction 
1635    81D4          8145     	AJMP	RUN1						; No - go back to run 1
                      8146     
                      8147     IF MODE >= 1	; Tail or multi
1637    306B1B        8148     JNB FLAGS1 . 3 , RUN_TO_WAIT_FOR_POWER_ON 
                      8149     
163A    C26B          8150     CLR FLAGS1 . 3 
163C    C27D          8151     CLR FLAGS3 . 5 
163E    307602        8152     JNB FLAGS2 . 6 , ( $+5 ) 
1641    D27D          8153     SETB FLAGS3 . 5 
1643    D26A          8154     SETB FLAGS1 . 2 
1645    753412        8155     	MOV	INITIAL_RUN_ROT_CNT, #18
1648    856461        8156     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG	; Set initial max power
164B    81D4          8157     	AJMP	RUN1						; Go back to run 1 
                      8158     ENDIF
                      8159     
                      8160     RUN_TO_WAIT_FOR_POWER_ON_FAIL: 	
164D    0535          8161     	INC	STALL_CNT					; Increment stall count
164F    E55C          8162     	MOV	A, NEW_RCP				; Check if RCP is zero, then it is a normal stop			
1651    6002          8163     	JZ	RUN_TO_WAIT_FOR_POWER_ON
1653    C158          8164     	AJMP	RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE
                      8165     
                      8166     RUN_TO_WAIT_FOR_POWER_ON: 	
1655    753500        8167     	MOV	STALL_CNT, #0
                      8168     
                      8169     RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE: 
1658    C2AF          8170     	CLR	EA
165A    120F90        8171     	CALL SWITCH_POWER_OFF
165D    7887          8172     MOV R0 , # PGM_PWM_FREQ 
165F    E6            8173     MOV A , @ R0 
1660    FE            8174     MOV R6 , A 
1661    7602          8175     MOV @ R0 , # 2 
1663    110E          8176     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1665    7887          8177     MOV R0 , # PGM_PWM_FREQ 
1667    EE            8178     MOV A , R6 
1668    F6            8179     MOV @ R0 , A 
1669    E4            8180     	CLR	A
166A    F522          8181     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
166C    F523          8182     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
166E    F524          8183     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1670    F525          8184     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1672    F526          8185     	MOV	CURRENT_PWM_LIM_DITH, A	
1674    F565          8186     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1676    C268          8187     CLR FLAGS1 . 0 
                      8188     IF MCU_48MHZ == 1
                      8189     	SET_MCU_CLK_24MHZ
1678    75B680        8189+1   MOV FLSCL , # 80H  ; SET FLASH TIMING FOR 24MHZ
167B    75A900        8189+1   MOV CLKSEL , # 0  ; SET CLOCK TO 24MHZ
167E    757A00        8189+1   MOV CLOCK_SET_AT_48MHZ , # 0 
                      8190     ENDIF
1681    D2AF          8191     	SETB	EA
1683    120607        8192     	CALL	WAIT1MS					; Wait for pwm to be stopped
1686    120F90        8193     	CALL SWITCH_POWER_OFF
                      8194     IF MODE == 0	; Main
                               	JNB	FLAGS2.RCP_PPM, RUN_TO_NEXT_STATE_MAIN	; If flag is not set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	INIT_NO_SIGNAL				; If it is zero (pulses missing) - go back to detect input signal
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      8214     IF MODE >= 1	; Tail or multi
1689    307409        8215     JNB FLAGS2 . 4 , JMP_WAIT_FOR_POWER_ON 
                      8216     
168C    C3            8217     	CLR	C
168D    E535          8218     	MOV	A, STALL_CNT
168F    9405          8219     	SUBB	A, #5
1691    4002          8220     	JC	JMP_WAIT_FOR_POWER_ON
1693    218C          8221     	JMP	INIT_NO_SIGNAL
                      8222     
                      8223     JMP_WAIT_FOR_POWER_ON: 
1695    619A          8224     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      8225     ENDIF
                      8226     
                      8227     
                      8228     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8229     
                      8230     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      8890     $INCLUDE (BLHELIBOOTLOAD.INC)			; Include source code for bootloader
                      9283     
                      9284     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      9285     
                      9286     
------                9287     CSEG AT 19FDH
                      9288     RESET: 
19FD    0210F4        9289     LJMP	PGM_START
                      9290     
                      9291     
                      9292     
                      9293     
                      9294     END
MACRO ASSEMBLER BLHELI                                      12/30/15 18:07:03 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

SET4 . . . . . . .  C ADDR   1CC5H   A 
ID3. . . . . . . .  C ADDR   1C52H   A 
BYTE_CNTH. . . . .  D ADDR   0028H   A 
CRCH . . . . . . .  D ADDR   0023H   A 
CMDL . . . . . . .    REG    R4             
XH . . . . . . . .    REG    R1             
NORMAL_RUN_CHECK_~  C ADDR   15EAH   A 
DECODE_DEMAG_HIGH.  C ADDR   107AH   A 
COMM61_DAMP_REV. .  C ADDR   0F41H   A 
COMP_WAIT_ON_COMP~  C ADDR   0C89H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0C40H   A 
CHECK_TEMP_VOLTAG~  C ADDR   091EH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0884H   A 
GOVERNOR_CORR_NEG~  C ADDR   084CH   A 
PCA_INT_PPM_BELOW~  C ADDR   04F7H   A 
T2_INT_CURRENT_PW~  C ADDR   02DBH   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
TIMER0_OVERFLOW_V~  D ADDR   0079H   A 
PPM_THROTTLE_GAIN.  D ADDR   0072H   A 
LIPO_ADC_LIMIT_H .  D ADDR   006FH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005EH   A 
RCP_EDGE_H . . . .  D ADDR   0058H   A 
FLAGS3 . . . . . .  D ADDR   002FH   A 
RCP_PREV_EDGE_L. .  D ADDR   0027H   A 
ADC_IP . . . . . .  N NUMB   0001h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
POLARIS_THUNDER_4~  N NUMB   008Fh            
POLARIS_THUNDER_3~  N NUMB   008Dh            
POLARIS_THUNDER_1~  N NUMB   0087h            
SET5 . . . . . . .  C ADDR   1CCBH   A 
ID4. . . . . . . .  C ADDR   1C5DH   A 
BOOT_START . . . .  N NUMB   1C00h            
FUNCTION_BEEP. . .  C ADDR   1826H   A 
INIT_START . . . .  C ADDR   140AH   A 
PROGRAM_BY_TX_ENT~  C ADDR   12B9H   A 
FIND_THROTTLE_GAI~  C ADDR   10ACH   A 
COMM45_NONDAMP . .  C ADDR   0EC5H   A 
COMM4COMM5 . . . .  C ADDR   0E7FH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0A84H   A 
SET_PWM_LIMIT_HIG~  C ADDR   0910H   A 
SET_PWM_DEMAG_DONE  C ADDR   08D5H   A 
PCA_INT_RESTORE_E~  C ADDR   0474H   A 
T2H_INT_RCP_STOP .  C ADDR   0327H   A 
T0_INT_PWM_OFF_DA~  C ADDR   013FH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006DH   A 
RANDOM . . . . . .  D ADDR   0068H   A 
PWM_MOTOR_IDLE . .  D ADDR   0065H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005DH   A 
NEXT_WT_START_L. .  D ADDR   0053H   A 
COMM_PERIOD4X_H. .  D ADDR   003EH   A 
PWM_START. . . . .  N NUMB   0032h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D6h            
EMAX_NANO_20A_TAIL  N NUMB   00B3h            
PLATINUM_50AV3_TA~  N NUMB   00A1h            
PLATINUM_PRO_30A_~  N NUMB   009Ah            
POLARIS_THUNDER_4~  N NUMB   0090h            
H_KING_35A_TAIL. .  N NUMB   0080h            
SET6 . . . . . . .  C ADDR   1CD3H   A 
ID5. . . . . . . .  C ADDR   1C6AH   A 
ERRORPROG. . . . .  N NUMB   00C5h            
ERRORCRC . . . . .  N NUMB   00C2h            
BOOT_DELAY . . . .  N NUMB   5F5E10h            
PARAVAL_BEEP . . .  C ADDR   1834H   A 
STORE_MULTI_FUNC_~  C ADDR   17ADH   A 
COMM45_DAMP_REV. .  C ADDR   0EA5H   A 
COMM23_NFET_DONE .  C ADDR   0E3BH   A 
GOVERNOR_CHECK_PWM  C ADDR   07DAH   A 
GOVERNOR_ACTIVATE.  C ADDR   0735H   A 
PWM_AFET_DAMPED_D~  C ADDR   0187H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
DEMAG_DETECTED_ME~  D ADDR   0036H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
SIGNATURE_001. . .  N NUMB   00F3h            
RTX_PORT . . . . .  N NUMB   0080h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
EMAX_NANO_20A_MUL~  N NUMB   00B4h            
PLATINUM_50AV3_MU~  N NUMB   00A2h            
POLARIS_THUNDER_6~  N NUMB   0092h            
H_KING_35A_MULTI .  N NUMB   0081h            
TURNIGY_AE_25A_MA~  N NUMB   0043h            
TURNIGY_AE_20A_TA~  N NUMB   0041h            
TURNIGY_PLUSH_10A~  N NUMB   001Fh            
XP_35A_SW_TAIL . .  N NUMB   0014h            
GETC . . . . . . .  C ADDR   1D7FH   A 
BIT_CNT. . . . . .  D ADDR   0026H   A 
BOOT_PAGES . . . .  N NUMB   0001h            
STORE_MULTI_FUNC_~  C ADDR   17B2H   A 
WRITE_EEPROM_SIGN~  C ADDR   174BH   A 
WAIT_FOR_POWER_ON.  C ADDR   139AH   A 
THROTTLE_LOW_CAL_~  C ADDR   131CH   A 
ERASE_AND_STORE_A~  C ADDR   16D9H   A 
ARMING_INITIAL_AR~  C ADDR   12A2H   A 
PROGRAM_BY_TX_CHE~  C ADDR   1368H   A 
FIND_THROTTLE_GAI~  C ADDR   10A5H   A 
SET_DEFAULT_PARAM~  C ADDR   0FA5H   A 
COMM56_REV . . . .  C ADDR   0F0AH   A 
COMM5COMM6 . . . .  C ADDR   0EF6H   A 
COMM23_NFET_OFF_R~  C ADDR   0E1FH   A 
COMP_READ_OK . . .  C ADDR   0D21H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B24H   A 
CALC_NEXT_COMM_TI~  C ADDR   09DDH   A 
CALC_GOVERNOR_TAR~  C ADDR   076BH   A 
PCA_INT_STORE_DATA  C ADDR   0499H   A 
T2_INT_RCP_GAIN_P~  C ADDR   026CH   A 
T2_INT_RCP_UPDATE~  C ADDR   022EH   A 
PWM_BFET_DAMPED_D~  C ADDR   0198H   A 
RESET. . . . . . .  C ADDR   19FDH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   00A4H   A 
PGM_ENABLE_TEMP_P~  I ADDR   00A0H   A 
_PGM_THROTTLE_RATE  I ADDR   009BH   A 
_PGM_STARTUP_RPM .  I ADDR   008FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   0062H   A 
RCP_PREPREV_EDGE_H  D ADDR   0056H   A 
WT_ZC_SCAN_START_L  D ADDR   004DH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0003h            
STARTUP_PHASE. . .  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
SIGNATURE_002. . .  N NUMB   0090h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C5h            
POLARIS_THUNDER_6~  N NUMB   0093h            
SKYWALKER_20A_MAIN  N NUMB   0058h            
TURNIGY_AE_30A_TA~  N NUMB   0047h            
TURNIGY_AE_20A_MU~  N NUMB   0042h            
XP_35A_SW_MULTI. .  N NUMB   0015h            
XP_7A_MAIN . . . .  N NUMB   0004h            
PRO3 . . . . . . .  C ADDR   1D01H   A 
BOOT_SIGN. . . . .  C ADDR   1DD6H   A 
BYTE_CNTL. . . . .  D ADDR   0027H   A 
BAUDH. . . . . . .  D ADDR   0025H   A 
CRCL . . . . . . .  D ADDR   0022H   A 
XL . . . . . . . .    REG    R0             
FUNCTION_NEXT. . .  C ADDR   18A5H   A 
THROTTLE_HIGH_CAL.  C ADDR   12E6H   A 
COMM61_NFET_DONE .  C ADDR   0F72H   A 
STORE_TIMES_INCRE~  C ADDR   0BEFH   A 
STARTUP_PWM_SET_P~  C ADDR   09CBH   A 
PWM_CFET_DAMPED_D~  C ADDR   01A9H   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006EH   A 
RCP_EDGE_L . . . .  D ADDR   0057H   A 
COMM_DIFF. . . . .  D ADDR   003FH   A 
STALL_CNT. . . . .  D ADDR   0035H   A 
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
RTX_PIN. . . . . .  N NUMB   0005h            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C6h            
POLARIS_THUNDER_8~  N NUMB   0095h            
TURNIGY_KFORCE_12~  N NUMB   0053h            
TURNIGY_AE_45A_MA~  N NUMB   0049h            
TURNIGY_AE_30A_MU~  N NUMB   0048h            
TURNIGY_PLUSH_30A~  N NUMB   002Bh            
TURNIGY_PLUSH_12A~  N NUMB   0022h            
XP_3A_TAIL . . . .  N NUMB   0002h            
PRO4 . . . . . . .  C ADDR   1D0DH   A 
MAIN . . . . . . .  C ADDR   1C7CH   A 
PARAVAL_NEXT . . .  C ADDR   188FH   A 
WRITE_EEPROM_BYTE.  C ADDR   171FH   A 
TEST_FOR_ONESHOT .  C ADDR   1255H   A 
MEASURE_PWM_FREQ_~  C ADDR   1202H   A 
COMM61_NFET_OFF_R~  C ADDR   0F57H   A 
COMM_EXIT. . . . .  C ADDR   0F8DH   A 
CALC_GOVERNOR_INT~  C ADDR   085DH   A 
PCA_INT_PPM_CHECK~  C ADDR   0512H   A 
PCA_INT_FALL_CHEC~  C ADDR   04E9H   A 
PCA_INT_PWM_DIVIDE  C ADDR   05A6H   A 
PCA_INT_LIMITED. .  C ADDR   05C9H   A 
T2H_INT_START. . .  C ADDR   030BH   A 
T2_INT_PWM_UPDATE.  C ADDR   0273H   A 
T0_INT_PWM_OFF_DA~  C ADDR   012DH   A 
EEP_DUMMY. . . . .  C ADDR   1A27H   A 
EEP_PGM_ENABLE_PW~  C ADDR   1A25H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A13H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
CLOCK_SET_AT_48MHZ  D ADDR   007AH   A 
COMM_PERIOD4X_L. .  D ADDR   003DH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
RTX_MDIN . . . . .  N NUMB   00F1h            
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0002h            
POLARIS_THUNDER_8~  N NUMB   0096h            
SKYWALKER_40A_MAIN  N NUMB   005Bh            
TURNIGY_KFORCE_12~  N NUMB   0054h            
TURNIGY_PLUSH_40A~  N NUMB   002Eh            
SUPERMICRO_3P5A_M~  N NUMB   0019h            
XP_3A_MULTI. . . .  N NUMB   0003h            
WAIT1. . . . . . .  C ADDR   1DCFH   A 
PRO5 . . . . . . .  C ADDR   1D13H   A 
FUNC_PARAVAL_WAIT.  C ADDR   1855H   A 
WRITE_TAG. . . . .  C ADDR   1774H   A 
READ_EEPROM_STORE~  C ADDR   16B0H   A 
RUN6_CHECK_DIR . .  C ADDR   1608H   A 
RUN1 . . . . . . .  C ADDR   14D4H   A 
WAIT_FOR_POWER_ON~  C ADDR   1403H   A 
MEASURE_PWM_FREQ_~  C ADDR   1213H   A 
CLEAR_RAM. . . . .  C ADDR   1162H   A 
SET_BEC_VOLTAGE. .  C ADDR   1091H   A 
DECODE_DEMAG_DONE.  C ADDR   1083H   A 
COMM45_NFET_DONE .  C ADDR   0ED7H   A 
WAIT_FOR_COMM. . .  C ADDR   0D74H   A 
ADJUST_TIMING_TWO~  C ADDR   0BE2H   A 
CALC_GOVERNOR_PRO~  C ADDR   07A0H   A 
DIV_U16_BY_U16_DI~  C ADDR   0689H   A 
WAIT100MS. . . . .  C ADDR   061BH   A 
WAIT1MS. . . . . .  C ADDR   0607H   A 
T0_INT_PWM_OFF_TI~  C ADDR   010DH   A 
T0_INT_PWM_OFF_SE~  C ADDR   010BH   A 
STARTUP_POWER_TAB~  C ADDR   008DH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
SKIP_T2_INT. . . .  D ADDR   0077H   A 
TX_PGM_BEEP_NO . .  D ADDR   0076H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   006AH   A 
WT_ZC_TOUT_START_H  D ADDR   0050H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
RTX_MDOUT. . . . .  N NUMB   00A4h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D7h            
PLATINUM_PRO_30A_~  N NUMB   009Bh            
TURNIGY_KFORCE_12~  N NUMB   0055h            
RD1. . . . . . . .  C ADDR   1D2AH   A 
PRO6 . . . . . . .  C ADDR   1D20H   A 
ABD. . . . . . . .  C ADDR   1C2BH   A 
FUNCTION_PARAVAL_~  C ADDR   1820H   A 
STORE_NEW_VALUE_I~  C ADDR   177CH   A 
RUN2 . . . . . . .  C ADDR   14F2H   A 
ARMING_PPM_CHECK .  C ADDR   12ACH   A 
COMM45_NFET_OFF_R~  C ADDR   0EBBH   A 
COMM23_FETS_DONE .  C ADDR   0E01H   A 
COMP_READ_WRONG_T~  C ADDR   0D01H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0BFDH   A 
STORE_TIMES_EXIT .  C ADDR   0BC8H   A 
CHECK_VOLTAGE_PWM~  C ADDR   09ADH   A 
GOVERNOR_CORR_INT~  C ADDR   08A3H   A 
GOVERNOR_STORE_PR~  C ADDR   079CH   A 
DIV_U16_BY_U16_DI~  C ADDR   0693H   A 
WAIT200MS. . . . .  C ADDR   0620H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0263H   A 
T2_INT_CURRENT_PW~  C ADDR   028AH   A 
T2_INT_PULSES_ABS~  C ADDR   01D9H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_MAIN_SPOOLUP_~  I ADDR   009FH   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0055H   A 
GOV_ACTIVE . . . .  N NUMB   0005h            
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
ZTW_SPIDER_PRO_20~  N NUMB   00D8h            
PLATINUM_PRO_30A_~  N NUMB   009Ch            
TURNIGY_AE_25A_TA~  N NUMB   0044h            
TURNIGY_PLUSH_60A~  N NUMB   0031h            
TURNIGY_PLUSH_10A~  N NUMB   0020h            
MAI1 . . . . . . .  C ADDR   1C7EH   A 
IN1. . . . . . . .  C ADDR   1C74H   A 
BAUDL. . . . . . .  D ADDR   0024H   A 
RUN3 . . . . . . .  C ADDR   151FH   A 
GOVERNOR_LIMIT_IN~  C ADDR   088BH   A 
GOVERNOR_CHECK_IN~  C ADDR   07C2H   A 
DIV_U16_BY_U16_DI~  C ADDR   06AAH   A 
WAIT3MS. . . . . .  C ADDR   060CH   A 
T2_INT_PULSES_ABS~  C ADDR   020EH   A 
T0_INT_PWM_ON_TIM~  C ADDR   00EDH   A 
T0_INT_PWM_ON_SET~  C ADDR   00EBH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0045H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
RCP_PPM_ONESHOT125  N NUMB   0005h            
DIR_CHANGE_BRAKE .  N NUMB   0003h            
DEMAG_ENABLED. . .  N NUMB   0004h            
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
POLARIS_THUNDER_1~  N NUMB   0097h            
SKYWALKER_20A_TAIL  N NUMB   0059h            
TURNIGY_AE_25A_MU~  N NUMB   0045h            
TURNIGY_PLUSH_25A~  N NUMB   0028h            
TURNIGY_PLUSH_10A~  N NUMB   0021h            
XP_7A_TAIL . . . .  N NUMB   0005h            
PUTP . . . . . . .  C ADDR   1D40H   A 
SETBUF . . . . . .  C ADDR   1CBFH   A 
MAI2 . . . . . . .  C ADDR   1CA0H   A 
ERRORCOMMAND . . .  N NUMB   00C1h            
BEEP_NO_ENTRY. . .  C ADDR   184EH   A 
JMP_WAIT_FOR_POWE~  C ADDR   1695H   A 
DIRECT_START_CHEC~  C ADDR   15CEH   A 
RUN4 . . . . . . .  C ADDR   1540H   A 
COMM61_FETS_DONE .  C ADDR   0F39H   A 
COMM23_NONDAMP_REV  C ADDR   0E43H   A 
COMP_READ_OK_JMP .  C ADDR   0D33H   A 
STORE_TIMES_UP_OR~  C ADDR   0B86H   A 
STORE_TIMES_DECRE~  C ADDR   0B99H   A 
CALC_NEXT_COMM_NE~  C ADDR   0A69H   A 
TEMP_AVERAGE_INC .  C ADDR   0958H   A 
GOVERNOR_CORR_INT~  C ADDR   08B4H   A 
MULT_S16_BY_U8_DI~  C ADDR   06B9H   A 
PCA_INT_PPM_NEG_C~  C ADDR   0566H   A 
T2_INT_EXIT. . . .  C ADDR   02F1H   A 
_EEP_PGM_DAMPING_~  C ADDR   1A16H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PWM_DITHER_EXCESS~  D ADDR   0067H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   005Ah            
TURNIGY_AE_45A_TA~  N NUMB   004Ah            
TURNIGY_PLUSH_80A~  N NUMB   0034h            
TURNIGY_PLUSH_30A~  N NUMB   002Ch            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
XP_7A_MULTI. . . .  N NUMB   0006h            
PUT1 . . . . . . .  C ADDR   1D46H   A 
READ_TAGS. . . . .  C ADDR   175AH   A 
RUN5 . . . . . . .  C ADDR   1561H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0ADBH   A 
SET_PWM_LIMIT_HIG~  C ADDR   0900H   A 
GOVERNOR_CORR_NEG~  C ADDR   08A8H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0791H   A 
GOVERNOR_TARGET_C~  C ADDR   0718H   A 
CALC_GOVERNOR_TAR~  C ADDR   0710H   A 
PCA_INT_PWM_DIVID~  C ADDR   05ADH   A 
PCA_INT_CHECK_12K~  C ADDR   0418H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
CURRENT_PWM_LIMIT~  D ADDR   007CH   A 
BEEP_STRENGTH. . .  D ADDR   0073H   A 
RCP_PREV_PERIOD_H.  D ADDR   005AH   A 
WT_COMM_START_H. .  D ADDR   0052H   A 
WT_ZC_TOUT_START_L  D ADDR   004FH   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
F85_3A_MAIN. . . .  N NUMB   00D3h            
SKYWALKER_40A_TAIL  N NUMB   005Ch            
TURNIGY_AE_45A_MU~  N NUMB   004Bh            
TURNIGY_PLUSH_40A~  N NUMB   002Fh            
TURNIGY_PLUSH_30A~  N NUMB   002Dh            
TURNIGY_PLUSH_18A~  N NUMB   0025h            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
SUPERMICRO_3P5A_T~  N NUMB   001Ah            
PUT2 . . . . . . .  C ADDR   1D59H   A 
MAI4 . . . . . . .  C ADDR   1CD6H   A 
BAUDTIME . . . . .  N NUMB   0198h            
RUN6_CHECK_DIR_CH~  C ADDR   161BH   A 
RUN6 . . . . . . .  C ADDR   1582H   A 
ARMING_START . . .  C ADDR   128CH   A 
MEASURE_PWM_FREQ_~  C ADDR   1208H   A 
COMM61_NONDAMP_REV  C ADDR   0F79H   A 
COMM45_FETS_DONE .  C ADDR   0E9DH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0C05H   A 
GOVERNOR_DEACTIVA~  C ADDR   0722H   A 
PCA_INT_CHECK_LEG~  C ADDR   05BEH   A 
PCA_INT_FALL_NOT_~  C ADDR   04CAH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
PREV_PREV_COMM_H .  D ADDR   003CH   A 
RCP_UPDATED. . . .  N NUMB   0000h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
MUX_A1 . . . . . .  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Ah            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
FLYCOLOR_FAIRY_30~  N NUMB   00C7h            
ROTORGEEKS_20A_MA~  N NUMB   00C1h            
ALIGN_RCE_BL15P_M~  N NUMB   006Dh            
SKYWALKER_40A_MUL~  N NUMB   005Dh            
TURNIGY_KFORCE_12~  N NUMB   0056h            
TURNIGY_PLUSH_40A~  N NUMB   0030h            
SUPERMICRO_3P5A_M~  N NUMB   001Bh            
DP_3A_MAIN . . . .  N NUMB   0016h            
PUT3 . . . . . . .  C ADDR   1D65H   A 
MAI5 . . . . . . .  C ADDR   1D25H   A 
WAIT_FOR_LOW . . .  C ADDR   1C42H   A 
PARAH. . . . . . .    REG    R3             
ARM_TARGET_UPDATED  C ADDR   1372H   A 
EVALUATE_COMPARAT~  C ADDR   0D38H   A 
COMP_WAIT_READ_CO~  C ADDR   0CC8H   A 
TEMP_CHECK_EXIT. .  C ADDR   0982H   A 
GOVERNOR_APPLY_PR~  C ADDR   0833H   A 
PWM_AFET_EXIT. . .  C ADDR   0164H   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_PWM_IN~  I ADDR   00A2H   A 
_PGM_STARTUP_ACCEL  I ADDR   0090H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
CURRENT_PWM_LIM_D~  D ADDR   007DH   A 
GOV_INTEGRAL_L . .  D ADDR   0044H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0025h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
TURNIGY_KFORCE_12~  N NUMB   0057h            
TURNIGY_PLUSH_60A~  N NUMB   0032h            
PUT4 . . . . . . .  C ADDR   1D77H   A 
MAI6 . . . . . . .  C ADDR   1D36H   A 
CNTH . . . . . . .    REG    R7             
WRITE_EEPROM_BLOC~  C ADDR   16FCH   A 
NORMAL_RUN_CHECKS.  C ADDR   15DBH   A 
INIT_NO_SIGNAL . .  C ADDR   118CH   A 
COMM45_NONDAMP_REV  C ADDR   0EDFH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0C60H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0B29H   A 
CALC_NEW_WAIT_PER~  C ADDR   0A93H   A 
CALC_GOVERNOR_PRO~  C ADDR   076CH   A 
PCA_INT_PPM_UNIDI~  C ADDR   0560H   A 
T2_INT_PPM_TIMEOU~  C ADDR   021AH   A 
PWM_BFET_EXIT. . .  C ADDR   016EH   A 
T0_INT_PWM_OFF_EX~  C ADDR   011AH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
POLARIS_THUNDER_1~  N NUMB   0098h            
ALIGN_RCE_BL35P_M~  N NUMB   0073h            
TURNIGY_PLUSH_60A~  N NUMB   0033h            
TURNIGY_PLUSH_25A~  N NUMB   0029h            
POLYNOM. . . . . .  N NUMB   A001h            
WRITE_EEPROM_BLOC~  C ADDR   170AH   A 
PROGRAM_BY_TX_ENT~  C ADDR   1359H   A 
READ_ALL_EEPROM_P~  C ADDR   1697H   A 
COMM23_NFET_DONE_~  C ADDR   0E52H   A 
CALC_NEXT_COMM_NE~  C ADDR   0A72H   A 
CHECK_VOLTAGE_LOW~  C ADDR   09A1H   A 
PWM_CFET_EXIT. . .  C ADDR   0178H   A 
T0_INT . . . . . .  C ADDR   00B5H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A18H   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
SKIP_T2H_INT . . .  D ADDR   0078H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006BH   A 
RCP_STOP_CNT . . .  D ADDR   005FH   A 
NEW_RCP. . . . . .  D ADDR   005CH   A 
RCP_PREV_PERIOD_L.  D ADDR   0059H   A 
WT_COMM_START_L. .  D ADDR   0051H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
INITIAL_RUN_PHASE.  N NUMB   0002h            
HIGH_RPM . . . . .  N NUMB   0007h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00D0h            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0003h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
POLARIS_THUNDER_1~  N NUMB   0099h            
TURNIGY_PLUSH_80A~  N NUMB   0035h            
TURNIGY_PLUSH_25A~  N NUMB   002Ah            
INIT_START_BIDIR_~  C ADDR   14A3H   A 
EVAL_COMP_EXIT . .  C ADDR   0D56H   A 
PCA_INT_SET_TIMEO~  C ADDR   05E1H   A 
PWM_NOFET. . . . .  C ADDR   015AH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00D9H   A 
EEP_PGM_PWM_DITHER  C ADDR   1A26H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
PREV_PREV_COMM_L .  D ADDR   003BH   A 
PREV_COMM_H. . . .  D ADDR   003AH   A 
RCP_DIR_REV. . . .  N NUMB   0006h            
RCP_TIMEOUT_CNT. .  D ADDR   002AH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0004h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
F85_3A_TAIL. . . .  N NUMB   00D4h            
FVT_LITTLEBEE_20A~  N NUMB   00CAh            
MDRX62H_MAIN . . .  N NUMB   00BEh            
TURNIGY_PLUSH_80A~  N NUMB   0036h            
TURNIGY_PLUSH_18A~  N NUMB   0026h            
XP_12A_MAIN. . . .  N NUMB   000Ah            
PUTW . . . . . . .  C ADDR   1D38H   A 
PARAL. . . . . . .    REG    R2             
BOOTLOADER_DONE. .  C ADDR   119CH   A 
AVERAGE_THROTTLE .  C ADDR   10C9H   A 
DECODE_PARAMS_DIR~  C ADDR   1029H   A 
COMM61_NFET_DONE_~  C ADDR   0F88H   A 
SETUP_COMM_WAIT. .  C ADDR   0D57H   A 
CALC_NEXT_COMM_TI~  C ADDR   0ADCH   A 
CALC_GOVERNOR_INT~  C ADDR   07FEH   A 
T2_INT . . . . . .  C ADDR   01ADH   A 
_PGM_DAMPING_FORCE  I ADDR   0093H   A 
AUTO_BAILOUT_ARMED  D ADDR   0060H   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
MOTOR_PPM_LOW_SLO~  N NUMB   002Bh            
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0002h            
CNFET. . . . . . .  N NUMB   0007h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
F85_3A_MULTI . . .  N NUMB   00D5h            
FVT_LITTLEBEE_30A~  N NUMB   00CDh            
FLYCOLOR_FAIRY_30~  N NUMB   00C8h            
ROTORGEEKS_20A_TA~  N NUMB   00C2h            
ALIGN_RCE_BL15P_T~  N NUMB   006Eh            
RCTIMER_6A_MAIN. .  N NUMB   0067h            
TURNIGY_PLUSH_NFE~  N NUMB   003Dh            
TURNIGY_PLUSH_18A~  N NUMB   0027h            
DP_3A_TAIL . . . .  N NUMB   0017h            
XP_7A_FAST_MAIN. .  N NUMB   0007h            
GET1 . . . . . . .  C ADDR   1D84H   A 
BYTE_REG . . . . .  D ADDR   0021H   A 
CNTL . . . . . . .    REG    R6             
ARM_END_BEEP . . .  C ADDR   1387H   A 
THROTTLE_HIGH_CAL~  C ADDR   12E4H   A 
PGM_START. . . . .  C ADDR   10F4H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0C41H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0B3AH   A 
LOAD_MIN_TIME. . .  C ADDR   0AD7H   A 
SET_STARTUP_PWM. .  C ADDR   09B6H   A 
GOVERNOR_STORE_IN~  C ADDR   07F8H   A 
GOVERNOR_ACTIVATE~  C ADDR   075EH   A 
T2H_INT_EXIT . . .  C ADDR   0338H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   0342H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0075H   A 
ADC_CONVERSION_CNT  D ADDR   0070H   A 
GOV_ARM_TARGET . .  D ADDR   004AH   A 
RCP_PPM. . . . . .  N NUMB   0004h            
RCP_OUTSIDE_RANGE~  D ADDR   0029H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0005h            
ADC_LIMIT_L. . . .  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
GRAUPNER_ULTRA_20~  N NUMB   00D0h            
FLYCOLOR_FAIRY_30~  N NUMB   00C9h            
ROTORGEEKS_20A_MU~  N NUMB   00C3h            
EMAX_20A_MAIN. . .  N NUMB   00ACh            
TAROT_30A_MAIN . .  N NUMB   00A6h            
ALIGN_RCE_BL15P_M~  N NUMB   006Fh            
DP_3A_MULTI. . . .  N NUMB   0018h            
GET2 . . . . . . .  C ADDR   1D99H   A 
FUNC_PARAVAL . . .  C ADDR   1851H   A 
WAIT1S_LOOP. . . .  C ADDR   17BCH   A 
STORE_MULTI_FUNC_1  C ADDR   1780H   A 
RUN6_CHECK_DIR_REV  C ADDR   1616H   A 
AVERAGE_THROTTLE_~  C ADDR   10E5H   A 
CALC_GOVERNOR_PRO~  C ADDR   085CH   A 
GOVERNOR_INT_MIN_~  C ADDR   07F3H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0798H   A 
BEEP_F1. . . . . .  C ADDR   0630H   A 
PCA_INT_PPM_OUTSI~  C ADDR   0500H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   0071H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0064H   A 
PWM_LIMIT. . . . .  D ADDR   0061H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0006h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
ALIGN_RCE_BL35P_T~  N NUMB   0074h            
GET3 . . . . . . .  C ADDR   1DBDH   A 
STORE_MULTI_FUNC_2  C ADDR   1785H   A 
INITIAL_RUN_PHASE~  C ADDR   15F9H   A 
TEST_THROTTLE_GAIN  C ADDR   10BAH   A 
COMM23_FETS_DONE_~  C ADDR   0E21H   A 
CALC_NEXT_COMM_ST~  C ADDR   0A3AH   A 
GOVERNOR_STORE_PR~  C ADDR   085AH   A 
GOVERNOR_CHECK_PR~  C ADDR   081EH   A 
MULT_S16_BY_U8_PO~  C ADDR   06D3H   A 
DIV_U16_BY_U16 . .  C ADDR   0681H   A 
BEEP_ONOFF . . . .  C ADDR   064EH   A 
BEEP_F2. . . . . .  C ADDR   0637H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0547H   A 
PCA_INT_CHECK_DIFF  C ADDR   048CH   A 
T2_INT_SKIP_START.  C ADDR   021EH   A 
PWM_AFET . . . . .  C ADDR   015CH   A 
T0_INT_PWM_OFF_FU~  C ADDR   014CH   A 
EEP_PGM_ENABLE_PO~  C ADDR   1A24H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0014h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
PREV_COMM_L. . . .  D ADDR   0039H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
XROTOR_10A_MAIN. .  N NUMB   00B5h            
EMAX_40A_MAIN. . .  N NUMB   00AFh            
ALIGN_RCE_BL35P_M~  N NUMB   0075h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ah            
TURNIGY_KFORCE_70~  N NUMB   004Fh            
TURNIGY_KFORCE_40~  N NUMB   004Ch            
XP_25A_MAIN. . . .  N NUMB   0010h            
INIT . . . . . . .  C ADDR   1C00H   A 
PARAVAL_NO_ENTRY .  C ADDR   184BH   A 
STORE_MULTI_FUNC_3  C ADDR   178AH   A 
RUN6_BRAKE_DONE. .  C ADDR   162FH   A 
SUCCESS_BEEP_INVE~  C ADDR   17F1H   A 
SUCCESS_BEEP . . .  C ADDR   17C2H   A 
FIND_THROTTLE_GAIN  C ADDR   1092H   A 
DECODE_SETTINGS. .  C ADDR   1047H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   164DH   A 
TEMP_AVERAGE_INC_~  C ADDR   0948H   A 
GOVERNOR_INT_MAX_~  C ADDR   07EBH   A 
GOVERNOR_LIMIT_IN~  C ADDR   07CBH   A 
BEEP_F3. . . . . .  C ADDR   063EH   A 
PCA_INT_FAIL_MINI~  C ADDR   03A5H   A 
PWM_BFET . . . . .  C ADDR   0166H   A 
T0_INT_PWM_OFF_EX~  C ADDR   013FH   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0069H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
SKIP_DAMP_ON . . .  N NUMB   0006h            
P1_INIT. . . . . .  N NUMB   0002h            
RTX_SKIP . . . . .  N NUMB   00D4h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
FVT_LITTLEBEE_20A~  N NUMB   00CBh            
MDRX62H_TAIL . . .  N NUMB   00BFh            
XROTOR_20A_MAIN. .  N NUMB   00B8h            
PLATINUM_PRO_150A~  N NUMB   009Dh            
TURNIGY_PLUSH_NFE~  N NUMB   003Ah            
XP_12A_TAIL. . . .  N NUMB   000Bh            
UART_LOOP. . . . .  N NUMB   001Ah            
STORE_MULTI_FUNC_4  C ADDR   178FH   A 
DAMPED_TRANSITION.  C ADDR   14C8H   A 
BEEP_DELAY_SET . .  C ADDR   13C2H   A 
PROGRAM_BY_TX_ENT~  C ADDR   12CAH   A 
LOCK_BYTE_OK . . .  C ADDR   1113H   A 
AVERAGE_THROTTLE_~  C ADDR   10D6H   A 
DECODE_PWM_FREQ_L~  C ADDR   1041H   A 
COMM61_FETS_DONE_~  C ADDR   0F59H   A 
COMP_READ_WRONG_L~  C ADDR   0D0BH   A 
SET_PWM_LIMIT_LOW~  C ADDR   08FDH   A 
BEEP_F4. . . . . .  C ADDR   0645H   A 
PCA_INT_PPM_MAX_C~  C ADDR   058DH   A 
PCA_INT_RESTORE_E~  C ADDR   0476H   A 
T2_INT_CURRENT_PW~  C ADDR   02D9H   A 
PWM_CFET . . . . .  C ADDR   0170H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A6H   A 
_PGM_STARTUP_METH~  I ADDR   0095H   A 
_PGM_VOLT_COMP . .  I ADDR   0091H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0006h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
FVT_LITTLEBEE_30A~  N NUMB   00CEh            
FVT_LITTLEBEE_20A~  N NUMB   00CCh            
MDRX62H_MULTI. . .  N NUMB   00C0h            
H_KING_10A_MAIN. .  N NUMB   0079h            
ALIGN_RCE_BL35X_M~  N NUMB   0070h            
RCTIMER_6A_TAIL. .  N NUMB   0068h            
TURNIGY_PLUSH_NFE~  N NUMB   003Eh            
XP_18A_MAIN. . . .  N NUMB   000Dh            
XP_12A_MULTI . . .  N NUMB   000Ch            
XP_7A_FAST_TAIL. .  N NUMB   0008h            
PROGRAM_BY_TX_EXIT  C ADDR   18B6H   A 
STORE_MULTI_FUNC_5  C ADDR   1794H   A 
READ_EEPROM_BYTE .  C ADDR   171BH   A 
THROTTLE_LOW_CAL .  C ADDR   131EH   A 
COMP_READ_WRONG. .  C ADDR   0CD4H   A 
STORE_TIMES_UP_OR~  C ADDR   0BE9H   A 
STORE_TIMES_DECRE~  C ADDR   0BF6H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0960H   A 
SET_PWM_LIMIT_HIG~  C ADDR   0911H   A 
GOVERNOR_APPLY_IN~  C ADDR   088FH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0829H   A 
BEEP_OFF . . . . .  C ADDR   0677H   A 
WAIT10MS . . . . .  C ADDR   0611H   A 
T2_INT_CURRENT_PW~  C ADDR   02B7H   A 
PWM_AFET_DAMPED_E~  C ADDR   0189H   A 
T0_INT_PWM_ON_EXIT  C ADDR   00DBH   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Eh            
PGM_PWM_DITHER . .  I ADDR   00A3H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0074H   A 
INITIAL_RUN_ROT_C~  D ADDR   0034H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
GRAUPNER_ULTRA_20~  N NUMB   00D1h            
FVT_LITTLEBEE_30A~  N NUMB   00CFh            
XROTOR_40A_MAIN. .  N NUMB   00BBh            
EMAX_20A_TAIL. . .  N NUMB   00ADh            
TAROT_30A_TAIL . .  N NUMB   00A7h            
H_KING_20A_MAIN. .  N NUMB   007Ch            
RCTIMER_6A_MULTI .  N NUMB   0069h            
HIMODEL_COOL_22A_~  N NUMB   005Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0037h            
XP_7A_FAST_MULTI .  N NUMB   0009h            
GETW . . . . . . .  C ADDR   1D7BH   A 
STORE_MULTI_FUNC_6  C ADDR   1799H   A 
READ_TAG . . . . .  C ADDR   1763H   A 
RESET_CAL_DONE . .  C ADDR   1139H   A 
DECODE_PARAMETERS.  C ADDR   100EH   A 
COMM45_FETS_DONE_~  C ADDR   0EBDH   A 
COMM23_NFET_OFF. .  C ADDR   0DFFH   A 
STORE_TIMES_INCRE~  C ADDR   0B8CH   A 
MEASURE_LIPO_CELLS  C ADDR   0916H   A 
CALC_GOVERNOR_INT~  C ADDR   07A1H   A 
PCA_INT_PPM_CALCU~  C ADDR   0529H   A 
PCA_INT_EXIT . . .  C ADDR   05F5H   A 
T2_INT_RCP_UPDATE~  C ADDR   024BH   A 
PWM_BFET_DAMPED_E~  C ADDR   019AH   A 
RCP_PERIOD_DIFF_A~  D ADDR   005BH   A 
COMPARATOR_READ_C~  D ADDR   0041H   A 
STARTUP_CNT. . . .  D ADDR   0033H   A 
PWM_TIMER0_OVERFL~  N NUMB   0003h            
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
GRAUPNER_ULTRA_20~  N NUMB   00D2h            
EMAX_20A_MULTI . .  N NUMB   00AEh            
TAROT_30A_MULTI. .  N NUMB   00A8h            
HIMODEL_COOL_41A_~  N NUMB   0064h            
TURNIGY_PLUSH_6A_~  N NUMB   001Ch            
GETX . . . . . . .  C ADDR   1D89H   A 
STORE_MULTI_FUNC_7  C ADDR   179EH   A 
RUN6_CHECK_SPEED .  C ADDR   1625H   A 
WAIT_FOR_POWER_ON~  C ADDR   13EBH   A 
SWITCH_POWER_OFF .  C ADDR   0F90H   A 
COMP_READ_WRONG_N~  C ADDR   0CEBH   A 
CALC_NEW_WAIT_PER~  C ADDR   0AAFH   A 
WAIT30MS . . . . .  C ADDR   0616H   A 
PCA_INT_PPM_BIDIR~  C ADDR   057EH   A 
PCA_INT_CHECK_1KHZ  C ADDR   0465H   A 
T2H_INT. . . . . .  C ADDR   02FEH   A 
PWM_CFET_DAMPED_E~  C ADDR   01ABH   A 
MOTOR_PWM_REMAP. .  C ADDR   00AAH   A 
GOV_INTEGRAL_X . .  D ADDR   0046H   A 
COMP_TIMED_OUT . .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   000Ch            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
XROTOR_10A_TAIL. .  N NUMB   00B6h            
EMAX_40A_TAIL. . .  N NUMB   00B0h            
EAZY_3AV2_MAIN . .  N NUMB   00A3h            
ALIGN_RCE_BL15X_T~  N NUMB   006Bh            
HIMODEL_COOL_33A_~  N NUMB   0061h            
TURNIGY_KFORCE_70~  N NUMB   0050h            
TURNIGY_KFORCE_40~  N NUMB   004Dh            
XP_25A_TAIL. . . .  N NUMB   0011h            
RST. . . . . . . .  C ADDR   1CBDH   A 
SUCCESS. . . . . .  N NUMB   0030h            
BOOT_VERSION . . .  N NUMB   0006h            
XTAL . . . . . . .  N NUMB   17D7840h            
FUNC_PARAVAL_CONT~  C ADDR   1882H   A 
WAIT1S . . . . . .  C ADDR   17BAH   A 
STORE_MULTI_FUNC_8  C ADDR   17A3H   A 
WRITE_TAGS . . . .  C ADDR   176DH   A 
RUN_TO_WAIT_FOR_P~  C ADDR   1655H   A 
COMM61_NFET_OFF. .  C ADDR   0F37H   A 
EVAL_COMP_CHECK_T~  C ADDR   0D46H   A 
COMP_WAIT_ON_COMP~  C ADDR   0C95H   A 
ADJUST_TIMING_TWO~  C ADDR   0B73H   A 
INITIALIZE_TIMING.  C ADDR   09D6H   A 
CHECK_VOLTAGE_RET.  C ADDR   09B5H   A 
GOVERNOR_ACTIVATE~  C ADDR   0765H   A 
WAITXMS_M. . . . .  C ADDR   0627H   A 
PCA_INT_CHECK_2KHZ  C ADDR   0454H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
WT_ADV_START_H . .  D ADDR   004CH   A 
GOV_TARGET_H . . .  D ADDR   0043H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
XROTOR_20A_TAIL. .  N NUMB   00B9h            
XROTOR_10A_MULTI .  N NUMB   00B7h            
EMAX_40A_MULTI . .  N NUMB   00B1h            
SKYIII_30A_MAIN. .  N NUMB   00A9h            
PLATINUM_PRO_150A~  N NUMB   009Eh            
POLARIS_THUNDER_2~  N NUMB   0088h            
H_KING_50A_MAIN. .  N NUMB   0082h            
GAUI_GE_183_18A_M~  N NUMB   0076h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ch            
TURNIGY_KFORCE_70~  N NUMB   0051h            
TURNIGY_KFORCE_40~  N NUMB   004Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Bh            
XP_25A_MULTI . . .  N NUMB   0012h            
EXIT . . . . . . .  C ADDR   1CB4H   A 
BOOT_MSG . . . . .  C ADDR   1DDCH   A 
STORE_MULTI_FUNC_9  C ADDR   17A8H   A 
READ_INITIAL_TEMP.  C ADDR   1444H   A 
WAIT_FOR_POWER_ON~  C ADDR   13DFH   A 
DECODE_PWM_FREQ_E~  C ADDR   1046H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0DADH   A 
START_ADC_CONVERS~  C ADDR   091AH   A 
MULT_S16_BY_U8_EX~  C ADDR   0707H   A 
PCA_INT_PPM_LIMIT~  C ADDR   059FH   A 
GET_RCP_END. . . .  C ADDR   037CH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0338H   A 
T2_INT_PWM_MIN_RUN  C ADDR   0273H   A 
PWM_DITHER_TABLE .  C ADDR   009AH   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
PGM_ENABLE_POWER_~  I ADDR   00A1H   A 
PWM_DITHER_DECODED  D ADDR   0066H   A 
PWM_LIMIT_BY_RPM .  D ADDR   0063H   A 
LOW_RPM_PWR_SLOPE.  D ADDR   0038H   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   000Ch            
HIGH_BEC_VOLTAGE .  N NUMB   0000h            
PSW. . . . . . . .  D ADDR   00D0H   A 
XROTOR_20A_MULTI .  N NUMB   00BAh            
PLATINUM_PRO_150A~  N NUMB   009Fh            
POLARIS_THUNDER_3~  N NUMB   008Bh            
POLARIS_THUNDER_1~  N NUMB   0085h            
H_KING_10A_TAIL. .  N NUMB   007Ah            
ALIGN_RCE_BL35X_T~  N NUMB   0071h            
TURNIGY_PLUSH_NFE~  N NUMB   003Ch            
XP_18A_TAIL. . . .  N NUMB   000Eh            
WAITF. . . . . . .  C ADDR   1DC9H   A 
BOOT_BAUDRATE. . .  N NUMB   4B00h            
STORE_IN_RAM_EXIT.  C ADDR   17B7H   A 
VALIDATE_RCP_START  C ADDR   1269H   A 
LOCK_BYTE_TEST . .  C ADDR   110CH   A 
COMM45_NFET_OFF. .  C ADDR   0E9BH   A 
COMM12_REV . . . .  C ADDR   0DD2H   A 
COMM1COMM2 . . . .  C ADDR   0DBEH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0C07H   A 
TEMP_AVERAGE_UPDA~  C ADDR   095EH   A 
TEMP_AVERAGE_DEC .  C ADDR   0954H   A 
CALC_GOVERNOR_PRO~  C ADDR   07FFH   A 
WAITXMS_O. . . . .  C ADDR   0625H   A 
PCA_INT_PPM_TIMEO~  C ADDR   05EAH   A 
PCA_INT_CHECK_4KHZ  C ADDR   0443H   A 
T0_INT_PWM_OFF . .  C ADDR   00FCH   A 
T0_INT_START . . .  C ADDR   00C2H   A 
EEPROM_FW_SUB_REV~  N NUMB   0003h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0048H   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
XROTOR_40A_TAIL. .  N NUMB   00BCh            
POLARIS_THUNDER_4~  N NUMB   008Eh            
H_KING_20A_TAIL. .  N NUMB   007Dh            
H_KING_10A_MULTI .  N NUMB   007Bh            
ALIGN_RCE_BL35X_M~  N NUMB   0072h            
HIMODEL_COOL_22A_~  N NUMB   005Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0038h            
XP_18A_MULTI . . .  N NUMB   000Fh            
PUTC . . . . . . .  C ADDR   1D5CH   A 
BIT_REG. . . . . .  D ADDR   0020H   A 
CMDH . . . . . . .    REG    R5             
READ_EEPROM_EXIT .  C ADDR   16D8H   A 
WAIT_FOR_POWER_ON~  C ADDR   139FH   A 
INPUT_HIGH_CHECK_1  C ADDR   1190H   A 
CHECK_VOLTAGE_STA~  C ADDR   0986H   A 
SET_PWM_LIMIT_LOW~  C ADDR   08B9H   A 
CALC_GOVERNOR_INT~  C ADDR   08B8H   A 
GOVERNOR_LIMIT_IN~  C ADDR   07D4H   A 
MULT_S16_BY_U8_DI~  C ADDR   06ECH   A 
BEEP . . . . . . .  C ADDR   064CH   A 
PCA_INT_PPM_BIDIR~  C ADDR   054CH   A 
PCA_INT_FALL . . .  C ADDR   04A7H   A 
T2_INT_PWM_EXIT. .  C ADDR   02E8H   A 
T2_INT_SKIP_END. .  C ADDR   0229H   A 
TX_PGM_PARAMS_MUL~  C ADDR   009FH   A 
EEP_PGM_TEMP_PROT~  C ADDR   1A23H   A 
_EEP_PGM_THROTTLE~  C ADDR   1A1EH   A 
_EEP_PGM_STARTUP_~  C ADDR   1A12H   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A5H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
MAIN_SPOOLUP_TIME~  D ADDR   006CH   A 
COMM_PHASE . . . .  D ADDR   0040H   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
XROTOR_40A_MULTI .  N NUMB   00BDh            
EMAX_NANO_20A_MAIN  N NUMB   00B2h            
PLATINUM_50AV3_MA~  N NUMB   00A0h            
H_KING_35A_MAIN. .  N NUMB   007Fh            
H_KING_20A_MULTI .  N NUMB   007Eh            
HIMODEL_COOL_41A_~  N NUMB   0065h            
HIMODEL_COOL_22A_~  N NUMB   0060h            
TURNIGY_PLUSH_NFE~  N NUMB   0039h            
TURNIGY_PLUSH_6A_~  N NUMB   001Dh            
WAITH. . . . . . .  C ADDR   1DCDH   A 
ERASE_FLASH. . . .  C ADDR   1734H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   1658H   A 
PROGRAM_BY_TX. . .  C ADDR   183FH   A 
INPUT_HIGH_CHECK_2  C ADDR   1192H   A 
COMM23_NONDAMP . .  C ADDR   0E29H   A 
COMM2COMM3 . . . .  C ADDR   0DE3H   A 
CALC_NEXT_COMM_AV~  C ADDR   0A56H   A 
GOVERNOR_STORE_IN~  C ADDR   08B6H   A 
GOVERNOR_CHECK_IN~  C ADDR   0878H   A 
GOVERNOR_CORR_PRO~  C ADDR   0847H   A 
GOVERNOR_ACTIVATE~  C ADDR   0752H   A 
T2_INT_START . . .  C ADDR   01C9H   A 
PWM_AFET_DAMPED. .  C ADDR   017AH   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
NEXT_WT_START_H. .  D ADDR   0054H   A 
WT_ADV_START_L . .  D ADDR   004BH   A 
GOV_TARGET_L . . .  D ADDR   0042H   A 
DEMAG_PWR_OFF_THR~  D ADDR   0037H   A 
FLAGS0 . . . . . .  D ADDR   002CH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
EAZY_3AV2_TAIL . .  N NUMB   00A4h            
POLARIS_THUNDER_6~  N NUMB   0091h            
HIMODEL_COOL_41A_~  N NUMB   0066h            
HIMODEL_COOL_33A_~  N NUMB   0062h            
TURNIGY_AE_20A_MA~  N NUMB   0040h            
TURNIGY_PLUSH_6A_~  N NUMB   001Eh            
XP_35A_SW_MAIN . .  N NUMB   0013h            
ID1. . . . . . . .  C ADDR   1C47H   A 
FUNC_PARAVAL_STORE  C ADDR   1871H   A 
WRITE_EEPROM_BYTE~  C ADDR   1720H   A 
READ_EEPROM_BLOCK1  C ADDR   16C0H   A 
READ_EEPROM_READ .  C ADDR   16B9H   A 
COMM23_DAMP_REV. .  C ADDR   0E09H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0BC9H   A 
LOAD_MIN_TIME_FAST  C ADDR   0B22H   A 
MEASURE_LIPO_EXIT.  C ADDR   0919H   A 
GOVERNOR_LIMIT_PR~  C ADDR   082FH   A 
GOVERNOR_CHECK_PR~  C ADDR   0785H   A 
PCA_INT_SECOND_ME~  C ADDR   03CEH   A 
T2H_INT_RCP_STOP_~  C ADDR   031BH   A 
PWM_BFET_DAMPED. .  C ADDR   018BH   A 
PCA_INT. . . . . .  C ADDR   035CH   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
FLAGS1 . . . . . .  D ADDR   002DH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
FLYCOLOR_FAIRY_6A~  N NUMB   00C4h            
SKYIII_30A_TAIL. .  N NUMB   00AAh            
EAZY_3AV2_MULTI. .  N NUMB   00A5h            
POLARIS_THUNDER_2~  N NUMB   0089h            
H_KING_50A_TAIL. .  N NUMB   0083h            
GAUI_GE_183_18A_T~  N NUMB   0077h            
HIMODEL_COOL_33A_~  N NUMB   0063h            
TURNIGY_AE_30A_MA~  N NUMB   0046h            
BOOT_INFO. . . . .  C ADDR   1DE0H   A 
ERRORVERIFY. . . .  N NUMB   00C0h            
READ_EEPROM_BLOCK2  C ADDR   16CEH   A 
MEASURE_PWM_FREQ_~  C ADDR   1206H   A 
COMM61_NONDAMP . .  C ADDR   0F60H   A 
COMM6COMM1 . . . .  C ADDR   0F1BH   A 
COMM34_REV . . . .  C ADDR   0E6EH   A 
COMM3COMM4 . . . .  C ADDR   0E5AH   A 
COMP_WAIT_NO_OF_R~  C ADDR   0C84H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0C52H   A 
GOVERNOR_CORR_PRO~  C ADDR   0858H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0540H   A 
PCA_INT_CHECK_8KHZ  C ADDR   0432H   A 
T2_INT_CURRENT_PW~  C ADDR   02D0H   A 
PWM_CFET_DAMPED. .  C ADDR   019CH   A 
_EEP_PGM_MAIN_SPO~  C ADDR   1A22H   A 
_EEP_PGM_LOW_VOLT~  C ADDR   1A06H   A 
DAMPINGFET . . . .  D ADDR   007BH   A 
WT_ZC_SCAN_START_H  D ADDR   004EH   A 
GOV_PROP_PWM . . .  D ADDR   0049H   A 
GOV_PROPORTIONAL_L  D ADDR   0047H   A 
FLAGS2 . . . . . .  D ADDR   002EH   A 
DEMAG_DETECTED . .  N NUMB   0005h            
RCP_SKIP_CNT . . .  D ADDR   002BH   A 
CURRENT_PWM_LIM_D~  D ADDR   0026H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
MCU_48MHZ. . . . .  N NUMB   0001h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
SKYIII_30A_MULTI .  N NUMB   00ABh            
POLARIS_THUNDER_8~  N NUMB   0094h            
POLARIS_THUNDER_3~  N NUMB   008Ch            
POLARIS_THUNDER_2~  N NUMB   008Ah            
POLARIS_THUNDER_1~  N NUMB   0086h            
H_KING_50A_MULTI .  N NUMB   0084h            
GAUI_GE_183_18A_M~  N NUMB   0078h            
TURNIGY_KFORCE_12~  N NUMB   0052h            
XP_3A_MAIN . . . .  N NUMB   0001h            



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6802    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =    103    ----
   IDATA SIZE       =     87    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
